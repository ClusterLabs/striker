#!/usr/bin/perl
# 
# This tool tries to safely start an Anvil! when a node boots. It will replace 'safe_anvil_start' once 
# finished.
# 
# Exit Codes;
# 0  = OK
# 1  = Another instance was running
# 2  = Failed to load drbd kernel module
# 3  = Unexpected module state
# 4  = Unexpected daemon state
# 5  = Daemon not installed on the local node.
# 6  = Daemon not installed on the peer node.
# 7  = A daemon failed to start on one of the nodes.
# 8  = A DRBD resource on the peer failed to connect.
# 9  = A DRBD resource on the local machine failed to connect.
#

use strict;
use warnings;
use IO::Handle;
use AN::Tools;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	        $running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		path		=>	{
			cluster_conf		=>	"/etc/cluster/cluster.conf", 
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			'anvil-safe-start'	=>	"/sbin/striker/anvil-safe-start",
			'anvil-safe-start_link'	=>	"/etc/rc3.d/S99_anvil-safe-start",
		},
		switches	=>	{
		},
		peer		=>	{
			short_name		=>	"",
			bcn_name		=>	"",
			sn_name			=>	"",
			ifn_name		=>	"",
		},
		daemon		=>	{
			cman			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
			rgmanager			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
		},
		drbd		=>	{
			resource		=>	{},
		},
		sys		=>	{
			i_am_node2		=>	0,
			language		=>	"en_CA",
			local_node		=>	"",
			log_language		=>	"en_CA",
			log_level		=>	2,
			peer_node		=>	"",
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->String->read_words  ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	exit(0);
}
if ($an->data->{switches}{enable})
{
	# Create the /etc/rc3.d link.
	create_rc3d_symlink($an);
	exit(0);
}
if ($an->data->{switches}{disable})
{
	# Create the /etc/rc3.d link.
	remove_rc3d_symlink($an);
	exit(0);
}
if (($an->data->{switches}{'state'}) or ($an->data->{switches}{status}))
{
	# Reports whether a instance is running at the moment or not and whether it is enabled on boot or 
	# not.
	report_state($an);
	exit(0);
}
if ($an->data->{switches}{abort})
{
	# Create the /etc/rc3.d link.
	abort_other_instances($an);
	exit(0);
}
if (not $an->data->{switches}{force})
{
	# Exit if another instance is running already.
	avoid_duplicate_run($an);
}

# Log our startup
$an->Log->entry({log_level => 2, message_key => "asst_log_0001", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});


### Process
# 1. Check if I am enabled in striker.conf and that no other copies are running.
# 2. Who am I and who is my peer?
#    - Node 2 pauses for five minutes (this allows time for 'anvil-delay-run' to fire)
# 3. Can I ping my peer on all three networks? Loop until true.
#    - Wait here indefinately
# 4. Check to see if cman/rgmanager was running.
#    - Start 'cman' on both nodes
#    - Start drbd on both nodes
#      - Verify all resources 'Connect'
#    - Start rgmanager on both nodes.
#      - Watch clvmd; make sure all LVs go ACTIVE (and activate them if not)
#    - Verify that /shared/ mounts and test;
#      - 'touch /shared/status/${node}.test && rm -f /shared/status/${node}.test'
#    - Verify that all resources are Primary on both nodes and promote any that aren't.
#    - Verify that libvirtd is running.
# 5. Watch DRBD; If resync'ing, wait up to ~1 minute for storage to sync. Boost resync speed to 40% of SN 
#    speed. If it looks like resync will take > 5 minutes 10 seconds after boosting, abort the wait.
#    - Reset DRBD config before proceeding.
# 6. Using Start Groups/Delays (and ignoring 'clean' off VMs), boot servers.
# 

# Who am I and what Anvil! do I belong to?
find_myself($an);

# Wait until I can ping the peer on all three networks. This will not return until access is available on all
# networks. There is no timeout.
wait_for_access($an);

# If I am node 2, sleep for five minutes.
if ($an->data->{sys}{i_am_node2})
{
	$an->Log->entry({log_level => 2, message_key => "asst_log_0008", file => $THIS_FILE, line => __LINE__});
	sleep 300;
}

# Make sure I can connect to at least one striker DB.
my $connections = 0;
until ($connections)
{
	$connections = $an->DB->connect_to_databases({file => $THIS_FILE});
	$an->Log->entry({log_level => 2, message_key => "notice_message_0013", message_variables => {
		connections	=>	$connections,
	}, file => $THIS_FILE, line => __LINE__});
	if (not $connections)
	{
		$an->Log->entry({log_level => 2, message_key => "asst_log_0009", file => $THIS_FILE, line => __LINE__});
		sleep 5;
	}
}

# Start the cluster
start_the_cluster($an);


# We're done.
$an->Log->entry({log_level => 2, message_key => "asst_log_0006", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});
exit(0);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This starts cman on both nodes, the starts DRBD, makes sure all is well (fixing it if not), the starts
# clvmd and makes sure all LVs are ACTIVE and then mounts /shared. If that all goes well, rgmanager is 
# started.
sub start_the_cluster
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "start_the_cluster" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, check and start cman.
	start_daemons($an, "cman", 1);
	
	# Now start drbd manually.
	start_drbd($an);
	
	
	return(0);
}

# This starts drbd on both nodes and makes sure it starts cleanly.
sub start_drbd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "start_the_cluster" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Check to see if the daemon is running locally and remotely. States are:
	# 0 = Not loaded or not found
	# 1 = Loaded
	my $module       = "drbd";
	my $local_state  = $an->Check->kernel_module({module => $module});
	my $remote_state = $an->Check->kernel_module({
		module		=>	$module,
		target		=>	$an->data->{sys}{peer_node}, 
		password	=>	$an->data->{sys}{anvil_password},
		port		=>	"",
	});
	my $shell_call = $an->data->{path}{modprobe}." $module";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "local_state",  value1 => $local_state, 
		name2 => "remote_state", value2 => $remote_state, 
		name3 => "shell_call",   value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ((not $local_state) && (not $remote_state))
	{
		# We need to load DRBD on both nodes
		my $command = $shell_call;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "command",        value1 => $command,
			name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
		}, file => $THIS_FILE, line => __LINE__});
		my ($output) = $an->Remote->dual_command_run({
			command		=>	$command, 
			node1		=>	"local", 
			node2		=>	$an->data->{sys}{peer_node}, 
			delay		=>	10,
			password	=>	$an->data->{sys}{anvil_password}, 
		});
		foreach my $node ("local", $an->data->{sys}{peer_node})
		{
			foreach my $line (split/\n/, $output->{$node})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	elsif ((not $local_state) && ($remote_state))
	{
		# Start it locally, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	elsif (($local_state) && (not $remote_state))
	{
		# Start it remotely, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call",     value1 => $shell_call,
			name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{peer_node},
			port		=>	"", 
			password	=>	$an->data->{sys}{anvil_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif (($local_state) && ($remote_state))
	{
		# Already loaded on both nodes.
		$an->Log->entry({log_level => 2, message_key => "asst_message_0014", message_variables => {
			module => $module, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Unexpected state
		$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0002", message_variables => {
			local_state	=>	$local_state,
			remote_state	=>	$remote_state,
		}, code => 3, file => "$THIS_FILE", line => __LINE__});
		exit(3);
	}
	
	# Make sure the modules are loaded now.
	$local_state  = $an->Check->kernel_module({module => $module});
	$remote_state = $an->Check->kernel_module({
		module		=>	$module,
		target		=>	$an->data->{sys}{peer_node}, 
		password	=>	$an->data->{sys}{anvil_password},
		port		=>	"",
	});
	if ((not $local_state) or (not $remote_state))
	{
		# What?!
		$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0001", message_variables => {
			local_state	=>	$local_state,
			remote_state	=>	$remote_state,
		}, code => 2, file => "$THIS_FILE", line => __LINE__});
		exit(2);
	}
	
	# Still alive? Good. Now see if I need to brind up DRBD's resource. Start by seeing which resources exist.
	$shell_call = $an->data->{path}{drbdadm}." dump";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /resource (.*) {/)
		{
			my $resource = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "resource", value1 => $resource, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{drbd}{resource}{$resource}{exits} = 1;
		}
	}
	close $file_handle;
	
	# Now loop through each resource and see if it is up on the nodes, and bring it up if not. Start with
	# the remote node.
	foreach my $resource (sort {$a cmp $b} keys %{$an->data->{drbd}{resource}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "resource", value1 => $resource, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# First, is the resource up yet?
		my $local_resource = $an->Check->drbd_resource({resource => $resource});
		my $peer_resource  = $an->Check->drbd_resource({
			resource	=>	$resource,
			target		=>	$an->data->{sys}{peer_node},
			password	=>	$an->data->{sys}{anvil_password},
		});
		
		# I will call this if the resource needs to come up.
		my $shell_call = $an->data->{path}{drbdadm}." up $resource";
		
		# Start the resource on the peer, then locally, if needed.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_resource->{resource_is_up}", value1 => $peer_resource->{resource_is_up}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $peer_resource->{resource_is_up})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "shell_call",     value1 => $shell_call,
				name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{peer_node},
				port		=>	"", 
				password	=>	$an->data->{sys}{anvil_password},
				ssh_fh		=>	"",
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now wait for it to come up.
			until ($peer_resource->{resource_is_up})
			{
				sleep 5;
				$peer_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{peer_node},
					password	=>	$an->data->{sys}{anvil_password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_resource->{resource_is_up}", value1 => $peer_resource->{resource_is_up}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Make sure the resource is not 'StandAlone' and fix it if it is.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "peer_resource->{connection_state}", value1 => $peer_resource->{connection_state}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($peer_resource->{connection_state} =~ /StandAlone/) 
			{
				# Tell it to connect
				my $shell_call = $an->data->{path}{drbdadm}." connect $resource";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "shell_call",     value1 => $shell_call,
					name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target		=>	$an->data->{sys}{peer_node},
					port		=>	"", 
					password	=>	$an->data->{sys}{anvil_password},
					ssh_fh		=>	"",
					'close'		=>	0,
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				# Check now.
				sleep 5;
				$peer_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{peer_node},
					password	=>	$an->data->{sys}{anvil_password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_resource->{connection_state}", value1 => $peer_resource->{connection_state}, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($peer_resource->{connection_state} =~ /StandAlone/) 
				{
					# Failed to Connect...
					$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0007", message_variables => {
						resource	=>	$resource, 
					}, code => 8, file => "$THIS_FILE", line => __LINE__});
					exit(8);
				}
			}
		}
		
		# Now locally.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "local_resource->{resource_is_up}", value1 => $local_resource->{resource_is_up}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $local_resource->{resource_is_up})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			until ($local_resource->{resource_is_up})
			{
				sleep 5;
				$local_resource = $an->Check->drbd_resource({resource => $resource});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{resource_is_up}", value1 => $local_resource->{resource_is_up}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Make sure the resource is not 'StandAlone' and fix it if it is.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "local_resource->{connection_state}", value1 => $local_resource->{connection_state}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($local_resource->{connection_state} =~ /StandAlone/) 
			{
				# Tell it to connect
				my $shell_call = $an->data->{path}{drbdadm}." connect $resource";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
				
				# Check now.
				sleep 5;
				$local_resource = $an->Check->drbd_resource({resource => $resource});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{connection_state}", value1 => $local_resource->{connection_state}, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($local_resource->{connection_state} =~ /StandAlone/) 
				{
					# Failed to Connect...
					$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0007", message_variables => {
						resource	=>	$resource, 
					}, code => 8, file => "$THIS_FILE", line => __LINE__});
					exit(8);
				}
			}
		}
		
		### If I am still alive here, the resource should be connected. So make sure both are Primary
		### now.
		# First the peer.
		$shell_call = $an->data->{path}{drbdadm}." primary $resource";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_resource->{this_role}", value1 => $peer_resource->{this_role}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($peer_resource->{this_role} !~ /Primary/)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "shell_call",     value1 => $shell_call,
				name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{peer_node},
				port		=>	"", 
				password	=>	$an->data->{sys}{anvil_password},
				ssh_fh		=>	"",
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			until ($peer_resource->{this_role} =~ /Primary/i)
			{
				sleep 5;
				$peer_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{peer_node},
					password	=>	$an->data->{sys}{anvil_password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_resource->{this_role}", value1 => $peer_resource->{this_role}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Now locally.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "local_resource->{this_role}", value1 => $local_resource->{this_role}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($local_resource->{this_role} !~ /Primary/)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			until ($local_resource->{this_role} =~ /Primary/i)
			{
				sleep 5;
				$local_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{local_node},
					password	=>	$an->data->{sys}{anvil_password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{this_role}", value1 => $local_resource->{this_role}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# If I am here, DRBD should be fully up.
	}
	
	return(0);
}

# This starts a daemon on both nodes at the same time, if needed. If the daemon is running on the peer, it
# just starts the daemon locally directly.
sub start_daemons
{
	my ($an, $daemon, $syncronous) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "start_daemons" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "daemon",     value1 => $daemon, 
		name2 => "syncronous", value2 => $syncronous,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Check to see if the daemon is running locally and remotely. States are:
	# 0 = Stopped
	# 1 = Running
	# 2 = Daemin not found
	my $local_state  = $an->Check->daemon({daemon => $daemon});
	my $remote_state = $an->Check->daemon({
		daemon		=>	$daemon,
		target		=>	$an->data->{sys}{peer_node}, 
		password	=>	$an->data->{sys}{anvil_password},
		port		=>	"",
	});
	my $shell_call = $an->data->{path}{initd}."/$daemon start";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "local_state",  value1 => $local_state, 
		name2 => "remote_state", value2 => $remote_state, 
		name3 => "shell_call",   value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ((not $local_state) && (not $remote_state))
	{
		if ($syncronous)
		{
			# We need to synchronize the start on both nodes.
			my $command = $shell_call;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "command",        value1 => $command,
				name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
			}, file => $THIS_FILE, line => __LINE__});
			my ($output) = $an->Remote->synchronous_command_run({
				command		=>	$command, 
				node1		=>	"local", 
				node2		=>	$an->data->{sys}{peer_node}, 
				delay		=>	10,
				password	=>	$an->data->{sys}{anvil_password}, 
			});
			foreach my $node ("local", $an->data->{sys}{peer_node})
			{
				foreach my $line (split/\n/, $output->{$node})
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		else
		{
			### Start them sequentially.
			# First on the peer, then locally.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "shell_call",     value1 => $shell_call,
				name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{peer_node},
				port		=>	"", 
				password	=>	$an->data->{sys}{anvil_password},
				ssh_fh		=>	"",
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now locally
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
	}
	elsif ((not $local_state) && ($remote_state eq "1"))
	{
		# Start it locally, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	elsif (($local_state eq "1") && (not $remote_state))
	{
		# Start it remotely, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call",     value1 => $shell_call,
			name2 => "sys::peer_node", value2 => $an->data->{sys}{peer_node},
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{peer_node},
			port		=>	"", 
			password	=>	$an->data->{sys}{anvil_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif (($local_state eq "1") && ($remote_state eq "1"))
	{
		# Both are already running.
		$an->Log->entry({log_level => 2, message_key => "asst_message_0013", message_variables => {
			daemon => $daemon, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($local_state eq "2")
	{
		# Not installed locally
		$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0004", message_variables => {
			daemon	=>	$daemon,
		}, code => 5, file => "$THIS_FILE", line => __LINE__});
		exit(5);
	}
	elsif ($remote_state eq "2")
	{
		# Not installed on the peer.
		$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0005", message_variables => {
			daemon	=>	$daemon,
		}, code => 6, file => "$THIS_FILE", line => __LINE__});
		exit(6);
	}
	else
	{
		# Unexpected state
		$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0003", message_variables => {
			daemon		=>	$daemon,
			local_state	=>	$local_state,
			remote_state	=>	$remote_state,
		}, code => 4, file => "$THIS_FILE", line => __LINE__});
		exit(4);
	}
	
	# Check again to make sure the daemon is runnin on both nodes now.
	$local_state  = $an->Check->daemon({daemon => $daemon});
	$remote_state = $an->Check->daemon({
		daemon		=>	$daemon,
		target		=>	$an->data->{sys}{peer_node}, 
		password	=>	$an->data->{sys}{anvil_password},
		port		=>	"",
	});
	$shell_call = $an->data->{path}{initd}."/$daemon start";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "local_state",  value1 => $local_state, 
		name2 => "remote_state", value2 => $remote_state, 
		name3 => "shell_call",   value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if (($local_state ne "1") or ($remote_state ne "1"))
	{
		# Something went wrong.
		$an->Alert->error({fatal => 1, title_key => "error_title_0005", message_key => "asst_error_0006", message_variables => {
			daemon		=>	$daemon, 
			local_state	=>	$local_state, 
			remote_state	=>	$remote_state, 
		}, code => 7, file => "$THIS_FILE", line => __LINE__});
		exit(7);
	}
	
	return(0);
}

# Wait until I can ping the peer on all three networks. This will not return until access is available on all
# networks. There is no timeout.
sub wait_for_access
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "wait_for_access" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $can_ping = 0;
	until ($can_ping)
	{
		my $peer_bcn = $an->data->{peer}{bcn_name};
		my $peer_sn  = $an->data->{peer}{sn_name};
		my $peer_ifn = $an->data->{peer}{ifn_name};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "peer_bcn", value1 => $peer_bcn, 
			name2 => "peer_sn",  value2 => $peer_sn, 
			name3 => "peer_ifn", value3 => $peer_ifn, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $bcn_access = 0;
		my $sn_access  = 0;
		my $ifn_access = 0;
		
		# Test access now. RC == 0; pinged. 1 == no response.
		my $bcn_return_code = $an->Check->ping({target => $peer_bcn});
		my $sn_return_code  = $an->Check->ping({target => $peer_sn});
		my $ifn_return_code = $an->Check->ping({target => $peer_ifn});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "bcn_return_code", value1 => $bcn_return_code, 
			name2 => "sn_return_code",  value2 => $sn_return_code, 
			name3 => "ifn_return_code", value3 => $ifn_return_code, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ((not $bcn_return_code) && (not $sn_return_code) && (not $ifn_return_code))
		{
			# We're good!
			$can_ping = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "can_ping", value1 => $can_ping, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Something isn't responding, so sleep.
			$an->Log->entry({log_level => 2, message_key => "asst_log_0007", file => $THIS_FILE, line => __LINE__});
			sleep 5;
		}
	}
	
	my $access = 0;
	until ($access)
	{
		my $target     = $an->data->{sys}{peer_node};
		my $password   = $an->data->{sys}{anvil_password};
		my $port       = "";
		my $shell_call = $an->data->{path}{echo}." 1";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
			name2 => "target",     value2 => $target,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$target,
			port		=>	$port, 
			password	=>	$password,
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line eq "1")
			{
				$access = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "access", value1 => $access, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		if (not $access)
		{
			# Tell the user.
			if ($error)
			{
				$an->Log->entry({log_level => 2, message_key => "asst_log_0010", message_variables => {
					peer	=>	$target,
					error	=>	$error, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				$an->Log->entry({log_level => 2, message_key => "asst_log_0011", message_variables => {
					peer	=>	$target,
				}, file => $THIS_FILE, line => __LINE__});
			}
			# Sleep a bit.
			sleep 5;
		}
	}
	
	return(0);
}

# This figures out who I am, what Anvil! I am in and who my peer is.
sub find_myself
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_myself" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $hostname_full  = $an->hostname();
	my $hostname_short = $an->short_hostname();
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "hostname_full",  value1 => $hostname_full, 
		name2 => "hostname_short", value2 => $hostname_short, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Collect information about this Anvil!
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cluster_conf},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I am node 2, make note so that we can delay and let node 1 run first.
	if (($an->data->{sys}{local_node} =~ /n02/) or ($an->data->{sys}{local_node} =~ /node02/) or ($an->data->{sys}{local_node} =~ /node2/))
	{
		$an->data->{sys}{i_am_node2} = 1;
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::i_am_node2", value1 => $an->data->{sys}{i_am_node2}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Figure out what my peer's BCN, SN and IFN names are
	$an->data->{peer}{short_name} =  $an->data->{sys}{peer_node};
	$an->data->{peer}{short_name} =~ s/\..*$//;
	$an->data->{peer}{bcn_name}   = $an->data->{peer}{short_name}.".bcn";
	$an->data->{peer}{sn_name}    = $an->data->{peer}{short_name}.".sn";
	$an->data->{peer}{ifn_name}   = $an->data->{peer}{short_name}.".ifn";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "peer::short_name", value1 => $an->data->{peer}{short_name}, 
		name2 => "peer::bcn_name",   value2 => $an->data->{peer}{bcn_name}, 
		name3 => "peer::sn_name",    value3 => $an->data->{peer}{sn_name}, 
		name4 => "peer::ifn_name",   value4 => $an->data->{peer}{ifn_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This exits if any other instance of this program is running already.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $pids  = $an->Get->pids({program_name => $THIS_FILE});
	my $count = @{$pids};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		exit(1);
	}
	
	return(0);
}

# This looks for other running instances and kills them.
sub abort_other_instances
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "abort_other_instances" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $pids  = $an->Get->pids({program_name => $THIS_FILE});
	my $count = @{$pids};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $pid (sort {$a cmp $b} @{$pids})
	{
		my $killed = kill 15, $pid;
		if ($killed)
		{
			# He's dead, Jim.
			print $an->String->get({key => "asst_message_0010", variables => { pid => $pid }})."\n";
		}
		else
		{
			# SIGTERM was not terminal enough...
			my $die_already = kill 9, $pid;
			if ($die_already)
			{
				print $an->String->get({key => "asst_message_0011", variables => { pid => $pid }})."\n";
			}
			else
			{
				# Fine, be stubborn, see if I care...
				print $an->String->get({key => "asst_message_0012", variables => { pid => $pid }})."\n";
			}
		}
	}
	
	return(0);
}

# This checks to see if an instance of the program is running. It also checks to see if the program is 
# configured to run on boot.
sub report_state
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "report_state" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Is it enabled on boot?
	if (-e $an->data->{path}{'anvil-safe-start_link'})
	{
		# Yup.
		print $an->String->get({key => "asst_message_0005", variables => { this_file => $THIS_FILE }})."\n";
	}
	else
	{
		# Nope.
		print $an->String->get({key => "asst_message_0006", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	# Is it running now?
	my $pids  = $an->Get->pids({program_name => $THIS_FILE});
	my $count = @{$pids};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		# Yup.
		print $an->String->get({key => "asst_message_0007", variables => { this_file => $THIS_FILE }})."\n";
		foreach my $pid (sort {$a cmp $b} @{$pids})
		{
			print $an->String->get({key => "asst_message_0008", variables => { pid => $pid }})."\n";
		}
	}
	else
	{
		print $an->String->get({key => "asst_message_0009", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	return(0);
}

# This creates the /etc/rc3.d/ symlink that runs this program on boot.
sub create_rc3d_symlink
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "create_rc3d_symlink" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, does the symlink exist already?
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "path::anvil-safe-start_link", value1 => $an->data->{path}{'anvil-safe-start_link'}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{'anvil-safe-start_link'})
	{
		# Already exists, nothing to do.
		$an->Log->entry({log_level => 2, message_key => "asst_log_0003", file => $THIS_FILE, line => __LINE__});
		print $an->String->get({key => "asst_message_0002", variables => { this_file => $THIS_FILE }})."\n";
	}
	else
	{
		# Create it.
		my $target = $an->data->{path}{'anvil-safe-start'};
		my $link   = $an->data->{path}{'anvil-safe-start_link'};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "target", value1 => $target, 
			name2 => "link",   value2 => $link, 
		}, file => $THIS_FILE, line => __LINE__});
		symlink $target, $link or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_message_0052", message_variables => { target => $target, 'link' => $link, error => $! }, code => 52, file => "$THIS_FILE", line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "asst_log_0002", file => $THIS_FILE, line => __LINE__});
		print $an->String->get({key => "asst_message_0001", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	return(0);
}

# This removes the /etc/rc3.d/ symlink that runs this program on boot.
sub remove_rc3d_symlink
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "remove_rc3d_symlink" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, does the symlink exist already?
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "path::anvil-safe-start_link", value1 => $an->data->{path}{'anvil-safe-start_link'}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{'anvil-safe-start_link'})
	{
		# Already gone, nothing to do.
		$an->Log->entry({log_level => 2, message_key => "asst_log_0005", file => $THIS_FILE, line => __LINE__});
		print $an->String->get({key => "asst_message_0004", variables => { this_file => $THIS_FILE }})."\n";
	}
	else
	{
		# Remove it
		my $file = $an->data->{path}{'anvil-safe-start_file'};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "file", value1 => $file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		unlink $file or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_message_0053", message_variables => { file => $file, error => $! }, code => 53, file => "$THIS_FILE", line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "asst_log_0004", file => $THIS_FILE, line => __LINE__});
		print $an->String->get({key => "asst_message_0003", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $help = "";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
