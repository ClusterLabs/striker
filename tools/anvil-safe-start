#!/usr/bin/perl
# 
# This tool tries to safely start an Anvil! when a node boots. 
# 
# Exit Codes;
# 0  = OK
# 1  = Another instance was running
# 2  = Failed to load drbd kernel module
# 3  = Unexpected module state
# 4  = Unexpected daemon state
# 5  = Daemon not installed on the local node.
# 6  = Daemon not installed on the peer node.
# 7  = A daemon failed to start on one of the nodes.
# 8  = A DRBD resource on the peer failed to connect.
# 9  = A DRBD resource on the local machine failed to connect.
# 10 = A clustered LV failed to ACTIVATE.
# 11 = Failed to mount /shared
# 12 = Failed to find this Anvil!'s password.
# 13 = During single-node start, the 'cman' daemon was found to already be running which should not happen.
#
# TODO:
# - 
#
# BUG:
# - 
#

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Data::Dumper;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		path		=>	{
			cluster_conf		=>	"/etc/cluster/cluster.conf", 
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		switches	=>	{
		},
		peer		=>	{
			short_name		=>	"",
			bcn_name		=>	"",
			sn_name			=>	"",
			ifn_name		=>	"",
		},
		daemon		=>	{
			cman			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
			rgmanager			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
		},
		drbd		=>	{
			resource		=>	{},
		},
		sys		=>	{
			# Don't print the webUI footer when invoked by a web-called parent
			footer_printed		=>	1,
			i_am_node2		=>	0,
			language		=>	"en_CA",
			local_node		=>	"",
			log_language		=>	"en_CA",
			log_level		=>	2,
			peer_node		=>	"",
			program_name		=>	$program_name,
			# These are only used if the user sets an invalid value in striker.conf
			resync			=>	{
				boost_speed		=>	80,
				max_wait_time		=>	300,
				delay			=>	15,
				always_boost		=>	0,
			},
			single_node_start	=>	{
				boot_frequency		=>	86400,
				boot_delay		=>	300,
				enabled			=>	0,
				ran			=>	0,
			},
		},
		'anvil-safe-start' =>	{
			drbd		=>	{
				boost_speed	=>	80,
				max_wait_time	=>	300,
				resync_delay	=>	15,
				always_boost	=>	0,
			},
			log_db_transactions	=>	0,
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{'anvil-safe-start'}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# I used to have a dumb and complex way of handling this before I knew about '@reboot' in cron... This 
# function cleans that up, if the old way is found.
check_root_crontab($an);

if ($an->data->{switches}{enable})
{
	# Make sure we're in the root user's crontab and enabled in striker.conf.
	add_to_root_crontab($an);
	update_striker_conf($an, "enable");
	$an->nice_exit({exit_code => 0});
}
if ($an->data->{switches}{disable})
{
	# Remove our entry in the root user's crontab and disable in striker.conf.
	remove_from_root_crontab($an);
	update_striker_conf($an, "disable");
	$an->nice_exit({exit_code => 0});
}
if (($an->data->{switches}{'state'}) or ($an->data->{switches}{status}))
{
	# Reports whether a instance is running at the moment or not and whether it is enabled on boot or 
	# not.
	report_state($an);
	$an->nice_exit({exit_code => 0});
}
if ($an->data->{switches}{abort})
{
	# Abort the other instance.
	abort_other_instances($an);
	$an->nice_exit({exit_code => 0});
}
if (not $an->data->{switches}{force})
{
	# Exit if another instance is running already.
	avoid_duplicate_run($an);
}
# Exit if we're disabled.
if ((not $an->data->{switches}{force}) && (not $an->data->{tools}{'anvil-safe-start'}{enabled}))
{
	print $an->String->get({key => "asst_message_0023"})."\n";
	$an->nice_exit({exit_code => 0});
}

# Log our startup
$an->Log->entry({log_level => 1, message_key => "asst_log_0001", message_variables => { this_file => $THIS_FILE }, file => $THIS_FILE, line => __LINE__});

### Process
# 1. Check if I am enabled in striker.conf and that no other copies are running.
# 2. Who am I and who is my peer?
#    - Node 2 pauses for five minutes (this allows time for 'anvil-delay-run' to fire)
# 3. Can I ping my peer on all three networks? Loop until true.
#    - Wait here indefinately
# 4. Check to see if cman/rgmanager was running.
#    - Start 'cman' on both nodes
#    - Start drbd on both nodes
#      - Verify all resources 'Connect'
#    - Start rgmanager on both nodes.
#      - Watch clvmd; make sure all LVs go ACTIVE (and activate them if not)
#    - Verify that /shared/ mounts and test;
#      - 'touch /shared/status/${node}.test && rm -f /shared/status/${node}.test'
#    - Verify that all resources are Primary on both nodes and promote any that aren't.
#    - Verify that libvirtd is running.
# 5. Watch DRBD; If resync'ing, wait up to ~1 minute for storage to sync. Boost resync speed to 40% of SN 
#    speed. If it looks like resync will take > 5 minutes 10 seconds after boosting, abort the wait.
#    - Reset DRBD config before proceeding.
# 6. Using Start Groups/Delays (and ignoring 'clean' off VMs), boot servers.
# 


# Now wait for access to a ScanCore database.
wait_for_scancore_database($an);

# Who am I and what Anvil! do I belong to?
find_myself($an);

# Mark the node as clean on now.
$an->Striker->mark_node_as_clean_on({node_uuid => $an->data->{sys}{host_uuid}});

### Check if cman is running and, if so, abort. 
# States are:
# 0 = Stopped
# 1 = Running
# 2 = Daemon not found
my $cman_state = $an->Check->daemon({daemon => "cman"});
$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
	name1 => "cman_state", value1 => $cman_state, 
}, file => $THIS_FILE, line => __LINE__});
if ($cman_state)
{
	# Error out... cman shouldn't be running so what?!
	$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0012", code => 13, file => $THIS_FILE, line => __LINE__});
	$an->nice_exit({exit_code => 13});
}

# Wait until I can ping the peer on all three networks. This will not return until access is available on all
# networks. There is no timeout.
wait_for_access($an);

if (not $an->data->{sys}{single_node_start}{ran})
{
	# If I am node 2, sleep for five minutes.
	wait_if_node2($an);
	
	# Start the cluster
	start_the_cluster($an);
}

# Start the servers!!
start_servers($an);

# We're done.
$an->Log->entry({log_level => 1, message_key => "asst_log_0006", message_variables => { this_file => $THIS_FILE }, file => $THIS_FILE, line => __LINE__});
$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This updates the tools::anvil-safe-start::enabled value in striker.conf
sub update_striker_conf
{
	my ($an, $task) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_striker_conf" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "task", value1 => $task, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# $an->data->{tools}{anvil-safe-start}{enabled}
	my $changed = 0;
	my $found   = 0;
	my $set     = $task eq "enable" ? 1 : 0;
	
	# Read in striker.conf.
	my $new_config = "";
	my $old_config = "";
	my $shell_call = $an->data->{path}{striker_config};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^tools::anvil-safe-start::enabled(\s+)=(\s+)(.*)$/)
		{
			my $space1 = $1;
			my $space2 = $2;
			my $value  = $3;
			   $found  = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "value", value1 => $value, 
				name2 => "set",   value2 => $set, 
				name3 => "found", value3 => $found, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($value ne $set)
			{
				$changed = 1;
				$line    = "tools::anvil-safe-start::enabled".$space1."=".$space2."$set";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "changed", value1 => $changed, 
					name2 => "line",    value2 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		$new_config .= $line."\n";
		$old_config .= $line."\n";
	}
	close $file_handle;
	
	# If I didn't find the value, loop through the new config and insert the value when we see the 
	# commented out version. If we don't see a commented out version, we'll stick it on the end of the 
	# file.
	if (not $found)
	{
		$new_config = "";
		foreach my $line (split/\n/, $old_config)
		{
			$new_config .= $line."\n";
			if ($line =~ /tools::anvil-safe-start::enabled(\s+)=(\s+)/)
			{
				my $lhs     = $1;
				my $rhs     = $2;
				   $found   = 1;
				   $changed = 1;
				$new_config .= "tools::anvil-safe-start::enabled".$lhs."=".$rhs."$set\n";
			}
		}
		if (not $found)
		{
			$changed    =  1;
			$new_config .= "tools::anvil-safe-start::enabled\t=\t$set\n";
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "changed", value1 => $changed, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($changed)
	{
		# Write out the new version.
		my $shell_call = $an->data->{path}{striker_config};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle $new_config;
		close $file_handle;
		if ($set)
		{
			# Enabled, as requested
			$an->Log->entry({log_level => 1, message_key => "asst_message_0016", message_variables => {this_file => $THIS_FILE}, file => $THIS_FILE, line => __LINE__});
			print $an->String->get({key => "asst_message_0016", variables => { this_file => $THIS_FILE }})."\n";
		}
		else
		{
			# Disabled, as requested
			$an->Log->entry({log_level => 1, message_key => "asst_message_0017", message_variables => {this_file => $THIS_FILE}, file => $THIS_FILE, line => __LINE__});
			print $an->String->get({key => "asst_message_0017", variables => { this_file => $THIS_FILE }})."\n";
		}
	}
	else
	{
		if ($set)
		{
			# Already enabled
			$an->Log->entry({log_level => 1, message_key => "asst_message_0018", message_variables => {this_file => $THIS_FILE}, file => $THIS_FILE, line => __LINE__});
			print $an->String->get({key => "asst_message_0018", variables => { this_file => $THIS_FILE }})."\n";
		}
		else
		{
			# Already disabled.
			$an->Log->entry({log_level => 1, message_key => "asst_message_0019", message_variables => {this_file => $THIS_FILE}, file => $THIS_FILE, line => __LINE__});
			if (not $an->data->{switches}{force})
			{
				print $an->String->get({key => "asst_message_0019", variables => { this_file => $THIS_FILE }})."\n";
			}
		}
	}
	
	return(0);
}

# This starts the servers in the user's requested order. Any servers that the user turned off gracefully in
# Striker or that are set to never start will be left off. A check is made to ensure we're only booting 
# servers defined locally and shown in clustat.
sub start_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "start_servers" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, call clustat to get a list of VMs.
	my ($servers, $state) = $an->Cman->get_cluster_server_list();
	
	# If there are no servers, we're done.
	my $count = @{$servers};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not $servers)
	{
		# None found, we're out.
		$an->Log->entry({log_level => 1, message_key => "asst_log_0024", file => $THIS_FILE, line => __LINE__});
		return(0);
	}
	
	### TODO: Left off here. We can now use 'server_anvil_uuid' to select only servers from this Anvil! system...
	# Now call up the servers from the server table. We'll read all and decide what to skip later.
	my $query = "
SELECT 
    server_name, 
    server_uuid, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay 
FROM 
    servers
WHERE 
    server_note IS DISTINCT FROM 'DELETED'
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do the query against the source DB and loop through the results.
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $server_name        = $row->[0];
		my $server_uuid        = $row->[1];
		my $server_stop_reason = $row->[2];
		my $server_start_after = $row->[3];
		my $server_start_delay = $row->[4];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "server_name",        value1 => $server_name, 
			name2 => "server_uuid",        value2 => $server_uuid, 
			name3 => "server_stop_reason", value3 => $server_stop_reason, 
			name4 => "server_start_after", value4 => $server_start_after, 
			name5 => "server_start_delay", value5 => $server_start_delay, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{server_uuid}{$server_uuid} = {
			processed	=>	0, 
			name		=>	$server_name, 
			stop_reason	=>	$server_stop_reason, 
			start_after	=>	$server_start_after, 
			start_delay	=>	$server_start_delay, 
		};
		$an->data->{server_name}{$server_name}{uuid} = $server_uuid;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
			name1 => "server_uuid",                              value1 => $server_uuid, 
			name2 => "server_uuid::${server_uuid}::processed",   value2 => $an->data->{server_uuid}{$server_uuid}{processed}, 
			name3 => "server_uuid::${server_uuid}::name",        value3 => $an->data->{server_uuid}{$server_uuid}{name},
			name4 => "server_uuid::${server_uuid}::stop_reason", value4 => $an->data->{server_uuid}{$server_uuid}{stop_reason}, 
			name5 => "server_uuid::${server_uuid}::start_after", value5 => $an->data->{server_uuid}{$server_uuid}{start_after}, 
			name6 => "server_uuid::${server_uuid}::start_delay", value6 => $an->data->{server_uuid}{$server_uuid}{start_delay}, 
			name7 => "server_name::${server_name}::uuid",        value7 => $an->data->{server_name}{$server_name}{uuid}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Weed out servers from the DB that aren't on this Anvil!
	foreach my $server_uuid (keys %{$an->data->{server_uuid}})
	{
		my $this_server_name = $an->data->{server_uuid}{$server_uuid}{name};
		my $on_this_anvil    = 0;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "server_uuid",      value1 => $server_uuid, 
			name2 => "this_server_name", value2 => $this_server_name, 
		}, file => $THIS_FILE, line => __LINE__});
		
		foreach my $server_name (sort {$a cmp $b} @{$servers})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "server_name",      value1 => $server_name, 
				name2 => "this_server_name", value2 => $this_server_name, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($this_server_name eq $server_name)
			{
				$on_this_anvil = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "on_this_anvil", value1 => $on_this_anvil, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		
		# Delete it from the hash if it wasn't found.
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "on_this_anvil", value1 => $on_this_anvil, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $on_this_anvil)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "on_this_anvil", value1 => $on_this_anvil, 
				name2 => "server_uuid",   value2 => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			delete $an->data->{server_uuid}{$server_uuid};
		}
	}
	
	# Check to see if any servers are already running. If so, mark the current time as their "processed"
	# time because we don't know when they booted so, from a delay perspective, we will assume the worst.
	foreach my $server_name (sort {$a cmp $b} keys %{$state})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "server_name",           value1 => $server_name, 
			name2 => "state->{$server_name}", value2 => $state->{$server_name}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($state->{$server_name} =~ /start/)
		{
			my $server_uuid                                      = $an->data->{server_name}{$server_name}{uuid};
			   $an->data->{server_uuid}{$server_uuid}{processed} = time;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "server_uuid",                            value1 => $server_uuid, 
				name2 => "server_uuid::${server_uuid}::processed", value2 => $an->data->{server_uuid}{$server_uuid}{processed}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Enter a loop where we look at what the boot condition is for each server. When it is time, deal 
	# with the server and mark the time it was dealt with. If a given machine depends on another, check 
	# that machine to see if it was dealt with yet. If so, check for a delay. If the current time minus
	# the dependent machine's 'dealt with' time is >= the delay, deal with it. Loop until all machines
	# have been dealt with.
	my $done = 0;
	until($done)
	{
		# This will get set to '0' if we hit any servers we're not dealing with in this loop.
		my $all_dealt_with = 1;
		
		foreach my $server_uuid (keys %{$an->data->{server_uuid}})
		{
			# Gather our thoughts...
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "server_uuid",                              value1 => $server_uuid, 
				name2 => "server_uuid::${server_uuid}::processed",   value2 => $an->data->{server_uuid}{$server_uuid}{processed}, 
				name3 => "server_uuid::${server_uuid}::name",        value3 => $an->data->{server_uuid}{$server_uuid}{name},
				name4 => "server_uuid::${server_uuid}::stop_reason", value4 => $an->data->{server_uuid}{$server_uuid}{stop_reason}, 
				name5 => "server_uuid::${server_uuid}::start_after", value5 => $an->data->{server_uuid}{$server_uuid}{start_after}, 
				name6 => "server_uuid::${server_uuid}::start_delay", value6 => $an->data->{server_uuid}{$server_uuid}{start_delay}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $processed   = $an->data->{server_uuid}{$server_uuid}{processed}   ? $an->data->{server_uuid}{$server_uuid}{processed}   : "";
			my $server_name = $an->data->{server_uuid}{$server_uuid}{name}        ? $an->data->{server_uuid}{$server_uuid}{name}        : "";
			my $stop_reason = $an->data->{server_uuid}{$server_uuid}{stop_reason} ? $an->data->{server_uuid}{$server_uuid}{stop_reason} : "";
			my $start_after = $an->data->{server_uuid}{$server_uuid}{start_after} ? $an->data->{server_uuid}{$server_uuid}{start_after} : "";
			my $start_delay = $an->data->{server_uuid}{$server_uuid}{start_delay} ? $an->data->{server_uuid}{$server_uuid}{start_delay} : "";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "server_uuid", value1 => $server_uuid, 
				name2 => "processed",   value2 => $processed, 
				name3 => "server_name", value3 => $server_name, 
				name4 => "stop_reason", value4 => $stop_reason, 
				name5 => "start_after", value5 => $start_after, 
				name6 => "start_delay", value6 => $start_delay, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Nothing to do if the server has already been processed.
			next if $processed;
			
			# If it was 'clean' or 'user_stopped' off, leave it off.
			if (($stop_reason =~ /clean/) or ($stop_reason =~ /user_stopped/))
			{
				# Leave it off. Set the 'processed' to '1' instead of the time so that we can
				# tell that the server wasn't booted.
				$an->data->{server_uuid}{$server_uuid}{processed} = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "server_uuid::${server_uuid}::processed", value1 => $an->data->{server_uuid}{$server_uuid}{processed}, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			# If the dependent UUID is all '0', we're leaving it off.
			if ($start_after eq "00000000-0000-0000-0000-000000000000")
			{
				$an->data->{server_uuid}{$server_uuid}{processed} = 2;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "server_uuid::${server_uuid}::processed", value1 => $an->data->{server_uuid}{$server_uuid}{processed}, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			# If this server isn't dependent on anyone else, boot it.
			if (not $start_after)
			{
				# 0 = Didn't boot (maybe no healthy node?)
				# 1 = Booted
				# 2 = Tried to boot, but it failed.
				my ($booted, $boot_return) = $an->Cman->boot_server({server => $server_name});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "booted",      value1 => $booted, 
					name2 => "boot_return", value2 => $boot_return, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($booted eq "1")
				{
					# Excellent!
					$an->data->{server_uuid}{$server_uuid}{processed} = time;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "server_uuid::${server_uuid}::processed", value1 => $an->data->{server_uuid}{$server_uuid}{processed}, 
					}, file => $THIS_FILE, line => __LINE__});
					next;
				}
				elsif ($booted eq "2")
				{
					# Human intervention required. :(
					$an->data->{server_uuid}{$server_uuid}{processed} = 3;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "server_uuid::${server_uuid}::processed", value1 => $an->data->{server_uuid}{$server_uuid}{processed}, 
					}, file => $THIS_FILE, line => __LINE__});
					next;
				}
				else
				{
					# Didn't boot it for some reason, like a node isn't ready yet.
					$all_dealt_with = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "all_dealt_with", value1 => $all_dealt_with, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			else
			{
				### There is a dependent server. 
				# Does it still exist?
				my $boot = 0;
				if ($an->data->{server_uuid}{$start_after}{name})
				{
					# It does exist. Has it been processed?
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "server_uuid::${start_after}::processed", value1 => $start_after, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{server_uuid}{$start_after}{processed})
					{
						# Looks like it.
						if ($an->data->{server_uuid}{$start_after}{processed} eq "1")
						{
							# The dependent was cleanly turned off, so we might 
							# as well boot it now.
							$an->Log->entry({log_level => 1, message_key => "asst_log_0027", message_variables => {
								server      => $server_name, 
								start_after => $an->data->{server_uuid}{$server_uuid}{name},
							}, file => $THIS_FILE, line => __LINE__});
							$boot = 1;
						}
						elsif ($an->data->{server_uuid}{$start_after}{processed} eq "2")
						{
							# The dependent is configured to never boot, so there
							# is no reason to wait.
							$an->Log->entry({log_level => 1, message_key => "asst_log_0028", message_variables => {
								server      => $server_name, 
								start_after => $an->data->{server_uuid}{$server_uuid}{name},
							}, file => $THIS_FILE, line => __LINE__});
							$boot = 1;
						}
						elsif ($an->data->{server_uuid}{$start_after}{processed} eq "3")
						{
							# The dependent failed to boot, so there is no reason
							# to wait.
							$an->Log->entry({log_level => 1, message_key => "asst_log_0029", message_variables => {
								server      => $server_name, 
								start_after => $an->data->{server_uuid}{$server_uuid}{name},
							}, file => $THIS_FILE, line => __LINE__});
							$boot = 1;
						}
						else
						{
							# It appears to have booted cleanly, but how long 
							# ago?
							my $current_time    = time;
							my $time_since_boot = $current_time - $an->data->{server_uuid}{$start_after}{processed};
							$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
								name1 => "current_time",                           value1 => $current_time, 
								name2 => "server_uuid::${start_after}::processed", value2 => $an->data->{server_uuid}{$start_after}{processed},
								name3 => "time_since_boot",                        value3 => $time_since_boot, 
								name4 => "start_delay",                            value4 => $start_delay, 
							}, file => $THIS_FILE, line => __LINE__});
							if ($time_since_boot >= $start_delay)
							{
								# Boot it!
								$an->Log->entry({log_level => 1, message_key => "asst_log_0030", message_variables => {
									server          => $server_name, 
									start_after     => $an->data->{server_uuid}{$server_uuid}{name},
									start_delay     => $start_delay, 
									time_since_boot => $time_since_boot, 
								}, file => $THIS_FILE, line => __LINE__});
								$boot = 1;
							}
							else
							{
								# Not yet.
								$an->Log->entry({log_level => 1, message_key => "asst_log_0031", message_variables => {
									server          => $server_name, 
									start_after     => $an->data->{server_uuid}{$server_uuid}{name},
									start_delay     => $start_delay, 
									time_since_boot => $time_since_boot, 
								}, file => $THIS_FILE, line => __LINE__});
								
								$all_dealt_with = 0;
								$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
									name1 => "all_dealt_with", value1 => $all_dealt_with, 
								}, file => $THIS_FILE, line => __LINE__});
							}
						}
					}
					else
					{
						# The dependent server hasn't booted yet.
						$all_dealt_with = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "all_dealt_with", value1 => $all_dealt_with, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
				else
				{
					# The dependent doesn't seem to exist now, so we'll boot immediately.
					$an->Log->entry({log_level => 1, message_key => "asst_log_0032", message_variables => {
						server           => $server_name, 
						start_after_uuid => $an->data->{server_uuid}{$server_uuid}{name},
					}, file => $THIS_FILE, line => __LINE__});
					$boot = 1;
				}
				
				# Boot?
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "boot", value1 => $boot, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($boot)
				{
					# 0 = Didn't boot (maybe no healthy node?)
					# 1 = Booted
					# 2 = Tried to boot, but it failed.
					my $booted = $an->Cman->boot_server({server => $server_name});
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "booted", value1 => $booted, 
					}, file => $THIS_FILE, line => __LINE__});
					
					if ($booted eq "1")
					{
						# Excellent!
						$an->data->{server_uuid}{$server_uuid}{processed} = time;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "server_uuid::${server_uuid}::processed", value1 => $an->data->{server_uuid}{$server_uuid}{processed}, 
						}, file => $THIS_FILE, line => __LINE__});
						next;
					}
					elsif ($booted eq "2")
					{
						# Human intervention required. :(
						$an->data->{server_uuid}{$server_uuid}{processed} = 3;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "server_uuid::${server_uuid}::processed", value1 => $an->data->{server_uuid}{$server_uuid}{processed}, 
						}, file => $THIS_FILE, line => __LINE__});
						next;
					}
					else
					{
						# Didn't boot it for some reason, like neither node is ready 
						# yet.
						$all_dealt_with = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "all_dealt_with", value1 => $all_dealt_with, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
		}
		
		# Are we done?
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "all_dealt_with", value1 => $all_dealt_with, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($all_dealt_with)
		{
			# \o/
			$done = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "done", value1 => $done, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			### TODO: Determine if sleeping only 1 second puts too much of a load on the system.
			$an->Log->entry({log_level => 1, message_key => "asst_log_0026", file => $THIS_FILE, line => __LINE__});
			sleep 3;
		}
	}
	
	return(0);
}

# This starts cman on both nodes, the starts DRBD, makes sure all is well (fixing it if not), the starts
# clvmd and makes sure all LVs are ACTIVE and then mounts /shared. If that all goes well, rgmanager is 
# started.
sub start_the_cluster
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "start_the_cluster" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, check and start cman.
	start_daemons($an, "cman", 1);
	
	### NOTE: We start clvmd right away because of 'https://github.com/ClusterLabs/striker/issues/89'.
	# First, check and start cman.
	start_daemons($an, "clvmd", 1);
	
	# Now start drbd manually.
	start_drbd($an);
	
	# Now start clvmd. This also checks that all LVs are ACTIVE and activates any that aren't.
	start_clvmd($an);
	
	# Now start gfs2 and make sure '/shared' mounts on both nodes.
	start_gfs2($an);
	
	# Now start rgmanager! I don't need this to be synchronous because the daemon start will exit and 
	# then start the storage services.
	start_daemons($an, "rgmanager", 0);
	
	# It takes a bit for the storage to actually come up, so we'll watch clustat for the storage services
	# to start, then verify that /shared is mounted on both nodes.
	wait_for_storage($an, "both");
	
	return(0);
}

# This simply waits until /shared is mounted on both nodes before it returns.
sub wait_for_storage
{
	my ($an, $who) = @_;
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, title_key => "tools_log_0001", title_variables => { function => "wait_for_storage" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "who", value1 => $who,
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, loop locally watching clustat for the storage services.
	my $started_waiting        = time;
	my $restart_rgmanager_time = $started_waiting + 120;
	my $force_reset_time       = $started_waiting + 300;
	my $peer_key               = $an->data->{sys}{peer_key};
	my $local_key              = $an->data->{sys}{local_key};
	my $peer_name              = $an->data->{sys}{anvil}{$peer_key}{name};
	my $peer_state_variable    = "sys::node::".$peer_name."::last_seen";
	my $last_booted_variable   = "sys::node::".$peer_name."::last_booted_without";
	my $storage_up             = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
		name1 => "started_waiting",        value1 => $started_waiting, 
		name2 => "restart_rgmanager_time", value2 => $restart_rgmanager_time, 
		name3 => "force_reset_time",       value3 => $force_reset_time, 
		name4 => "local_key",              value4 => $local_key,
		name5 => "peer_key",               value5 => $peer_key,
		name6 => "peer_name",              value6 => $peer_name,
		name7 => "peer_state_variable",    value7 => $peer_state_variable,
		name8 => "last_booted_variable",   value8 => $last_booted_variable,
	}, file => $THIS_FILE, line => __LINE__});
	
	# I need to know my service names so that if 'who' is set to 'local', we only watch that service.
	my $local_service = $local_key eq "node1" ? "storage_n01" : "storage_n02";
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
		name1 => "local_service", value1 => $local_service, 
	}, file => $THIS_FILE, line => __LINE__});
	
	until ($storage_up)
	{
		# If I've waited too long, clvmd might be hung. Try force-stopping clvmd and then restarting
		# rgmanager.
		if (time > $restart_rgmanager_time)
		{
			# Try to recover
			$an->Log->entry({log_level => 0, message_key => "asst_error_0013", file => $THIS_FILE, line => __LINE__});
			sleep 1;
			
			### NOTE: If the storage was 'failed', it will go 'disabled' and need to be manually
			###       enabled.
			# Stop storage (clvmd is usually the culprit here) and then restart rgmanager. The 
			# timeout is there to make sure this doesn't hang so that we can commit suicide if
			# needed.
			my $shell_call = "
".$an->data->{path}{timeout}." 15 ".$an->data->{path}{initd}."/gfs2 stop; 
".$an->data->{path}{timeout}." 15 ".$an->data->{path}{initd}."/clvmd stop; 
".$an->data->{path}{timeout}." 15 ".$an->data->{path}{initd}."/drbd stop; 
".$an->data->{path}{timeout}." 15 ".$an->data->{path}{initd}."/rgmanager stop; 
".$an->data->{path}{timeout}." 15 ".$an->data->{path}{initd}."/rgmanager start; 
";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			# Push the reset time out so that we don't trigger this again.
			$restart_rgmanager_time += 300;
		}
		
		if (time > $force_reset_time)
		{
			# Screw it, suicide.
			$an->Log->entry({log_level => 0, message_key => "asst_error_0014", file => $THIS_FILE, line => __LINE__});
			
			# Sleep to make sure the log entry above makes it to disk
			sleep 5;
			
			# If this is dying after a single node start, reset our counter so that we can try
			# again.
			if ($an->data->{sys}{single_node_start}{ran})
			{
				my $variable_uuid = $an->ScanCore->insert_or_update_variables({
					variable_name         => $last_booted_variable,
					variable_value        => 0,
					variable_source_uuid  => $an->data->{sys}{host_uuid}, 
					variable_source_table => "hosts", 
					update_value_only     => 1,
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "variable_uuid", value1 => $variable_uuid, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Use ipmitool to reset our own chassis
			my $shell_call = $an->data->{path}{ipmitool}." chassis power reset";
			$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		
		# Call clustat;
		my $storage_enabled = 0;
		my $storage_count   = 0;
		my $shell_call      = $an->data->{path}{clustat};
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($line =~ /service:(storage_n\d+) .*? (.*)$/)
			{
				my $service = $1;
				my $state   = $2;
				### NOTE: Customer requested, move to 2 before v2.0 release
				$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
					name1 => "service", value1 => $service, 
					name2 => "state",   value2 => $state, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($state eq "started")
				{
					$storage_count++;
					### NOTE: Customer requested, move to 2 before v2.0 release
					$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
						name1 => "storage_count", value1 => $storage_count, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($who eq "local")
				{
					if ($service eq $local_service)
					{
						# This is local storage. If it is disabled, enable it. We 
						# don't do any further processing here, but if it worked, it
						# should be picked up in the next loop.
						if ((not $storage_enabled) && ($state eq "disabled"))
						{
							my $shell_call = $an->data->{path}{timeout}." 15 ".$an->data->{path}{clusvcadm}." -e $service || ".$an->data->{path}{echo}." timed out";
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "shell_call", value1 => $shell_call, 
							}, file => $THIS_FILE, line => __LINE__});
							open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
							while(<$file_handle>)
							{
								chomp;
								my $line =  $_;
								$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
									name1 => "line", value1 => $line, 
								}, file => $THIS_FILE, line => __LINE__});
							}
							close $file_handle;
						}
					}
					else
					{
						# This is the peer's storage and we're only watching local so pretend
						# it is up.
						$storage_count++;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "storage_count", value1 => $storage_count, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
		}
		close $file_handle;
		
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "storage_count", value1 => $storage_count, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($storage_count == 2)
		{
			# Now verify that '/shared/ is mounted on both nodes.
			my $shared_up = check_shared($an, $who);
			### NOTE: Customer requested, move to 2 before v2.0 release
			$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
				name1 => "shared_up", value1 => $shared_up, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($shared_up)
			{
				$storage_up = 1;
				### NOTE: Customer requested, move to 2 before v2.0 release
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "storage_up", value1 => $storage_up, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "storage_up", value1 => $storage_up, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $storage_up)
		{
			$an->Log->entry({log_level => 1, message_key => "asst_log_0025", file => $THIS_FILE, line => __LINE__});
			sleep 5;
		}
	}
	
	return(0);
}

# This returns '1' if shared is mounted on both nods and '0' if it is not.
sub check_shared
{
	my ($an, $who) = @_;
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, title_key => "tools_log_0001", title_variables => { function => "check_shared" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "who", value1 => $who,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $node_key = $an->data->{sys}{local_key};
	my $peer_key = $an->data->{sys}{peer_key};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node_key", value1 => $node_key,
		name2 => "peer_key", value2 => $peer_key,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $mounted    = 1;
	my $shell_call = $an->data->{path}{mount};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($who eq "local")
	{
		# I only care about local storage.
		my $shared_mounted = 0;
		open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			next if not $line;
			if ($line =~ /\/shared type gfs2/)
			{
				$shared_mounted = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shared_mounted", value1 => $shared_mounted,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shared_mounted", value1 => $shared_mounted,
		}, file => $THIS_FILE, line => __LINE__});
		if (not $shared_mounted)
		{
			$mounted = 0;
			$an->Log->entry({log_level => 1, message_key => "asst_log_0023", message_variables => {
				node => $an->hostname, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	else
	{
		# Call 'mount' on both nodes and make sure '/shared' is found.
		my ($output) = $an->System->dual_command_run({
			command => $shell_call, 
			delay   => 10,
		});
		foreach my $node ($an->data->{sys}{anvil}{$node_key}{name}, $an->data->{sys}{anvil}{$peer_key}{name})
		{
			my $shared_mounted = 0;
			foreach my $line (split/\n/, $output->{$node})
			{
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				next if not $line;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "node", value1 => $node,
					name2 => "line", value2 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /\/shared type gfs2/)
				{
					$shared_mounted = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "shared_mounted", value1 => $shared_mounted,
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shared_mounted", value1 => $shared_mounted,
			}, file => $THIS_FILE, line => __LINE__});
			if (not $shared_mounted)
			{
				$mounted = 0;
				$an->Log->entry({log_level => 1, message_key => "asst_log_0023", message_variables => {
					node => $node, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "mounted", value1 => $mounted,
	}, file => $THIS_FILE, line => __LINE__});
	return($mounted);
}

# This starts drbd on both nodes and makes sure it starts cleanly.
sub start_gfs2
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "start_gfs2" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, check and start cman.
	start_daemons($an, "gfs2", 0);
	
	# Verify
	my $proceed = check_shared($an, "both");
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "proceed", value1 => $proceed, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if (not $proceed)
	{
		# We don't try to fix this yet. Only known reason for this to fail at this stage is if the
		# cluster was renamed and we're NOT mucking with the gfs2 metadata.
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0010", code => 11, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 11});
	}
	
	return(0);
}

# This starts drbd on both nodes and makes sure it starts cleanly.
sub start_clvmd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "start_clvmd" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: This should already be started, but we're leaving the call here just in case.
	# First, check and start cman.
	start_daemons($an, "clvmd", 0);
	
	# Now check 'lvscan' on both nodes (it is possible that one node's LV could be inactive while the 
	# other's is active).
	my $recheck = 0;
	my $command = $an->data->{path}{lvscan};
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
		name1 => "command", value1 => $command,
	}, file => $THIS_FILE, line => __LINE__});
	my ($output) = $an->System->dual_command_run({
		command => $command, 
		delay   => 10,
	});
	
	my $node_key = $an->data->{sys}{local_key};
	my $peer_key = $an->data->{sys}{peer_key};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node_key", value1 => $node_key,
		name2 => "peer_key", value2 => $peer_key,
	}, file => $THIS_FILE, line => __LINE__});
	
	### Check each node separetly.
	# Peer first.
	my $local_name = $an->data->{sys}{anvil}{$node_key}{name};
	my $peer_name  = $an->data->{sys}{anvil}{$peer_key}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "local_name", value1 => $local_name,
		name2 => "peer_name",  value2 => $peer_name,
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $line (split/\n/, $output->{$peer_name})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		next if not $line;
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
			name1 => "peer_name", value1 => $peer_name,
			name2 => "line",      value2 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^inactive '(.*?)' /)
		{
			# Needs to be activated.
			my $logical_volume = $1;
			$an->Log->entry({log_level => 1, message_key => "asst_log_0021", message_variables => {
				logical_volume => $logical_volume, 
				node           => $peer_name, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $shell_call = $an->data->{path}{lvchange}." -ay $logical_volume";
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
				port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
				password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$recheck = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "recheck", value1 => $recheck, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Now local
	foreach my $line (split/\n/, $output->{$local_name})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		next if not $line;
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
			name1 => "local_name", value1 => $local_name,
			name2 => "line",       value2 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^inactive '(.*?)' /)
		{
			# Needs to be activated.
			my $logical_volume = $1;
			$an->Log->entry({log_level => 1, message_key => "asst_log_0021", message_variables => {
				logical_volume => $logical_volume, 
				node           => $local_name, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $shell_call = $an->data->{path}{lvchange}." -ay $logical_volume";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			$recheck = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "recheck", value1 => $recheck, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Verify if anything was activated.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "recheck", value1 => $recheck, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($recheck)
	{
		# This time, we check the output from both nodes at the same time because anything being 
		# inactive is fatal.
		my $inactive = 0;
		my $command  = $an->data->{path}{lvscan};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "command", value1 => $command,
		}, file => $THIS_FILE, line => __LINE__});
		my ($output) = $an->System->dual_command_run({
			command => $command, 
			delay   => 10,
		});
		foreach my $node ($an->data->{sys}{anvil}{$node_key}{name}, $an->data->{sys}{anvil}{$peer_key}{name})
		{
			foreach my $line (split/\n/, $output->{$node})
			{
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				next if not $line;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "node", value1 => $node,
					name2 => "line", value2 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /^inactive '(.*?)' /)
				{
					# Well shoot...
					my $logical_volume = $1;
					   $inactive       = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "logical_volume", value1 => $logical_volume,
						name2 => "inactive",       value2 => $inactive,
					}, file => $THIS_FILE, line => __LINE__});
					$an->Log->entry({log_level => 1, message_key => "asst_log_0020", message_variables => {
						logical_volume => $logical_volume, 
						node           => $node, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		if ($inactive)
		{
			# We're dead...
			$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0009", code => 10, file => $THIS_FILE, line => __LINE__});
			$an->nice_exit({exit_code => 10});
		}
		else
		{
			# Yay us!
			$an->Log->entry({log_level => 1, message_key => "asst_log_0022", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This starts drbd on both nodes and makes sure it starts cleanly.
sub start_drbd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "start_drbd" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $node_key = $an->data->{sys}{local_key};
	my $peer_key = $an->data->{sys}{peer_key};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node_key", value1 => $node_key,
		name2 => "peer_key", value2 => $peer_key,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Check to see if the daemon is running locally and remotely. States are:
	# 0 = Not loaded or not found
	# 1 = Loaded
	my $module       = "drbd";
	my $local_state  = $an->Check->kernel_module({module => $module});
	my $remote_state = $an->Check->kernel_module({
		module		=>	$module,
		target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
		port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
		password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
	});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "module",       value1 => $module, 
		name2 => "local_state",  value2 => $local_state, 
		name3 => "remote_state", value3 => $remote_state, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Will be called below, if needed.
	my $shell_call = $an->data->{path}{modprobe}." $module";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ((not $local_state) && (not $remote_state))
	{
		# We need to load DRBD on both nodes
		my $command = $shell_call;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "command", value1 => $command,
		}, file => $THIS_FILE, line => __LINE__});
		my ($output) = $an->System->dual_command_run({
			command => $command, 
			delay   => 10,
		});
		foreach my $node ($an->data->{sys}{anvil}{$node_key}{name}, $an->data->{sys}{anvil}{$peer_key}{name})
		{
			foreach my $line (split/\n/, $output->{$node})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	elsif ((not $local_state) && ($remote_state))
	{
		# Start it locally, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	elsif (($local_state) && (not $remote_state))
	{
		# Start it remotely, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
			name2 => "shell_call",                      value2 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
			port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
			password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif (($local_state) && ($remote_state))
	{
		# Already loaded on both nodes.
		$an->Log->entry({log_level => 2, message_key => "asst_message_0014", message_variables => {
			module => $module, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Unexpected state
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0002", message_variables => {
			local_state	=>	$local_state,
			remote_state	=>	$remote_state,
		}, code => 3, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 3});
	}
	
	# Make sure the modules are loaded now.
	$local_state  = $an->Check->kernel_module({module => $module});
	$remote_state = $an->Check->kernel_module({
		module		=>	$module,
		target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
		port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
		password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
	});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "local_state",  value1 => $local_state, 
		name2 => "remote_state", value2 => $remote_state, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $local_state) or (not $remote_state))
	{
		# What?!
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0001", message_variables => {
			local_state	=>	$local_state,
			remote_state	=>	$remote_state,
		}, code => 2, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 2});
	}
	
	# Still alive? Good. Now see if I need to brind up DRBD's resource. Start by seeing which resources exist.
	$shell_call = $an->data->{path}{drbdadm}." dump";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /resource (.*) {/)
		{
			my $resource = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "resource", value1 => $resource, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{drbd}{resource}{$resource}{exits} = 1;
		}
	}
	close $file_handle;
	
	# Now loop through each resource and see if it is up on the nodes, and bring it up if not. Start with
	# the remote node.
	foreach my $resource (sort {$a cmp $b} keys %{$an->data->{drbd}{resource}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "resource", value1 => $resource, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# First, is the resource up yet?
		my $local_resource = $an->Check->drbd_resource({resource => $resource});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "local_resource", value1 => $local_resource, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $peer_resource = $an->Check->drbd_resource({
			resource	=>	$resource,
			target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
			port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
			password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_resource", value1 => $peer_resource, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# I will call this if the resource needs to come up.
		my $shell_call = $an->data->{path}{drbdadm}." up $resource";
		
		# Start the resource on the peer, then locally, if needed.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_resource->{resource_is_up}", value1 => $peer_resource->{resource_is_up}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $peer_resource->{resource_is_up})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
				name2 => "shell_call",                      value2 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
				port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
				password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now wait for it to come up.
			until ($peer_resource->{resource_is_up})
			{
				sleep 5;
				$peer_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
					port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
					password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_resource->{resource_is_up}", value1 => $peer_resource->{resource_is_up}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Make sure the resource is not 'StandAlone' and fix it if it is.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "peer_resource->{connection_state}", value1 => $peer_resource->{connection_state}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($peer_resource->{connection_state} =~ /StandAlone/) 
			{
				# Tell it to connect
				my $shell_call = $an->data->{path}{drbdadm}." connect $resource";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
					name2 => "shell_call",                      value2 => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip}, 
					port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port},
					password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				# Check now.
				sleep 5;
				$peer_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
					port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
					password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_resource->{connection_state}", value1 => $peer_resource->{connection_state}, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($peer_resource->{connection_state} =~ /StandAlone/) 
				{
					# Failed to Connect...
					$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0007", message_variables => { resource => $resource }, code => 8, file => $THIS_FILE, line => __LINE__});
					$an->nice_exit({exit_code => 8});
				}
			}
		}
		
		# Now locally.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "local_resource->{resource_is_up}", value1 => $local_resource->{resource_is_up}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $local_resource->{resource_is_up})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			until ($local_resource->{resource_is_up})
			{
				sleep 5;
				$local_resource = $an->Check->drbd_resource({resource => $resource});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{resource_is_up}", value1 => $local_resource->{resource_is_up}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Wait here until the connection state is NOT WFConnection
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "local_resource->{connection_state}", value1 => $local_resource->{connection_state}, 
			}, file => $THIS_FILE, line => __LINE__});
			until ($local_resource->{connection_state} ne "WFConnection")
			{
				sleep 5;
				$local_resource = $an->Check->drbd_resource({resource => $resource});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{connection_state}", value1 => $local_resource->{connection_state}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Make sure the resource is not 'StandAlone' and fix it if it is.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "local_resource->{connection_state}", value1 => $local_resource->{connection_state}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($local_resource->{connection_state} =~ /StandAlone/) 
			{
				# Tell it to connect
				my $shell_call = $an->data->{path}{drbdadm}." connect $resource";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
				
				# Check now.
				sleep 5;
				$local_resource = $an->Check->drbd_resource({resource => $resource});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{connection_state}", value1 => $local_resource->{connection_state}, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($local_resource->{connection_state} =~ /StandAlone/) 
				{
					# Failed to Connect...
					$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0007", message_variables => { resource => $resource }, code => 8, file => $THIS_FILE, line => __LINE__});
					$an->nice_exit({exit_code => 8});
				}
			}
		}
		
		### If I am still alive here, the resource should be connected. So make sure both are Primary
		### now.
		# First the peer.
		$shell_call = $an->data->{path}{drbdadm}." primary $resource";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_resource->{this_role}", value1 => $peer_resource->{this_role}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($peer_resource->{this_role} !~ /Primary/)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
				name2 => "shell_call",                      value2 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
				port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
				password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			until ($peer_resource->{this_role} =~ /Primary/i)
			{
				sleep 5;
				$peer_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
					port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
					password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_resource->{this_role}", value1 => $peer_resource->{this_role}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Now locally.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "local_resource->{this_role}", value1 => $local_resource->{this_role}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($local_resource->{this_role} !~ /Primary/)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			until ($local_resource->{this_role} =~ /Primary/i)
			{
				sleep 5;
				$local_resource = $an->Check->drbd_resource({
					resource	=>	$resource,
					target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
					port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
					password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_resource->{this_role}", value1 => $local_resource->{this_role}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	### TODO: Check the speed of the SN and if it is 10Gbps+, use a resync speed of '500M'.
	# Here I am watching the resync speeds, so I can work locally in all cases.
	foreach my $resource (sort {$a cmp $b} keys %{$an->data->{drbd}{resource}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "resource", value1 => $resource, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# First, is the resource up yet?
		my $local_resource = $an->Check->drbd_resource({resource => $resource});
		
		# If I am here, DRBD should be fully up. See if we need to wait for DRBD to be UpToDate.
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
			name1 => "local_resource->{this_disk_state}", value1 => $local_resource->{this_disk_state}, 
			name2 => "local_resource->{peer_disk_state}", value2 => $local_resource->{peer_disk_state}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($local_resource->{this_disk_state} !~ /UpToDate/) or ($local_resource->{peer_disk_state} !~ /UpToDate/))
		{
			# Something isn't UpToDate, so lets see what we can do.
			my $sync_eta = $local_resource->{sync_eta};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "sync_eta",                              value1 => $sync_eta, 
				name2 => "anvil-safe-start::drbd::boost_speed",   value2 => $an->data->{'anvil-safe-start'}{drbd}{boost_speed}, 
				name3 => "anvil-safe-start::drbd::max_wait_time", value3 => $an->data->{'anvil-safe-start'}{drbd}{max_wait_time}, 
				name4 => "anvil-safe-start::drbd::resync_delay",  value4 => $an->data->{'anvil-safe-start'}{drbd}{resync_delay}, 
				name5 => "anvil-safe-start::drbd::always_boost",  value5 => $an->data->{'anvil-safe-start'}{drbd}{always_boost}, 
				name6 => "sys::resync::boost_speed",              value6 => $an->data->{sys}{resync}{boost_speed}, 
				name7 => "sys::resync::max_wait_time",            value7 => $an->data->{sys}{resync}{max_wait_time}, 
				name8 => "sys::resync::delay",                    value8 => $an->data->{sys}{resync}{delay}, 
				name9 => "sys::resync::always_boost",             value9 => $an->data->{sys}{resync}{always_boost}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{'anvil-safe-start'}{drbd}{boost_speed} !~ /^\d+$/)
			{
				$an->data->{'anvil-safe-start'}{drbd}{boost_speed} = $an->data->{sys}{resync}{boost_speed};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "anvil-safe-start::drbd::boost_speed", value1 => $an->data->{'anvil-safe-start'}{drbd}{boost_speed}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($an->data->{'anvil-safe-start'}{drbd}{max_wait_time} eq "wait")
			{
				# Wait forever (or wait for at least one year).
				$an->data->{'anvil-safe-start'}{drbd}{max_wait_time} = 31536000;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "anvil-safe-start::drbd::max_wait_time", value1 => $an->data->{'anvil-safe-start'}{drbd}{max_wait_time}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($an->data->{'anvil-safe-start'}{drbd}{max_wait_time} !~ /^\d+$/)
			{
				$an->data->{'anvil-safe-start'}{drbd}{max_wait_time} = $an->data->{sys}{resync}{max_wait_time};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "anvil-safe-start::drbd::max_wait_time", value1 => $an->data->{'anvil-safe-start'}{drbd}{max_wait_time}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($an->data->{'anvil-safe-start'}{drbd}{resync_delay} !~ /^\d+$/)
			{
				$an->data->{'anvil-safe-start'}{drbd}{resync_delay} = $an->data->{sys}{resync}{delay};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "anvil-safe-start::drbd::resync_delay", value1 => $an->data->{'anvil-safe-start'}{drbd}{resync_delay}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# If the sync ETA is > 'anvil-safe-start::drbd::max_wait_time' seconds, or if 
			# 'always_boost' is set, boost the sync speed.
			my $wait_for_sync = 1;
			my $sync_boosted  = 0;
			### NOTE: Customer requested, move to 2 before v2.0 release
			$an->Log->entry({log_level => 1, message_key => "an_variables_0003", message_variables => {
				name1 => "wait_for_sync",                        value1 => $wait_for_sync, 
				name2 => "sync_boosted",                         value2 => $sync_boosted, 
				name3 => "anvil-safe-start::drbd::always_boost", value3 => $an->data->{'anvil-safe-start'}{drbd}{always_boost}, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($sync_eta > $an->data->{'anvil-safe-start'}{drbd}{max_wait_time}) or ($an->data->{'anvil-safe-start'}{drbd}{always_boost}))
			{
				# Boost the sync speed and then wait 15 seconds and check again to see what 
				# the ETA becomes.
				$an->Log->entry({log_level => 1, message_key => "asst_log_0014", message_variables => {
					sync_eta => $sync_eta, 
					resource => $resource, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# I can always issue this locally.
				my $shell_call = $an->data->{path}{drbdadm}." disk-options --c-plan-ahead=0 --resync-rate=".$an->data->{'anvil-safe-start'}{drbd}{boost_speed}."M $resource";
				### NOTE: Customer requested, move to 2 before v2.0 release
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
				$sync_boosted = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "sync_boosted", value1 => $sync_boosted, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Now wait a bit for the sync speed to spool up
				sleep $an->data->{'anvil-safe-start'}{drbd}{resync_delay};
				
				# How is it now?
				$local_resource = $an->Check->drbd_resource({resource => $resource});
				$sync_eta       = $local_resource->{sync_eta};
				### NOTE: Customer requested, move to 2 before v2.0 release
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "sync_eta", value1 => $sync_eta, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# If the sync ETA is > 'anvil-safe-start::drbd::max_wait_time' seconds, get the SN sync speed 
				if ($sync_eta > $an->data->{'anvil-safe-start'}{drbd}{max_wait_time})
				{
					# Still too long, we'll abort now and boot the servers on whoever is UpToDate
					$an->Log->entry({log_level => 1, message_key => "asst_log_0015", message_variables => {
						sync_eta => $sync_eta, 
						resource => $resource, 
					}, file => $THIS_FILE, line => __LINE__});
					$wait_for_sync = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "wait_for_sync", value1 => $wait_for_sync, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			# Shall we wait?
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "wait_for_sync", value1 => $wait_for_sync, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($wait_for_sync)
			{
				# Excellent! Wait for it to sync
				$an->Log->entry({log_level => 1, message_key => "asst_log_0016", message_variables => {
					sync_eta => $sync_eta, 
					resource => $resource, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $finished = 0;
				until ($finished)
				{
					sleep 10;
					$local_resource = $an->Check->drbd_resource({resource => $resource});
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "local_resource->{this_disk_state}", value1 => $local_resource->{this_disk_state}, 
						name2 => "local_resource->{peer_disk_state}", value2 => $local_resource->{peer_disk_state}, 
					}, file => $THIS_FILE, line => __LINE__});
					if (($local_resource->{this_disk_state} =~ /UpToDate/) && ($local_resource->{peer_disk_state} =~ /UpToDate/))
					{
						# We're done!
						$finished = 1;
						$an->Log->entry({log_level => 1, message_key => "asst_log_0017", message_variables => {
							resource => $resource, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					else
					{
						$local_resource = $an->Check->drbd_resource({resource => $resource});
						$sync_eta       = $local_resource->{sync_eta};
						$an->Log->entry({log_level => 1, message_key => "asst_log_0018", message_variables => {
							sync_eta => $sync_eta, 
							resource => $resource, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
			
			# If the speed was boosted, drop it back
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sync_boosted", value1 => $sync_boosted, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($sync_boosted)
			{
				# Reset the sync speed.
				$shell_call = $an->data->{path}{drbdadm}." adjust $resource";
				### NOTE: Customer requested, move to 2 before v2.0 release
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
			}
		}
		else
		{
			# The resource is already fully sync'ed.
			$an->Log->entry({log_level => 1, message_key => "asst_log_0019", message_variables => { resource => $resource }, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Done!
	
	return(0);
}

# This will loop until we get access to at least one ScanCore database.
sub wait_for_scancore_database
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "wait_for_scancore_database" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Make sure I can connect to at least one striker DB.
	my $connections = 0;
	until ($connections)
	{
		$connections = $an->DB->connect_to_databases({file => $THIS_FILE});
		$an->Log->entry({log_level => 2, message_key => "notice_message_0013", message_variables => {
			connections => $connections,
		}, file => $THIS_FILE, line => __LINE__});
		if (not $connections)
		{
			$an->Log->entry({log_level => 1, message_key => "asst_log_0009", file => $THIS_FILE, line => __LINE__});
			sleep 30;
		}
		else
		{
			$an->Log->entry({log_level => 1, message_key => "asst_log_0033", message_variables => { connections => $connections }, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This will wait for a bit, then check to see if node 1 is running anvil-safe-start. If it is, it will keep 
# waiting until it exits. If it isn't, it will run without further delay.
sub wait_if_node2
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "wait_if_node2" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if ($an->data->{sys}{i_am_node2})
	{
		my $peer_key = $an->data->{sys}{peer_key};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_key", value1 => $peer_key,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Remote->wait_on_peer({
			program		=>	$an->data->{sys}{program_name}, 
			target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
			port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
			password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
		});
	}
	
	return(0);
}

# This starts a daemon on both nodes at the same time, if needed. If the daemon is running on the peer, it
# just starts the daemon locally directly.
sub start_daemons
{
	my ($an, $daemon, $syncronous) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "start_daemons" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "daemon",     value1 => $daemon, 
		name2 => "syncronous", value2 => $syncronous,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $node_key = $an->data->{sys}{local_key};
	my $peer_key = $an->data->{sys}{peer_key};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node_key", value1 => $node_key,
		name2 => "peer_key", value2 => $peer_key,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Check to see if the daemon is running locally and remotely. States are:
	# 0 = Stopped
	# 1 = Running
	# 2 = Daemon not found
	my $local_state  = $an->Check->daemon({daemon => $daemon});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "local_state", value1 => $local_state, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $remote_state = $an->Check->daemon({
		daemon		=>	$daemon,
		target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
		port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
		password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
	});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "remote_state", value1 => $remote_state, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If the daemon is 'gfs2' and the state is '2', there is a stale lock file. Delete it and check 
	# again.
	if ($daemon eq "gfs2")
	{
		if ($local_state eq "2")
		{
			$an->Storage->cleanup_gfs2();
			$local_state  = $an->Check->daemon({daemon => $daemon});
		}
		if ($remote_state eq "2")
		{
			$an->Storage->cleanup_gfs2({
				target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
				port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
				password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
			});
			$remote_state = $an->Check->daemon({
				daemon		=>	$daemon,
				target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
				port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
				password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
			});
		}
	}
	
	# If the daemon is clvmd and the return code is 255, clvmd hung, so we'll call 'start' as this might
	# be because clvmd is running on one node but not the other while cman is running on both.
	if ($daemon eq "clvmd")
	{
		if ($local_state eq "124")
		{
			$local_state = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "local_state", value1 => $local_state, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($remote_state eq "124")
		{
			$remote_state = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "remote_state", value1 => $remote_state, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	my $shell_call = $an->data->{path}{initd}."/$daemon start";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "daemon",       value1 => $daemon, 
		name2 => "local_state",  value2 => $local_state, 
		name3 => "remote_state", value3 => $remote_state, 
		name4 => "shell_call",   value4 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ((not $local_state) && (not $remote_state))
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "syncronous", value1 => $syncronous, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($syncronous)
		{
			# We need to synchronize the start on both nodes.
			my $command = $shell_call;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "command", value1 => $command,
			}, file => $THIS_FILE, line => __LINE__});
			my ($output) = $an->System->synchronous_command_run({
				command => $command, 
				delay   => 10,
			});
			foreach my $node ($an->data->{sys}{anvil}{$node_key}{name}, $an->data->{sys}{anvil}{$peer_key}{name})
			{
				foreach my $line (split/\n/, $output->{$node})
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		else
		{
			### Start them sequentially.
			# First on the peer, then locally.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
				name2 => "shell_call",                      value2 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
				port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
				password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now locally
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				   $line =~ s/\r//g;
				   $line =~ s/[\000-\037]/ /g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
	}
	elsif ((not $local_state) && ($remote_state eq "1"))
	{
		# Start it locally, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/\r//g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	elsif (($local_state eq "1") && (not $remote_state))
	{
		# Start it remotely, no need to sync.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
			name2 => "shell_call",                      value2 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
			port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
			password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif (($local_state eq "1") && ($remote_state eq "1"))
	{
		# Both are already running.
		$an->Log->entry({log_level => 2, message_key => "asst_message_0013", message_variables => {
			daemon => $daemon, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($local_state eq "2")
	{
		# Not installed locally
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0004", message_variables => { daemon => $daemon }, code => 5, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 5});
	}
	elsif ($remote_state eq "2")
	{
		# Not installed on the peer.
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0005", message_variables => { daemon => $daemon }, code => 6, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 6});
	}
	else
	{
		# Unexpected state
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0003", message_variables => {
			daemon		=>	$daemon,
			local_state	=>	$local_state,
			remote_state	=>	$remote_state,
		}, code => 4, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 4});
	}
	
	# Check again to make sure the daemon is runnin on both nodes now.
	$local_state  = $an->Check->daemon({daemon => $daemon});
	$remote_state = $an->Check->daemon({
		daemon		=>	$daemon,
		target		=>	$an->data->{sys}{anvil}{$peer_key}{use_ip},
		port		=>	$an->data->{sys}{anvil}{$peer_key}{use_port}, 
		password	=>	$an->data->{sys}{anvil}{$peer_key}{password},
	});
	$shell_call = $an->data->{path}{initd}."/$daemon start";
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, message_key => "an_variables_0003", message_variables => {
		name1 => "local_state",  value1 => $local_state, 
		name2 => "remote_state", value2 => $remote_state, 
		name3 => "shell_call",   value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if (($local_state ne "1") or ($remote_state ne "1"))
	{
		# Something went wrong.
		# If the problem is local and if it is with clvmd, stop drbd and cman.
		if ((not $local_state) && ($daemon eq "clvmd"))
		{
			# Shut down DRBD and cman.
			$an->Log->entry({log_level => 1, title_key => "title_0190", message_key => "asst_warning_0001", file => $THIS_FILE, line => __LINE__});
			
			my $local_drbd_state = $an->Check->daemon({daemon => "drbd"});
			my $local_cman_state = $an->Check->daemon({daemon => "cman"});
			if ($local_drbd_state eq "1")
			{
				my $shell_call = $an->data->{path}{initd}."/drbd stop";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$line =~ s/\r//g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
			}
			if ($local_cman_state eq "1")
			{
				my $shell_call = $an->data->{path}{initd}."/cman stop";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$line =~ s/\r//g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
			}
			
			# Suicide... Whatever causes clvmd to get stuck thinking something has bound 21064 
			# doesn't recover until we reboot. We'll give the user some warning.
			my $reboot_delay = 120;
			$an->Log->entry({log_level => 1, title_key => "title_0190", message_key => "asst_warning_0002", message_variables => {
				reboot_delay => $reboot_delay, 
			}, file => $THIS_FILE, line => __LINE__});
			sleep $reboot_delay;
			
			my $shell_call = $an->data->{path}{reboot};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				$line =~ s/\r//g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		
		# Alert the user
		$an->Alert->error({title_key => "an_0003", message_key => "asst_error_0006", message_variables => {
			daemon		=>	$daemon, 
			local_state	=>	$local_state, 
			remote_state	=>	$remote_state, 
		}, code => 7, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 7});
	}
	
	return(0);
}

# Wait until I can ping the peer on all three networks. This will not return until access is available on all
# networks. There is no timeout.
sub wait_for_access
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "wait_for_access" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $node_key  = $an->data->{sys}{local_key};
	my $peer_key  = $an->data->{sys}{peer_key};
	my $peer_name = $an->data->{sys}{anvil}{$peer_key}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "node_key",  value1 => $node_key,
		name2 => "peer_key",  value2 => $peer_key,
		name3 => "peer_name", value3 => $peer_name,
	}, file => $THIS_FILE, line => __LINE__});
	
	# If 'sys::single_node_start::enabled' is enabled and the peer was last known to be offline, we'll 
	# only wait for so long. This tracks when we started waiting.
	my $waiting_started_at = time;
	my $stop_waiting_at    = $waiting_started_at + $an->data->{sys}{single_node_start}{boot_delay};
	my $difference         = $stop_waiting_at - time;
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, message_key => "an_variables_0004", message_variables => {
		name1 => "waiting_started_at", value1 => $waiting_started_at,
		name2 => "stop_waiting_at",    value2 => $stop_waiting_at,
		name3 => "time",               value3 => time,
		name4 => "difference",         value4 => $difference,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $can_ping = 0;
	until ($can_ping)
	{
		my $bcn_access = 0;
		my $sn_access  = 0;
		my $ifn_access = 0;
		
		# Get the node_key for my peer (done inside the loop to pickup changes to /etc/hosts).
		my ($peer_bcn, $peer_sn, $peer_ifn) = $an->Get->peer_network_details();
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "peer_bcn", value1 => $peer_bcn, 
			name2 => "peer_sn",  value2 => $peer_sn, 
			name3 => "peer_ifn", value3 => $peer_ifn, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Test access now. RC == 1; pinged. 0 == no response.
		my $bcn_return_code = $an->Check->ping({ping => $peer_bcn});
		my $sn_return_code  = $an->Check->ping({ping => $peer_sn});
		my $ifn_return_code = $an->Check->ping({ping => $peer_ifn});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "bcn_return_code", value1 => $bcn_return_code, 
			name2 => "sn_return_code",  value2 => $sn_return_code, 
			name3 => "ifn_return_code", value3 => $ifn_return_code, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (($bcn_return_code) && ($sn_return_code) && ($ifn_return_code))
		{
			# We're good!
			$can_ping = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "can_ping", value1 => $can_ping, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# This will set 'sys::single_node_start::ran' if we gave up waiting and started alone. If 
			# that is non-zero, we'll set 'can_ping' to end the loop.
			check_single_node_start($an, $peer_name, $waiting_started_at, $stop_waiting_at);
			$can_ping = $an->data->{sys}{single_node_start}{ran};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "can_ping", value1 => $can_ping, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Something isn't responding, so sleep.
			$an->Log->entry({log_level => 1, message_key => "asst_log_0007", file => $THIS_FILE, line => __LINE__});
			sleep 5;
		}
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::single_node_start::ran", value1 => $an->data->{sys}{single_node_start}{ran},
			name2 => "can_ping",                    value2 => $can_ping,
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Return now if we started alone.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::single_node_start::ran", value1 => $an->data->{sys}{single_node_start}{ran},
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{single_node_start}{ran})
	{
		return(0);
	}
	
	my $access = 0;
	until ($access)
	{
		my $shell_call = $an->data->{path}{echo}." 1";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
			name2 => "shell_call",                      value2 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If I don't have a 'use_ip', scan the node.
		if (not $an->data->{sys}{anvil}{$peer_key}{use_ip})
		{
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$peer_key}{uuid}, short_scan => 1});
			
			# If I still don't have a 'use_ip', sleep and loop.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::anvil::${peer_key}::use_ip", value1 => $an->data->{sys}{anvil}{$peer_key}{use_ip},
			}, file => $THIS_FILE, line => __LINE__});
			if (not $an->data->{sys}{anvil}{$peer_key}{use_ip})
			{
				sleep 5;
				next;
			}
		}
		
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $an->data->{sys}{anvil}{$peer_key}{use_ip},
			port       => $an->data->{sys}{anvil}{$peer_key}{use_port}, 
			password   => $an->data->{sys}{anvil}{$peer_key}{password},
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line eq "1")
			{
				$access = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "access", value1 => $access, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "access", value1 => $access, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $access)
		{
			# Tell the user.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "error", value1 => $error, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($error)
			{
				$an->Log->entry({log_level => 1, message_key => "asst_log_0010", message_variables => {
					peer	=>	$an->data->{sys}{anvil}{$peer_key}{name},
					error	=>	$error, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				$an->Log->entry({log_level => 1, message_key => "asst_log_0011", message_variables => {
					peer	=>	$an->data->{sys}{anvil}{$peer_key}{name},
				}, file => $THIS_FILE, line => __LINE__});
			}
			# Sleep a bit.
			sleep 5;
		}
	}
	
	return(0);
}

# This checks to see if we should start without our peer and sets 'sys::single_node_start::ran' if it does.
sub check_single_node_start
{
	my ($an, $peer_name, $waiting_started_at, $stop_waiting_at) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_single_node_start" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "peer_name",          value1 => $peer_name, 
		name2 => "waiting_started_at", value2 => $waiting_started_at, 
		name3 => "stop_waiting_at",    value3 => $stop_waiting_at, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Waited more that our boot delay and single node start is enabled, so see if we last saw the peer as
	# offline and, if so, end the wait.
	my $difference = $stop_waiting_at - time;
	### NOTE: Customer requested, move to 2 before v2.0 release
	$an->Log->entry({log_level => 1, message_key => "an_variables_0006", message_variables => {
		name1 => "peer_name",                       value1 => $peer_name, 
		name2 => "sys::single_node_start::enabled", value2 => $an->data->{sys}{single_node_start}{enabled},
		name3 => "waiting_started_at",              value3 => $waiting_started_at, 
		name4 => "stop_waiting_at",                 value4 => $stop_waiting_at,
		name5 => "time",                            value5 => time,
		name6 => "difference",                      value6 => $difference,
	}, file => $THIS_FILE, line => __LINE__});
	if ((time > $stop_waiting_at) && ($an->data->{sys}{single_node_start}{enabled}))
	{
		# what was the state of my peer last time I saw it?
		my $peer_state_variable  = "sys::node::".$peer_name."::last_seen";
		my $last_booted_variable = "sys::node::".$peer_name."::last_booted_without";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "peer_state_variable",  value1 => $peer_state_variable,
			name2 => "last_booted_variable", value2 => $last_booted_variable,
		}, file => $THIS_FILE, line => __LINE__});
		
		my $last_peer_state = $an->ScanCore->read_variable({
				variable_name         => $peer_state_variable,
				variable_source_uuid  => $an->data->{sys}{host_uuid},
				variable_source_table => "hosts",
			});
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "last_peer_state", value1 => $last_peer_state,
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($last_peer_state eq "off")
		{
			# It was off. See if we've kicked it before and, if so, how long ago.
			my $last_booted = $an->ScanCore->read_variable({
				variable_name         => $last_booted_variable,
				variable_source_uuid  => $an->data->{sys}{host_uuid},
				variable_source_table => "hosts",
			});
			$last_booted = 0 if not $last_booted;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "last_booted", value1 => $last_booted,
			}, file => $THIS_FILE, line => __LINE__});
			
			# I am allowed to boot when the current time is greater than the last boot time plus
			# the boot frequency time.
			my $boot_after = $last_booted + $an->data->{sys}{single_node_start}{boot_frequency};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "sys::single_node_start::boot_frequency", value1 => $an->data->{sys}{single_node_start}{boot_frequency},
				name2 => "time",                                   value2 => time,
				name3 => "boot_after",                             value3 => $boot_after,
			}, file => $THIS_FILE, line => __LINE__});
			
			# Is it time?
			my $waited_long_enough = 0;
			until ($waited_long_enough)
			{
				if (time > $boot_after)
				{
					### Boot!
					# Record this start time
					my $variable_uuid = $an->ScanCore->insert_or_update_variables({
						variable_name         => $last_booted_variable,
						variable_value        => time,
						variable_source_uuid  => $an->data->{sys}{host_uuid}, 
						variable_source_table => "hosts", 
						update_value_only     => 1,
					});
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "variable_uuid", value1 => $variable_uuid, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Record that we waited long enough
					$waited_long_enough = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "waited_long_enough", value1 => $waited_long_enough,
					}, file => $THIS_FILE, line => __LINE__});
					
					# We'll now start cman, set a delayed_run for five minutes in the 
					# future to call 'pkill drbdadm', start rgmanager and wait for the
					# pkill to fire. Once fired, we'll verify that our local storage is
					# 'Primary/UpToDate' and if so, proceed with the boot. If not, we'll
					# shut down.
					my $shell_call = $an->data->{path}{initd}."/cman start";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "shell_call", value1 => $shell_call, 
					}, file => $THIS_FILE, line => __LINE__});
					open(my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
					while(<$file_handle>)
					{
						chomp;
						my $line =  $_;
						$line =~ s/\r//g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "line", value1 => $line, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					close $file_handle;
					
					# Set the delayed pkill to abort drbd's wait-for-connection
					my ($token, $delayed_run_output, $problem) = $an->System->delayed_run({
						command  => $an->data->{path}{pkill}." drbdadm",
						delay    => 300,
						target   => "local",
					});
					
					# Now start rgmanager
					$shell_call = $an->data->{path}{initd}."/rgmanager start";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "shell_call", value1 => $shell_call, 
					}, file => $THIS_FILE, line => __LINE__});
					open($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
					while(<$file_handle>)
					{
						chomp;
						my $line =  $_;
						$line =~ s/\r//g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "line", value1 => $line, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					close $file_handle;
					
					# Now wait for the output from the pkill.
					my $done = 0;
					until($done)
					{
						# Read the output.
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "delayed_run_output", value1 => $delayed_run_output, 
						}, file => $THIS_FILE, line => __LINE__});
						if (-e $delayed_run_output)
						{
							my $output     = "";
							my $shell_call = $delayed_run_output;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "shell_call", value1 => $shell_call, 
							}, file => $THIS_FILE, line => __LINE__});
							open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
							while(<$file_handle>)
							{
								chomp;
								my $line = $_;
								$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
									name1 => "line", value1 => $line, 
								}, file => $THIS_FILE, line => __LINE__});
								
								if ($line =~ /arj-rc:(\d+)/)
								{
									# We're done.
									my $return_code = $1;
									   $done        = 1;
									$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
										name1 => "return_code", value1 => $return_code, 
										name2 => "done",        value2 => $done, 
									}, file => $THIS_FILE, line => __LINE__});
								}
							}
							close $file_handle;
							
							# sleep if we haven't seen the output yet.
							if (not $done)
							{
								sleep 1;
							}
						}
						else
						{
							# No output yet, sleep.
							sleep 5;
						}
					}
					
					# Record that we started alone.
					$an->data->{sys}{single_node_start}{ran} = 1;
					
					# It takes a bit for the storage to actually come up, so we'll watch clustat for the storage services
					# to start, then verify that /shared is mounted on both nodes.
					wait_for_storage($an, "local");
				}
				else
				{
					### TODO: If this is running after a second reboot within the boot 
					###       frequency delay, it will wait up to 24 hours (or whatever 
					###       the user set), even if the peer shows up in the meantime. 
					###       Update this to abort if the peer connects.
					sleep 10;
					my $difference = $boot_after - time;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
						name1 => "time",       value1 => time,
						name2 => "boot_after", value2 => $boot_after,
						name3 => "difference", value3 => $difference,
					}, file => $THIS_FILE, line => __LINE__});
					
					# See if my peer came up in the meantime.
				}
			}
		}
	}
	
	return(0);
}

# This figures out who I am, what Anvil! I am in and who my peer is.
sub find_myself
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "find_myself" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $hostname_full  = $an->hostname();
	my $hostname_short = $an->short_hostname();
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "hostname_full",  value1 => $hostname_full, 
		name2 => "hostname_short", value2 => $hostname_short, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Collect information about this Anvil!
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cluster_conf},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_uuid}     = $return->{anvil_uuid};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
		name4 => "sys::anvil_uuid", value4 => $an->data->{sys}{anvil_uuid}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Load the Anvil!
	$an->Striker->load_anvil({anvil_uuid => $an->data->{sys}{anvil_uuid}});
	
	# If I am node 2, make note so that we can delay and let node 1 run first.
	if (($an->data->{sys}{local_node} =~ /n02/) or ($an->data->{sys}{local_node} =~ /node02/) or ($an->data->{sys}{local_node} =~ /node2/))
	{
		$an->data->{sys}{i_am_node2} = 1;
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::i_am_node2", value1 => $an->data->{sys}{i_am_node2}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Do a quick scan of the nodes.
	$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}, short_scan => 1});
	$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}, short_scan => 1});
	
	# Now setup my access info.
	my $node_name = $an->data->{sys}{local_node};
	my $node_key  = $an->data->{sys}{node_name}{$node_name}{node_key};
	my $peer_key  = $an->data->{sys}{node_name}{$node_name}{peer_node_key};
	my $peer_name = $an->data->{sys}{anvil}{$node_key}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "node_name", value1 => $node_name, 
		name2 => "node_key",  value2 => $node_key, 
		name3 => "peer_key",  value3 => $peer_key, 
		name4 => "peer_name", value4 => $peer_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{sys}{local_key} = $node_key;
	$an->data->{sys}{peer_key}  = $peer_key;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
		name1 => "sys::anvil::${node_key}::name",     value1 => $an->data->{sys}{anvil}{$node_key}{name}, 
		name2 => "sys::anvil::${node_key}::use_ip",   value2 => $an->data->{sys}{anvil}{$node_key}{use_ip}, 
		name3 => "sys::anvil::${node_key}::use_port", value3 => $an->data->{sys}{anvil}{$node_key}{use_port}, 
		name4 => "sys::anvil::${node_key}::online",   value4 => $an->data->{sys}{anvil}{$node_key}{online}, 
		name5 => "sys::anvil::${peer_key}::name",     value5 => $an->data->{sys}{anvil}{$peer_key}{name}, 
		name6 => "sys::anvil::${peer_key}::use_ip",   value6 => $an->data->{sys}{anvil}{$peer_key}{use_ip}, 
		name7 => "sys::anvil::${peer_key}::use_port", value7 => $an->data->{sys}{anvil}{$peer_key}{use_port}, 
		name8 => "sys::anvil::${peer_key}::online",   value8 => $an->data->{sys}{anvil}{$peer_key}{online}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0002", message_variables => {
		name1 => "sys::anvil::${node_key}::password", value1 => $an->data->{sys}{anvil}{$node_key}{password}, 
		name2 => "sys::anvil::${peer_key}::password", value2 => $an->data->{sys}{anvil}{$peer_key}{password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Figure out what my peer's BCN, SN and IFN names are
	$an->data->{peer}{short_name} =  $an->data->{sys}{peer_node};
	$an->data->{peer}{short_name} =~ s/\..*$//;
	$an->data->{peer}{bcn_name}   =  $an->data->{peer}{short_name}.".bcn";
	$an->data->{peer}{sn_name}    =  $an->data->{peer}{short_name}.".sn";
	$an->data->{peer}{ifn_name}   =  $an->data->{peer}{short_name}.".ifn";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "peer::short_name", value1 => $an->data->{peer}{short_name}, 
		name2 => "peer::bcn_name",   value2 => $an->data->{peer}{bcn_name}, 
		name3 => "peer::sn_name",    value3 => $an->data->{peer}{sn_name}, 
		name4 => "peer::ifn_name",   value4 => $an->data->{peer}{ifn_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This exits if any other instance of this program is running already.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $pids  = $an->Get->pids({program_name => $an->data->{sys}{program_name}});
	my $count = @{$pids};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		$an->nice_exit({exit_code => 1});
	}
	
	return(0);
}

# This looks for other running instances and kills them.
sub abort_other_instances
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "abort_other_instances" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $pids  = $an->Get->pids({program_name => $an->data->{sys}{program_name}});
	my $count = @{$pids};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $pid (sort {$a cmp $b} @{$pids})
	{
		my $killed = kill 15, $pid;
		if ($killed)
		{
			# He's dead, Jim.
			print $an->String->get({key => "asst_message_0010", variables => { pid => $pid }})."\n";
		}
		else
		{
			# SIGTERM was not terminal enough...
			my $die_already = kill 9, $pid;
			if ($die_already)
			{
				print $an->String->get({key => "asst_message_0011", variables => { pid => $pid }})."\n";
			}
			else
			{
				# Fine, be stubborn, see if I care...
				print $an->String->get({key => "asst_message_0012", variables => { pid => $pid }})."\n";
			}
		}
	}
	
	return(0);
}

### TODO: This will break if translated; add '--script' to have codes printed and parse that.
# This checks to see if an instance of the program is running. It also checks to see if the program is 
# configured to run on boot.
sub report_state
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "report_state" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Is it enabled in striker.conf?
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "tools::anvil-safe-start::enabled", value1 => $an->data->{tools}{'anvil-safe-start'}{enabled}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{tools}{'anvil-safe-start'}{enabled})
	{
		# Yup.
		print $an->String->get({key => "asst_message_0005", variables => { this_file => $THIS_FILE }})."\n";
	}
	else
	{
		# Nope.
		print $an->String->get({key => "asst_message_0006", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	# Is it running now?
	my $pids  = $an->Get->pids({program_name => $an->data->{sys}{program_name}});
	my $count = @{$pids};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		# Yup.
		print $an->String->get({key => "asst_message_0007", variables => { this_file => $THIS_FILE }})."\n";
		foreach my $pid (sort {$a cmp $b} @{$pids})
		{
			print $an->String->get({key => "asst_message_0008", variables => { pid => $pid }})."\n";
		}
	}
	else
	{
		print $an->String->get({key => "asst_message_0009", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	return(0);
}

# Remove the crontab entry.
sub remove_from_root_crontab
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "remove_from_root_crontab" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $rewrite    = 0;
	my $body       = "";
	my $shell_call = $an->data->{path}{root_crontab};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $path = $an->data->{path}{'anvil-safe-start'};
		if ($line =~ /$path/)
		{
			# Found it
			$rewrite = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "rewrite", value1 => $rewrite, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Save this line
			$body .= $line."\n";
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "rewrite", value1 => $rewrite, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($rewrite)
	{
		# Save the file.
		my $shell_call = $an->data->{path}{root_crontab};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle $body;
		close $file_handle;
	}
	
	return(0);
}

# This checks to see if the old-style 'anvil-safe-start' crontab entry exists and, if do, removes it
sub check_root_crontab
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "add_to_root_crontab" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Make sure the crontab entry exists.
	my $clean_up   = 0;
	my $shell_call = "
if \$(".$an->data->{path}{'grep'}." -q '\\*/1 \\* \\* \\* \\* ".$an->data->{path}{'anvil-safe-start'}."' ".$an->data->{path}{root_crontab}.");
then 
    ".$an->data->{path}{echo}." 'old found'; 
fi";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /old found/)
		{
			# Remove it.
			$clean_up = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "clean_up", value1 => $clean_up, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# If I need to clean up, remove the rc3.d symlink, if found, and remove the old crontab entry. If the
	# symlink existed, enable this program in striker.conf.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "clean_up", value1 => $clean_up, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($clean_up)
	{
		print $an->String->get({key => "asst_message_0024"})."\n";
		my $enable = 0;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::anvil-safe-start_link", value1 => $an->data->{path}{'anvil-safe-start_link'}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (-e $an->data->{path}{'anvil-safe-start_link'})
		{
			$enable = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "enable", value1 => $enable, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Delete the old crontab entry.
		remove_from_root_crontab($an);
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "enable", value1 => $enable, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($enable)
		{
			# Remove the link
			remove_rc3d_symlink($an);
			
			# Add the new style to crontab
			add_to_root_crontab($an);
			
			# Enable this is striker.conf
			update_striker_conf($an, "enable");
		}
		else
		{
			# Make sure it's disabled in striker.conf.
			update_striker_conf($an, "disable");
		}
	}
	
	return(0);
}

# This removes the /etc/rc3.d/ symlink that was used in the past.
sub remove_rc3d_symlink
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "remove_rc3d_symlink" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, does the symlink exist already?
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "path::anvil-safe-start_link", value1 => $an->data->{path}{'anvil-safe-start_link'}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{'anvil-safe-start_link'})
	{
		# Remove it
		my $file = $an->data->{path}{'anvil-safe-start_link'};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "file", value1 => $file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		unlink $file or $an->Alert->error({title_key => "an_0003", message_key => "error_message_0053", message_variables => { file => $file, error => $! }, code => 53, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 1, message_key => "asst_log_0004", file => $THIS_FILE, line => __LINE__});
		print $an->String->get({key => "asst_message_0003", variables => { this_file => $THIS_FILE }})."\n";
	}
	else
	{
		# Already gone, nothing to do.
		$an->Log->entry({log_level => 1, message_key => "asst_log_0005", file => $THIS_FILE, line => __LINE__});
		print $an->String->get({key => "asst_message_0004", variables => { this_file => $THIS_FILE }})."\n";
	}
	
	return(0);
}

# This adds anvil-safe-start to the root user's cron table if needed.
sub add_to_root_crontab
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "add_to_root_crontab" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Make sure the crontab entry exists.
	my $shell_call = "
if \$(".$an->data->{path}{'grep'}." -q '".$an->data->{path}{'anvil-safe-start'}."' ".$an->data->{path}{root_crontab}.");
then 
    ".$an->data->{path}{echo}." '".$an->String->get({key => "asst_message_0021"})."'; 
else 
    ".$an->data->{path}{echo}." '".$an->String->get({key => "asst_message_0022"})."';
    ".$an->data->{path}{echo}." '\@reboot ".$an->data->{path}{'anvil-safe-start'}."' >> ".$an->data->{path}{root_crontab}."
fi";
#    ".$an->data->{path}{echo}." '*/1 * * * * ".$an->data->{path}{'anvil-safe-start'}."' >> ".$an->data->{path}{root_crontab}."
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "asst_message_0015"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
