#!/usr/bin/perl
# 
# This tool updates the local dashboard's OS, Striker/ScanCore software, updates the ScanCore database and
# uses cached RPMs to update its own local repository. Optionally, it can be pointed at a node and pull and
# integrate its updated RPMs into the local repository.
# 
# Return Codes:
# 0  = OK
# 1  = Not run on a Striker dashboard.
# 2  = Not run as root.
# 

use strict;
use warnings;
use IO::Handle;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# We can't use the AN::Tools here because it will be part of what we're updating.
my $conf = {
	executable	=>	{
		createrepo	=>	"createrepo",
		'mkdir'		=>	"/bin/mkdir",
		ping		=>	"/bin/ping",
	},
	path		=>	{
		current_dir	=>	$ENV{PWD},
		# This file is checked to verify that we're on a Striker dashboard.
		striker		=>	"/var/www/cgi-bin/striker",
		# These are appended to 'path::current_dir'
		updates		=>	{
			# If this directory exists and has RPMs in it, we'll use what is in it to 
			# update the local repository before doing the OS update. Once the update is
			# done, all downloaded RPMs will be copied into this directory
			rpms		=>	$THIS_FILE."/rpms/",
			# The striker source files will be saved in this directory. If there is no
			# internet access to download the latest version, files found in here will be
			# used instead.
			striker		=>	$THIS_FILE."/source/",
			# This is used to store temporary files
			temp		=>	$THIS_FILE."/temp/",
		},
	},
	url		=>	{
		# By default, we will read the latest release from 'striker_latest'. If, however, we can't
		# access that file, we'll use 'striker_default'. Optionally, the user can request the latest
		# master with '--master', in which case we will download the 'striker_master' URL. In all
		# cases, the downloaded file will be saved as 'striker_zip_file'.
		striker_default	=>	"https://github.com/ClusterLabs/striker/archive/2.0.0b-rc8.zip",
		striker_latest	=>	"https://www.alteeve.com/an-repo/striker_latest.txt",
		striker_master	=>	"https://codeload.github.com/ClusterLabs/striker/zip/master",
		striker_zip_file =>	"striker.zip",
		support		=>	"https://alteeve.com/w/Support",
		ping_targets	=>	"8.8.8.8,google.com,redhat.com,alteeve.com",
	},
	switches	=>	{
		offline		=>	0,
		'gather-only'	=>	0,
	},
	sys		=>	{
		debug		=>	2,
		update		=>	1,
		offline		=>	0,
		ping_attempts	=>	3,
	},
};

print "-=] Anvil! system (Striker and ScanCore) update started.\n\n";

get_switches($conf);
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};
if (($conf->{switches}{h})    or 
    ($conf->{switches}{'?'})  or 
    ($conf->{switches}{help}))
{
	print_usage($conf);
	exit(0);
}

# Enable debugging if the user requested it.
$conf->{sys}{debug} = 1 if $conf->{switches}{v};
$conf->{sys}{debug} = 2 if $conf->{switches}{vv};
$conf->{sys}{debug} = 3 if $conf->{switches}{vvv};

# Is this a striker dashboard?
if (not -e $conf->{path}{striker})
{
	print "[ Error ] - This must be run on a Striker dashboard.\n";
	exit(1);
}

# Is this running as root?
if (($< != 0) && ($> != 0))
{
	print "[ Error ] - This must be run as the root user.\n";
	exit(2);
}

# Am I to go offline?
if ($conf->{switches}{offline})
{
	print "[ Note ] - Offline update requested. Cached data will be used.\n\n";
	$conf->{sys}{offline} = 1;
}

# Am I to download updates only?
if ($conf->{switches}{'gather-only'})
{
	print "[ Note ] - Updates will be downloaded and stored in cache only.\n\n";
	$conf->{sys}{offline} = 1;
}

# First, setup the local cache directories, if they don't already exists
setup_cache($conf);

# Make sure we're actually online, unless we were told to work offline
if (not $conf->{sys}{offline})
{
	check_internet_access($conf);
}

# If we're online (still), download the striker source
if (not $conf->{sys}{offline})
{
	# Download the latest source
	print "Downloading latest Striker...\n";
	if ($conf->{switches}{master})
	{
		print "[ Warning ] - Master branch requested. This should be used by developers and\n";
		print "              testers only. Please don't use this in production!\n\n";
		sleep 3;
	}
}

# What am I doing?
if (($conf->{switches}{'node-name'}) or ($conf->{switches}{'node-name'}))
{
	update_node($conf);
}
else
{
	update_local($conf);
}


	
die $THIS_FILE." ".__LINE__."; testing...\n";

exit(0);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This tries to ping a few targets to see if we have internet access.
sub check_internet_access
{
	my ($conf) = @_;
	
	print "Checking for Internet access...\n";
	my $pinged = 0;
	my $count  = $conf->{sys}{ping_attempts};
	foreach my $target (split/,/, $conf->{url}{ping_targets})
	{
		print "- Trying to ping: [$target]...\n" if $conf->{sys}{debug} >= 1;
		
		my $shell_call = $conf->{executable}{ping}." -W 1 -c $count $target";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 3;
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; \n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 3;
			
			if ($line =~ /^\d+ bytes from $target: icmp_seq=\d+ ttl=\d+ time=\d+/)
			{
				# Success!
				$pinged = 1;
				last;
			}
			if ($line =~ /(\d+) packets transmitted, (\d+) received/)
			{
				# This isn't really needed, but might help folks watching the logs.
				my $pings_sent     = $1;
				my $pings_received = $2;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - pings_sent: [$pings_sent], pings_received: [$pings_received]\n" if $conf->{sys}{debug} >= 3;
				if ($pings_received)
				{
					# Contact!
					$pinged = 1;
					last;
				}
				else
				{
					# Not yet... Sleep to give time for transient network problems to 
					# pass.
					sleep 1;
				}
			}
		}
		close $file_handle;
		if ($pinged)
		{
			print "- Success!\n" if $conf->{sys}{debug} >= 1;
			last;
		}
	}
	
	if ($pinged)
	{
		print "- Internet access appears to be available.\n\n";
	}
	else
	{
		print "- We appear to be offline. Update will proceed with cached data, if any.\n\n";
		$conf->{sys}{offline} = 1;
	}
	
	return(0);
}

# This creates the cache directories, if they don't already exist.
sub setup_cache
{
	my ($conf) = @_;
	
	print "Checking cache directories...\n";
	my $rpm_cache     = $conf->{path}{current_dir}."/".$conf->{path}{updates}{rpms};
	my $striker_cache = $conf->{path}{current_dir}."/".$conf->{path}{updates}{striker};
	my $temp_cache    = $conf->{path}{current_dir}."/".$conf->{path}{updates}{temp};
	print "$THIS_FILE ".__LINE__."; [ Debug ] - path::current_dir: [".$conf->{path}{current_dir}."], rpm_cache: [$rpm_cache], striker_cache: [$striker_cache], temp_cache: [$temp_cache]\n" if $conf->{sys}{debug} >= 3;
	
	if (-e $rpm_cache)
	{
		print "- RPM cache: [$rpm_cache] already exists.\n";
	}
	else
	{
		print "- Creating RPM cache: [$rpm_cache]\n";
		my $shell_call = $conf->{executable}{'mkdir'}." -p ".$rpm_cache;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 3;
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; \n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 3;
		}
		close $file_handle;
	}
	if (-e $striker_cache)
	{
		print "- Striker cache: [$striker_cache] already exists.\n";
	}
	else
	{
		print "- Creating Striker cache: [$striker_cache]\n";
		my $shell_call = $conf->{executable}{'mkdir'}." -p ".$striker_cache;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 3;
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; \n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 3;
		}
		close $file_handle;
	}
	if (-e $temp_cache)
	{
		print "- Working cache: [$temp_cache] already exists.\n";
	}
	else
	{
		print "- Creating working cache: [$temp_cache]\n";
		my $shell_call = $conf->{executable}{'mkdir'}." -p ".$temp_cache;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 3;
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; \n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 3;
		}
		close $file_handle;
	}
	print "- Done.\n\n";
	
	return(0);
}

# This updates the local machine.
sub update_local
{
	my ($conf) = @_;
	
	# First, are we online?
	
	
	return(0);
}

# This updates a node.
sub update_node
{
	my ($conf) = @_;
	
	
	
	return(0);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			elsif (($argument eq "start") or ($argument eq "stop") or ($argument eq "status"))
			{
				$conf->{switches}{$argument} = 1;
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	if ($conf->{sys}{debug} >= 2)
	{
		foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}})
		{
			print "$THIS_FILE ".__LINE__."; [ Debug ] - switches::$variable: [$conf->{switches}{$variable}]\n" if $conf->{sys}{debug} >= 3;
		}
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Striker Update

DESCRIPTION

This program will update the local OS, the Striker/ScanCore data and Update the
ScanCore database. Packages updated when the OS is updated will be integrated
into the loca repository. Optionally, updated RPMs on a target node can also be
integrated into the local repository.


NOTE

If your system has no internet connection, you can manually copy files to:

#!data!path::update_cache!#/rpms/
#!data!path::update_cache!#/source/

Any RPMs found in the 'rpms' directory will be loaded into the local repository
prior to running the OS update. If 'striker*.zip' (striker.zip, 
striker-master.zip, etc) is found under the 'source' directory, that will be
unpacked and used to update Striker (on dashboards) and ScanCore (on all 
machines). 

You only need to pre-populate on Striker dashboards. This program will use the
local data to update nodes.


SWITCHES

 --gather-only

	When called without a node being defined, 

 -h, -?, --help

	Show this dialoge and exit.

 --master

	This will upgrade to the latest (master branch) version available on 
	GitHub: https://github.com/ClusterLabs/striker
	
	### WARNING: This is only recommended for developers or testers. Do not
	###          upgrade to master on production systems!

 --node-name <node>
 --node-uuid <uuid>

	This is the node name or UUID connect to. The node must be a member of
	an Anvil! we know of. 
	
	By default, we will check to see if the node is withdrawn and, if it 
	is, we will update its OS and ScanCore tools prior to pulling updates
	over to integrate. 
	
	If '--gather-only' is used, or if the node is still a member of the 
	Anvil!, no update will be performed. 

 --offline

	Don't try to update anything from the Internet. This will use files 
	already in:
	
	RPMS: .. #!data!path::updates::rpms!#
	Striker: #!data!path::updates::striker!#


SUPPORT

".$conf->{url}{support}."

                                                          Alteeve's Niche! Inc.
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die __LINE__."; Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}
