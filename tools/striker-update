#!/usr/bin/perl
# 
# This tool updates the local dashboard's OS, Striker/ScanCore software, updates the ScanCore database and
# uses cached RPMs to update its own local repository. Optionally, it can be pointed at a node and pull and
# integrate its updated RPMs into the local repository.
# 
### NOTE: The local machine needs to be updated before trying to update the other dashboard or nodes.
#
### NOTE: This program doesn't use translated strings because it is too likely that the old version won't 
#         have all the strings we need, which would cause String->get() to error out.
#         
### TODO: Test the database schema and if the old schema doesn't match, either update it or abort.
### 
### TODO: Look for path::updates::striker/.dontupdate and, if found, don't download the source. This will 
###       allow an update to the OS without updating Striker/ScanCore.
# 
# Return Codes:
# 0  = OK
# 1  = Not run on a Striker dashboard.
# 2  = Not run as root.
# 3  = The temporary directory didn't end in /temp, indicating a program error.
# 4  = Failed to connect to the ScanCore database.
# 5  = Failed to look up the Anvil! UUID for the given name.
# 6  = Failed to look up the Anvil! name for the given uuid.
# 7  = Neither node was online or reachable.
# 8  = Failed to find the source ISO needed to populate the img/ directory.
# 9  = Failed to find the XML file used by 'createrepo' on the source ISO.
# 10 = Failed generating the RPM repository metadata.
# 11 = Failed to rsync a file from a remote machine.
# 12 = Unable to access one or more peer dashboards.
# 13 = Failed to find an active Anvil! system.
# 14 = One or more Anvil! nodes are offline.
# 15 = A node's DRBD disk state was not UpToDate.
# 16 = One node is in the cluster and the other isn't.
# 17 = Failed to match a server to a host.
# 18 = One or more servers found still running after trying to migrate all servers off a node.
# 19 = Node didn't withdraw from the Anvil! properly.
# 20 = Failed to download a file.
# 21 = Failed to connect to a given database while checking if the DB schema needed to be updated.
# 22 = Failed to update the an-el6.repo file.
# 23 = Server migration failed.
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use XML::Simple;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({
	data			=> {
		copy			=>	{
			all			=>	{
				'tools/*'		=>	'/sbin/striker/',
				'ScanCore'		=>	'/sbin/striker/',
				'cgi-bin/Data'		=>	'/sbin/striker/',
				'AN'			=>	'/usr/share/perl5/',
			},
			dashboard		=>	{
				'cgi-bin'		=>	'/var/www/',
				'html'			=>	'/var/www/',
			},
		},
		path			=>	{
			an_repo			=>	"/etc/yum.repos.d/an-el6.repo",
			# Some of the paths to executables weren't defined in older versions of Tools.pm.
			'anvil-migrate-server'	=>	"/sbin/striker/anvil-migrate-server",
			'anvil-safe-start'	=>	"/sbin/striker/anvil-safe-start",
			bzip2			=>	"/usr/bin/bzip2",
			createrepo		=>	"/usr/bin/createrepo",
			'chown'			=>	"/bin/chown",
			'chmod'			=>	"/bin/chmod",
			curl			=>	"/usr/bin/curl",
			current_dir		=>	$ENV{PWD},
			echo			=>	"/bin/echo",
			etc_fstab		=>	"/etc/fstab",
			# This file is checked to verify that we're on a Striker dashboard.
			find			=>	"/bin/find",
			gcc			=>	"/usr/bin/gcc",
			'grep'			=>	"/bin/grep",
			img_directory		=>	"/var/www/html/#!os_type!#/x86_64/img",
			iso_directory		=>	"/var/www/html/#!os_type!#/x86_64/iso",
			log_file		=>	"/var/log/striker.log",
			mount			=>	"/bin/mount",
			mv			=>	"/bin/mv",
			# This is needed for some legacy support
			nodes			=>	{
				'anvil-safe-start'	=>	"/sbin/striker/anvil-safe-start",
			},
			os_release		=>	"/etc/redhat-release",
			pg_dump			=>	"/usr/bin/pg_dump",
			reboot			=>	"/sbin/reboot",
			sed			=>	"/bin/sed",
			striker			=>	"/var/www/cgi-bin/striker",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_dir		=>	"/sbin/striker/",
			su			=>	"/bin/su",
			tar			=>	"/bin/tar",
			tarball_dir		=>	"",
			unzip			=>	"/usr/bin/unzip",
			umount			=>	"/bin/umount",
			# These are appended to 'path::current_dir'
			updates			=>	{
				# If this directory exists and has RPMs in it, we'll use what is in it to 
				# update the local repository before doing the OS update. Once the update is
				# done, all downloaded RPMs will be copied into this directory
				rpms			=>	$running_directory."/".$THIS_FILE."_cache/rpms",
				# The striker source files will be saved in this directory. If there is no
				# internet access to download the latest version, files found in here will be
				# used instead.
				striker			=>	$running_directory."/".$THIS_FILE."_cache/source",
				# This is used to store temporary files
				temp			=>	$running_directory."/".$THIS_FILE."_cache/temp",
			},
			yum_cache		=>	"/var/cache/yum",
		},
		url			=>	{
			# By default, we will read the latest release from 'striker_latest'. If, however, we can't
			# access that file, we'll use 'striker_default'. Optionally, the user can request a branch
			# with '--branch [branch_name]', in which case we will download the 'striker_source_prefix'.'branch_name' URL. In all
			# cases, the downloaded file will be saved as 'striker_zip_file'.
			striker_default			=>	"https://github.com/ClusterLabs/striker/archive/v2.0.8.zip",
			striker_latest			=>	"https://www.alteeve.com/an-repo/striker_latest.txt",
			striker_source_prefix	=>	"https://codeload.github.com/ClusterLabs/striker/zip/",
			support					=>	"https://alteeve.com/w/Support",
			ping_targets			=>	"8.8.8.8,google.com,redhat.com,alteeve.com",
		},
		switches		=>	{
			offline			=>	0,
			'gather-only'		=>	0,
			'anvil-name'		=>	"",
			'anvil-uuid'		=>	"",
		},
		sys			=>	{
			debug			=>	2,
			install_master		=>	0,
			install_version		=>	"",
			log_level		=>	2,
			log_language		=>	"en_CA",
			log_db_transactions	=>	0,
			offline			=>	0,
			ping_attempts		=>	3,
			reboot_needed		=>	0,
			reboot_timeout		=>	600,
			striker_zip_file	=>	"striker.zip",
			update			=>	1,
		},
		permissions		=>	{
			striker_cache		=>	{
				path			=>	"/var/www/home/cache",
				owner			=>	"apache",
				group			=>	"apache",
				mode			=>	"775",
				chown_recursive		=>	1,
				chmod_recursive		=>	0,
			},
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{$THIS_FILE}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

print "-=] Anvil! system (Striker and ScanCore) update started.\n\n";

# Enable debugging if the user requested it.
$an->data->{sys}{debug} = 1 if $an->data->{switches}{v};
$an->data->{sys}{debug} = 2 if $an->data->{switches}{vv};
$an->data->{sys}{debug} = 3 if $an->data->{switches}{vvv};

# If the user used '--anvil', copy it to 'anvil-name')
if ($an->data->{switches}{'anvil'})
{
	$an->data->{switches}{'anvil-name'} = $an->data->{switches}{'anvil'};
}

# Is this a striker dashboard?
if (not -e $an->data->{path}{striker})
{
	print "[ Error ] - This must be run on a Striker dashboard.\n";
	exit(1);
}

# Is this running as root?
if (($< != 0) && ($> != 0))
{
	print "[ Error ] - This must be run as the root user.\n";
	exit(2);
}

# Make '--no-os-updates' work
if ($an->data->{switches}{'no-os-updates'})
{
	$an->data->{switches}{'no-os-update'} = 1;
}

# Am I to go offline?
if ($an->data->{switches}{offline})
{
	print "[ Note ] - Offline update requested. Cached data will be used.\n\n";
	$an->data->{sys}{offline} = 1;
}

# Am I to download updates only?
if ($an->data->{switches}{'gather-only'})
{
	print "[ Note ] - Updates will be downloaded and stored in cache only.\n\n";
}

# Connect to the database(s).
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
	name1 => "connections", value1 => $connections,
}, file => $THIS_FILE, line => __LINE__});
if (not $connections)
{
	print "[ Error ] - Failed to connect to the ScanCore database. Is postgres running?\n";
	exit(4);
}

# Make sure we're actually online, unless we were told to work offline
if (not $an->data->{sys}{offline})
{
	check_internet_access($an);
}

if (($an->data->{sys}{offline}) && ($an->data->{switches}{'gather-only'}))
{
	print "There appears to be no internet connection and we've been asked to gather-only.\n";
	print "There is no reason to proceed, exiting.\n";
	exit(0);
}

# Ask the user to confirm. What exactly we say will depend on a few switches. First, a general warning.
print "\n-=] Striker Updater [=-\n\n";
print "This update tool is designed to update an Anvil! without causing a service\n";
print "interruption. However, no software is perfect.\n\n";

my $show_striker_warning = 1;
my $show_anvil_warning   = 1;
if ($an->data->{sys}{offline})
{
	print "[ Note ] - We are offline. Updates will be limited to local data in cache.\n";
	print "Updates will use files under:\n";
	print "- RPMs: .. [".$an->data->{path}{updates}{rpms}."]\n";
	print "- Striker: [".$an->data->{path}{updates}{striker}."]\n\n";
}
elsif ($an->data->{switches}{'gather-only'})
{
	$show_anvil_warning   = 0;
	$show_striker_warning = 0;
	if (($an->data->{switches}{'anvil-uuid'}) or ($an->data->{switches}{'anvil-name'}))
	{
		print "We will NOT update anything, but we will download and collect operating system.\n";
		print "packages locally and from one of the nodes. The local RPM repository will be\n";
		print "refreshed and, if this system uses an ISO mount, that will be converted to a\n";
		print "standard directory under 'img/'.\n";
	}
	else
	{
		print "We will NOT update anything, but we will download and collect operating system.\n";
		print "packages available for this system. The local RPM repository will be refreshed\n";
		print "and, if this system uses an ISO mount, that will be converted to a standard\n";
		print "directory under 'img/'.\n";
	}
}
elsif ($an->data->{switches}{'anvil-name'} eq "all")
{
	print "This Striker machine, peer dashboards configured in striker.conf, and all\n";
	print "Anvil! systems we know about will be updated.\n\n";
}
elsif (($an->data->{switches}{'anvil-name'}) or ($an->data->{switches}{'anvil-uuid'}))
{
	print "This Striker machine, peer dashboards configured in striker.conf, and the\n";
	print "Anvil! system will be updated.\n\n";
}
else
{
	# Not updating an Anvil!.
	$show_anvil_warning = 0;
}

my $is_branch_switch_set = (($an->data->{switches}{branch}) && ($an->data->{switches}{branch} ne "#!SET!#"));

if ($an->data->{switches}{'no-refresh'})
{
	print "We will NOT refresh our local copy of the Striker source code. If it exists,\n";
	print "we will use what is already cached in:\n";
	print "- Striker: [".$an->data->{path}{updates}{striker}."]\n\n";
}
elsif (($an->data->{switches}{master} or $is_branch_switch_set) && (not $an->data->{switches}{offline}))
{
	if ($an->data->{switches}{master})
	{
		$an->data->{switches}{branch} = "master";
	}

	$an->data->{url}{striker_branch} = $an->data->{url}{striker_source_prefix} . $an->data->{switches}{branch};

	print "We will download the latest source code from GitHub's [".$an->data->{switches}{branch}."] branch.\n";
	print "- NOTE: This should only be done on test and development platforms!\n\n";
}
else
{
	print "We will download the latest Striker release from GitHub.\n\n";
}

if ($show_striker_warning)
{
	print "ScanCore will be stopped during the Striker update. This may cause alerts to be\n";
	print "missed during the update process.\n\n";
}

if ($show_anvil_warning)
{
	print "ScanCore will be stopped during the update of Anvil! nodes. This can cause\n";
	print "alerts to be missed and some self-healing features to be unavailable until the\n";
	print "update completes.\n\n";
	if (not $an->data->{switches}{'no-os-update'})
	{
		print "##] Warning [##################################################################\n";
		print "# The nodes will be withdrawn from the Anvil! during their updates. This will\n";
		print "# result in the loss of redundancy for a period of time. If the kernel is\n";
		print "# updated, the nodes will be rebooted as well.\n";
		print "#\n";
		print "# Servers running on a node will be migrated to their peer node prior to\n";
		print "# withdrawal. If a server's migration type is 'cold' (NOT the default), this\n";
		print "# will cause the server to be rebooted.\n";
		print "###############################################################################\n\n";
	}
}
elsif ($an->data->{switches}{'no-os-update'})
{
	print "NOTE: No OS updates will be applied, only Striker and ScanCore will be updated.\n\n";
}

print "##] NOTE [#####################################################################\n";
print "# Please make sure no one else uses the Striker web interface until this update\n";
print "# is complete! Please also warn anyone receiving alerts to expect notifications\n";
print "# during the update process.\n";
print "###############################################################################\n\n";

print "Shall I proceed? [y/N] ";
if (($an->data->{switches}{y}) or ($an->data->{switches}{yes}))
{
	print "\n- 'Yes' assumed via '-y' switch, proceeding.\n\n";
}
else
{
	my $answer = <STDIN>;
	chomp($answer);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "answer", value1 => $answer,
	}, file => $THIS_FILE, line => __LINE__});
	if (($answer) && (lc($answer) =~ /^y/))
	{
		print "- Proceeding.\n\n";
	}
	else
	{
		print "- Aborting!\n\n";
		exit(0);
	}
}

# First, setup the local cache directories, if they don't already exists
setup_cache($an);

# Update the databases, if needed
update_scancore_databases($an);

# If we're online (still), download the striker source
if (not $an->data->{sys}{offline})
{
	### WARNING: Re-enable this and the download/extract later... We pissed off github downloading them 
	###          too often in dev.
	# Clear out any old temp files.
	#clear_temp($an);
	
	# Download the latest source
	print "Downloading latest Striker...\n";
	print "- Determining version to download...\n";
	get_latest_version($an);
	
	# First, does the '.dontupdate' file exist?
	my $striker_dontupdate = $an->data->{path}{updates}{striker}."/.dontupdate";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "striker_dontupdate", value1 => $striker_dontupdate,
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $striker_dontupdate)
	{
		print "- The \"don't update\" file: [$striker_dontupdate] was found, skipping source code update.\n";
	}
	else
	{
		my $striker_source_test = $an->data->{path}{updates}{striker}."/cgi-bin/striker";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "striker_source_test", value1 => $striker_source_test,
		}, file => $THIS_FILE, line => __LINE__});
		if ($an->data->{switches}{branch})
		{
			print "- Downloading: [".$an->data->{url}{striker_branch}."]\n";
			if ((-e $striker_source_test) && ($an->data->{switches}{'no-refresh'}))
			{
				print "- Skipping download, source appears to already exist and '--no-refresh' used.\n";
			}
			else
			{
				print "\n[ Warning ] - Master branch requested. This should be used by developers and\n";
				print "              testers only. Please don't use this in production!\n\n";
				$an->data->{sys}{install_master} = 1;
				sleep 3;
				download_and_extract_source($an, $an->data->{url}{striker_branch});
			}
		}
		else
		{
			print "- Downloading version: [".$an->data->{sys}{install_version}."] from: [".$an->data->{url}{striker_default}."]\n";
			if ((-e $striker_source_test) && ($an->data->{switches}{'no-refresh'}))
			{
				print "- Skipping download, source appears to already exist and '--no-refresh' used.\n";
			}
			else
			{
				download_and_extract_source($an, $an->data->{url}{striker_default});
			}
		}
		print "- Done\n\n";
	}
	
	# Download any updates to the OS.
	print "Downloading OS updates.\n";
	download_os_updates($an);
	cache_updated_rpms($an);
	
	# If I've been asked to 'gather-only' and an Anvil! name or UUID was passed, pick a node to do a 
	# 'yum -y update --downloadonly' and then pull it's updated RPMs over, too.
	if (($an->data->{switches}{'gather-only'}) && (($an->data->{switches}{'anvil-uuid'}) or ($an->data->{switches}{'anvil-name'})))
	{
		# Gather the RPMs from one of the nodes.
		gather_updated_rpms_from_anvil($an);
	}
}

# Now, update my local RPM repo (be it from 'gather-only' or using cache)
update_local_repo($an);

# If I was doing a gather-only, we're done.
if ($an->data->{switches}{'gather-only'})
{
	print "- Gathered all updates. Exiting on '--gather-only'.\n\n";
	exit(0);
}

# If I am still alive, what am I doing?
if (($an->data->{switches}{'anvil-name'}) or ($an->data->{switches}{'anvil-uuid'}))
{
	# I'm updating everything
	update_all($an);
}
else
{
	# I'm updating the local dashboard only.
	update_local($an);
}

print "[ Note ] - No changes were made to 'striker.conf'.\n";
print "[ Note ]   If you wish to check for new options, please see:\n";
print "[ Note ]   ".$an->data->{path}{updates}{striker}."/striker.conf\n\n";

# Warn the user if a reboot is required.
foreach my $dashboard (sort {$a cmp $b} keys %{$an->data->{reboot_dashboard}})
{
	print "\n[ Note ] - The kernel was updated on: [$dashboard]. Please reboot that machine.\n\n";
}
if ($an->data->{sys}{reboot_needed})
{
	print "\n[ Note ] - The kernel was updated. Please reboot this machine.\n\n";
}

exit(0);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This changes the an-el6-repo to point at alteeve.com
sub update_an_repo
{
	my ($an, $target, $port, $password) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_an_repo" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "target", value1 => $target, 
		name2 => "port",   value2 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "Updating the Alteeve repo to point to alteeve.com.\n";
	my $shell_call = "
if [ -e '".$an->data->{path}{an_repo}."' ]
then
    if \$(".$an->data->{path}{'grep'}." -q alteeve.ca ".$an->data->{path}{an_repo}.");
    then 
        ".$an->data->{path}{echo}." update; 
        ".$an->data->{path}{sed}." -i 's/alteeve.ca/alteeve.com/' ".$an->data->{path}{an_repo}."
        if \$(".$an->data->{path}{'grep'}." -q alteeve.ca ".$an->data->{path}{an_repo}.");
        then
            ".$an->data->{path}{echo}." \"failed\"
        else
            ".$an->data->{path}{echo}." \"success\"
        fi
    else 
        ".$an->data->{path}{echo}." \"not needed\";
    fi  
else
    ".$an->data->{path}{echo}." \"no repo\"
fi
";

	my $return = [];
	if ($target eq "local")
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$return}, $line;
		}
		close $file_handle;
	}
	else
	{
		# Remote call
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		(my $error, my $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
	}
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1  => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line eq "update")
		{
			print "- Update needed.\n";
		}
		elsif ($line eq "failed")
		{
			print "[ Error ] - The RPM repo: [".$an->data->{path}{an_repo}."] on: [$target] needs to be updated, but the update failed.\n";
			print "[ Error ]   The URL should change from 'alteeve.ca' to 'alteeve.com'.\n";
			exit(22);
		}
		elsif ($line eq "success")
		{
			print "- The repo: [".$an->data->{path}{an_repo}."] on: [$target] was updated successfully.\n";
		}
		elsif ($line eq "not needed")
		{
			print "- The repo: [".$an->data->{path}{an_repo}."] on: [$target] doesn't need the update, skipping it.\n";
		}
		elsif ($line eq "no repo")
		{
			print "- The Alteeve EL6 repo is not installed on: [$target], skipping it.\n";
		}
	}
	
	print "- Done.\n\n";
	
	return(0);
}

# This checks to see if each database needs to have its schema updated.
sub update_scancore_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_scancore_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Checking if any databases schemas need to be updated.\n";
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $db_host = $an->data->{scancore}{db}{$id}{host};
		my $db_name = $an->data->{scancore}{db}{$id}{name};
		my $queue   = [];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "db_host", value1 => $db_host, 
			name2 => "db_name", value2 => $db_name, 
		}, file => $THIS_FILE, line => __LINE__});
		print "- Checking to see if the database: [$db_name] on: [$db_host ($id)] needs to be updated.\n";
		
		# Do I have a connection?
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "dbh::$id", value1 => $an->data->{dbh}{$id}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($an->data->{dbh}{$id} !~ /^DBI::db=HASH/)
		{
			print "[ Error ] - I need access to all configured databases in order to update the schema.\n";
			print "[ Error ]   This database is not accessible.\n";
			exit(21);
		}
		
		# Get the name of the database owner.
		my $query = "SELECT pg_catalog.pg_get_userbyid(a.datdba) AS owner FROM pg_catalog.pg_database a WHERE a.datname = ".$an->data->{sys}{use_db_fh}->quote($db_name)." LIMIT 1;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $db_owner = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "db_owner", value1 => $db_owner, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# There are four things to check;
		# 1. Does the locations table exist? If not, add it.
		# 2. Does the hosts table have the 'location_uuid' column? Add it and redo the procedure and trigger, if not.
		# 3. Does the states table have a history table? If so, remove it and its procedure/trigger.
		# 4. Does the history_storcli_physical_drives has the out of order procedure? If so, replace 
		#    it and flush the history table.
		
		# First, do we need to add the 'locations' table?
		$query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='locations' AND schemaname='public';";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (not $count)
		{
			# Add it.
			print "- The 'locations' table needs to be added.\n";
			my $query = '
CREATE TABLE locations (
       location_uuid                   uuid                            not null        primary key,
       location_name                   text                            not null,
       location_note                   text,
       modified_date                   timestamp with time zone        not null 
);
ALTER TABLE locations OWNER TO '.$db_owner.';

CREATE TABLE history.locations (
       history_id                      bigserial, 
       location_uuid                   uuid, 
       location_name                   text, 
       location_note                   text, 
       modified_date                   timestamp with time zone        not null 
);
ALTER TABLE history.locations OWNER TO '.$db_owner.';

CREATE FUNCTION history_locations() RETURNS trigger
AS $$
DECLARE
       history_locations RECORD;
BEGIN
       SELECT INTO history_locations * FROM locations WHERE location_uuid = new.location_uuid;
       INSERT INTO history.locations
               (location_uuid, 
                location_name, 
                location_note, 
                modified_date)
       VALUES
               (history_locations.location_uuid,
                history_locations.location_name, 
                history_locations.location_note, 
                history_locations.modified_date);
       RETURN NULL;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION history_locations() OWNER TO '.$db_owner.';

CREATE TRIGGER trigger_locations
       AFTER INSERT OR UPDATE ON locations
       FOR EACH ROW EXECUTE PROCEDURE history_locations();
';
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
		}
		
		# Second, do we need to add the host_location_uuid column to hosts?
		$query = "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'hosts' AND table_schema = 'public' AND column_name = 'host_location_uuid';";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (not $count)
		{
			# Drop the function and trigger
			print "- The 'hosts' table needs the 'host_location_uuid' column added.\n";
			my $query = "DROP FUNCTION history_hosts() CASCADE;";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
			
			# Add the columns to both schemas;
			$query = "ALTER TABLE public.hosts ADD COLUMN host_location_uuid uuid;";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
			
			$query = "ALTER TABLE history.hosts ADD COLUMN host_location_uuid uuid;";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
			
			# Add the foreign key
			$query = "ALTER TABLE public.hosts ADD CONSTRAINT hosts_host_location_uuid_fkey FOREIGN KEY(host_location_uuid) REFERENCES locations(location_uuid);";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
			
			# Recreate the function and trigger.
			$query = '
CREATE FUNCTION history_hosts() RETURNS trigger
AS $$
DECLARE
        history_hosts RECORD;
BEGIN
        SELECT INTO history_hosts * FROM hosts WHERE host_uuid = new.host_uuid;
        INSERT INTO history.hosts
                (host_uuid,
                 host_location_uuid, 
                 host_name,
                 host_type,
                 host_emergency_stop,
                 host_stop_reason, 
                 host_health, 
                 modified_date)
        VALUES
                (history_hosts.host_uuid,
                 history_hosts.host_location_uuid, 
                 history_hosts.host_name,
                 history_hosts.host_type,
                 history_hosts.host_emergency_stop,
                 history_hosts.host_stop_reason, 
                 history_hosts.host_health, 
                 history_hosts.modified_date);
        RETURN NULL;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION history_hosts() OWNER TO '.$db_owner.';

CREATE TRIGGER trigger_hosts
        AFTER INSERT OR UPDATE ON hosts
        FOR EACH ROW EXECUTE PROCEDURE history_hosts();
';
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
		}
		
		# Third; Does the states table have a history table? If so, remove it and its procedure/trigger.
		$query = "SELECT * FROM pg_catalog.pg_tables WHERE tablename = 'states' AND schemaname = 'history';";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($count)
		{
			# Remove it.
			print "- The 'states' table needs to be removed from the history schema.\n";
			my $query = "DROP FUNCTION history_states() CASCADE;";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
			
			$query = "DROP TABLE history.states;";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$queue}, $query;
		}
		
		# Fourth; Is the storcli_physical_drives function broken?
		$query = "SELECT prosrc FROM pg_proc WHERE proname = 'history_storcli_physical_drives';";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		my $function = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "function", value1 => $function, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($function)
		{
			my $bad           = 0;
			my $bad_next_line = "";
			foreach my $line (split/\n/, $function)
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /history_storcli_physical_drives.storcli_physical_drive_slot_number/)
				{
					# If this is the next line, we've git the bug.
					$bad_next_line = "storcli_physical_drive_size";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "bad_next_line", value1 => $bad_next_line, 
					}, file => $THIS_FILE, line => __LINE__});
					next;
				}
				if (($bad_next_line) && ($line =~ /$bad_next_line/))
				{
					$bad = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "bad", value1 => $bad, 
					}, file => $THIS_FILE, line => __LINE__});
					last;
				}
				elsif ($bad_next_line)
				{
					# The next line was fine.
					$bad_next_line = "";
				}
			}
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "bad", value1 => $bad, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($bad)
			{
				print "[ Warning ] - This database has the bugged 'history_storcli_physical_drives()' function.\n";
				print "[ Warning ]   The function will be repaired and erroneous data will be removed from the database.\n";
				
				# Purge old data
				foreach my $schema ("history", "public")
				{
					# Read in all the drives we know about and build a list of UUIDs to delete 
					# from this schema
					my $query     = "
SELECT 
    storcli_physical_drive_uuid, 
    storcli_physical_drive_serial_number, 
    storcli_physical_drive_size, 
    storcli_physical_drive_sector_size, 
    storcli_physical_drive_vendor, 
    storcli_physical_drive_model 
FROM 
    ".$schema.".storcli_physical_drives;";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query,
					}, file => $THIS_FILE, line => __LINE__});
					
					# Do the query against the source DB and loop through the results.
					my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
					foreach my $row (@{$results})
					{
						my $storcli_physical_drive_uuid          =         $row->[0]; 
						my $storcli_physical_drive_serial_number = defined $row->[1] ? $row->[1] : "";
						my $storcli_physical_drive_size          = defined $row->[2] ? $row->[2] : "";
						my $storcli_physical_drive_sector_size   = defined $row->[3] ? $row->[3] : "";
						my $storcli_physical_drive_vendor        = defined $row->[4] ? $row->[4] : "";
						my $storcli_physical_drive_model         = defined $row->[5] ? $row->[5] : "";
						$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
							name1 => "storcli_physical_drive_uuid",          value1 => $storcli_physical_drive_uuid,
							name2 => "storcli_physical_drive_serial_number", value2 => $storcli_physical_drive_serial_number,
							name3 => "storcli_physical_drive_size",          value3 => $storcli_physical_drive_size,
							name4 => "storcli_physical_drive_sector_size",   value4 => $storcli_physical_drive_sector_size,
							name5 => "storcli_physical_drive_vendor",        value5 => $storcli_physical_drive_vendor,
							name6 => "storcli_physical_drive_model",         value6 => $storcli_physical_drive_model,
						}, file => $THIS_FILE, line => __LINE__});
						
						# Now check for bad data.
						if ($storcli_physical_drive_serial_number =~ /^\d+\.\d+ \w\B/)
						{
							# Bad.
							push @{$queue}, "DELETE FROM ".$schema.".storcli_physical_drives WHERE storcli_physical_drive_uuid = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid).";";
							next;
						}
						if (($storcli_physical_drive_size eq "512B") or ($storcli_physical_drive_size eq "4KN"))
						{
							# Bad.
							push @{$queue}, "DELETE FROM ".$schema.".storcli_physical_drives WHERE storcli_physical_drive_uuid = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid).";";
							next;
						}
						if (($storcli_physical_drive_sector_size ne "512B") && ($storcli_physical_drive_sector_size ne "4KN"))
						{
							# Bad.
							push @{$queue}, "DELETE FROM ".$schema.".storcli_physical_drives WHERE storcli_physical_drive_uuid = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid).";";
							next;
						}
						if (($schema eq "public") && ($storcli_physical_drive_model eq "VANISHED"))
						{
							push @{$queue}, "DELETE FROM ".$schema.".storcli_physical_drives WHERE storcli_physical_drive_uuid = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid).";";
							next;
						}
					}
				}
				
				# Now the erroneous data should be gone, we can fix the procedure.
				push @{$queue}, "DROP FUNCTION history_storcli_physical_drives() CASCADE;";
				push @{$queue}, 'CREATE FUNCTION history_storcli_physical_drives() RETURNS trigger
AS $$
DECLARE
        history_storcli_physical_drives RECORD;
BEGIN
        SELECT INTO history_storcli_physical_drives * FROM storcli_physical_drives WHERE storcli_physical_drive_uuid=new.storcli_physical_drive_uuid;
        INSERT INTO history.storcli_physical_drives
                (storcli_physical_drive_uuid, 
                 storcli_physical_drive_host_uuid,
                 storcli_physical_drive_controller_uuid, 
                 storcli_physical_drive_virtual_drive, 
                 storcli_physical_drive_drive_group, 
                 storcli_physical_drive_enclosure_id, 
                 storcli_physical_drive_slot_number, 
                 storcli_physical_drive_serial_number, 
                 storcli_physical_drive_size, 
                 storcli_physical_drive_sector_size, 
                 storcli_physical_drive_vendor, 
                 storcli_physical_drive_model, 
                 storcli_physical_drive_self_encrypting_drive, 
                 modified_date)
        VALUES
                (history_storcli_physical_drives.storcli_physical_drive_uuid,
                 history_storcli_physical_drives.storcli_physical_drive_host_uuid,
                 history_storcli_physical_drives.storcli_physical_drive_controller_uuid, 
                 history_storcli_physical_drives.storcli_physical_drive_virtual_drive, 
                 history_storcli_physical_drives.storcli_physical_drive_drive_group, 
                 history_storcli_physical_drives.storcli_physical_drive_enclosure_id, 
                 history_storcli_physical_drives.storcli_physical_drive_slot_number, 
                 history_storcli_physical_drives.storcli_physical_drive_serial_number, 
                 history_storcli_physical_drives.storcli_physical_drive_size, 
                 history_storcli_physical_drives.storcli_physical_drive_sector_size, 
                 history_storcli_physical_drives.storcli_physical_drive_vendor, 
                 history_storcli_physical_drives.storcli_physical_drive_model, 
                 history_storcli_physical_drives.storcli_physical_drive_self_encrypting_drive, 
                 history_storcli_physical_drives.modified_date);
        RETURN NULL;
END;
$$
LANGUAGE plpgsql;
ALTER FUNCTION history_storcli_physical_drives() OWNER TO '.$db_owner.';';
				push @{$queue}, '
CREATE TRIGGER trigger_storcli_physical_drives
        AFTER INSERT OR UPDATE ON storcli_physical_drives
        FOR EACH ROW EXECUTE PROCEDURE history_storcli_physical_drives();';
			}
		}
		
		### NOTE: This requires deleting all data from this table.
		# Fifth: Check to see now if the ram_used_uuid is 'bigint' and convert it to UUID, if so.
		$query = "SELECT data_type FROM information_schema.columns WHERE table_name = 'ram_used' AND table_schema = 'public' AND column_name = 'ram_used_uuid';";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $data_type = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "data_type", value1 => $data_type, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($data_type eq "bigint")
		{
			# Fix needed.
			print "[ Warning ] - This database has the old 'ram_used -> ram_used_uuid' data type.\n";
			print "[ Warning ]   All data in the 'ram_used' history and public tables need to be removed for this fix.\n";
			
			push @{$queue}, "DELETE FROM history.ram_used;";
			push @{$queue}, "DELETE FROM ram_used;";
			push @{$queue}, "DELETE FROM history.ram_used;";
			push @{$queue}, "ALTER TABLE history.ram_used ALTER COLUMN ram_used_uuid SET DATA TYPE uuid USING null::uuid;";
			push @{$queue}, "ALTER TABLE public.ram_used ALTER COLUMN ram_used_uuid DROP DEFAULT;";
			push @{$queue}, "ALTER TABLE public.ram_used ALTER COLUMN ram_used_uuid SET DATA TYPE uuid USING null::uuid;";
		}
		
		# Do I have pending queries?
		my $queue_length = @{$queue};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "queue_length", value1 => $queue_length, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($queue_length)
		{
			print "- Database updates needed, applying now.\n";
			
			# Create a backup of the database if it is on this host.
			print "[ Debug ] - Database host: [$db_host], this host: [".$an->hostname."]\n" if $an->data->{sys}{debug} >= 2;
			if ($db_host eq $an->hostname)
			{
				print "- Creating a backup of the database.\n";
				my $backup_file = $db_name."_pre-upgrade.".time.".out";
				my $shell_call  = $an->data->{path}{su}." - postgres -c \"".$an->data->{path}{pg_dump}." $db_name > /tmp/$backup_file\" && ".$an->data->{path}{mv}." /tmp/$backup_file /root/ && ".$an->data->{path}{bzip2}." /root/$backup_file";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					print "[ Debug ] - Output: [$line]\n" if $an->data->{sys}{debug} >= 2; 
				}
				close $file_handle;
				print "- Done! Backup saved as: [/root/".$backup_file.".bz2]\n";
			}
			
			$an->DB->do_db_write({id => $id, query => $queue, source => $THIS_FILE, line => __LINE__});
			print "[ NOTE ] - 'drop cascades' warnings are safe to ignore.\n";
		}
		else
		{
			print "- No updates on this database are needed.\n";
		}
	}
	print "- Done!\n\n";
	
	return(0);
}


# This updates the local machine.
sub update_local
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_local" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Disable ScanCore.
	print "###############################################################################\n";
	print "# NOTE: ScanCore will be disabled. If anything causes the upgrade process to\n";
	print "#       abort unexpectedly, you may need to manually re-enable it by running:\n";
	print "#       ".$an->data->{path}{ScanCore}." --enable\n";
	print "###############################################################################\n\n";
	
	manage_scancore($an, "disable");
	
	update_target($an, "dashboard", "local");
	
	print "Enabling ScanCore...\n";
	manage_scancore($an, "enable");
	
	print "The update process has completed.\n\n";
	
	return(0);
}

# This updates a node.
sub update_all
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_all" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Copy myself and my cache to my peer dashboard(s) and run '--gather-only --offline' before starting.
	# This will not add any download bandwidth because the files will be in place already, but it will
	# handle converting ISO-based repos to file-based ones.
	print "Verifying access before starting the update process...\n";
	my $error = 0;
	
	# Check access to Striker peers.
	my $dashboards = {};
	my $peers      = $an->Get->striker_peers();
	foreach my $hash_ref (@{$peers})
	{
		# NOTE: At this time, we don't support peers using non-standard ports.
		my $peer_name     = $hash_ref->{name};
		my $peer_password = $hash_ref->{password};
		my $peer_port     = 22;
		print "- Checking access to the peer Striker: [$peer_name]\n";
		
		my $access = $an->Check->access({
			target   => $peer_name,
			port     => $peer_port, 
			password => $peer_password, 
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "access", value1 => $access,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If I can't access my peer, exit.
		if ($access)
		{
			print "- Online, good.\n";
			$dashboards->{$peer_name} = $peer_password;
		}
		else
		{
			print "[ Error ] - Offline!\n";
			$error = 1;
		}
	}
	if ($error)
	{
		print "[ Error ] - To insure compatibility, all dashboards must be updated at the same time.\n";
		exit(12);
	}
	
	# Check access to Anvil! nodes.
	my $anvils = {};
	if ($an->data->{switches}{'anvil-name'} eq "all")
	{
		my $query = "SELECT anvil_name, anvil_uuid FROM anvils WHERE anvil_note IS DISTINCT FROM 'DELETED' ORDER BY anvil_name ASC LIMIT 1;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $anvil_name = $row->[0];
			my $anvil_uuid = $row->[1];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
				name2 => "anvil_uuid", value2 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			# Some things expect this CGI variable to be set.
			$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
			}, file => $THIS_FILE, line => __LINE__});
			
			print "- Testing access to the nodes in the Anvil! system: [$anvil_name]\n";
			$anvils->{$anvil_name} = $anvil_uuid;
			$error = check_anvil($an, $anvil_uuid, $error, 1);
		}
	}
	elsif ($an->data->{switches}{'anvil-name'})
	{
		my $anvil_name = $an->data->{switches}{'anvil-name'};
		my $anvil_uuid = "";
		my $query      = "SELECT anvil_uuid FROM anvils WHERE anvil_name = ".$an->data->{sys}{use_db_fh}->quote($anvil_name).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_uuid = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_uuid", value1 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			# Some things expect this CGI variable to be set.
			$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_uuid)
		{
			print "[ Error ] - Failed to find an Anvil! UUID for the name: [$anvil_name]\n";
			exit(5);
		}
		$anvils->{$anvil_name} = $anvil_uuid;
		$error = check_anvil($an, $anvil_uuid, $error, 1);
	}
	else
	{
		my $anvil_name = "";
		my $anvil_uuid = $an->data->{switches}{'anvil-uuid'};
		my $query      = "SELECT anvil_name FROM anvils WHERE anvil_uuid = ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_name = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
			}, file => $THIS_FILE, line => __LINE__});
			
			# Some things expect this CGI variable to be set.
			$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_name)
		{
			print "[ Error ] - Failed to find an Anvil! name for the UUID: [$anvil_uuid]\n";
			exit(6);
		}
		$anvils->{$anvil_name} = $anvil_uuid;
		$error                 = check_anvil($an, $anvil_uuid, $error, 1);
	}
	if ($error)
	{
		print "[ Error ] - All nodes must be updated at the same time for the update to proceed.\n";
		exit(14);
	}
	
	print "- Ready to start the update process!\n\n";
	
	# Disable ScanCore on all dashboards and nodes, then go into a loop until all of them have exited.
	print "###############################################################################\n";
	print "# NOTE: ScanCore will be disabled on all dashboards and nodes. If anything\n";
	print "#       causes the upgrade process to abort unexpectedly, you may need to\n";
	print "#       manually re-enable ScanCore by running:\n";
	print "#       ".$an->data->{path}{ScanCore}." --enable\n";
	print "###############################################################################\n\n";
	
	# We'll call '--disable' on the peer dashboards, then all nodes, then on ourself. The local disable 
	# will wait until ScanCore exits, then we'll go into a loop while we wait for any stragglers to exit.
	print "Upgrade will now begin.\n";
	my $shell_call = $an->data->{path}{ScanCore}." --disable";
	foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
	{
		my $password = $dashboards->{$dashboard};
		print "- Disabling ScanCore on Striker dashboard: [$dashboard]\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "dashboard",  value1 => $dashboard,
			name2 => "shell_call", value2 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $dashboard,
			port       => 22, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
	{
		my $anvil_uuid = $anvils->{$anvil_name};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "anvil_name", value1 => $anvil_name,
			name2 => "anvil_uuid", value2 => $anvil_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Some things expect this CGI variable to be set.
		$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
		foreach my $node_key ("node1", "node2")
		{
			my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
			my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "node_name", value1 => $node_name,
				name2 => "node_uuid", value2 => $node_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			# I reload and rescan each loop in case I am updating two or more Anvil! systems
			print "- Disabling ScanCore on Anvil!: [$anvil_name]'s node: [$node_name]...\n";
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
			
			my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
			my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
			my $password   = $an->data->{sys}{anvil}{$node_key}{password};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Disabling the local ScanCore and waiting for it to exit...\n";
	manage_scancore($an, "disable");
	
	# Now wait for ScanCore to exit on everything.
	print "- Waiting now until ScanCore exits on all systems...\n";
	my $waiting = 1;
	while($waiting)
	{
		# This will be flipped back to '1' if any machine's ScanCore is still running.
		$waiting = 0;
		
		print "- Checking if ScanCore is running on any system...\n";
		my $shell_call = $an->data->{path}{ScanCore}." --status";
		foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
		{
			my $password = $dashboards->{$dashboard};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "dashboard",  value1 => $dashboard,
				name2 => "shell_call", value2 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $dashboard,
				port       => 22, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /-.*?\[(\d+)\]$/)
				{
					$waiting = 1;
					print "- ScanCore is still running on the Striker dashboard: [$dashboard]\n";
				}
			}
		}
		foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
		{
			my $anvil_uuid = $anvils->{$anvil_name};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
				name2 => "anvil_uuid", value2 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		
			# Some things expect this CGI variable to be set.
			$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
			foreach my $node_key ("node1", "node2")
			{
				my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
				my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "node_name", value1 => $node_name,
					name2 => "node_uuid", value2 => $node_uuid,
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
				my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
				my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
				my $password   = $an->data->{sys}{anvil}{$node_key}{password};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "target",     value1 => $target,
					name2 => "port",       value2 => $port,
					name3 => "shell_call", value3 => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
					name1 => "password", value1 => $password,
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target     => $target,
					port       => $port, 
					password   => $password,
					shell_call => $shell_call,
				});
				foreach my $line (@{$return})
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
					if ($line =~ /-.*?\[(\d+)\]$/)
					{
						$waiting = 1;
						print "- ScanCore is still running on Anvil!: [$anvil_name], node: [$node_name]\n";
					}
				}
			}
		}
		
		if ($waiting)
		{
			sleep 5;
		}
	}
	print "- ScanCore is stopped now on all systems. Ready to proceed.\n\n";
	
	# Update the dashboards.
	update_target($an, "dashboard", "local");
	foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
	{
		# Copy our cache directories and this update script to the peer dashboard and then call this
		# script without --anvil-X. This way the peer's ISO to flat file conversion and the RPM repo
		# will be updated properly.
		print "- Copying our cache over to the dashboard: [$dashboard]\n";
		my $password   = $dashboards->{$dashboard};
		my $cache_root = ($an->data->{path}{updates}{rpms} =~ /^(.*?)\/rpms/)[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "cache_root", value1 => $cache_root,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $source_path ($0, $cache_root)
		{
			print "- Copying over: [$source_path].\n";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "dashboard",   value1 => $dashboard,
				name2 => "source_path", value2 => $source_path,
			}, file => $THIS_FILE, line => __LINE__});
			my $return_code = $an->Storage->rsync({
				target      => $dashboard,
				port        => 22, 
				password    => $password,
				source      => $source_path,
				destination => "root\@$dashboard:/root/",
				switches    => "-avAX",
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "return_code", value1 => $return_code, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		print "- Cache has been copied.\n";
		
		print "- Running this update on the dashboard: [$dashboard]\n";
		print "###############################################################################\n";
		print "# Please be patient! The update process will take some time and there will be\n";
		print "# no output here until the update finishes. If you want to see if the update\n";
		print "# is still running, log into: [$dashboard] and run:\n";
		print "# ps aux | grep $THIS_FILE\n";
		print "###############################################################################\n";
		my $shell_call = "/root/".$THIS_FILE." --offline --no-refresh -y -vvv";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "dashboard",  value1 => $dashboard,
			name2 => "shell_call", value2 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		print "/-----[ Command output ]------------------------------------------------------\n";
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $dashboard,
			port       => 22, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /reboot this machine/)
			{
				$an->data->{reboot_dashboard}{$dashboard} = 1;
			}
			print "| $line\n";
		}
		print "- Finished updating: [$dashboard]\n";
		print "\\-----------------------------------------------------------------------------\n";
	}
	
	# Update the Anvil! systems.
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
	{
		my $anvil_uuid = $anvils->{$anvil_name};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "anvil_name", value1 => $anvil_name,
			name2 => "anvil_uuid", value2 => $anvil_uuid,
		}, file => $THIS_FILE, line => __LINE__});
	
		# Some things expect this CGI variable to be set.
		$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
		}, file => $THIS_FILE, line => __LINE__});
		
		# Load this Anvil! system's details.
		$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
		
		# If the user has disabled OS updates, we won't touch the cluster or servers.
		if ($an->data->{switches}{'no-os-update'})
		{
			print "- Servers will not be migrated nor will nodes be withdrawn or rebooted.\n\n";
			
			# Loop through the nodes and update their Striker/ScanCore files.
			foreach my $node_key ("node1", "node2")
			{
				my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
				my $target    = $an->data->{sys}{anvil}{$node_key}{use_ip};
				my $port      = $an->data->{sys}{anvil}{$node_key}{use_port};
				my $password  = $an->data->{sys}{anvil}{$node_key}{password};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "node_name",  value1 => $node_name,
					name2 => "target",     value2 => $target,
					name3 => "port",       value3 => $port,
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
					name1 => "password", value1 => $password,
				}, file => $THIS_FILE, line => __LINE__});
				update_target($an, "node", $target, $port, $password);
			}
		}
		else
		{
			update_nodes($an, $anvil_uuid);
		}
	}
	
	# Re-enable ScanCore now.
	print "ScanCore will now be restarted on all machines..\n";
	$shell_call = $an->data->{path}{ScanCore}." --enable";
	foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
	{
		my $password = $dashboards->{$dashboard};

		print "- Enabling ScanCore on Striker dashboard: [$dashboard]\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "dashboard",  value1 => $dashboard,
			name2 => "shell_call", value2 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $dashboard,
			port       => 22, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
	{
		my $anvil_uuid = $anvils->{$anvil_name};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "anvil_name", value1 => $anvil_name,
			name2 => "anvil_uuid", value2 => $anvil_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Some things expect this CGI variable to be set.
		$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
		foreach my $node_key ("node1", "node2")
		{
			my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
			my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "node_name", value1 => $node_name,
				name2 => "node_uuid", value2 => $node_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			# I reload and rescan each loop in case I am updating two or more Anvil! systems
			print "- Enabling ScanCore on Anvil!: [$anvil_name]'s node: [$node_name]...\n";
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
			
			my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
			my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
			my $password   = $an->data->{sys}{anvil}{$node_key}{password};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Enabling the local ScanCore and waiting for it to exit...\n";
	manage_scancore($an, "enable");
	
	print "The update process has completed.\n\n";
	
	return(0);
}

# This handles updating the nodes of each target Anvil!, determining the order of updates, migrating servers
# and waiting on DRBD resync.
sub update_nodes
{
	my ($an, $anvil_uuid) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_nodes" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "anvil_uuid", value1 => $anvil_uuid, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Load the details about this Anvil!
	my $anvil_name = $an->data->{sys}{anvil}{name};
	my $node1_name = $an->data->{sys}{anvil}{node1}{name};
	my $node2_name = $an->data->{sys}{anvil}{node2}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "anvil_name", value1 => $anvil_name, 
		name2 => "node1_name", value2 => $node1_name, 
		name3 => "node2_name", value3 => $node2_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "Updating Anvil!: [$anvil_name]\n";
	
	# Do a full scan of node 1 and 2.
	my $waiting = 1;
	while ($waiting)
	{
		print "- Checking if both nodes are ready to be updated at: [".$an->Get->date_and_time({split_date_time => 0})."]\n";
		my $error = check_anvil($an, $anvil_uuid, 0, 0);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "error", value1 => $error, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (not $error)
		{
			print "- Ready!\n";
			$waiting = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "waiting", value1 => $waiting, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			if (($an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster}))
			{
				foreach my $resource (sort {$a cmp $b} keys %{$an->data->{drbd}{resource}})
				{
					if ($an->data->{drbd}{resource}{$resource}{eta_to_sync})
					{
						print "- Estimated resync time for resource: [$resource] is: [".$an->data->{drbd}{resource}{$resource}{eta_to_sync}."] seconds.\n";
					}
					else
					{
						print "- Replicated storage resource: [$resource] is up to date.\n";
					}
				}
			}
			sleep 10;
		}
	}
	
	print "- Scanning both nodes, one moment please.\n";
	$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}});
	print "- Node 1: [$node1_name] scanned.\n";
	$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}});
	print "- Node 2: [$node2_name] scanned.\n";
	
	# Pick the first node to update. We're going to be simple about this; If both nodes have servers, 
	# we'll migrate all to node 1 and upgrade node 2. If no nodes have servers, we'll upgrade node 2.
	# If node 2 has all servers, we'll update node 1.
	print "- Picking which node to update first.\n";
	my $node1_servers    = [];
	my $node2_servers    = [];
	my $node1_short_name = $an->data->{sys}{anvil}{node1}{short_name};
	my $node2_short_name = $an->data->{sys}{anvil}{node2}{short_name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node1_short_name", value1 => $node1_short_name,
		name2 => "node2_short_name", value2 => $node2_short_name,
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $server (sort {$a cmp $b} keys %{$an->data->{server}})
	{
		# Shorten the host names because older versions would truncate long domains.
		my $this_host       =  $an->data->{server}{$server}{host};
		my $short_host_name =  $an->data->{server}{$server}{host};
		   $short_host_name =~ s/\..*$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "this_host",       value1 => $this_host,
			name2 => "short_host_name", value2 => $short_host_name,
		}, file => $THIS_FILE, line => __LINE__});
		if (($this_host eq "none") or ($this_host =~ /^\(.*?\)$/))
		{
			# Server is off, we can ignore it.
		}
		elsif ($short_host_name eq $node1_short_name)
		{
			push @{$node1_servers}, $server;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "server",           value1 => $server,
				name2 => "node1_short_name", value2 => $node1_short_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($short_host_name eq $node2_short_name)
		{
			push @{$node2_servers}, $server;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "server",           value1 => $server,
				name2 => "node2_short_name", value2 => $node2_short_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# What?
			print "[ Error ] - The server: [$server] is on the node: [$short_host_name] ($this_host)\n";
			print "[ Error ]   This doesn't match either node name's short name:\n";
			print "[ Error ]   Node 1: [$node1_name] ($node1_short_name)\n";
			print "[ Error ]   Node 2: [$node2_name] ($node2_short_name)\n";
			print "[ Error ] - This is likely a program error. Exiting.\n";
			exit(17);
		}
	}
	
	my $first_target  = "node2";
	my $second_target = "node1";
	my $node1_count   = @{$node1_servers};
	my $node2_count   = @{$node2_servers};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node1_count", value1 => $node1_count,
		name2 => "node2_count", value2 => $node2_count,
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $node1_count) && ($node1_count))
	{
		print "- There are no servers running on either node. Updating node 2 first.\n";
	}
	elsif (not $node2_count)
	{
		print "- There are no servers on node 2, so it will be updated first.\n";
	}
	elsif (not $node1_count)
	{
		print "- There are no servers on node 1, so it will be updated first.\n";
		$first_target = "node1";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "first_target", value1 => $first_target,
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		print "- There are servers on both nodes. We will move them to node 1 and update node 2 first.\n";
	}
	
	# If needed, migrate server off.
	my $first_array     = $node2_servers;
	my $second_array    = $node1_servers;
	my $first_node_key  = "node2";
	my $second_node_key = "node1";
	my $say_first_node  = $an->data->{sys}{anvil}{node2}{name};
	my $say_second_node = $an->data->{sys}{anvil}{node1}{name};
	if ($first_target eq "node1")
	{
		$first_array     = $node1_servers;
		$second_array    = $node2_servers;
		$first_node_key  = "node1";
		$second_node_key = "node2";
		$say_first_node  = $an->data->{sys}{anvil}{node1}{name};
		$say_second_node = $an->data->{sys}{anvil}{node2}{name};
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "first_node_key",  value1 => $first_node_key,
		name2 => "say_first_node",  value2 => $say_first_node,
		name3 => "second_node_key", value3 => $second_node_key,
		name4 => "say_second_node", value4 => $say_second_node,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $return_code = 0;
	my $target      = $an->data->{sys}{anvil}{$first_node_key}{use_ip};
	my $port        = $an->data->{sys}{anvil}{$first_node_key}{use_port};
	my $password    = $an->data->{sys}{anvil}{$first_node_key}{password};
	foreach my $server (sort {$a cmp $b} @{$first_array})
	{
		print "- Migrating: [$server] to: [$say_second_node]\n";
		print "/-----[ Command output ]------------------------------------------------------\n";
		my $shell_call = $an->data->{path}{'anvil-migrate-server'}." --server ".$server."; ".$an->data->{path}{'echo'}." return_code:\$?";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /return_code:(\d+)$/)
			{
				$return_code = $1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code,
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				print "| $line\n";
			}
		}
		
		push @{$second_array}, $server;
		print "\\-----------------------------------------------------------------------------\n";
		
		# Abort if there was a problem.
		if ($return_code eq "1")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0048"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "2")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0049"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "3")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0050"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "4")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0051"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "5")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0052"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "6")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0053"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
	}
	sleep 2;
	
	print "- Verifying all servers are off of: [$say_first_node]...\n";
	my $abort = 0;
	my $shell_call = $an->data->{path}{virsh}." list --all";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /(\d+)\s+(.*?)\s+(.*)/)
		{
			my $id     = $1;
			my $server = $2;
			my $state  = $3;
			if ($state =~ /run/)
			{
				print "[ Error ] - The server: [$server] is: [$state].\n";
				$abort = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "abort", value1 => $abort,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	undef $return;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "abort", value1 => $abort,
	}, file => $THIS_FILE, line => __LINE__});
	if ($abort)
	{
		print "[ Error ] - All servers should have been migrated off of: [$say_first_node]\n";
		print "[ Error ]   but that is not the case. Aborting.\n";
		exit(18);
	}
	else
	{
		print "- All servers are off this node, good.\n";
	}
	
	### NOTE: We don't use 'anvil-safe-stop' because some old versions didn't support '--no-reboot'.
	# Withdraw the node from the Anvil!
	print "- Withdrawing: [$say_first_node] from the Anvil!.\n";
	print "/-----[ Command output ]------------------------------------------------------\n";
	$shell_call = "/etc/init.d/rgmanager stop && /etc/init.d/cman stop";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		print "| $line\n";
	}
	print "\\-----------------------------------------------------------------------------\n";
	undef $return;
	
	print "- Verifying that the node: [$say_first_node] has withdrawn successfully.\n";
	$shell_call = "if [ -e /var/lock/subsys/cman ]; then echo online; else echo offline; fi";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /online/)
		{
			$abort = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "abort", value1 => $abort,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	undef $return;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "abort", value1 => $abort,
	}, file => $THIS_FILE, line => __LINE__});
	if ($abort)
	{
		print "[ Error ] - The node: [$say_first_node] appears to still be a member of the\n";
		print "[ Error ]   Anvil! system. If you can't withdraw the node manually, try:\n";
		print "[ Error ]   'killall rgmanager' and see if that fixes the problem\n";
		exit(19);
	}
	else
	{
		print "- The node has withdrawn, good.\n";
	}
	
	# All servers migrated. Update the node. If the node reboots, this won't return until it is 
	# accessible again.
	my ($rebooted) = update_target($an, "node", $target, $port, $password);
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "rebooted", value1 => $rebooted,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($rebooted)
	{
		# We need to wait for the storage to be fully up to date.
		print "- The node was rebooted. We will now wait for the node to rejoin the Anvil!\n";
		print "  system and for its storage to be fully synchronized before updating the \n";
		print "  other node. Please be patient!\n";
		
		my $waiting = 1;
		while ($waiting)
		{
			print "- Checking membership and replicated storage at: [".$an->Get->date_and_time({split_date_time => 0})."]\n";
			my $error = check_anvil($an, $anvil_uuid, 0, 0);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "error", value1 => $error, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (not $error)
			{
				print "- Ready!\n";
				$waiting = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "waiting", value1 => $waiting, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				if (($an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster}))
				{
					foreach my $resource (sort {$a cmp $b} keys %{$an->data->{drbd}{resource}})
					{
						if ($an->data->{drbd}{resource}{$resource}{eta_to_sync})
						{
							print "- Estimated resync time for resource: [$resource] is: [".$an->data->{drbd}{resource}{$resource}{eta_to_sync}."] seconds.\n";
						}
						else
						{
							print "- Replicated storage resource: [$resource] is up to date.\n";
						}
					}
				}
				sleep 10;
			}
		}
	}
	else
	{
		# Join the Anvil! back. Now we can use 'anvil-safe-start'.
		print "- Joining the node back to the Anvil! using 'anvil-safe-start'...\n";
		my $shell_call = $an->data->{path}{'anvil-safe-start'}." --force";
		print "/-----[ Command output ]------------------------------------------------------\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			'close'    => 1,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1  => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			print "| $line\n";
		}
		print "\\-----------------------------------------------------------------------------\n";
		print "- Done.\n\n";
	}
	
	print "- Ready to update the second node!\n";
	$target   = $an->data->{sys}{anvil}{$second_node_key}{use_ip};
	$port     = $an->data->{sys}{anvil}{$second_node_key}{use_port};
	$password = $an->data->{sys}{anvil}{$second_node_key}{password};
	# Migrate the servers over to the now-upgraded node.
	foreach my $server (sort {$a cmp $b} @{$second_array})
	{
		print "- Migrating: [$server] to: [$say_first_node]...\n";
		print "/-----[ Command output ]------------------------------------------------------\n";
		my $shell_call = $an->data->{path}{'anvil-migrate-server'}." --server ".$server."; ".$an->data->{path}{'echo'}." return_code:\$?";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /return_code:(\d+)$/)
			{
				$return_code = $1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code,
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				print "| $line\n";
			}
		}
		print "\\-----------------------------------------------------------------------------\n";
		
		# Abort if there was a problem.
		if ($return_code eq "1")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0048"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "2")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0049"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "3")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0050"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "4")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0051"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "5")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0052"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
		elsif ($return_code eq "6")
		{
			print "[ ".$an->String->get({key => "state_0008"})." ] - ".$an->String->get({key => "script_0053"})."\n";
			print "[ ".$an->String->get({key => "state_0008"})." ]   ".$an->String->get({key => "script_0003"})."\n";
			$an->nice_exit({exit_code => 23});
		}
	}
	sleep 2;
	
	print "- Verifying that all servers are off of: [$say_second_node]...\n";
	$shell_call = $an->data->{path}{virsh}." list --all";
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /(\d+)\s+(.*?)\s+(.*)/)
		{
			my $id     = $1;
			my $server = $2;
			my $state  = $3;
			if ($state =~ /run/)
			{
				print "[ Error ] - The server: [$server] is: [$state].\n";
				$abort = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "abort", value1 => $abort,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	undef $return;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "abort", value1 => $abort,
	}, file => $THIS_FILE, line => __LINE__});
	if ($abort)
	{
		print "[ Error ] - All servers should have been migrated off of: [$say_second_node]\n";
		print "[ Error ]   but that is not the case. Aborting.\n";
		exit(18);
	}
	else
	{
		print "- All servers are off this node, good.\n";
	}
	
	
	### NOTE: We don't use 'anvil-safe-stop' because some old versions didn't support '--no-reboot'.
	# Withdraw the node from the Anvil!
	print "- Withdrawing: [$say_second_node] from the Anvil!.\n";
	print "/-----[ Command output ]------------------------------------------------------\n";
	$shell_call = "/etc/init.d/rgmanager stop && /etc/init.d/cman stop";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		print "| $line\n";
	}
	print "\\-----------------------------------------------------------------------------\n";
	undef $return;
	
	print "- Verifying that the node: [$say_second_node] has withdrawn successfully.\n";
	$shell_call = "if [ -e /var/lock/subsys/cman ]; then echo online; else echo offline; fi";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /online/)
		{
			$abort = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "abort", value1 => $abort,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	undef $return;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "abort", value1 => $abort,
	}, file => $THIS_FILE, line => __LINE__});
	if ($abort)
	{
		print "[ Error ] - The node: [$say_second_node] appears to still be a member of the\n";
		print "[ Error ]   Anvil! system. If you can't withdraw the node manually, try:\n";
		print "[ Error ]   'killall rgmanager' and see if that fixes the problem\n";
		exit(19);
	}
	else
	{
		print "- The node has withdrawn, good.\n";
	}
	
	# All servers migrated. Update the node. If the node reboots, this won't return until it is 
	# accessible again.
	($rebooted) = update_target($an, "node", $target, $port, $password);
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "rebooted", value1 => $rebooted,
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($rebooted)
	{
		# We need to wait for the storage to be fully up to date.
		print "- The node was rebooted. We will now wait for the node to rejoin the Anvil!\n";
		print "  system and for its storage to be fully synchronized before updating the \n";
		print "  other node. Please be patient!\n";
		
		my $waiting = 1;
		while ($waiting)
		{
			print "- Checking membership and replicated storage at: [".$an->Get->date_and_time({split_date_time => 0})."]\n";
			my $error = check_anvil($an, $anvil_uuid, 0, 0);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "error", value1 => $error, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (not $error)
			{
				print "- Ready!\n";
				$waiting = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "waiting", value1 => $waiting, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				if (($an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster}))
				{
					foreach my $resource (sort {$a cmp $b} keys %{$an->data->{drbd}{resource}})
					{
						if ($an->data->{drbd}{resource}{$resource}{eta_to_sync})
						{
							print "- Estimated resync time for resource: [$resource] is: [".$an->data->{drbd}{resource}{$resource}{eta_to_sync}."] seconds.\n";
						}
						else
						{
							print "- Replicated storage resource: [$resource] is up to date.\n";
						}
					}
				}
				sleep 10;
			}
		}
	}
	else
	{
		# Join the Anvil! back. Now we can use 'anvil-safe-start'.
		print "- Joining the node back to the Anvil! using 'anvil-safe-start'...\n";
		$shell_call = $an->data->{path}{'anvil-safe-start'}." --force";
		print "/-----[ Command output ]------------------------------------------------------\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			'close'    => 1,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1  => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			print "| $line\n";
		}
		print "\\-----------------------------------------------------------------------------\n";
		print "- Done.\n\n";
	}
	print "- Anvil!: [$anvil_name] has been upgraded!\n\n";
	
	return(0);
}

# This updates a dashboard, either local or remote.
sub update_target
{
	my ($an, $type, $target, $port, $password) = @_;
	$port     = 22 if not defined $port;
	$password = "" if not defined $password;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_target" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "type",   value1 => $type, 
		name2 => "target", value2 => $target, 
		name3 => "port",   value3 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "###############################################################################\n";
	print "# Beginning update of: [".$target."]\n";
	print "###############################################################################\n";
	
	# Before we do anything, make sure the an-el6-repo is fixed.
	update_an_repo($an, $target, $port, $password);
	
	# Update the OS first, if not disabled.
	my $reboot_needed = 0;
	if ($an->data->{switches}{'no-os-update'})
	{
		print "Operating system updates have been disabled via '--no-os-update'. Skipping them.\n";
	}
	else
	{
		# Make sure the priority has been removed from the striker repos.
		my $shell_call = "
for repo in \$(".$an->data->{path}{ls}." ".$an->data->{path}{yum_repos}."/);
do 
    ".$an->data->{path}{sed}." -i '/priority=/d' ".$an->data->{path}{yum_repos}."/\${repo};
done
".$an->data->{path}{yum}." clean expire-cache
";
		if ($an->data->{switches}{offline})
		{
			$shell_call .= $an->data->{path}{yum}." -y update --disablerepo=* --enablerepo=*striker*";
		}
		else
		{
			$shell_call .=  $an->data->{path}{yum}." -y update";
		}
		
		if ($target eq "local")
		{
			# Local call. If an update is needed, we'll set 'sys::reboot_needed' and tell the user to 
			# reboot when we exit.
			print "Updating the operating system on the local machine now. Please be patient.\n";
			print "- If any dashboard repositories are still set to 'priority=1', they will be\n";
			print "  updated to remove this constraint.\n";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			print "/-----[ Command output ]------------------------------------------------------\n";
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				print "| $line\n"; 
				
				if ($line =~ / kernel\s+x86_64 /)
				{
					# Update required.
					$an->data->{sys}{reboot_needed} = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "sys::reboot_needed", value1 => $an->data->{sys}{reboot_needed}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				if ($line =~ /Total size: /i)
				{
					print "| #############################################################################\n";
					print "| Please be patient! Packages are downloading in the background. They should\n";
					print "| download from local repos fairly quickly. Once done, they will begin\n";
					print "| installing. At times, this may seem to stall. Please be patient.\n";
					print "| You can verify the download is running with 'ps aux | grep yum'.\n";
					print "| #############################################################################\n";
				}
			}
			close $file_handle;
			print "\\-----------------------------------------------------------------------------\n";
			if ($an->data->{sys}{reboot_needed})
			{
				print "- The operating system's kernel was updated.\n";
				print "- You will need to reboot this machine when the update process completes.\n";
			}
			
			# Now download the RPMs used only on the nodes so that we have updated cache.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::offline", value1 => $an->data->{sys}{offline}, 
			}, file => $THIS_FILE, line => __LINE__});
			if (not $an->data->{sys}{offline})
			{
				print "Downloading node-specific packages.\n";
				my $shell_call = $an->data->{path}{yum}." -y install lvm2-cluster dos2unix --disablerepo=*striker* --downloadonly";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				print "/-----[ Command output ]------------------------------------------------------\n";
				open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
				print "\\-----------------------------------------------------------------------------\n";
			}
		}
		else
		{
			# Update a remote machine. We'll reboot immediately if they need it.
			print "Updating the operating system on: [$target]. Please be patient.\n";
			print "- If any dashboard repositories are still set to 'priority=1', they will be\n";
			print "  updated to remove this constraint.\n";
			print "###############################################################################\n";
			print "# NOTE: There will be no output here until the update completes. The updates\n";
			print "# should download from local repos fairly quickly. Once done, they will need\n";
			print "# a little bit of time to install. Please be patient! If you want to check if\n";
			print "# the update is still running, on: [$target], run:\n";
			print "# 'ps aux | grep yum'.\n";
			print "###############################################################################\n";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			print "/-----[ Command output ]------------------------------------------------------\n";
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				print "| $line\n";
				if ($line =~ / kernel\s+x86_64 /)
				{
					# Update required.
					$reboot_needed = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "reboot_needed", value1 => $reboot_needed, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			print "\\-----------------------------------------------------------------------------\n";
			if ($reboot_needed)
			{
				print "- The operating system's kernel was updated. A reboot will be performed shortly.\n";
			}
		}
		print "- Done.\n\n";
	}
	
	# Copy all the files into place.
	print "Updating Striker and ScanCore files on: [$target] if needed.\n";
	
	# Build the array of packages to rsync.
	my $types = $type eq "node" ? ["all"] : ["all", "dashboard"];
	foreach my $type (@{$types})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "type", value1 => $type, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $source (sort {$a cmp $b} keys %{$an->data->{copy}{$type}})
		{
			my $source_path = $an->data->{path}{updates}{striker}."/".$source;
			my $destination = $an->data->{copy}{$type}{$source};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "source",      value1 => $source, 
				name2 => "source_path", value2 => $source_path, 
				name3 => "destination", value3 => $destination, 
			}, file => $THIS_FILE, line => __LINE__});
			print "- Updating: [$destination]...\n";
			
			if ($target eq "local")
			{
				# Local call
				rsync_data($an, $source_path, $destination);
			}
			else
			{
				# Remote call
				print "  (Progress not available when updating remote targets)\n";
				my $shell_call  = $an->data->{path}{rsync}." -aAX ".$source_path." ".$destination;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "target",     value1 => $shell_call, 
					name2 => "shell_call", value2 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				my $return_code = $an->Storage->rsync({
					target      => $target,
					port        => $port, 
					password    => $password,
					source      => $source_path,
					destination => "root\@$target:$destination",
					switches    => "-avAX",
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Done.\n\n";
	
	if ($type eq "node")
	{
		# Enable 'anvil-safe-start'.
		print "Enabling 'anvil-safe-start'.\n";
		my $shell_call = $an->data->{path}{'anvil-safe-start'}." --enable";
		print "/-----[ Command output ]------------------------------------------------------\n";
		if ($target eq "local")
		{
			# Local call
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				print "| $line\n";
			}
			close $file_handle;
		}
		else
		{
			# Remote call
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				'close'    => 1,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1  => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				print "| $line\n";
			}
		}
		print "\\-----------------------------------------------------------------------------\n";
		print "- Done.\n\n";
	}
	
	# Compile and setuid-root C-wrappers.
	print "Searching for setuid C-wrappers to recompile.\n";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "path::striker_dir", value1 => $an->data->{path}{striker_dir}, 
	}, file => $THIS_FILE, line => __LINE__});
	local(*DIRECTORY);
	opendir(DIRECTORY, $an->data->{path}{striker_dir});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		next if $file !~ /\.c$/;
		my $source_file = $an->data->{path}{striker_dir}."/$file";
		   $source_file =~ s/\/\//\//g;
		my $out_file    = ($source_file =~ /^(.*?)\.c$/)[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "source_file", value1 => $source_file, 
			name2 => "out_file",    value2 => $out_file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		print "- Recompiling: [$source_file]\n";
		my $shell_call = $an->data->{path}{gcc}." -o ".$out_file." ".$source_file." && chmod 6755 ".$out_file;
		if ($target eq "local")
		{
			# Local call
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		else
		{
			# Remote call
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				'close'    => 1,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1  => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Done.\n\n";
	
	# Make sure some permissions are set properly locally.
	if ($target eq "local")
	{
		foreach my $target (sort {$a cmp $b} keys %{$an->data->{permissions}})
		{
			my $path            = $an->data->{permissions}{$target}{path};
			my $owner           = $an->data->{permissions}{$target}{owner};
			my $group           = $an->data->{permissions}{$target}{group};
			my $mode            = $an->data->{permissions}{$target}{mode};
			my $chown_recursive = $an->data->{permissions}{$target}{chown_recursive};
			my $chmod_recursive = $an->data->{permissions}{$target}{chmod_recursive};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1  => "path",            value1 => $path, 
				name2  => "owner",           value2 => $owner, 
				name3  => "group",           value3 => $group, 
				name4  => "mode",            value4 => $mode, 
				name5  => "chown_recursive", value5 => $chown_recursive, 
				name6  => "chmod_recursive", value6 => $chmod_recursive, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Chown
			my $shell_call = $an->data->{path}{'chown'}." ".$owner.":".$group." ".$path;
			if ($chown_recursive)
			{
				$shell_call = $an->data->{path}{'chown'}." -R ".$owner.":".$group." ".$path;
			}
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			# Permissions
			$shell_call = $an->data->{path}{'chmod'}." ".$mode." ".$path;
			if ($chmod_recursive)
			{
				$shell_call = $an->data->{path}{'chmod'}." -R ".$mode." ".$path;
			}
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open ($file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
	}
	
	my $rebooted = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "reboot_needed", value1 => $reboot_needed, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($reboot_needed)
	{
		# Send the reboot command
		print "Rebooting: [$target]... Please be patient.\n";
		($rebooted) = reboot_target($an, $target, $port, $password);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "rebooted", value1 => $rebooted, 
		}, file => $THIS_FILE, line => __LINE__});
		print "- Done!\n\n";
	}
	
	print "###############################################################################\n";
	print "# Finished updating: [".$target."]\n";
	print "###############################################################################\n";
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "rebooted", value1 => $rebooted, 
	}, file => $THIS_FILE, line => __LINE__});
	return($rebooted);
}

# This reboots a target and waits for it to come back up.
sub reboot_target
{
	my ($an, $target, $port, $password) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "reboot_target" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "target", value1 => $target, 
		name2 => "port",   value2 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $rebooted   = 1;
	my $shell_call = $an->data->{path}{reboot};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		'close'    => 1,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1  => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# We need to give the system time to shut down.
	my $has_shutdown  = 0;
	my $wait_for_boot = 1;
	my $time_limit    = 60;
	my $uptime_max    = $time_limit + 60;
	my $timeout       = time + $time_limit;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "time",       value1 => time,
		name2 => "timeout",    value2 => $timeout,
		name3 => "uptime_max", value3 => $uptime_max,
	}, file => $THIS_FILE, line => __LINE__});
	while (not $has_shutdown)
	{
		# 1 == pinged, 0 == failed.
		my ($ping) = $an->Check->ping({ping => $target, count => 3});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "target", value1 => $target,
			name2 => "ping",   value2 => $ping,
		}, file => $THIS_FILE, line => __LINE__});
		if (not $ping)
		{
			# We can't ping it. Mark it as now being shut off.
			$has_shutdown = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "has_shutdown", value1 => $has_shutdown,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# We can ping it. Log in and see if the uptime is short. Failure to log in will cause
			# the uptime to return '0'.
			my $uptime = $an->System->get_uptime({
					target   => $target,
					port     => $port, 
					password => $password,
				});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "uptime",     value1 => $uptime, 
				name2 => "uptime_max", value2 => $uptime_max, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($uptime) && ($uptime < $uptime_max))
			{
				# We rebooted and missed it.
				$has_shutdown  = 1;
				$wait_for_boot = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "has_shutdown",  value1 => $has_shutdown, 
					name2 => "wait_for_boot", value2 => $wait_for_boot, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# If we've waited passed the timeout and the system hasn't shut down, give up.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "time",    value1 => time,
			name2 => "timeout", value2 => $timeout,
		}, file => $THIS_FILE, line => __LINE__});
		if (time > $timeout)
		{
			$rebooted      = 0;
			$wait_for_boot = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "rebooted",      value1 => $rebooted,
				name2 => "wait_for_boot", value2 => $wait_for_boot, 
			}, file => $THIS_FILE, line => __LINE__});
			last;
		}
		sleep 3;
	}
	
	# Now loop for 'sys::reboot_timeout' seconds waiting to see if the node recovers.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "wait_for_boot", value1 => $wait_for_boot,
	}, file => $THIS_FILE, line => __LINE__});
	if ($wait_for_boot)
	{
		my $give_up_time = time + $an->data->{sys}{reboot_timeout};
		my $wait         = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "time",      value1 => time,
			name2 => "give_up_time", value2 => $give_up_time,
		}, file => $THIS_FILE, line => __LINE__});
		while ($wait)
		{
			my $time      = time;
			my $will_wait = ($give_up_time - $time);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "will_wait", value1 => $will_wait,
			}, file => $THIS_FILE, line => __LINE__});
			if ($time > $give_up_time)
			{
				# Failed to come back up.
				$rebooted = 0;
				last;
			}
			
			# Try to access
			my ($access) = $an->Check->access({
					target   => $target, 
					port     => $port,
					password => $password,
				});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "access", value1 => $access, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($access)
			{
				# We're in!
				$wait = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "wait", value1 => $wait, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			sleep 3;
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "rebooted", value1 => $rebooted, 
	}, file => $THIS_FILE, line => __LINE__});
	return($rebooted);
}

# This checks access to the nodes in the Anvil! and that they're ready to be updated.
sub check_anvil
{
	my ($an, $anvil_uuid, $error, $fatal) = @_;
	$error = 0 if not defined $error;
	$fatal = 1 if not defined $fatal;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_anvil" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "anvil_uuid", value1 => $anvil_uuid, 
		name2 => "error",      value2 => $error, 
		name3 => "fatal",      value3 => $fatal, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the node info
	$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
	
	my $use_node = "";
	foreach my $node_key ("node1", "node2")
	{
		my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
		my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
		print "- Doing a quick scan of: [$node_name]\n";
		
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
		if ($an->data->{sys}{anvil}{$node_key}{online})
		{
			print "- Online, good.\n";
			check_cluster_and_storage($an, $node_key);
		}
		else
		{
			print "[ Error ] - Offline!\n";
			$error = 1;
		}
	}
	if (not $error)
	{
		$error = validate_cluster_and_storage($an, $fatal);
	}
	
	return($error);
}

# This will throw an error if only one node is in the cluster or if a DRBD disk state is not UpToDate.
sub validate_cluster_and_storage
{
	my ($an, $fatal) = @_;
	$fatal = 1 if not defined $fatal;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "validate_cluster_and_storage" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "fatal", value1 => $fatal, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If both are running rgmanager, make sure we're UpToDate.
	my $error = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "sys::anvil::node1::in_cluster", value1 => $an->data->{sys}{anvil}{node1}{in_cluster},
		name2 => "sys::anvil::node2::in_cluster", value2 => $an->data->{sys}{anvil}{node2}{in_cluster},
	}, file => $THIS_FILE, line => __LINE__});
	if (($an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster}))
	{
		# Both nodes are online. Did we see any resources that we're UpToDate?
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::anvil::node1::all_uptodate", value1 => $an->data->{sys}{anvil}{node1}{all_uptodate},
			name2 => "sys::anvil::node2::all_uptodate", value2 => $an->data->{sys}{anvil}{node2}{all_uptodate},
		}, file => $THIS_FILE, line => __LINE__});
		if ((not $an->data->{sys}{anvil}{node1}{all_uptodate}) or (not $an->data->{sys}{anvil}{node2}{all_uptodate}))
		{
			if ($fatal)
			{
				print "[ Error ] - The upgrade process requires taking each node out of the cluster,\n";
				print "[ Error ]   one at a time. To do this, both nodes have to have up to date \n";
				print "[ Error ]   storage. Please watch the Striker web interface for the replicated\n";
				print "[ Error ]   Storage's 'Disk State' to be 'UpToDate/UpToDate' on both nodes, \n";
				print "[ Error ]   then try again.\n";
				exit(15);
			}
			else
			{
				print "- Replicated storage is still coming online.\n";
				$error = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "error", value1 => $error,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	elsif ((($an->data->{sys}{anvil}{node1}{in_cluster}) && (not $an->data->{sys}{anvil}{node2}{in_cluster})) or 
	       ((not $an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster})))
	{
		# One node is in the cluster and the other isn't.
		if ($fatal)
		{
			print "[ Error ] - Only one node is in the cluster. Either both nodes must be in the cluster\n";
			print "[ Error ]   neither can be. If one node is up, we'll need to be able to move any\n";
			print "[ Error ]   servers it is hosting to withdraw and update it.\n";
			exit(16);
		}
		else
		{
			if (not $an->data->{sys}{anvil}{node1}{in_cluster})
			{
				print "- Node 1 hasn't joined the Anvil! yet.\n";
			}
			else
			{
				print "- Node 2 hasn't joined the Anvil! yet.\n";
			}
			$error = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "error", value1 => $error,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "error", value1 => $error,
	}, file => $THIS_FILE, line => __LINE__});
	return($error);
}

# This checks to see if rgmanager is running and, if so, if DRBD is UpToDate.
sub check_cluster_and_storage
{
	my ($an, $node_key) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_cluster_and_storage" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "node_key", value1 => $node_key, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# To update, either both nodes have to be in the Anvil!, or neither can be. If both are, DRBD must be
	# UpToDate/UpToDate.
	$an->data->{sys}{anvil}{$node_key}{in_cluster}   = 0;
	$an->data->{sys}{anvil}{$node_key}{all_uptodate} = 1;
	
	# Check rgmanager
	my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
	my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
	my $password   = $an->data->{sys}{anvil}{$node_key}{password};
	my $shell_call = $an->data->{path}{clustat}." -x";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		# We're looking at rgmanager, specifically
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if (($line =~ /<node /) && ($line =~ /local="1"/) && ($line =~ /rgmanager="(\d+)"/))
		{
			$an->data->{sys}{anvil}{$node_key}{in_cluster} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::anvil::${node_key}::in_cluster", value1 => $an->data->{sys}{anvil}{$node_key}{in_cluster},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Check drbd
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil::${node_key}::in_cluster", value1 => $an->data->{sys}{anvil}{$node_key}{in_cluster},
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{anvil}{$node_key}{in_cluster})
	{
		my $this_resource = "";
		my $shell_call    = $an->data->{path}{cat}." ".$an->data->{path}{proc_drbd};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			# We're looking at rgmanager, specifically
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /(\d+): cs/)
			{
				$this_resource                                           = "r".$1;
				$an->data->{drbd}{resource}{$this_resource}{eta_to_sync} = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "drbd::resource::${this_resource}::eta_to_sync", value1 => $an->data->{drbd}{resource}{$this_resource}{eta_to_sync}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			if ($line =~ / ds:(.*?)\/(.*?) /)
			{
				my $local_disk_state = $1;
				my $peer_disk_state  = $2;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "local_disk_state", value1 => $local_disk_state,
					name2 => "peer_disk_state",  value2 => $peer_disk_state,
				}, file => $THIS_FILE, line => __LINE__});
				if (($local_disk_state ne "UpToDate") or ($peer_disk_state ne "UpToDate"))
				{
					$an->data->{sys}{anvil}{$node_key}{all_uptodate} = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "sys::anvil::${node_key}::all_uptodate", value1 => $an->data->{sys}{anvil}{$node_key}{all_uptodate},
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			if ($line =~ /finish: (\d+):(\d+):(\d+)/)
			{
				my $hours   = $1;
				my $minutes = $2;
				my $seconds = $3;
				$an->data->{drbd}{resource}{$this_resource}{eta_to_sync} = ($hours * 3600) + ($minutes * 60) + $seconds;
				
				$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
					name1 => "hours",                                         value1 => $hours, 
					name2 => "minutes",                                       value2 => $minutes, 
					name3 => "seconds",                                       value3 => $seconds,
					name4 => "drbd::resource::${this_resource}::eta_to_sync", value4 => $an->data->{drbd}{resource}{$this_resource}{eta_to_sync}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	return(0);
}

# This calls 'yum -y update --downloadonly' on one of the Anvil! nodes
sub gather_updated_rpms_from_anvil
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "gather_updated_rpms_from_anvil" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Downloading updated RPMs for Anvil! nodes...\n";
	
	# If I have a UUID, look up the name. If I have a name, look up the UUID.
	my $anvil_uuid = "";
	my $anvil_name = "";
	if ($an->data->{switches}{'anvil-name'} eq "all")
	{
		my $query = "SELECT anvil_name, anvil_uuid FROM anvils WHERE anvil_note IS DISTINCT FROM 'DELETED' ORDER BY anvil_name ASC LIMIT 1;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_name = $row->[0];
			$anvil_uuid = $row->[1];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
				name2 => "anvil_uuid", value2 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_name)
		{
			print "[ Error ] - Failed to find an available Anvil! to work on.\n";
			exit(13);
		}
	}
	elsif ($an->data->{switches}{'anvil-name'})
	{
		   $anvil_name = $an->data->{switches}{'anvil-name'};
		my $query      = "SELECT anvil_uuid FROM anvils WHERE anvil_name = ".$an->data->{sys}{use_db_fh}->quote($anvil_name).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_uuid = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_uuid", value1 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_uuid)
		{
			print "[ Error ] - Failed to find an Anvil! UUID for the name: [$anvil_name]\n";
			exit(5);
		}
	}
	else
	{
		   $anvil_uuid = $an->data->{switches}{'anvil-uuid'};
		my $query      = "SELECT anvil_name FROM anvils WHERE anvil_uuid = ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_name = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_name)
		{
			print "[ Error ] - Failed to find an Anvil! name for the UUID: [$anvil_uuid]\n";
			exit(6);
		}
	}
	
	# Some things expect this CGI variable to be set.
	$an->data->{cgi}{anvil_uuid} = $anvil_uuid;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid},
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I am still alive, we've got a good Anvil!.
	print "- Picking a node in the Anvil!: [$anvil_name]\n";
	$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
	
	my $use_node = "";
	foreach my $node_key ("node1", "node2")
	{
		my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
		my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
		print "- Doing a quick scan of: [$node_name]\n";
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
		if ($an->data->{sys}{anvil}{$node_key}{online})
		{
			print "- The node is online.\n";
			$use_node = $node_key if not $use_node;
		}
		else
		{
			print "- The node appears to be offline or unreachable.\n";
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "use_node", value1 => $use_node,
	}, file => $THIS_FILE, line => __LINE__});
	if (not $use_node)
	{
		print "[ Error ] - Neither node is online or reachable. Unable to proceed.\n";
		exit(7);
	}
	
	# Update our local repo
	update_local_repo($an);
	
	# I'm not installing updates, so it doesn't matter which node I use.
	my $target     = $an->data->{sys}{anvil}{$use_node}{use_ip};
	my $port       = $an->data->{sys}{anvil}{$use_node}{use_port};
	my $password   = $an->data->{sys}{anvil}{$use_node}{password};
	my $shell_call = $an->data->{path}{yum}." clean expire-cache";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	print "- Clearing old RPM cache on: [$target]\n";
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	print "/-----[ Command output ]------------------------------------------------------\n";
	foreach my $line (@{$return})
	{
		print "| $line\n";
	}
	print "\\-----------------------------------------------------------------------------\n";
	undef $return;
	
	# Download updates now
	print "- Downloading, NOT installing, updated RPMs on: [$target]...\n";
	$shell_call = $an->data->{path}{yum}." -y update --downloadonly";
	if ($an->data->{switches}{offline})
	{
		$shell_call = $an->data->{path}{yum}." -y update --downloadonly --disablerepo=* --enablerepo=*striker*";
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	print "\n###############################################################################\n";
	print "# There will be no output here until the remote call completes. If you think\n";
	print "# there is a problem, run 'ps aux | grep yum' on: [$target].\n";
	print "# If you see '... /usr/bin/python /usr/bin/yum -y update --downloadonly', \n";
	print "# please keep waiting.\n";
	print "###############################################################################\n";
	print "/-----[ Command output ]------------------------------------------------------\n";
	foreach my $line (@{$return})
	{
		print "| $line\n";
	}
	print "\\-----------------------------------------------------------------------------\n";
	undef $return;
	
	# Now build a list of RPMs to rsync over to our cache. 
	my $rpm_files  = [];
	   $shell_call = $an->data->{path}{find}." ".$an->data->{path}{yum_cache};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^(\/.*?\.rpm)$/)
		{
			my $rpm = $1;
			push @{$rpm_files}, $rpm;
		}
	}
	
	print "- Copying over any RPMs from the node that aren't in our cache.\n";
	my $remote_copy_count = 0;
	foreach my $rpm_file (sort {$a cmp $b} @{$rpm_files})
	{
		my $file_name   = ($rpm_file =~ /^.*\/(.*)$/)[0];
		my $target_file = $an->data->{path}{updates}{rpms}."/".$file_name;
		next if -e $target_file;
		$remote_copy_count++;
		
		# 0 = OK, 1 = Failed
		print "- Caching: [$target:$rpm_file]\n";
		my $return_code = $an->Storage->rsync({
			target      => $target,
			port        => $port, 
			password    => $password,
			source      => "root\@$target:$rpm_file",
			destination => $an->data->{path}{updates}{rpms},
			switches    => "-avAX",
		});
		if ($return_code)
		{
			print "[ Error ] - Failed. Details of the failure may be in: [".$an->data->{path}{log_file}."]\n";
			exit(11);
		}
	}
	if ($remote_copy_count)
	{
		print "- Done.\n";
	}
	else
	{
		print "- No files needed to be copied. Done.\n";
	}
	
	return(0);
}

# This copies any RPMs from the local rpm cache to the repo directory and then rebuilds the repodata.
sub update_local_repo
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_local_repo" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $os_type = get_os_type($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "os_type",             value1 => $os_type,
		name2 => "path::img_directory", value2 => $an->data->{path}{img_directory},
		name3 => "path::iso_directory", value3 => $an->data->{path}{iso_directory},
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{path}{img_directory} =~ s/#!os_type!#/${os_type}6/;
	$an->data->{path}{iso_directory} =~ s/#!os_type!#/${os_type}6/;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "path::img_directory", value1 => $an->data->{path}{img_directory},
		name2 => "path::iso_directory", value2 => $an->data->{path}{iso_directory},
	}, file => $THIS_FILE, line => __LINE__});

	# Now, if this is a repo using a mounted ISO, we will need to convert it to standard files.
	convert_iso_to_files($an);
	
	# Copy cached RPMs to the RPM repo
	print "- Copying new RPMs to the RPM repository.\n";
	my $packages_dir = $an->data->{path}{img_directory}."/Packages";
	rsync_data($an, $an->data->{path}{updates}{rpms}."/*", $packages_dir);
	
	# Copy third party RPMs to the repo.
	my $packages_source      = $an->data->{path}{img_directory}."/Packages/*";
	my $packages_destination = $an->data->{path}{img_directory}."/";
	print "Copying source packages (including optional third party packages) to the repo.\n";
	rsync_data($an, $packages_source, $packages_destination);
	
	# Copy over any of our RPMs from cache to the repo source.
	my ($xml_file1, $xml_file2) = get_repodata_xml_file_name($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "xml_file1", value1 => $xml_file1,
		name2 => "xml_file2", value2 => $xml_file2,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Rebuild the repo.
	update_repo_metadata($an, $xml_file1, $xml_file2);
	
	# Copy tools
	print "- Copying fence agents and tools to the PXE 'img' directory.\n";
	my $fence_source      = $an->data->{path}{updates}{striker}."/tools/fence*";
	my $fence_destination = $an->data->{path}{img_directory}."/Tools/fence/";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "fence_source",      value1 => $fence_source,
		name2 => "fence_destination", value2 => $fence_destination,
	}, file => $THIS_FILE, line => __LINE__});
	rsync_data($an, $fence_source, $fence_destination);
	
	my $tools_source      = $an->data->{path}{updates}{striker}."/tools/*";
	my $tools_destination = $an->data->{path}{img_directory}."/striker/tools/";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "tools_source",      value1 => $tools_source,
		name2 => "tools_destination", value2 => $tools_destination,
	}, file => $THIS_FILE, line => __LINE__});
	rsync_data($an, $tools_source, $tools_destination);
	
	# Copy fence agents.
	print "- Copying fence agents to the system directory.\n";
	my $agent_destination = "/usr/sbin/";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "tools_source",      value1 => $tools_source,
		name2 => "agent_destination", value2 => $agent_destination,
	}, file => $THIS_FILE, line => __LINE__});
	rsync_data($an, $tools_source, $agent_destination);
	
	
	return(0);
}

# This updates the RPM repo metadata
sub update_repo_metadata
{
	my ($an, $xml_file1, $xml_file2) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_repo_metadata" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "xml_file1", value1 => $xml_file1, 
		name2 => "xml_file2", value2 => $xml_file2, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "- Regenerating the RPM repository meta-data.\n";
	print "- [ NOTE ] - Please be patient, this might take a minute.\n";
	my $shell_call = $an->data->{path}{createrepo}." -g ".$xml_file1." ".$an->data->{path}{img_directory};
	if ($xml_file2)
	{
		$shell_call = $an->data->{path}{createrepo}." -g ".$xml_file1." -g ".$xml_file2." ".$an->data->{path}{img_directory};
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	print "/-----[ Command output ]------------------------------------------------------\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		print "| $line\n";
		
		if ($line =~ /Error opening Package/)
		{
			print "
[ Error ] - There was an error when generating the 'Packages' repository data.
[ Error ]   It is possible some downloaded or copied 'RPM' package files are 
[ Error ]   corrupt. Check that your Internet connection is working. If the 
[ Error ]   error is not obvious, re-run this with '-vv' or '-vvv' for 
[ Error ]   debugging output.
";
			exit(10);
		}
	}
	close $file_handle;
	print "\\-----------------------------------------------------------------------------\n";
	
	return(0);
}

# This returns the XML files containing install groups.
sub get_repodata_xml_file_name
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_repodata_xml_file_name" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $xml_file1 = "";
	my $xml_file2 = "";
	my $source   = $an->data->{path}{img_directory}."/repodata";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "source", value1 => $source,
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $source)
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "source", value1 => $source,
		}, file => $THIS_FILE, line => __LINE__});
		local(*DIR);
		opendir(DIR, $source) or die __LINE__."; Failed to open the directory: [$source], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			my $full_path = $source."/".$file;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "full_path", value1 => $full_path,
			}, file => $THIS_FILE, line => __LINE__});
			
			#rm -f repodata/*.gz repodata/*.*.bz2 repodata/*.repomd.xml
			if ($file =~ /Server\.x86_64\.xml$/)
			{
				$xml_file2 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file2", value1 => $xml_file2,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($file =~ /c6-x86_64-comps\.xml$/)
			{
				$xml_file2 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file2", value1 => $xml_file2,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif (($file =~ /\.gz$/) or ($file =~ /\.bz2$/) or ($file =~ /\.repomd\.xml$/))
			{
				# Delete
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "full_path", value1 => $full_path,
				}, file => $THIS_FILE, line => __LINE__});
				unlink $full_path or die __LINE__."; [ Error ] - Failed to delete old 'repodata' file: [$full_path]. The error was: $!\n";
			}
			elsif ($file =~ /comps\.xml$/)
			{
				$xml_file1 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file1", value1 => $xml_file1,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($file =~ /repomd\.xml$/)
			{
				$xml_file1 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file1", value1 => $xml_file1,
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Ignore
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "full_path", value1 => $full_path,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		closedir(DIR);
	}
	
	if (not $xml_file1)
	{
		print "[ Error ] - Failed to find the XML file used by 'createrepo' on the source ISO.\n";
		exit(9);
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "xml_file1", value1 => $xml_file1,
		name2 => "xml_file2", value2 => $xml_file2,
	}, file => $THIS_FILE, line => __LINE__});
	return($xml_file1, $xml_file2);
}

# This looks to see if the local repo is using an ISO and, if so, converts it to plain files before 
# rebuilding the local repo
sub convert_iso_to_files
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "convert_iso_to_files" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# See if there is an ISO definied in fstab.
	my $img_directory = $an->data->{path}{img_directory};
	my $iso_directory = $an->data->{path}{iso_directory};
	my $update_fstab  = "";
	my $fstab_data_ok = 0;
	my $new_fstab     = "";
	my $shell_call    = $an->data->{path}{etc_fstab};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or die __LINE__."; [ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^(\/var\/www\/.*?)\s+$img_directory\s/i)
		{
			my $source_iso   = $1;
			   $update_fstab = 1;
			print "- This system used the ISO: [$source_iso] for the local repo.\n";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "update_fstab", value1 => $update_fstab,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			$new_fstab .= $line."\n";
			if ($line =~ /UUID=.*?\s+\/\s/)
			{
				# Good fstab data.
				$fstab_data_ok = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "fstab_data_ok", value1 => $fstab_data_ok,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "new_fstab",     value1 => $new_fstab,
		name2 => "fstab_data_ok", value2 => $fstab_data_ok,
		name3 => "update_fstab",  value3 => $update_fstab,
	}, file => $THIS_FILE, line => __LINE__});
	if (($new_fstab) && ($fstab_data_ok) && ($update_fstab))
	{
		# Make a backup.
		my $backup_file = $an->data->{path}{etc_fstab}.".$THIS_FILE";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "backup_file", value1 => $backup_file,
		}, file => $THIS_FILE, line => __LINE__});
		if (not -e $backup_file)
		{
			print "- Backing up original fstab file to: [$backup_file]\n";
			my $shell_call = $an->data->{path}{rsync}." -aAX ".$an->data->{path}{etc_fstab}." $backup_file";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		else
		{
			print "- Backup of fstab already exists: [$backup_file]\n";
		}
		
		# Write out the new fstab
		print "- Writing out new 'fstab' file.\n";
		my $shell_call = $an->data->{path}{etc_fstab};
		open (my $file_handle, ">$shell_call") or die "Failed to write to: [$shell_call], error was: $!\n";
		print $file_handle $new_fstab;
		close $file_handle;
	}
	
	# Now, is the ISO mounted? If it is, unmount it. We'll remount it later, if needed.
	my $unmount    = 0;
	   $shell_call = $an->data->{path}{df}." -hP";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /\s$img_directory$/i)
		{
			$unmount = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "unmount", value1 => $unmount,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "unmount", value1 => $unmount,
	}, file => $THIS_FILE, line => __LINE__});
	if ($unmount)
	{
		# Unmount it.
		my $shell_call = $an->data->{path}{umount}." $img_directory";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		print "- Unmounted: [$img_directory]\n";
	}
	
	# Now, do I have data in the img directory?
	my $packages_directory = $img_directory."/Packages";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "packages_directory", value1 => $packages_directory,
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $packages_directory)
	{
		print "- The RPM repo source appears to be ready to receive updates.\n";
	}
	else
	{
		# The packages directory doesn't exist, so we need to mount the old ISO and copy the 
		# contents.
		print "- The packages directory: [$packages_directory] doesn't exist.\n";
		my $temporary_mount = "/tmp/".time;
		
		mkdir $temporary_mount or die "[ Error ] - Failed to create the directory: [$temporary_mount]. Error was: $!\n";
		
		# What's the ISO file and path?
		my $iso_file   = "";
		my $shell_call = $an->data->{path}{ls}." $iso_directory";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /\.iso$/i)
			{
				# Found the ISO
				$iso_file = $iso_directory."/".$line;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "iso_file", value1 => $iso_file,
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		close $file_handle;
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "iso_file", value1 => $iso_file,
		}, file => $THIS_FILE, line => __LINE__});
		if (not $iso_file)
		{
			print "[ Error ] - Failed to find the original Anvil! ISO, and the img directory: [$img_directory] is empty, so we can't rebuild the RPM repo.\n";
			exit(8);
		}
		else
		{
			print "- Temporarily mounting the original ISO: [$iso_file] at: [$temporary_mount]\n";
			my $shell_call = $an->data->{path}{mount}." -o loop $iso_file $temporary_mount";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			my $source_check = $temporary_mount."/Packages";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "source_check", value1 => $source_check,
			}, file => $THIS_FILE, line => __LINE__});
			if (-e $source_check)
			{
				print "- Mounted successfully. Copying source to: [$img_directory]\n";
				rsync_data($an, $temporary_mount."/*", $img_directory);
			}
			
			print "- Done, unmounting ISO.\n";
			$shell_call = $an->data->{path}{umount}." $temporary_mount";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open ($file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			rmdir $temporary_mount or die "[ Error ] - Failed to remove the directory: [$temporary_mount]. Error was: $!\n";
		}
	}
	
	return(0);
}

# This returns either 'rhel' or 'centos', depending on the contents of 'path::os_release'.
sub get_os_type
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_os_type" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $os_type    = "";
	my $shell_call = $an->data->{path}{'os_release'};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or die __LINE__."; [ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Red Hat Enterprise Linux Server/i)
		{
			$os_type = "rhel";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "os_type", value1 => $os_type,
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /CentOS/i)
		{
			$os_type = "centos";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "os_type", value1 => $os_type,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	return($os_type);
}

# This walks through the yum cache and copies any found RPMs to 'path::rpm_cache'.
sub cache_updated_rpms
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "cache_updated_rpms" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "- Caching updated RPMs...\n";
	my $rpm_files  = [];
	my $shell_call = $an->data->{path}{find}." ".$an->data->{path}{yum_cache};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^(\/.*?\.rpm)$/)
		{
			my $rpm = $1;
			push @{$rpm_files}, $rpm;
		}
	}
	close $file_handle;
	
	foreach my $rpm_file (sort {$a cmp $b} @{$rpm_files})
	{
		my $file_name   = ($rpm_file =~ /^.*\/(.*)$/)[0];
		my $target_file = $an->data->{path}{updates}{rpms}."/".$file_name;
		next if -e $target_file;
		print "- Caching: [$rpm_file]\n";
		my $shell_call = $an->data->{path}{rsync}." -avAX $rpm_file ".$an->data->{path}{updates}{rpms}."/";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	print "- Done. RPMs are now stored in: [".$an->data->{path}{updates}{rpms}."/]\n";
	
	return(0);
}

# This downloads updated RPMs for the local OS. It does NOT install them.
sub download_os_updates
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "download_os_updates" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if ($an->data->{switches}{'no-os-update'})
	{
		print "- OS Updates disabled, skipping.\n";
		return(0);
	}
	
	my $shell_call = $an->data->{path}{yum}." -y update --downloadonly";
	if ($an->data->{switches}{offline})
	{
		$shell_call = $an->data->{path}{yum}." -y update --downloadonly --disablerepo=* --enablerepo=*striker*";
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	print "/-----[ Command output ]------------------------------------------------------\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "| $line\n";
		if ($line =~ /Downloading Packages/i)
		{
			print "| ################################################################\n";
			print "| Please be patient! Packages are downloading in the background.\n";
			print "| You can verify the download is running with 'ps aux | grep yum'.\n";
			print "| ################################################################\n";
		}
	}
	close $file_handle;
	print "\\-----------------------------------------------------------------------------\n";
	
	return(0);
}

# This disabled or enables ScanCore. When disabling, it waits until it exits before returning.
sub manage_scancore
{
	my ($an, $task) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "manage_scancore" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "task", value1 => $task, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($task eq "disable")
	{
		print "- Disabling ScanCore...\n";
		my $waiting    = 1;
		my $shell_call = $an->data->{path}{ScanCore}." --disable";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Now wait for it to exit
		print "- Disabled. Waiting now for it to exit: ";
		while($waiting)
		{
			my $pid_seen   = 0;
			my $shell_call = $an->data->{path}{ScanCore}." --status";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				# NOTE: Don't parse the string text, it could be in whatever language.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /-.*?\[(\d+)\]$/)
				{
					$pid_seen = 1;
				}
			}
			close $file_handle;
			
			if ($pid_seen)
			{
				if ($an->data->{sys}{debug} >= 3)
				{
					print "- Still running, will check again momentarily.\n";
				}
				else
				{
					print ".";
				}
				sleep 5;
			}
			else
			{
				if ($an->data->{sys}{debug} >= 3)
				{
					print "- It has exited.\n";
				}
				else
				{
					print " Done.\n";
				}
				$waiting = 0;
			}
		}
	}
	else
	{
		# Enable it
		print "- Enabling ScanCore...\n";
		my $waiting    = 1;
		my $shell_call = $an->data->{path}{ScanCore}." --enable";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		print "- Done.\n";
	}
	
	return(0);
}

# This downloads and extracts the Striker source
sub download_and_extract_source
{
	my ($an, $url) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "download_and_extract_source" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "url", value1 => $url, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Download the URL to path::temp_cache.
	my $out_file = $an->data->{path}{updates}{temp}."/".$an->data->{sys}{striker_zip_file};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "url",      value1 => $url,
		name2 => "out_file", value2 => $out_file,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Extract the source
	   $out_file     = download_file($an, $url, $out_file, 0644);
	my $extract_root = extract_file($an, $out_file);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "extract_root", value1 => $extract_root,
	}, file => $THIS_FILE, line => __LINE__});
	if (not $extract_root)
	{
		# Failed to download
		return(0);
	}
	
	# Move the source from temp.
	rsync_data($an, $extract_root."/*", $an->data->{path}{updates}{striker});
	
	# Clear the temp cache now that we're done.
	print "- Clearing out the old temporary directory contents (if any)...\n";
	clear_temp($an);
	
	return(0);
}

# This uses rsync to copy data
sub rsync_data
{
	my ($an, $source, $destination) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "rsync_data" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "source",      value1 => $source, 
		name2 => "destination", value2 => $destination, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $copy_count = 0;
	my $shell_call = $an->data->{path}{rsync}." -avAX $source $destination";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{debug} < 3)
	{
		print "- Progress: [";
	}
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$copy_count++;
		if ($an->data->{sys}{debug} >= 3)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif (not $copy_count % 10)
		{
			print ".";
		}
	}
	# The last four lines are a summary.
	$copy_count -= 4; 
	close $file_handle;
	if ($an->data->{sys}{debug} < 3)
	{
		print "]\n";
	}
	if ($copy_count > 1)
	{
		print "- Copied: [$copy_count] files and directories to: [$destination].\n";
	}
	else
	{
		print "- The directory: [$destination] was already up to date.\n";
	}
	
	return(0);
}

# This extracts a (compressed) tar file.
sub extract_file
{
	my ($an, $extract) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "extract_file" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "extract", value1 => $extract, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "- Extracting: [$extract]\n";
	my $shell_call = $an->data->{path}{tar}." -C ".$an->data->{path}{updates}{temp}." -xvf $extract";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if ($extract =~ /\.zip$/)
	{
		$shell_call = $an->data->{path}{unzip}." -o -d ".$an->data->{path}{updates}{temp}." $extract";
	}
	my $extract_root  = "";
	my $start_time    = time;
	my $extract_count = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{debug} < 3)
	{
		print "- Progress: [";
	}
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($an->data->{sys}{debug} >= 3)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (($line =~ / creating:/i) or ($line =~ / inflating:/) or ($line =~ / extracting:/))
		{
			$extract_count++;
			if (($an->data->{sys}{debug} < 3) && (not $extract_count % 10))
			{
				print ".";
			}
		}
		my $temp = $an->data->{path}{updates}{temp};
		if ((not $extract_root) && ($line =~ /$temp\/(.*?)\//))
		{
			$extract_root = $an->data->{path}{updates}{temp}."/".$1;
		}
	}
	close $file_handle;
	if ($an->data->{sys}{debug} < 3)
	{
		print "]\n";
	}
	my $duration = time - $start_time;
	if ($duration > 1)
	{
		print "- Extracted: [$extract_count] files and directories to: [$extract_root] in: [$duration] seconds.\n";
	}
	else
	{
		print "- Extracted: [$extract_count] files and directories to: [$extract_root].\n";
	}
	
	return($extract_root);
}

# This deletes whatever might be in the temp directory.
sub clear_temp
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "clear_temp" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if ($an->data->{path}{updates}{temp} !~ /\/temp$/)
	{
		# What?
		print "[ Error ] - There appears to be a programming error. We were about to clear out\n";
		print "[ Error ]   the temporary directory: [".$an->data->{path}{updates}{temp}."]\n";
		print "[ Error ]   which should has ended in '*/temp'. Exiting to avoid accidental\n";
		print "[ Error ]   data deletion.\n";
		exit(3);
	}
	
	my $shell_call = $an->data->{path}{rm}." -rf ".$an->data->{path}{updates}{temp}."/*";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	return(0);
}

# This tries to ping a few targets to see if we have internet access.
sub check_internet_access
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_internet_access" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Checking for Internet access...\n";
	my $pinged = 0;
	my $count  = $an->data->{sys}{ping_attempts};
	foreach my $target (split/,/, $an->data->{url}{ping_targets})
	{
		print "- Trying to ping: [$target]...\n" if $an->data->{sys}{debug} >= 1;
		my ($ping) = $an->Check->ping({ping => $target});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "ping", value1 => $ping,
		}, file => $THIS_FILE, line => __LINE__});
		if ($ping)
		{
			$pinged = 1;
			last;
		}
		if ($pinged)
		{
			print "- Success!\n" if $an->data->{sys}{debug} >= 1;
			last;
		}
		else
		{
			# No luck...
			print "- Failed.\n";
		}
	}
	
	if ($pinged)
	{
		print "- Internet access appears to be available.\n\n";
	}
	else
	{
		print "- We appear to be offline. Update will proceed with cached data, if any.\n\n";
		$an->data->{sys}{offline} = 1;
	}
	
	return(0);
}

# This creates the cache directories, if they don't already exist.
sub setup_cache
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "setup_cache" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Checking cache directories...\n";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "path::updates::rpms",    value1 => $an->data->{path}{updates}{rpms},
		name2 => "path::updates::striker", value2 => $an->data->{path}{updates}{striker},
		name3 => "path::updates::temp",    value3 => $an->data->{path}{updates}{temp},
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{updates}{rpms})
	{
		print "- RPM cache: [".$an->data->{path}{updates}{rpms}."] already exists.\n";
	}
	else
	{
		print "- Creating RPM cache: [".$an->data->{path}{updates}{rpms}."]\n";
		my $shell_call = $an->data->{path}{'mkdir'}." -p ".$an->data->{path}{updates}{rpms};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	if (-e $an->data->{path}{updates}{striker})
	{
		print "- Striker cache: [".$an->data->{path}{updates}{striker}."] already exists.\n";
	}
	else
	{
		print "- Creating Striker cache: [".$an->data->{path}{updates}{striker}."]\n";
		my $shell_call = $an->data->{path}{'mkdir'}." -p ".$an->data->{path}{updates}{striker};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	if (-e $an->data->{path}{updates}{temp})
	{
		print "- Working cache: [".$an->data->{path}{updates}{temp}."] already exists.\n";
	}
	else
	{
		print "- Creating working cache: [".$an->data->{path}{updates}{temp}."]\n";
		my $shell_call = $an->data->{path}{'mkdir'}." -p ".$an->data->{path}{updates}{temp};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	print "- Done.\n\n";
	
	return(0);
}

# This tries to determine the latest release by checking the alteeve website.
sub get_latest_version
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_latest_version" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $set        = 0;
	my $shell_call = $an->data->{path}{curl}." 2>/dev/null ".$an->data->{url}{striker_latest};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^striker:(http.*)$/)
		{
			$an->data->{url}{striker_default} = $1;
			$set                          = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "url::striker_default", value1 => $an->data->{url}{striker_default},
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /^master:(http.*)$/)
		{
			if ($an->data->{switches}{branch} eq "master")
			{
				$an->data->{url}{striker_branch} = $1;
			}
			$set                          = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "url::striker_branch", value1 => $an->data->{url}{striker_branch},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "set", value1 => $set,
	}, file => $THIS_FILE, line => __LINE__});
	if ($set)
	{
		if ($an->data->{url}{striker_default} =~ /.*\/(.*)\.zip$/)
		{
			$an->data->{sys}{install_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::install_version", value1 => $an->data->{sys}{install_version},
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{url}{striker_default} =~ /.*\/(.*)\.tar.gz$/)
		{
			$an->data->{sys}{install_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::install_version", value1 => $an->data->{sys}{install_version},
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{url}{striker_default} =~ /.*\/(.*)\.tar.bz2$/)
		{
			$an->data->{sys}{install_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::install_version", value1 => $an->data->{sys}{install_version},
			}, file => $THIS_FILE, line => __LINE__});
		}
		$an->data->{path}{tarball_dir} = "striker-".$an->data->{sys}{install_version};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::tarball_dir", value1 => $an->data->{path}{tarball_dir},
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		$an->data->{sys}{install_version} = "--";
	}
	
	return(0);
}

# This downloads the give file, if it is not already downloaded, and verifies that it is not a curl failure
# message.
sub download_file
{
	my ($an, $source, $target, $mode) = @_;
	$mode = "" if not defined $mode;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "download_file" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "source", value1 => $source, 
		name2 => "target", value2 => $target, 
		name3 => "mode",   value3 => $mode, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the file size so that we can warn the user
	my $out_file   = $target;
	my $size       = 0;
	my $shell_call = $an->data->{path}{curl}." --user-agent \"striker-update/2.0\" 2>/dev/null --head $source";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		   $line =~ s/\r//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Content-Length: (\d+)$/)
		{
			$size = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "size", value1 => $size,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# If I got a size, make it (crudely) human readable.
	my $say_size = 0;
	if ($size =~ /^\d+$/)
	{
		$say_size = $an->Readable->bytes_to_hr({'bytes' => $size});
	}
	
	my $start_time = time;
	if ($say_size)
	{
		print "- Downloading: [$source] to: [$target], which is: [$say_size]... ";
	}
	else
	{
		print "- Downloading: [$source] to: [$target]... ";
	}
	print "\n" if $an->data->{sys}{debug} >= 1;
	
	### NOTE: Do NOT use 2>&1 as this pushes the download progress into the download file. If 
	###       debug is enabled, we'll dump the progress to the screen.
	$shell_call = $an->data->{path}{curl}." --user-agent \"striker-update/2.0\" $source 2>/dev/null > $target";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	my $file_ok = 0;
	if (-e $target)
	{
		# If the file is less than 1024 bytes, read it in to make sure it is not a 
		# failure message.
		my $size = (stat($target))[7];
		print "- Downloaded file: [$target] is: [$size] bytes.\n";
		if ($size < 1024)
		{
			# Is it binary or text? If it is text, make sure it is not a failure message.
			if (not $size)
			{
				# File is empty.
				print "\n" if not $an->data->{sys}{debug};
				print "[ Error ] - Failed to download: [$target].\n";
				print "[ Error ]   The downloaded file was 0-bytes.\n";
				print "[ Error ]   Is the source: [$source] accessible?\n";
			}
			elsif (-B $target)
			{
				# Yay!
				$file_ok = 1;
				print "- Downloaded file: [$target] is binary, good.\n";
			}
			else
			{
				# Read it in.
				my $shell_call = $target;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "<$shell_call") or die __LINE__."; [ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
					if ($line =~ /Could not resolve host/i)
					{
						# Bad URL
						print "\n" if not $an->data->{sys}{debug};
						print "[ Error ] - Failed to download: [$target].\n";
						print "[ Error ]   It appears that the domain name is invalid.\n";
					}
					if ($line =~ /<title>404 Not Found<\/title>/i)
					{
						# File not found.
						print "\n" if not $an->data->{sys}{debug};
						print "[ Error ] - Failed to download: [$target].\n";
						print "[ Error ]   It appears that the file was not found on the server.\n";
					}
					if ($line =~ /<a href="(.*?)">redirected<\/a>/)
					{
						# Redirect
						my $new_source = $1;
						
						# Cleanup
						close $file_handle;
						unlink $target or die __LINE__."; [ Error ] - Failed to delete: [$target] (it is a failed download message, not the file). The error was: $!\n";
						
						# Download the new source
						print "- Redirected source: [$source]: to: [$new_source].\n";
						$out_file = download_file($an, $new_source, $target, $mode);
						return($out_file);
					}
				}
				close $file_handle;
			}
		}
		else
		{
			# Too big to be a failure, so we're probably good.
			$file_ok = 1;
			print "- Downloaded file: [$target] is large enough that analysis is not required.\n";
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "target",  value1 => $target,
		name2 => "file_ok", value2 => $file_ok,
	}, file => $THIS_FILE, line => __LINE__});
	if ($file_ok)
	{
		my $duration = time - $start_time;
		if ($duration > 1)
		{
			my $speed     = int($size / $duration);
			my $say_speed = $an->Readable->bytes_to_hr({'bytes' => $speed});
			print "- Finished! Took: [$duration] seconds to download: [$say_size] (~$say_speed/sec).\n";
		}
		else
		{
			# One second or less.
			print "- Finished! Downloaded: [$say_size].\n";
		}
	}
	else
	{
		# Sadness.
		print "\n" if not $an->data->{sys}{debug};
		print "[ Error ] - There was a problem downloading: [$source] to: [$target]\n";
		exit(20);
		if (-e $target)
		{
			# Remove the sadness
			print "[ Note ] - Failed download target: [$target] will now be removed.\n";
			unlink $target or die __LINE__."; [ Error ] - Failed to delete: [$target] (it is a failed download message, not the file). The error was: $!\n";
		}
		### NOTE: We don't die here because we *might* have usable cache. Maybe.
	}
	
	# Set the mode, if needed
	if ($mode)
	{
		chmod $mode, $target;
	}
	
	return($out_file);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $help = "
 -=] Striker Update

DESCRIPTION

This program will update the local OS, the Striker/ScanCore data and Update the
ScanCore database. Packages updated when the OS is updated will be integrated
into the loca repository. Optionally, updated RPMs on a target node can also be
integrated into the local repository.


IMPORTANT

Depending on how old your install is, this update tool might fail as it relies
on its own modules for some tasks. If that happens, run this program WITHOUT
--anvil-name or --anvil-uuid. That will cause only the local machine to be 
updated, including local modules. Once that completes, try the full upgrade
again.


NOTE

To avoid compatibility problems, the AN::Tools module is used as little as 
possible by this tool. As such, some features like translation are not 
supported, nor is logging.


NOTE

If your system has no internet connection, you can manually copy files to:

".$an->data->{path}{updates}{rpms}."
".$an->data->{path}{updates}{striker}."

Any RPMs found in the 'rpms' directory will be loaded into the local repository
prior to running the OS update. If 'striker*.zip' (striker.zip, 
striker-master.zip, etc) is found under the 'source' directory, that will be
unpacked and used to update Striker (on dashboards) and ScanCore (on all 
machines). 

You only need to pre-populate on Striker dashboards. This program will use the
local data to update nodes.


NOTE

Always do an initial run with '--gather-only'. If the local dashboard is using
a mounted ISO for the RPM repository, The gather process will convert the 
ISO-mounted repo to a normal file (and remove the ISO from /etc/fstab).


SWITCHES

 --anvil, --anvil-name {all,<anvil_name>}
 --anvil-uuid <anvil_uuid>

	This is the Anvil! name or UUID to update. When '--gather-only' is 
	specified, one of the nodes in this Anvil! will be used to download 
	updated operating system updates. The updates will NOT be installed
	when '--gather-only' is used.
	
	NOTE: Using '--anvil-name all' tells the system to update all known
	      Anvil! systems. If used with '--gather-only', an Anvil! will be
	      chosen at random to download updated RPMs from.

 --gather-only

	When called without an Anvil!, it will download and cache the latest 
	operating system updates, but NOT install them. It will also download
	the latest release of Striker (or git HEAD if '--master' is used) and
	cache that as well. 
	
	When called with an Anvil!, it will do all of the above, but then also
	download operating system updates on a node, but NOT install them, and
	copy over any updated RPMs that aren't already in the local RPM cache.
	
	In either case, the local RPM repository will be updated so that the 
	new RPMs become available to other dashboards and nodes.

 -h, -?, --help

	Show this dialogue and exit.

 --master

	This will upgrade to the latest (master branch) version available on 
	GitHub: https://github.com/ClusterLabs/striker
	
	### WARNING: This is only recommended for developers or testers. Do not
	###          upgrade to master on production systems!

 --no-os-update

	By default, the operating system will be updated on all target 
	machines. When new kernels are installed, the targets will be rebooted
	sequentially. 
	
	This increases the risks of a problem during updates.
	
	This switch disables the OS update process. When this switch is used,
	local RPM repositories will still be updated, but no new RPMs will be
	installed. Only Striker/ScanCore code will be updated.

 --no-refresh

	If this is passed, AND if the source already appears to be downloaded,
	the source code will not be downloaded again. This can be useful if you
	plan to run the download many times and worry about being throttled by
	github.

 --offline
	
	Don't try to update anything from the Internet. This will use files 
	already in:
	
	RPMS: .. ".$an->data->{path}{updates}{rpms}."
	Striker: ".$an->data->{path}{updates}{striker}."
	
	NOTE: Without this switch, a check for internet connectivity will be
	      performed. If not link is detected, the install will 
	      automatically run in offline mode.

 -y, --yes

	Auto-accepts the request to proceed.


SUPPORT

".$an->data->{url}{support}."

                                                          Alteeve's Niche! Inc.
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die __LINE__."; Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}
