#!/usr/bin/perl
# 
# This tool updates the local dashboard's OS, Striker/ScanCore software, updates the ScanCore database and
# uses cached RPMs to update its own local repository. Optionally, it can be pointed at a node and pull and
# integrate its updated RPMs into the local repository.
# 
### NOTE: The local machine needs to be updated before trying to update the other dashboard or nodes.
#
### NOTE: This program doesn't use translated strings because it is too likely that the old version won't 
#         have all the strings we need, which would cause String->get() to error out.
#         
### TODO: Make sure this throws useful errors if peer dashboards or nodes are offline.
# 
# Return Codes:
# 0  = OK
# 1  = Not run on a Striker dashboard.
# 2  = Not run as root.
# 3  = The temporary directory didn't end in /temp, indicating a program error.
# 4  = Failed to connect to the ScanCore database.
# 5  = Failed to look up the Anvil! UUID for the given name.
# 6  = Failed to look up the Anvil! name for the given uuid.
# 7  = Neither node was online or reachable.
# 8  = Failed to find the source ISO needed to populate the img/ directory.
# 9  = Failed to find the XML file used by 'createrepo' on the source ISO.
# 10 = Failed generating the RPM repository metadata.
# 11 = Failed to rsync a file from a remote machine.
# 12 = Unable to access one or more peer dashboards.
# 13 = Failed to find an active Anvil! system.
# 14 = One or more Anvil! nodes are offline.
# 15 = A node's DRBD disk state was not UpToDate.
# 16 = One node is in the cluster and the other isn't.
# 17 = Failed to match a server to a host.
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use XML::Simple;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({
	data		=> {
		copy		=>	{
			all		=>	{
				'tools/*'	=>	'/sbin/striker/',
				'ScanCore'	=>	'/sbin/striker/',
				'cgi-bin/Data' =>	'/sbin/striker/',
				'AN'		=>	'/usr/share/perl5/',
			},
			dashboard	=>	{
				'cgi-bin'	=>	'/var/www/',
				'html'		=>	'/var/www/',
			},
		},
		path		=>	{
			# Some of the paths to executables weren't defined in older versions of Tools.pm.
			createrepo	=>	"/usr/bin/createrepo",
			curl		=>	"/usr/bin/curl",
			current_dir	=>	$ENV{PWD},
			etc_fstab	=>	"/etc/fstab",
			# This file is checked to verify that we're on a Striker dashboard.
			find		=>	"/bin/find",
			img_directory	=>	"/var/www/html/#!os_type!#/x86_64/img",
			iso_directory	=>	"/var/www/html/#!os_type!#/x86_64/iso",
			mount		=>	"/bin/mount",
			# This is needed for some legacy support
			nodes		=>	{
				'anvil-safe-start' =>	"/sbin/striker/anvil-safe-start",
			},
			os_release	=>	"/etc/redhat-release",
			reboot		=>	"/sbin/reboot",
			striker		=>	"/var/www/cgi-bin/striker",
			tar		=>	"/bin/tar",
			tarball_dir	=>	"",
			unzip		=>	"/usr/bin/unzip",
			umount		=>	"/bin/umount",
			# These are appended to 'path::current_dir'
			updates		=>	{
				# If this directory exists and has RPMs in it, we'll use what is in it to 
				# update the local repository before doing the OS update. Once the update is
				# done, all downloaded RPMs will be copied into this directory
				rpms		=>	$THIS_FILE."/rpms",
				# The striker source files will be saved in this directory. If there is no
				# internet access to download the latest version, files found in here will be
				# used instead.
				striker		=>	$THIS_FILE."/source",
				# This is used to store temporary files
				temp		=>	$THIS_FILE."/temp",
			},
			yum_cache	=>	"/var/cache/yum",
		},
		url		=>	{
			# By default, we will read the latest release from 'striker_latest'. If, however, we can't
			# access that file, we'll use 'striker_default'. Optionally, the user can request the latest
			# master with '--master', in which case we will download the 'striker_master' URL. In all
			# cases, the downloaded file will be saved as 'striker_zip_file'.
			striker_default	=>	"https://github.com/ClusterLabs/striker/archive/2.0.0b-rc8.zip",
			striker_latest	=>	"https://www.alteeve.com/an-repo/striker_latest.txt",
			striker_master	=>	"https://codeload.github.com/ClusterLabs/striker/zip/master",
			support		=>	"https://alteeve.com/w/Support",
			ping_targets	=>	"8.8.8.8,google.com,redhat.com,alteeve.com",
		},
		switches	=>	{
			offline		=>	0,
			'gather-only'	=>	0,
		},
		sys		=>	{
			debug		=>	2,
			install_master	=>	0,
			install_version	=>	"",
			update		=>	1,
			offline		=>	0,
			ping_attempts	=>	3,
			reboot_needed	=>	0,
			reboot_timeout	=>	600,
			striker_zip_file =>	"striker.zip",
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{$THIS_FILE}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

print "-=] Anvil! system (Striker and ScanCore) update started.\n\n";

# Enable debugging if the user requested it.
$an->data->{sys}{debug} = 1 if $an->data->{switches}{v};
$an->data->{sys}{debug} = 2 if $an->data->{switches}{vv};
$an->data->{sys}{debug} = 3 if $an->data->{switches}{vvv};

# Is this a striker dashboard?
if (not -e $an->data->{path}{striker})
{
	print "[ Error ] - This must be run on a Striker dashboard.\n";
	exit(1);
}

# Is this running as root?
if (($< != 0) && ($> != 0))
{
	print "[ Error ] - This must be run as the root user.\n";
	exit(2);
}

# Am I to go offline?
if ($an->data->{switches}{offline})
{
	print "[ Note ] - Offline update requested. Cached data will be used.\n\n";
	$an->data->{sys}{offline} = 1;
}

# Am I to download updates only?
if ($an->data->{switches}{'gather-only'})
{
	print "[ Note ] - Updates will be downloaded and stored in cache only.\n\n";
}

# Connect to the database(s).
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
	name1 => "connections", value1 => $connections,
}, file => $THIS_FILE, line => __LINE__});
if (not $connections)
{
	print "[ Error ] - Failed to connect to the ScanCore database. Is postgres running?\n";
	exit(4);
}

# First, setup the local cache directories, if they don't already exists
setup_cache($an);

# Make sure we're actually online, unless we were told to work offline
if (not $an->data->{sys}{offline})
{
	check_internet_access($an);
}

# If we're online (still), download the striker source
if (not $an->data->{sys}{offline})
{
	### WARNING: Re-enable this and the download/extract later... We pissed off github downloading them 
	###          too often in dev.
	# Clear out any old temp files.
	#clear_temp($an);
	
	# Download the latest source
	print "Downloading latest Striker...\n";
	print "- Determining version to download...\n";
	get_latest_version($an);
	
	my $striker_source_test = $an->data->{path}{striker_cache}."/cgi-bin/striker";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "striker_source_test", value1 => $striker_source_test,
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{switches}{master})
	{
		print "- Downloading: [".$an->data->{url}{striker_master}."]\n";
		if ((-e $striker_source_test) && ($an->data->{switches}{'no-refresh'}))
		{
			print "- Skipping download, source appears to already exist and '--no-refresh' used.\n";
		}
		else
		{
			print "\n[ Warning ] - Master branch requested. This should be used by developers and\n";
			print "              testers only. Please don't use this in production!\n\n";
			$an->data->{sys}{install_master} = 1;
			sleep 3;
			download_and_extract_source($an, $an->data->{url}{striker_master});
		}
	}
	else
	{
		print "- Downloading version: [".$an->data->{sys}{install_version}."] from: [".$an->data->{url}{striker_default}."]\n";
		if ((-e $striker_source_test) && ($an->data->{switches}{'no-refresh'}))
		{
			print "- Skipping download, source appears to already exist and '--no-refresh' used.\n";
		}
		else
		{
			download_and_extract_source($an, $an->data->{url}{striker_default});
		}
	}
	print "- Done\n\n";
	
	# Download any updates to the OS.
	print "Downloading OS updates.\n";
	download_os_updates($an);
	cache_updated_rpms($an);
	
	# If I've been asked to 'gather-only' and an Anvil! name or UUID was passed, pick a node to do a 
	# 'yum -y update --downloadonly' and then pull it's updated RPMs over, too.
	if (($an->data->{switches}{'gather-only'}) && (($an->data->{switches}{'anvil-uuid'}) or ($an->data->{switches}{'anvil-name'})))
	{
		# Gather the RPMs from one of the nodes.
		gather_updated_rpms_from_anvil($an);
	}
}

# Now, update my local RPM repo (be it from 'gather-only' or using cache)
update_local_repo($an);

# If I was doing a gather-only, we're done.
if ($an->data->{switches}{'gather-only'})
{
	print "- Gathered all updates. Exiting on '--gather-only'.\n\n";
	exit(0);
}

# If I am still alive, what am I doing?
if (($an->data->{switches}{'anvil-name'}) or ($an->data->{switches}{'anvil-uuid'}))
{
	# I'm updating everything
	update_all($an);
}
else
{
	# I'm updating the local dashboard only.
	update_local($an);
}

# Warn the user if a reboot is required.
if ($an->data->{sys}{reboot_needed})
{
	print "\n[ Note ] - The kernel was updated. Please reboot this machine.\n\n";
}

exit(0);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This updates the local machine.
sub update_local
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_local" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, are we online?
	
	
	return(0);
}

# This updates a node.
sub update_all
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_all" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Copy myself and my cache to my peer dashboard(s) and run '--gather-only --offline' before starting.
	# This will not add any download bandwidth because the files will be in place already, but it will
	# handle converting ISO-based repos to file-based ones.
	print "Verifying access before starting the update process...\n";
	my $error = 0;
	
	# Check access to Striker peers.
	my $dashboards = {};
	my $peers      = $an->Get->striker_peers();
	foreach my $hash_ref (@{$peers})
	{
		# NOTE: At this time, we don't support peers using non-standard ports.
		my $peer_name     = $hash_ref->{name};
		my $peer_password = $hash_ref->{password};
		my $peer_port     = 22;
		print "- Checking access to the peer Striker: [$peer_name]\n";
		
		my $access = $an->Check->access({
			target   => $peer_name,
			port     => $peer_port, 
			password => $peer_password, 
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "access", value1 => $access,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If I can't access my peer, exit.
		if ($access)
		{
			print "- Online, good.\n";
			$dashboards->{$peer_name} = $peer_password;
		}
		else
		{
			print "[ Error ] - Offline!\n";
			$error = 1;
		}
	}
	if ($error)
	{
		print "[ Error ] - To insure compatibility, all dashboards must be updated at the same time.\n";
		exit(12);
	}
	
	# Check access to Anvil! nodes.
	my $anvils = {};
	if ($an->data->{switches}{'anvil-name'} eq "all")
	{
		my $query = "SELECT anvil_name, anvil_uuid FROM anvils WHERE anvil_note IS DISTINCT FROM 'DELETED' ORDER BY anvil_name ASC LIMIT 1;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $anvil_name = $row->[0];
			my $anvil_uuid = $row->[1];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
				name2 => "anvil_uuid", value2 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			print "- Testing access to the nodes in the Anvil! system: [$anvil_name] (UUID: [$anvil_uuid])\n";
			$anvils->{$anvil_name} = $anvil_uuid;
			$error = check_anvil($an, $anvil_uuid, $error, 1);
		}
	}
	elsif ($an->data->{switches}{'anvil-name'})
	{
		my $anvil_name = $an->data->{switches}{'anvil-name'};
		my $anvil_uuid = "";
		my $query      = "SELECT anvil_uuid FROM anvils WHERE anvil_name = ".$an->data->{sys}{use_db_fh}->quote($anvil_name).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_uuid = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_uuid", value1 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_uuid)
		{
			print "[ Error ] - Failed to find an Anvil! UUID for the name: [$anvil_name]\n";
			exit(5);
		}
		$anvils->{$anvil_name} = $anvil_uuid;
		$error = check_anvil($an, $anvil_uuid, $error, 1);
	}
	else
	{
		my $anvil_name = "";
		my $anvil_uuid = $an->data->{switches}{'anvil-uuid'};
		my $query      = "SELECT anvil_name FROM anvils WHERE anvil_uuid = ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_name = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_name)
		{
			print "[ Error ] - Failed to find an Anvil! name for the UUID: [$anvil_uuid]\n";
			exit(6);
		}
		$anvils->{$anvil_name} = $anvil_uuid;
		$error = check_anvil($an, $anvil_uuid, $error, 1);
	}
	if ($error)
	{
		print "[ Error ] - All nodes must be updated at the same time for the update to proceed.\n";
		exit(14);
	}
	
	print "- Ready to start the update process!\n\n";
	
	# Disable ScanCore on all dashboards and nodes, then go into a loop until all of them have exited.
	print "###############################################################################\n";
	print "# NOTE: ScanCore will be disabled on all dashboards and nodes. If anything\n";
	print "#       causes the upgrade process to abort unexpectedly, you may need to\n";
	print "#       manually re-enable ScanCore by running:\n";
	print "#       ".$an->data->{path}{ScanCore}." --enable\n";
	print "#       ScanCore will be re-enabled when the upgrade finishes.\n";
	print "###############################################################################\n\n";
	
	# We'll call '--disable' on the peer dashboards, then all nodes, then on ourself. The local disable 
	# will wait until ScanCore exits, then we'll go into a loop while we wait for any stragglers to exit.
	print "Upgrade will now begin.\n";
	my $shell_call = $an->data->{path}{ScanCore}." --disable";
	foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
	{
		my $password = $dashboards->{$dashboard};

		print "- Disabling ScanCore on Striker dashboard: [$dashboard]\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "dashboard",  value1 => $dashboard,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $dashboard,
			port       => 22, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
	{
		my $anvil_uuid = $anvils->{$anvil_name};
		$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "anvil_name", value1 => $anvil_name,
			name2 => "anvil_uuid", value2 => $anvil_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $node_key ("node1", "node2")
		{
			my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
			my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "node_name", value1 => $node_name,
				name2 => "node_uuid", value2 => $node_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			# I reload and rescan each loop in case I am updating two or more Anvil! systems
			print "- Disabling ScanCore on Anvil!: [$anvil_name]'s node: [$node_name]...\n";
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
			
			my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
			my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
			my $password   = $an->data->{sys}{anvil}{$node_key}{password};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Disabling the local ScanCore and waiting for it to exit...\n";
	manage_scancore($an, "disable");
	
	# Now wait for ScanCore to exit on everything.
	print "- Waiting now until ScanCore exits on all systems...\n";
	my $waiting = 1;
	while($waiting)
	{
		# This will be flipped back to '1' if any machine's ScanCore is still running.
		$waiting = 0;
		
		print "- Checking if ScanCore is running on any system...\n";
		my $shell_call = $an->data->{path}{ScanCore}." --status";
		foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
		{
			my $password = $dashboards->{$dashboard};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "dashboard",  value1 => $dashboard,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $dashboard,
				port       => 22, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /-.*?\[(\d+)\]$/)
				{
					$waiting = 1;
					print "- ScanCore is still running on the Striker dashboard: [$dashboard]\n";
				}
			}
		}
		foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
		{
			my $anvil_uuid = $anvils->{$anvil_name};
			$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
				name2 => "anvil_uuid", value2 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $node_key ("node1", "node2")
			{
				my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
				my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "node_name", value1 => $node_name,
					name2 => "node_uuid", value2 => $node_uuid,
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
				my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
				my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
				my $password   = $an->data->{sys}{anvil}{$node_key}{password};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "target",     value1 => $target,
					name2 => "port",       value2 => $port,
					name3 => "shell_call", value3 => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
					name1 => "password", value1 => $password,
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target     => $target,
					port       => $port, 
					password   => $password,
					shell_call => $shell_call,
				});
				foreach my $line (@{$return})
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
					if ($line =~ /-.*?\[(\d+)\]$/)
					{
						$waiting = 1;
						print "- ScanCore is still running on Anvil!: [$anvil_name], node: [$node_name]\n";
					}
				}
			}
		}
		
		if ($waiting)
		{
			sleep 5;
		}
	}
	print "- ScanCore is stopped now on all systems. Ready to proceed.\n\n";
	
	### Do Work Here...
# 	update_target($an, "dashboard", "local");
# 	foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
# 	{
# 		my $password = $dashboards->{$dashboard};
# 		update_target($an, "dashboard", $dashboard, 22, $password);
# 	}
	
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
	{
		my $anvil_uuid = $anvils->{$anvil_name};
		update_nodes($an, $anvil_uuid);
	}
	die;
	
	# Re-enable ScanCore now.
	print "ScanCore will now be restarted on all machines..\n";
	$shell_call = $an->data->{path}{ScanCore}." --enable";
	foreach my $dashboard (sort {$a cmp $b} keys %{$dashboards})
	{
		my $password = $dashboards->{$dashboard};

		print "- Enabling ScanCore on Striker dashboard: [$dashboard]\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "dashboard",  value1 => $dashboard,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $dashboard,
			port       => 22, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	foreach my $anvil_name (sort {$a cmp $b} keys %{$anvils})
	{
		my $anvil_uuid = $anvils->{$anvil_name};
		$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "anvil_name", value1 => $anvil_name,
			name2 => "anvil_uuid", value2 => $anvil_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $node_key ("node1", "node2")
		{
			my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
			my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "node_name", value1 => $node_name,
				name2 => "node_uuid", value2 => $node_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			# I reload and rescan each loop in case I am updating two or more Anvil! systems
			print "- Enabling ScanCore on Anvil!: [$anvil_name]'s node: [$node_name]...\n";
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
			
			my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
			my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
			my $password   = $an->data->{sys}{anvil}{$node_key}{password};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "target",     value1 => $target,
				name2 => "port",       value2 => $port,
				name3 => "shell_call", value3 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target     => $target,
				port       => $port, 
				password   => $password,
				shell_call => $shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Enabling the local ScanCore and waiting for it to exit...\n";
	manage_scancore($an, "enable");
	
	print "- Done!\n\n";
	
	return(0);
}

# This handles updating the nodes of each target Anvil!, determining the order of updates, migrating servers
# and waiting on DRBD resync.
sub update_nodes
{
	my ($an, $anvil_uuid) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_nodes" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "anvil_uuid", value1 => $anvil_uuid, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Load the details about this Anvil!
	$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
	my $anvil_name = $an->data->{sys}{anvil}{name};
	my $node1_name = $an->data->{sys}{anvil}{node1}{name};
	my $node2_name = $an->data->{sys}{anvil}{node2}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "anvil_name", value1 => $anvil_name, 
		name2 => "node1_name", value2 => $node1_name, 
		name3 => "node2_name", value3 => $node2_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "Updating Anvil!: [$anvil_name]\n";
	
	# Do a full scan of node 1 and 2.
	my $waiting = 1;
	while ($waiting)
	{
		print "- Checking if both nodes are ready to be updated at: [".$an->Get->date_and_time({split_date_time => 0})."]\n";
		my $error = check_anvil($an, $anvil_uuid, 0, 0);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "error", value1 => $error, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (not $error)
		{
			print "- Ready!\n";
			$waiting = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "waiting", value1 => $waiting, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			sleep 10;
		}
	}
	
	print "- Scanning both nodes, one moment please.\n";
	$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}});
	print "- Node 1: [$node1_name] scanned.\n";
	$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}});
	print "- Node 2: [$node2_name] scanned.\n";
	
	# Pick the first node to update. We're going to be simple about this; If both nodes have servers, 
	# we'll migrate all to node 1 and upgrade node 2. If no nodes have servers, we'll upgrade node 2.
	# If node 2 has all servers, we'll update node 1.
	print "- Picking which node to update first.\n";
	my $node1_servers    = [];
	my $node2_servers    = [];
	my $node1_short_name = $an->data->{sys}{anvil}{node1}{short_name};
	my $node2_short_name = $an->data->{sys}{anvil}{node2}{short_name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node1_short_name", value1 => $node1_short_name,
		name2 => "node2_short_name", value2 => $node2_short_name,
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $server (sort {$a cmp $b} keys %{$an->data->{server}})
	{
		# Shorten the host names because older versions would truncate long domains.
		my $this_host       =  $an->data->{server}{$server}{host};
		my $short_host_name =  $an->data->{server}{$server}{host};
		   $short_host_name =~ s/\..*$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "this_host",       value1 => $this_host,
			name2 => "short_host_name", value2 => $short_host_name,
		}, file => $THIS_FILE, line => __LINE__});
		if ($short_host_name eq $node1_short_name)
		{
			push @{$node1_servers}, $server;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "server",           value1 => $server,
				name2 => "node1_short_name", value2 => $node1_short_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($short_host_name eq $node2_short_name)
		{
			push @{$node2_servers}, $server;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "server",           value1 => $server,
				name2 => "node2_short_name", value2 => $node2_short_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# What?
			print "[ Error ] - The server: [$server] is on the node: [$short_host_name] ($this_host)\n";
			print "[ Error ]   This doesn't match either node name's short name:\n";
			print "[ Error ]   Node 1: [$node1_name] ($node1_short_name)\n";
			print "[ Error ]   Node 2: [$node2_name] ($node2_short_name)\n";
			print "[ Error ] - This is likely a program error. Exiting.\n";
			exit(17);
		}
	}
	
	my $first_target = "node2";
	my $node1_count  = @{$node1_servers};
	my $node2_count  = @{$node2_servers};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node1_count", value1 => $node1_count,
		name2 => "node2_count", value2 => $node2_count,
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $node1_count) && ($node1_count))
	{
		print "- There are no servers running on either node. Updating node 2 first.\n";
	}
	elsif (not $node2_count)
	{
		print "- There are no servers on node 2, so it will be updated first.\n";
	}
	elsif (not $node1_count)
	{
		print "- There are no servers on node 1, so it will be updated first.\n";
		$first_target = "node1";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "first_target", value1 => $first_target,
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		print "- There are servers on both nodes. We will move them to node 1 and update node 2 first.\n";
	}
	die;
=cut
	
	
	
	
	
	
	wait_for_resync($an);
	
	foreach my $node_key ("node1", "node2")
	{
		my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
		my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "node_name", value1 => $node_name,
			name2 => "node_uuid", value2 => $node_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		
		# I reload and rescan each loop in case I am updating two or more Anvil! systems
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
		
		my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
		my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
		my $password   = $an->data->{sys}{anvil}{$node_key}{password};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
=cut;
	
	
	return(0);
}

# This will loop until DRBD has resync'ed fully.
sub wait_for_resync
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "wait_for_resync" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
=cut	# I don't need this anymore.

	# We always use node 1.
	my $node1_name = $an->data->{sys}{anvil}{node1}{name};
	my $node2_name = $an->data->{sys}{anvil}{node2}{name};
	my $target     = $an->data->{sys}{anvil}{node1}{use_ip};
	my $port       = $an->data->{sys}{anvil}{node1}{use_port};
	my $password   = $an->data->{sys}{anvil}{node1}{password};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "node1_name", value1 => $node1_name, 
		name2 => "node2_name", value2 => $node2_name, 
		name3 => "target",     value3 => $target, 
		name4 => "port",       value4 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Make sure both nodes are online.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "sys::anvil::node1::online", value1 => $an->data->{sys}{anvil}{node1}{online}, 
		name2 => "sys::anvil::node2::online", value2 => $an->data->{sys}{anvil}{node2}{online}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $an->data->{sys}{anvil}{node1}{online}) or (not $an->data->{sys}{anvil}{node2}{online}))
	{
		print "- Waiting for both nodes to come online...\n";
		my $waiting = 1;
		while ($waiting)
		{
			sleep 10;
			print "- Checking if both nodes are up at: [".$an->Get->date_and_time({split_date_time => 0})."]\n";
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}, short_scan => 1});
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}, short_scan => 1});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "sys::anvil::node1::online", value1 => $an->data->{sys}{anvil}{node1}{online}, 
				name2 => "sys::anvil::node2::online", value2 => $an->data->{sys}{anvil}{node2}{online}, 
			}, file => $THIS_FILE, line => __LINE__});
			if (not $an->data->{sys}{anvil}{node1}{online})
			{
				print "- Node 1: [".$an->data->{sys}{anvil}{node1}{name}."] is not yet online.\n";
			}
			elsif (not $an->data->{sys}{anvil}{node1}{online})
			{
				print "- Node 2: [".$an->data->{sys}{anvil}{node2}{name}."] is not yet online.\n";
			}
			else
			{
				print "- Both nodes are now online. Doing a full scan and then proceeding.\n";
				$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}});
				print "- Node 1: [$node1_name] scanned.\n";
				$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}});
				print "- Node 2: [$node2_name] scanned.\n";
				$waiting = 0;
			}
		}
	}
	else
	{
		print "- Both nodes are online.\n";
	}
	
	# Both nodes are online now, so now we're going to wait for both storage services to be in the
	# 'started' state.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node::${node1_name}::me::rgmanager", value1 => $an->data->{node}{$node1_name}{me}{rgmanager}, 
		name2 => "node::${node2_name}::me::rgmanager", value2 => $an->data->{node}{$node2_name}{me}{rgmanager}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $an->data->{node}{$node1_name}{me}{rgmanager}) or (not $an->data->{node}{$node2_name}{me}{rgmanager}))
	{
		print "- Waiting for both nodes to join the Anvil! system.\n";
		my $waiting = 1;
		while ($waiting)
		{
			sleep 10;
			### NOTE: We'll do a full scan of node 1 and check it's view on things to save some 
			###       time.
			print "- Checking if both nodes cluster members at: [".$an->Get->date_and_time({split_date_time => 0})."]\n";
			$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}});
			
			# NOTE: There was a bug for a while where '$an->data->{node}{peer}{rgmanager}' was 
			#       being set instead of '$an->data->{node}{node1}{peer}{rgmanager}'. This 
			#       handles that case.
			if ((exists $an->data->{node}{peer}{rgmanager}) && (not defined $an->data->{node}{$node1_name}{peer}{rgmanager}))
			{
				$an->data->{node}{$node1_name}{peer}{rgmanager} = $an->data->{node}{peer}{rgmanager};
			}
			
			# Not check that both nodes show rgmanager as being online.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "node::${node1_name}::me::rgmanager",   value1 => $an->data->{node}{$node1_name}{me}{rgmanager}, 
				name2 => "node::${node1_name}::peer::rgmanager", value2 => $an->data->{node}{$node1_name}{peer}{rgmanager}, 
			}, file => $THIS_FILE, line => __LINE__});
			if (not $an->data->{node}{$node1_name}{me}{rgmanager})
			{
				print "- Node 1: [".$an->data->{sys}{anvil}{node1}{name}."] is not yet a member of the Anvil!.\n";
			}
			elsif (not $an->data->{node}{$node1_name}{peer}{rgmanager})
			{
				
				print "- Node 1: [".$an->data->{sys}{anvil}{node1}{name}."] is not yet a member of the Anvil!.\n";
			}
			else
			{
				print "- Both nodes are now members of the Anvil!. Doing a full scan and then proceeding.\n";
				$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}});
				print "- Node 1: [$node1_name] scanned.\n";
				$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}});
				print "- Node 2: [$node2_name] scanned.\n";
				$waiting = 0;
			}
		}
	}
	
	# Now wait for all DRBD resource to be UpToDate on both nodes.
	print "- Checking that all replicated storage resources are synchronized.\n";
	my $all_uptodate = 0;
	# The resource list is set by the config, so we don't need to worry about missing any when DRBD is
	# stopped.
	foreach my $resource (sort {$a cmp $b} keys %{$an->data->{node}{$node1_name}{drbd}{resource}})
	{
		# Make sure I have a disk state from both nodes.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "drbd::${resource}::node::${node1_name}::disk_state", value1 => $an->data->{drbd}{$resource}{node}{$node1_name}{disk_state}, 
			name2 => "drbd::${resource}::node::${node2_name}::disk_state", value2 => $an->data->{drbd}{$resource}{node}{$node2_name}{disk_state}, 
		}, file => $THIS_FILE, line => __LINE__});
		
	}
	#$an->data->{node}{$node_name}{drbd}{resource}{$resource}{eta_to_sync}
=cut
	
	return(0);
}

# This updates a dashboard, either local or remote.
sub update_target
{
	my ($an, $type, $target, $port, $password) = @_;
	$port     = 22 if not defined $port;
	$password = "" if not defined $password;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_target" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "type",   value1 => $type, 
		name2 => "target", value2 => $target, 
		name3 => "port",   value3 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Update the OS first.
	my $reboot_needed = 0;
	my $shell_call    = $an->data->{path}{yum}." -y update";
	if ($target eq "local")
	{
		# Local call. If an update is needed, we'll set 'sys::reboot_needed' and tell the user to 
		# reboot when we exit.
		print "Updating the operating system on the local machine now. Please be patient.\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		print "/-----[ Command output ]------------------------------------------------------\n";
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			print "| $line\n"; 
			
			if ($line =~ / kernel\s+x86_64 /)
			{
				# Update required.
				$an->data->{sys}{reboot_needed} = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "sys::reboot_needed", value1 => $an->data->{sys}{reboot_needed}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /Total size: /i)
			{
				print "| #############################################################################\n";
				print "| Please be patient! Packages are downloading in the background. They should\n";
				print "| download from local repos fairly quickly. Once done, they will begin\n";
				print "| installing. At times, this may seem to stall. Please be patient.\n";
				print "| You can verify the download is running with 'ps aux | grep yum'.\n";
				print "| #############################################################################\n";
			}
		}
		close $file_handle;
		print "\\-----------------------------------------------------------------------------\n";
		if ($an->data->{sys}{reboot_needed})
		{
			print "- The operating system's kernel was updated.\n";
			print "- You will need to reboot this machine when the update process completes.\n";
		}
	}
	else
	{
		# Update a remote machine. We'll reboot immediately if they need it.
		print "Updating the operating system on: [$target]. Please be patient.\n";
		print "###############################################################################\n";
		print "# NOTE: There will be no output here until the update completes. The updates\n";
		print "# should download from local repos fairly quickly. Once done, they will need\n";
		print "# a little bit of time to install. Please be patient! If you want to check if\n";
		print "# the update is still running, on: [$target], run:\n";
		print "# 'ps aux | grep yum'.\n";
		print "###############################################################################\n";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		print "/-----[ Command output ]------------------------------------------------------\n";
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			print "| $line\n";
			if ($line =~ / kernel\s+x86_64 /)
			{
				# Update required.
				$reboot_needed = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "reboot_needed", value1 => $reboot_needed, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		print "\\-----------------------------------------------------------------------------\n";
		if ($reboot_needed)
		{
			print "- The operating system's kernel was updated. A reboot will be performed shortly.\n";
		}
	}
	print "- Done.\n\n";
	
	# Copy all the files into place.
	print "Updating Striker and ScanCore files on: [$target] if needed.\n";
	
	# Build the array of packages to rsync.
	my $types = $type eq "node" ? ["all"] : ["all", "dashboard"];
	foreach my $type (@{$types})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "type", value1 => $type, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $source (sort {$a cmp $b} keys %{$an->data->{copy}{$type}})
		{
			my $source_path = $an->data->{path}{striker_cache}."/".$source;
			my $destination = $an->data->{copy}{$type}{$source};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "source",      value1 => $source, 
				name2 => "source_path", value2 => $source_path, 
				name3 => "destination", value3 => $destination, 
			}, file => $THIS_FILE, line => __LINE__});
			print "- Updating: [$destination]...\n";
			
			if ($target eq "local")
			{
				# Local call
				rsync_data($an, $source_path, $destination);
			}
			else
			{
				# Remote call
				print "  (Progress not available when updating remote targets)\n";
				my $shell_call  = $an->data->{path}{rsync}." -aAX ".$source_path." ".$destination;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "target",     value1 => $shell_call, 
					name2 => "shell_call", value2 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				my $return_code = $an->Storage->rsync({
					target      => $target,
					port        => $port, 
					password    => $password,
					source      => $source_path,
					destination => "root\@$target:$destination",
					switches    => "-aAX",
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	print "- Done.\n\n\n";
	
	my $rebooted = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "reboot_needed", value1 => $reboot_needed, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($reboot_needed)
	{
		# Send the reboot command
		($rebooted) = reboot_target($an, $target, $port, $password);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "rebooted", value1 => $rebooted, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "rebooted", value1 => $rebooted, 
	}, file => $THIS_FILE, line => __LINE__});
	return($rebooted);
}

# This reboots a target and waits for it to come back up.
sub reboot_target
{
	my ($an, $target, $port, $password) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "reboot_target" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "target", value1 => $target, 
		name2 => "port",   value2 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $rebooted   = 1;
	my $shell_call = $an->data->{path}{reboot};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		'close'    => 1,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1  => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# We need to give the system time to shut down.
	my $has_shutdown  = 0;
	my $wait_for_boot = 1;
	my $time_limit    = 60;
	my $uptime_max    = $time_limit + 60;
	my $timeout       = time + $time_limit;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "time",       value1 => time,
		name2 => "timeout",    value2 => $timeout,
		name3 => "uptime_max", value3 => $uptime_max,
	}, file => $THIS_FILE, line => __LINE__});
	while (not $has_shutdown)
	{
		# 1 == pinged, 0 == failed.
		my ($ping) = $an->Check->ping({ping => $target, count => 3});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "target", value1 => $target,
			name2 => "ping",   value2 => $ping,
		}, file => $THIS_FILE, line => __LINE__});
		if (not $ping)
		{
			# We can't ping it. Mark it as now being shut off.
			$has_shutdown = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "has_shutdown", value1 => $has_shutdown,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# We can ping it. Log in and see if the uptime is short. Failure to log in will cause
			# the uptime to return '0'.
			my $uptime = $an->System->get_uptime({
					target   => $target,
					port     => $port, 
					password => $password,
				});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "uptime",     value1 => $uptime, 
				name2 => "uptime_max", value2 => $uptime_max, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($uptime) && ($uptime < $uptime_max))
			{
				# We rebooted and missed it.
				$has_shutdown  = 1;
				$wait_for_boot = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "has_shutdown",  value1 => $has_shutdown, 
					name2 => "wait_for_boot", value2 => $wait_for_boot, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# If we've waited passed the timeout and the system hasn't shut down, give up.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "time",    value1 => time,
			name2 => "timeout", value2 => $timeout,
		}, file => $THIS_FILE, line => __LINE__});
		if (time > $timeout)
		{
			$rebooted      = 0;
			$wait_for_boot = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "rebooted",      value1 => $rebooted,
				name2 => "wait_for_boot", value2 => $wait_for_boot, 
			}, file => $THIS_FILE, line => __LINE__});
			last;
		}
		sleep 3;
	}
	
	# Now loop for 'sys::reboot_timeout' seconds waiting to see if the node recovers.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "wait_for_boot", value1 => $wait_for_boot,
	}, file => $THIS_FILE, line => __LINE__});
	if ($wait_for_boot)
	{
		my $give_up_time = time + $an->data->{sys}{reboot_timeout};
		my $wait         = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "time",      value1 => time,
			name2 => "give_up_time", value2 => $give_up_time,
		}, file => $THIS_FILE, line => __LINE__});
		while ($wait)
		{
			my $time      = time;
			my $will_wait = ($give_up_time - $time);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "will_wait", value1 => $will_wait,
			}, file => $THIS_FILE, line => __LINE__});
			if ($time > $give_up_time)
			{
				# Failed to come back up.
				$rebooted = 0;
				last;
			}
			
			# Try to access
			my ($access) = $an->Check->access({
					target   => $target, 
					port     => $port,
					password => $password,
				});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "access", value1 => $access, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($access)
			{
				# We're in!
				$wait = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "wait", value1 => $wait, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			sleep 3;
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "rebooted", value1 => $rebooted, 
	}, file => $THIS_FILE, line => __LINE__});
	return($rebooted);
}

# This checks access to the nodes in the Anvil! and that they're ready to be updated.
sub check_anvil
{
	my ($an, $anvil_uuid, $error, $fatal) = @_;
	$error = 0 if not defined $error;
	$fatal = 1 if not defined $fatal;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_anvil" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "anvil_uuid", value1 => $anvil_uuid, 
		name2 => "error",      value2 => $error, 
		name3 => "fatal",      value3 => $fatal, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the node info
	$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
	
	my $use_node = "";
	foreach my $node_key ("node1", "node2")
	{
		my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
		my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
		print "- Doing a quick scan of: [$node_name] (UUID: [$node_uuid])]\n";
		
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
		if ($an->data->{sys}{anvil}{$node_key}{online})
		{
			print "- Online, good.\n";
			check_cluster_and_storage($an, $node_key);
		}
		else
		{
			print "[ Error ] - Offline!\n";
			$error = 1;
		}
	}
	if (not $error)
	{
		$error = validate_cluster_and_storage($an, 0);
	}
	
	return($error);
}

# This will throw an error if only one node is in the cluster or if a DRBD disk state is not UpToDate.
sub validate_cluster_and_storage
{
	my ($an, $fatal) = @_;
	$fatal = 1 if not defined $fatal;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "validate_cluster_and_storage" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "fatal", value1 => $fatal, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If both are running rgmanager, make sure we're UpToDate.
	my $error = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "sys::anvil::node1::in_cluster", value1 => $an->data->{sys}{anvil}{node1}{in_cluster},
		name2 => "sys::anvil::node2::in_cluster", value2 => $an->data->{sys}{anvil}{node2}{in_cluster},
	}, file => $THIS_FILE, line => __LINE__});
	if (($an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster}))
	{
		# Both nodes are online. Did we see any resources that we're UpToDate?
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::anvil::node1::all_uptodate", value1 => $an->data->{sys}{anvil}{node1}{all_uptodate},
			name2 => "sys::anvil::node2::all_uptodate", value2 => $an->data->{sys}{anvil}{node2}{all_uptodate},
		}, file => $THIS_FILE, line => __LINE__});
		if ((not $an->data->{sys}{anvil}{node1}{all_uptodate}) or (not $an->data->{sys}{anvil}{node2}{all_uptodate}))
		{
			if ($fatal)
			{
				print "[ Error ] - The upgrade process requires taking each node out of the cluster,\n";
				print "[ Error ]   one at a time. To do this, both nodes have to have up to date \n";
				print "[ Error ]   storage. Please watch the Striker web interface for the replicated\n";
				print "[ Error ]   Storage's 'Disk State' to be 'UpToDate/UpToDate' on both nodes, \n";
				print "[ Error ]   then try again.\n";
				exit(15);
			}
			else
			{
				$error = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "error", value1 => $error,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	elsif ((($an->data->{sys}{anvil}{node1}{in_cluster}) && (not $an->data->{sys}{anvil}{node2}{in_cluster})) or 
	       ((not $an->data->{sys}{anvil}{node1}{in_cluster}) && ($an->data->{sys}{anvil}{node2}{in_cluster})))
	{
		# One node is in the cluster and the other isn't.
		if ($fatal)
		{
			print "[ Error ] - Only one node is in the cluster. Either both nodes must be in the cluster\n";
			print "[ Error ]   neither can be. If one node is up, we'll need to be able to move any\n";
			print "[ Error ]   servers it is hosting to withdraw and update it.\n";
			exit(16);
		}
		else
		{
			$error = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "error", value1 => $error,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "error", value1 => $error,
	}, file => $THIS_FILE, line => __LINE__});
	return($error);
}

# This checks to see if rgmanager is running and, if so, if DRBD is UpToDate.
sub check_cluster_and_storage
{
	my ($an, $node_key) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_cluster_and_storage" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "node_key", value1 => $node_key, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# To update, either both nodes have to be in the Anvil!, or neither can be. If both are, DRBD must be
	# UpToDate/UpToDate.
	$an->data->{sys}{anvil}{$node_key}{in_cluster}   = 0;
	$an->data->{sys}{anvil}{$node_key}{all_uptodate} = 1;
	
	# Check rgmanager
	my $target     = $an->data->{sys}{anvil}{$node_key}{use_ip};
	my $port       = $an->data->{sys}{anvil}{$node_key}{use_port};
	my $password   = $an->data->{sys}{anvil}{$node_key}{password};
	my $shell_call = $an->data->{path}{clustat}." -x";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		# We're looking at rgmanager, specifically
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if (($line =~ /<node /) && ($line =~ /local="1"/) && ($line =~ /rgmanager="(\d+)"/))
		{
			$an->data->{sys}{anvil}{$node_key}{in_cluster} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::anvil::${node_key}::in_cluster", value1 => $an->data->{sys}{anvil}{$node_key}{in_cluster},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Check drbd
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil::${node_key}::in_cluster", value1 => $an->data->{sys}{anvil}{$node_key}{in_cluster},
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{anvil}{$node_key}{in_cluster})
	{
		my $shell_call = $an->data->{path}{cat}." ".$an->data->{path}{proc_drbd};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "target",     value1 => $target,
			name2 => "port",       value2 => $port,
			name3 => "shell_call", value3 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target     => $target,
			port       => $port, 
			password   => $password,
			shell_call => $shell_call,
		});
		foreach my $line (@{$return})
		{
			# We're looking at rgmanager, specifically
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ / ds:(.*?)\/(.*?) /)
			{
				my $local_disk_state = $1;
				my $peer_disk_state  = $2;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "local_disk_state", value1 => $local_disk_state,
					name2 => "peer_disk_state",  value2 => $peer_disk_state,
				}, file => $THIS_FILE, line => __LINE__});
				if (($local_disk_state ne "UpToDate") or ($peer_disk_state ne "UpToDate"))
				{
					$an->data->{sys}{anvil}{$node_key}{all_uptodate} = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "sys::anvil::${node_key}::all_uptodate", value1 => $an->data->{sys}{anvil}{$node_key}{all_uptodate},
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
	}
	
	return(0);
}

# This calls 'yum -y update --downloadonly' on one of the Anvil! nodes
sub gather_updated_rpms_from_anvil
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "gather_updated_rpms_from_anvil" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Downloading updated RPMs for Anvil! nodes...\n";
	
	# If I have a UUID, look up the name. If I have a name, look up the UUID.
	my $anvil_uuid = "";
	my $anvil_name = "";
	if ($an->data->{switches}{'anvil-name'} eq "all")
	{
		my $query = "SELECT anvil_name, anvil_uuid FROM anvils WHERE anvil_note IS DISTINCT FROM 'DELETED' ORDER BY anvil_name ASC LIMIT 1;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_name = $row->[0];
			$anvil_uuid = $row->[1];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
				name2 => "anvil_uuid", value2 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_name)
		{
			print "[ Error ] - Failed to find an available Anvil! to work on.\n";
			exit(13);
		}
	}
	elsif ($an->data->{switches}{'anvil-name'})
	{
		   $anvil_name = $an->data->{switches}{'anvil-name'};
		my $query      = "SELECT anvil_uuid FROM anvils WHERE anvil_name = ".$an->data->{sys}{use_db_fh}->quote($anvil_name).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_uuid = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_uuid", value1 => $anvil_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_uuid)
		{
			print "[ Error ] - Failed to find an Anvil! UUID for the name: [$anvil_name]\n";
			exit(5);
		}
	}
	else
	{
		   $anvil_uuid = $an->data->{switches}{'anvil-uuid'};
		my $query      = "SELECT anvil_name FROM anvils WHERE anvil_uuid = ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$anvil_name = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if (not $anvil_name)
		{
			print "[ Error ] - Failed to find an Anvil! name for the UUID: [$anvil_uuid]\n";
			exit(6);
		}
	}
	
	# If I am still alive, we've got a good Anvil!.
	print "- Picking a node in the Anvil!: [$anvil_name] (UUID: [$anvil_uuid])\n";
	$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
	
	my $use_node = "";
	foreach my $node_key ("node1", "node2")
	{
		my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
		my $node_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
		print "- Doing a quick scan of: [$node_name] (UUID: [$node_uuid])]\n";
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{$node_key}{uuid}, short_scan => 1});
		if ($an->data->{sys}{anvil}{$node_key}{online})
		{
			print "- The node is online.\n";
			$use_node = $node_key if not $use_node;
		}
		else
		{
			print "- The node appears to be offline or unreachable.\n";
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "use_node", value1 => $use_node,
	}, file => $THIS_FILE, line => __LINE__});
	if (not $use_node)
	{
		print "[ Error ] - Neither node is online or reachable. Unable to proceed.\n";
		exit(7);
	}
	
	# Update our local repo
	update_local_repo($an);
	
	# I'm not installing updates, so it doesn't matter which node I use.
	my $target     = $an->data->{sys}{anvil}{$use_node}{use_ip};
	my $port       = $an->data->{sys}{anvil}{$use_node}{use_port};
	my $password   = $an->data->{sys}{anvil}{$use_node}{password};
	my $shell_call = $an->data->{path}{yum}." clean expire-cache";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	
	print "- Clearing old RPM cache on: [$target]\n";
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	print "/-----[ Command output ]------------------------------------------------------\n";
	foreach my $line (@{$return})
	{
		print "| $line\n";
	}
	print "\\-----------------------------------------------------------------------------\n";
	undef $return;
	
	# Download updates now
	print "- Downloading, NOT installing, updated RPMs on: [$target]...\n";
	$shell_call = $an->data->{path}{yum}." -y update --downloadonly";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	print "\n###############################################################################\n";
	print "# There will be no output here until the remote call completes. If you think\n";
	print "# there is a problem, run 'ps aux | grep yum' on: [$target].\n";
	print "# If you see '... /usr/bin/python /usr/bin/yum -y update --downloadonly', \n";
	print "# please keep waiting.\n";
	print "###############################################################################\n";
	print "/-----[ Command output ]------------------------------------------------------\n";
	foreach my $line (@{$return})
	{
		print "| $line\n";
	}
	print "\\-----------------------------------------------------------------------------\n";
	undef $return;
	
	# Now build a list of RPMs to rsync over to our cache. 
	my $rpm_files  = [];
	   $shell_call = $an->data->{path}{find}." ".$an->data->{path}{yum_cache};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "target",     value1 => $target,
		name2 => "port",       value2 => $port,
		name3 => "shell_call", value3 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password,
	}, file => $THIS_FILE, line => __LINE__});
	($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target     => $target,
		port       => $port, 
		password   => $password,
		shell_call => $shell_call,
	});
	foreach my $line (@{$return})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^(\/.*?\.rpm)$/)
		{
			my $rpm = $1;
			push @{$rpm_files}, $rpm;
		}
	}
	
	print "- Copying over any RPMs from the node that aren't in our cache.\n";
	my $remote_copy_count = 0;
	foreach my $rpm_file (sort {$a cmp $b} @{$rpm_files})
	{
		my $file_name   = ($rpm_file =~ /^.*\/(.*)$/)[0];
		my $target_file = $an->data->{path}{rpm_cache}."/".$file_name;
		next if -e $target_file;
		$remote_copy_count++;
		
		# 0 = OK, 1 = Failed
		print "- Caching: [$target:$rpm_file]\n";
		my $return_code = $an->Storage->rsync({
			target      => $target,
			port        => $port, 
			password    => $password,
			source      => "root\@$target:$rpm_file",
			destination => $an->data->{path}{rpm_cache},
			switches    => "-a",
		});
		if ($return_code)
		{
			print "[ Error ] - Failed. Details of the failure may be in: [".$an->data->{path}{log_file}."]\n";
			exit(11);
		}
	}
	if ($remote_copy_count)
	{
		print "- Done.\n";
	}
	else
	{
		print "- No files needed to be copied. Done.\n";
	}
	
	return(0);
}

# This copies any RPMs from the local rpm cache to the repo directory and then rebuilds the repodata.
sub update_local_repo
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_local_repo" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $os_type = get_os_type($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "os_type",             value1 => $os_type,
		name2 => "path::img_directory", value2 => $an->data->{path}{img_directory},
		name3 => "path::iso_directory", value3 => $an->data->{path}{iso_directory},
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{path}{img_directory} =~ s/#!os_type!#/${os_type}6/;
	$an->data->{path}{iso_directory} =~ s/#!os_type!#/${os_type}6/;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "path::img_directory", value1 => $an->data->{path}{img_directory},
		name2 => "path::iso_directory", value2 => $an->data->{path}{iso_directory},
	}, file => $THIS_FILE, line => __LINE__});

	# Now, if this is a repo using a mounted ISO, we will need to convert it to standard files.
	convert_iso_to_files($an);
	
	# Copy cached RPMs to the RPM repo
	print "- Copying new RPMs to the RPM repository.\n";
	my $packages_dir = $an->data->{path}{img_directory}."/Packages";
	rsync_data($an, $an->data->{path}{rpm_cache}."/*", $packages_dir);
	
	# Copy over any of our RPMs from cache to the repo source.
	my ($xml_file1, $xml_file2) = get_repodata_xml_file_name($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "xml_file1", value1 => $xml_file1,
		name2 => "xml_file2", value2 => $xml_file2,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Rebuild the repo.
	update_repo_metadata($an, $xml_file1, $xml_file2);
	
	return(0);
}

# This updates the RPM repo metadata
sub update_repo_metadata
{
	my ($an, $xml_file1, $xml_file2) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_repo_metadata" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "xml_file1", value1 => $xml_file1, 
		name2 => "xml_file2", value2 => $xml_file2, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "- Regenerating the RPM repository meta-data.\n";
	print "- [ NOTE ] - Please be patient, this might take a minute.\n";
	my $shell_call = $an->data->{path}{createrepo}." -g ".$xml_file1." ".$an->data->{path}{img_directory};
	if ($xml_file2)
	{
		$shell_call = $an->data->{path}{createrepo}." -g ".$xml_file1." -g ".$xml_file2." ".$an->data->{path}{img_directory};
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	print "/-----[ Command output ]------------------------------------------------------\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		print "| $line\n";
		
		if ($line =~ /Error opening Package/)
		{
			print "
[ Error ] - There was an error when generating the 'Packages' repository data.
[ Error ]   It is possible some downloaded or copied 'RPM' package files are 
[ Error ]   corrupt. Check that your Internet connection is working. If the 
[ Error ]   error is not obvious, re-run this with '-vv' or '-vvv' for 
[ Error ]   debugging output.
";
			exit(10);
		}
	}
	close $file_handle;
	print "\\-----------------------------------------------------------------------------\n";
	
	return(0);
}

# This returns the XML files containing install groups.
sub get_repodata_xml_file_name
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_repodata_xml_file_name" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $xml_file1 = "";
	my $xml_file2 = "";
	my $source   = $an->data->{path}{img_directory}."/repodata";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "source", value1 => $source,
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $source)
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "source", value1 => $source,
		}, file => $THIS_FILE, line => __LINE__});
		local(*DIR);
		opendir(DIR, $source) or die __LINE__."; Failed to open the directory: [$source], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			my $full_path = $source."/".$file;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "full_path", value1 => $full_path,
			}, file => $THIS_FILE, line => __LINE__});
			
			#rm -f repodata/*.gz repodata/*.*.bz2 repodata/*.repomd.xml
			if ($file =~ /Server\.x86_64\.xml$/)
			{
				$xml_file2 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file2", value1 => $xml_file2,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($file =~ /c6-x86_64-comps\.xml$/)
			{
				$xml_file2 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file2", value1 => $xml_file2,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif (($file =~ /\.gz$/) or ($file =~ /\.bz2$/) or ($file =~ /\.repomd\.xml$/))
			{
				# Delete
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "full_path", value1 => $full_path,
				}, file => $THIS_FILE, line => __LINE__});
				unlink $full_path or die __LINE__."; [ Error ] - Failed to delete old 'repodata' file: [$full_path]. The error was: $!\n";
			}
			elsif ($file =~ /comps\.xml$/)
			{
				$xml_file1 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file1", value1 => $xml_file1,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($file =~ /repomd\.xml$/)
			{
				$xml_file1 = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "xml_file1", value1 => $xml_file1,
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Ignore
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "full_path", value1 => $full_path,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		closedir(DIR);
	}
	
	if (not $xml_file1)
	{
		print "[ Error ] - Failed to find the XML file used by 'createrepo' on the source ISO.\n";
		exit(9);
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "xml_file1", value1 => $xml_file1,
		name2 => "xml_file2", value2 => $xml_file2,
	}, file => $THIS_FILE, line => __LINE__});
	return($xml_file1, $xml_file2);
}

# This looks to see if the local repo is using an ISO and, if so, converts it to plain files before 
# rebuilding the local repo
sub convert_iso_to_files
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "convert_iso_to_files" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# See if there is an ISO definied in fstab.
	my $img_directory = $an->data->{path}{img_directory};
	my $iso_directory = $an->data->{path}{iso_directory};
	my $update_fstab  = "";
	my $fstab_data_ok = 0;
	my $new_fstab     = "";
	my $shell_call    = $an->data->{path}{etc_fstab};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or die __LINE__."; [ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^(\/var\/www\/.*?)\s+$img_directory\s/i)
		{
			my $source_iso   = $1;
			   $update_fstab = 1;
			print "- This system used the ISO: [$source_iso] for the local repo.\n";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "update_fstab", value1 => $update_fstab,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			$new_fstab .= $line."\n";
			if ($line =~ /UUID=.*?\s+\/\s/)
			{
				# Good fstab data.
				$fstab_data_ok = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "fstab_data_ok", value1 => $fstab_data_ok,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "new_fstab",     value1 => $new_fstab,
		name2 => "fstab_data_ok", value2 => $fstab_data_ok,
		name3 => "update_fstab",  value3 => $update_fstab,
	}, file => $THIS_FILE, line => __LINE__});
	if (($new_fstab) && ($fstab_data_ok) && ($update_fstab))
	{
		# Make a backup.
		my $backup_file = $an->data->{path}{etc_fstab}.".$THIS_FILE";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "backup_file", value1 => $backup_file,
		}, file => $THIS_FILE, line => __LINE__});
		if (not -e $backup_file)
		{
			print "- Backing up original fstab file to: [$backup_file]\n";
			my $shell_call = $an->data->{path}{rsync}." -aAX ".$an->data->{path}{etc_fstab}." $backup_file";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		else
		{
			print "- Backup of fstab already exists: [$backup_file]\n";
		}
		
		# Write out the new fstab
		print "- Writing out new 'fstab' file.\n";
		my $shell_call = $an->data->{path}{etc_fstab};
		open (my $file_handle, ">$shell_call") or die "Failed to write to: [$shell_call], error was: $!\n";
		print $file_handle $new_fstab;
		close $file_handle;
	}
	
	# Now, is the ISO mounted? If it is, unmount it. We'll remount it later, if needed.
	my $unmount    = 0;
	   $shell_call = $an->data->{path}{df}." -hP";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /\s$img_directory$/i)
		{
			$unmount = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "unmount", value1 => $unmount,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "unmount", value1 => $unmount,
	}, file => $THIS_FILE, line => __LINE__});
	if ($unmount)
	{
		# Unmount it.
		my $shell_call = $an->data->{path}{umount}." $img_directory";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		print "- Unmounted: [$img_directory]\n";
	}
	
	# Now, do I have data in the img directory?
	my $packages_directory = $img_directory."/Packages";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "packages_directory", value1 => $packages_directory,
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $packages_directory)
	{
		print "- The RPM repo source appears to be ready to receive updates.\n";
	}
	else
	{
		# The packages directory doesn't exist, so we need to mount the old ISO and copy the 
		# contents.
		print "- The packages directory: [$packages_directory] doesn't exist.\n";
		my $temporary_mount = "/tmp/".time;
		
		mkdir $temporary_mount or die "[ Error ] - Failed to create the directory: [$temporary_mount]. Error was: $!\n";
		
		# What's the ISO file and path?
		my $iso_file   = "";
		my $shell_call = $an->data->{path}{ls}." $iso_directory";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /\.iso$/i)
			{
				# Found the ISO
				$iso_file = $iso_directory."/".$line;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "iso_file", value1 => $iso_file,
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		close $file_handle;
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "iso_file", value1 => $iso_file,
		}, file => $THIS_FILE, line => __LINE__});
		if (not $iso_file)
		{
			print "[ Error ] - Failed to find the original Anvil! ISO, and the img directory: [$img_directory] is empty, so we can't rebuild the RPM repo.\n";
			exit(8);
		}
		else
		{
			print "- Temporarily mounting the original ISO: [$iso_file] at: [$temporary_mount]\n";
			my $shell_call = $an->data->{path}{mount}." -o loop $iso_file $temporary_mount";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			my $source_check = $temporary_mount."/Packages";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "source_check", value1 => $source_check,
			}, file => $THIS_FILE, line => __LINE__});
			if (-e $source_check)
			{
				print "- Mounted successfully. Copying source to: [$img_directory]";
				rsync_data($an, $temporary_mount."/*", $img_directory);
			}
			
			print "- Done, unmounting ISO.\n";
			$shell_call = $an->data->{path}{umount}." $temporary_mount";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open ($file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			rmdir $temporary_mount or die "[ Error ] - Failed to remove the directory: [$temporary_mount]. Error was: $!\n";
		}
	}
	
	return(0);
}

# This returns either 'rhel' or 'centos', depending on the contents of 'path::os_release'.
sub get_os_type
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_os_type" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $os_type    = "";
	my $shell_call = $an->data->{path}{'os_release'};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or die __LINE__."; [ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Red Hat Enterprise Linux Server/i)
		{
			$os_type = "rhel";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "os_type", value1 => $os_type,
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /CentOS/i)
		{
			$os_type = "centos";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "os_type", value1 => $os_type,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	return($os_type);
}

# This walks through the yum cache and copies any found RPMs to 'path::rpm_cache'.
sub cache_updated_rpms
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "cache_updated_rpms" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "- Caching updated RPMs...\n";
	my $rpm_files  = [];
	my $shell_call = $an->data->{path}{find}." ".$an->data->{path}{yum_cache};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^(\/.*?\.rpm)$/)
		{
			my $rpm = $1;
			push @{$rpm_files}, $rpm;
		}
	}
	close $file_handle;
	
	foreach my $rpm_file (sort {$a cmp $b} @{$rpm_files})
	{
		my $file_name   = ($rpm_file =~ /^.*\/(.*)$/)[0];
		my $target_file = $an->data->{path}{rpm_cache}."/".$file_name;
		next if -e $target_file;
		print "- Caching: [$rpm_file]\n";
		my $shell_call = $an->data->{path}{rsync}." -a $rpm_file ".$an->data->{path}{rpm_cache}."/";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	print "- Done. RPMs are now stored in: [".$an->data->{path}{rpm_cache}."/]\n";
	
	return(0);
}

# This downloads updated RPMs for the local OS. It does NOT install them.
sub download_os_updates
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "download_os_updates" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{yum}." -y update --downloadonly";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	print "/-----[ Command output ]------------------------------------------------------\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "| $line\n";
		if ($line =~ /Downloading Packages/i)
		{
			print "| ################################################################\n";
			print "| Please be patient! Packages are downloading in the background.\n";
			print "| You can verify the download is running with 'ps aux | grep yum'.\n";
			print "| ################################################################\n";
		}
	}
	close $file_handle;
	print "\\-----------------------------------------------------------------------------\n";
	
	return(0);
}

# This disabled or enables ScanCore. When disabling, it waits until it exits before returning.
sub manage_scancore
{
	my ($an, $task) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "manage_scancore" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "task", value1 => $task, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($task eq "disable")
	{
		print "- Disabling ScanCore...\n";
		my $waiting    = 1;
		my $shell_call = $an->data->{path}{ScanCore}." --disable";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Now wait for it to exit
		print "- Disabled. Waiting now for it to exit: ";
		while($waiting)
		{
			my $pid_seen   = 0;
			my $shell_call = $an->data->{path}{ScanCore}." --status";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				# NOTE: Don't parse the string text, it could be in whatever language.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /-.*?\[(\d+)\]$/)
				{
					$pid_seen = 1;
				}
			}
			close $file_handle;
			
			if ($pid_seen)
			{
				if ($an->data->{sys}{debug} >= 3)
				{
					print "- Still running, will check again momentarily.\n";
				}
				else
				{
					print ".";
				}
				sleep 5;
			}
			else
			{
				if ($an->data->{sys}{debug} >= 3)
				{
					print "- It has exited.\n";
				}
				else
				{
					print " Done.\n";
				}
				$waiting = 0;
			}
		}
	}
	else
	{
		# Enable it
		print "- Enabling ScanCore...\n";
		my $waiting    = 1;
		my $shell_call = $an->data->{path}{ScanCore}." --enable";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		print "- Done.\n";
	}
	
	return(0);
}

# This downloads and extracts the Striker source
sub download_and_extract_source
{
	my ($an, $url) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "download_and_extract_source" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "url", value1 => $url, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Download the URL to path::temp_cache.
	my $out_file = $an->data->{path}{temp_cache}."/".$an->data->{sys}{striker_zip_file};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "url",      value1 => $url,
		name2 => "out_file", value2 => $out_file,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Extract the source
	   $out_file     = download_file($an, $url, $out_file, 0644);
	my $extract_root = extract_file($an, $out_file);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "extract_root", value1 => $extract_root,
	}, file => $THIS_FILE, line => __LINE__});
	if (not $extract_root)
	{
		# Failed to download
		return(0);
	}
	
	# Move the source from temp.
	rsync_data($an, $extract_root."/*", $an->data->{path}{striker_cache});
	
	# Clear the temp cache now that we're done.
	clear_temp($an);
	
	return(0);
}

# This uses rsync to copy data
sub rsync_data
{
	my ($an, $source, $destination) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "rsync_data" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "source",      value1 => $source, 
		name2 => "destination", value2 => $destination, 
	}, file => $THIS_FILE, line => __LINE__});
	
	#rsync -av striker-update/temp/striker-2.0.0b-rc8/* striker-update/source
	my $copy_count = 0;
	my $shell_call = $an->data->{path}{rsync}." -avAX $source $destination";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{debug} < 3)
	{
		print "- Progress: [";
	}
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$copy_count++;
		if ($an->data->{sys}{debug} >= 3)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif (not $copy_count % 10)
		{
			print ".";
		}
	}
	# The last four lines are a summary.
	$copy_count -= 4; 
	close $file_handle;
	if ($an->data->{sys}{debug} < 3)
	{
		print "]\n";
	}
	if ($copy_count > 1)
	{
		print "- Copied: [$copy_count] files and directories to: [$destination].\n";
	}
	else
	{
		print "- The directory: [$destination] was already up to date.\n";
	}
	
	return(0);
}

# This extracts a (compressed) tar file.
sub extract_file
{
	my ($an, $extract) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "extract_file" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "extract", value1 => $extract, 
	}, file => $THIS_FILE, line => __LINE__});
	
	print "- Extracting: [$extract]\n";
	my $shell_call = $an->data->{path}{tar}." -C ".$an->data->{path}{temp_cache}." -xvf $extract";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if ($extract =~ /\.zip$/)
	{
		$shell_call = $an->data->{path}{unzip}." -o -d ".$an->data->{path}{temp_cache}." $extract";
	}
	my $extract_root  = "";
	my $start_time    = time;
	my $extract_count = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{debug} < 3)
	{
		print "- Progress: [";
	}
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($an->data->{sys}{debug} >= 3)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (($line =~ / creating:/i) or ($line =~ / inflating:/) or ($line =~ / extracting:/))
		{
			$extract_count++;
			if (($an->data->{sys}{debug} < 3) && (not $extract_count % 10))
			{
				print ".";
			}
		}
		my $temp = $an->data->{path}{temp_cache};
		if ((not $extract_root) && ($line =~ /$temp\/(.*?)\//))
		{
			$extract_root = $an->data->{path}{temp_cache}."/".$1;
		}
	}
	close $file_handle;
	if ($an->data->{sys}{debug} < 3)
	{
		print "]\n";
	}
	my $duration = time - $start_time;
	if ($duration > 1)
	{
		print "- Extracted: [$extract_count] files and directories to: [$extract_root] in: [$duration] seconds.\n";
	}
	else
	{
		print "- Extracted: [$extract_count] files and directories to: [$extract_root].\n";
	}
	
	return($extract_root);
}

# This deletes whatever might be in the temp directory.
sub clear_temp
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "clear_temp" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if ($an->data->{path}{temp_cache} !~ /\/temp$/)
	{
		# What?
		print "[ Error ] - There appears to be a programming error. We were about to clear out\n";
		print "[ Error ]   the temporary directory: [".$an->data->{path}{temp_cache}."]\n";
		print "[ Error ]   which should has ended in '*/temp'. Exiting to avoid accidental\n";
		print "[ Error ]   data deletion.\n";
		exit(3);
	}
	
	print "Clearing out the old temporary directory contents (if any)...\n";
	my $shell_call = $an->data->{path}{rm}." -rf ".$an->data->{path}{temp_cache}."/*";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	print "- Done.\n\n";
	
	return(0);
}

# This tries to ping a few targets to see if we have internet access.
sub check_internet_access
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_internet_access" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Checking for Internet access...\n";
	my $pinged = 0;
	my $count  = $an->data->{sys}{ping_attempts};
	foreach my $target (split/,/, $an->data->{url}{ping_targets})
	{
		print "- Trying to ping: [$target]...\n" if $an->data->{sys}{debug} >= 1;
		my ($ping) = $an->Check->ping({ping => $target});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "ping", value1 => $ping,
		}, file => $THIS_FILE, line => __LINE__});
		if ($ping)
		{
			$pinged = 1;
			last;
		}
		if ($pinged)
		{
			print "- Success!\n" if $an->data->{sys}{debug} >= 1;
			last;
		}
		else
		{
			# No luck...
			print "- Failed.\n";
		}
	}
	
	if ($pinged)
	{
		print "- Internet access appears to be available.\n\n";
	}
	else
	{
		print "- We appear to be offline. Update will proceed with cached data, if any.\n\n";
		$an->data->{sys}{offline} = 1;
	}
	
	return(0);
}

# This creates the cache directories, if they don't already exist.
sub setup_cache
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "setup_cache" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print "Checking cache directories...\n";
	$an->data->{path}{rpm_cache}     = $an->data->{path}{current_dir}."/".$an->data->{path}{updates}{rpms};
	$an->data->{path}{striker_cache} = $an->data->{path}{current_dir}."/".$an->data->{path}{updates}{striker};
	$an->data->{path}{temp_cache}    = $an->data->{path}{current_dir}."/".$an->data->{path}{updates}{temp};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "path::current_dir",   value1 => $an->data->{path}{current_dir},
		name2 => "path::rpm_cache",     value2 => $an->data->{path}{rpm_cache},
		name3 => "path::striker_cache", value3 => $an->data->{path}{striker_cache},
		name4 => "path::temp_cache",    value4 => $an->data->{path}{temp_cache},
	}, file => $THIS_FILE, line => __LINE__});
	
	if (-e $an->data->{path}{rpm_cache})
	{
		print "- RPM cache: [".$an->data->{path}{rpm_cache}."] already exists.\n";
	}
	else
	{
		print "- Creating RPM cache: [".$an->data->{path}{rpm_cache}."]\n";
		my $shell_call = $an->data->{path}{'mkdir'}." -p ".$an->data->{path}{rpm_cache};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	if (-e $an->data->{path}{striker_cache})
	{
		print "- Striker cache: [".$an->data->{path}{striker_cache}."] already exists.\n";
	}
	else
	{
		print "- Creating Striker cache: [".$an->data->{path}{striker_cache}."]\n";
		my $shell_call = $an->data->{path}{'mkdir'}." -p ".$an->data->{path}{striker_cache};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	if (-e $an->data->{path}{temp_cache})
	{
		print "- Working cache: [".$an->data->{path}{temp_cache}."] already exists.\n";
	}
	else
	{
		print "- Creating working cache: [".$an->data->{path}{temp_cache}."]\n";
		my $shell_call = $an->data->{path}{'mkdir'}." -p ".$an->data->{path}{temp_cache};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	print "- Done.\n\n";
	
	return(0);
}

# This tries to determine the latest release by checking the alteeve website.
sub get_latest_version
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_latest_version" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $set        = 0;
	my $shell_call = $an->data->{path}{curl}." 2>/dev/null ".$an->data->{url}{striker_latest};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^striker:(http.*)$/)
		{
			$an->data->{url}{striker_default} = $1;
			$set                          = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "url::striker_default", value1 => $an->data->{url}{striker_default},
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /^master:(http.*)$/)
		{
			$an->data->{url}{striker_master} = $1;
			$set                          = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "url::striker_master", value1 => $an->data->{url}{striker_master},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "set", value1 => $set,
	}, file => $THIS_FILE, line => __LINE__});
	if ($set)
	{
		if ($an->data->{url}{striker_default} =~ /.*\/(.*)\.zip$/)
		{
			$an->data->{sys}{install_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::install_version", value1 => $an->data->{sys}{install_version},
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{url}{striker_default} =~ /.*\/(.*)\.tar.gz$/)
		{
			$an->data->{sys}{install_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::install_version", value1 => $an->data->{sys}{install_version},
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{url}{striker_default} =~ /.*\/(.*)\.tar.bz2$/)
		{
			$an->data->{sys}{install_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::install_version", value1 => $an->data->{sys}{install_version},
			}, file => $THIS_FILE, line => __LINE__});
		}
		$an->data->{path}{tarball_dir} = "striker-".$an->data->{sys}{install_version};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::tarball_dir", value1 => $an->data->{path}{tarball_dir},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This downloads the give file, if it is not already downloaded, and verifies that it is not a curl failure
# message.
sub download_file
{
	my ($an, $source, $target, $mode) = @_;
	$mode = "" if not defined $mode;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "download_file" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "source", value1 => $source, 
		name2 => "target", value2 => $target, 
		name3 => "mode",   value3 => $mode, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the file size so that we can warn the user
	my $out_file   = $target;
	my $size       = 0;
	my $shell_call = $an->data->{path}{curl}." --user-agent \"striker-update/2.0\" 2>/dev/null --head $source";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		   $line =~ s/\r//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Content-Length: (\d+)$/)
		{
			$size = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "size", value1 => $size,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# If I got a size, make it (crudely) human readable.
	my $say_size = 0;
	if ($size =~ /^\d+$/)
	{
		$say_size = $an->Readable->bytes_to_hr({'bytes' => $size});
	}
	
	my $start_time = time;
	if ($say_size)
	{
		print "- Downloading: [$source] to: [$target], which is: [$say_size]... ";
	}
	else
	{
		print "- Downloading: [$source] to: [$target]... ";
	}
	print "\n" if $an->data->{sys}{debug} >= 1;
	
	### NOTE: Do NOT use 2>&1 as this pushes the download progress into the download file. If 
	###       debug is enabled, we'll dump the progress to the screen.
	$shell_call = $an->data->{path}{curl}." --user-agent \"striker-update/2.0\" $source 2>/dev/null > $target";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call |") or die __LINE__."; [ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	my $file_ok = 0;
	if (-e $target)
	{
		# If the file is less than 1024 bytes, read it in to make sure it is not a 
		# failure message.
		my $size = (stat($target))[7];
		print "- Downloaded file: [$target] is: [$size] bytes.\n";
		if ($size < 1024)
		{
			# Is it binary or text? If it is text, make sure it is not a failure message.
			if (not $size)
			{
				# File is empty.
				print "\n" if not $an->data->{sys}{debug};
				print "[ Error ] - Failed to download: [$target].\n";
				print "[ Error ]   The downloaded file was 0-bytes.\n";
				print "[ Error ]   Is the source: [$source] accessible?\n";
			}
			elsif (-B $target)
			{
				# Yay!
				$file_ok = 1;
				print "- Downloaded file: [$target] is binary, good.\n";
			}
			else
			{
				# Read it in.
				my $shell_call = $target;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "<$shell_call") or die __LINE__."; [ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
					if ($line =~ /Could not resolve host/i)
					{
						# Bad URL
						print "\n" if not $an->data->{sys}{debug};
						print "[ Error ] - Failed to download: [$target].\n";
						print "[ Error ]   It appears that the domain name is invalid.\n";
					}
					if ($line =~ /<title>404 Not Found<\/title>/i)
					{
						# File not found.
						print "\n" if not $an->data->{sys}{debug};
						print "[ Error ] - Failed to download: [$target].\n";
						print "[ Error ]   It appears that the file was not found on the server.\n";
					}
					if ($line =~ /<a href="(.*?)">redirected<\/a>/)
					{
						# Redirect
						my $new_source = $1;
						
						# Cleanup
						close $file_handle;
						unlink $target or die __LINE__."; [ Error ] - Failed to delete: [$target] (it is a failed download message, not the file). The error was: $!\n";
						
						# Download the new source
						print "- Redirected source: [$source]: to: [$new_source].\n";
						$out_file = download_file($an, $new_source, $target, $mode);
						return($out_file);
					}
				}
				close $file_handle;
			}
		}
		else
		{
			# Too big to be a failure, so we're probably good.
			$file_ok = 1;
			print "- Downloaded file: [$target] is large enough that analysis is not required.\n";
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "target",  value1 => $target,
		name2 => "file_ok", value2 => $file_ok,
	}, file => $THIS_FILE, line => __LINE__});
	if ($file_ok)
	{
		my $duration = time - $start_time;
		if ($duration > 1)
		{
			my $speed     = int($size / $duration);
			my $say_speed = $an->Readable->bytes_to_hr({'bytes' => $speed});
			print "- Finished! Took: [$duration] seconds to download: [$say_size] (~$say_speed/sec).\n";
		}
		else
		{
			# One second or less.
			print "- Finished! Downloaded: [$say_size].\n";
		}
	}
	else
	{
		# Sadness.
		print "\n" if not $an->data->{sys}{debug};
		print "[ Error ] - There was a problem downloading: [$source] to: [$target]\n";
		if (-e $target)
		{
			# Remove the sadness
			print "[ Note ] - Failed download target: [$target] will now be removed.\n";
			unlink $target or die __LINE__."; [ Error ] - Failed to delete: [$target] (it is a failed download message, not the file). The error was: $!\n";
		}
		### NOTE: We don't die here because we *might* have usable cache. Maybe.
	}
	
	# Set the mode, if needed
	if ($mode)
	{
		chmod $mode, $target;
	}
	
	return($out_file);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $help = "
 -=] Striker Update

DESCRIPTION

This program will update the local OS, the Striker/ScanCore data and Update the
ScanCore database. Packages updated when the OS is updated will be integrated
into the loca repository. Optionally, updated RPMs on a target node can also be
integrated into the local repository.


NOTE

To avoid compatibility problems, the AN::Tools module is used as little as 
possible by this tool. As such, some features like translation are not 
supported, nor is logging.


NOTE

If your system has no internet connection, you can manually copy files to:

".$an->data->{path}{update_cache}."/rpms/
".$an->data->{path}{update_cache}."/source/

Any RPMs found in the 'rpms' directory will be loaded into the local repository
prior to running the OS update. If 'striker*.zip' (striker.zip, 
striker-master.zip, etc) is found under the 'source' directory, that will be
unpacked and used to update Striker (on dashboards) and ScanCore (on all 
machines). 

You only need to pre-populate on Striker dashboards. This program will use the
local data to update nodes.


NOTE

Always do an initial run with '--gather-only'. If the local dashboard is using
a mounted ISO for the RPM repository, The gather process will convert the 
ISO-mounted repo to a normal file (and remove the ISO from /etc/fstab).


SWITCHES

 --anvil-name {all,<anvil_name>}
 --anvil-uuid <anvil_uuid>

	This is the Anvil! name or UUID to update. When '--gather-only' is 
	specified, one of the nodes in this Anvil! will be used to download 
	updated operating system updates. The updates will NOT be installed
	when '--gather-only' is used.
	
	NOTE: Using '--anvil-name all' tells the system to update all known
	      Anvil! systems. If used with '--gather-only', an Anvil! will be
	      chosen at random to download updated RPMs from.

 --gather-only

	When called without an Anvil!, it will download and cache the latest 
	operating system updates, but NOT install them. It will also download
	the latest release of Striker (or git HEAD if '--master' is used) and
	cache that as well. 
	
	When called with an Anvil!, it will do all of the above, but then also
	download operating system updates on a node, but NOT install them, and
	copy over any updated RPMs that aren't already in the local RPM cache.
	
	In either case, the local RPM repository will be updated so that the 
	new RPMs become available to other dashboards and nodes.

 -h, -?, --help

	Show this dialoge and exit.

 --master

	This will upgrade to the latest (master branch) version available on 
	GitHub: https://github.com/ClusterLabs/striker
	
	### WARNING: This is only recommended for developers or testers. Do not
	###          upgrade to master on production systems!

 --no-refresh

	If this is passed, AND if the source already appears to be downloaded,
	the source code will not be downloaded again. This can be useful if you
	plan to run the download many times and worry about being throttled by
	github.

 --offline
	
	Don't try to update anything from the Internet. This will use files 
	already in:
	
	RPMS: .. ".$an->data->{path}{updates}{rpms}."
	Striker: ".$an->data->{path}{updates}{striker}."
	
	NOTE: Without this switch, a check for internet connectivity will be
	      performed. If not link is detected, the install will 
	      automatically run in offline mode.


SUPPORT

".$an->data->{url}{support}."

                                                          Alteeve's Niche! Inc.
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die __LINE__."; Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}
