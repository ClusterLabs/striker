#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - The referenced network interface seen when the user unplugged a network
#      cable did not (properly) record that interfaces MAC address.
# 2  - The referenced network interface seen when the user unplugged a network
#      cable did not (properly) record that interfaces current device name.
# 3  - 
# 4  - Insufficient number of network interfaces found. This program requires
#      two interfaces to run. Wireless interfaces are not supported.
# 5  - The '$conf->{path}{backups}' value is not set.
# 6  - The '$conf->{path}{backups}' backup directory failed to be created. The
#      failure warning should be displayed immediately prior to this error.
# 7  - backup_file() was called without a specified file to backup.
# 8  - Failed to find the '$conf->{path}{network_configs}' directory. I hope
#      for the user's sake that this is a program problem...
# 9  - There was one or more problems while sanity checking the command line
#      options. The problems will be displayed prior to the exit.
# 10 - No switches passed.
# 11 - Failed to bring up a network interface and network configuration was
#      requested.
# 12 - Failed to install all required packages.
# 13 - OS isn't RHEL based.
# 14 - OS isn't EL6.x
# 15 - Unable to get the apache user's UID.
# 16 - Unable to get the apache user's GID.
# 17 - Installer didn't run as 'root'.
# 18 - Failed to download a requested file.
# 19 - Failed to copy a file.
# 20 - Failed to create a symlink.
# 21 - Failed to rsync a file or directory.
# 22 - Failed to find CentOS source ISO.
# 23 - Failed to find RHEL source ISO.
# 24 - Unable to parse repo file name from path.
# 25 - Failed to download the repository.
# 26 - BCN not specified or found and DHCP server config requested.
# 27 - BCN not specified and IP not defined in ifcfg file.
# 28 - Failed to install one or more required packaged for the GUI.
# 29 - 
# 
# TODO: - Create an init script that deletes anything in the media directory on
#         boot. Can't use /tmp as it's usually too small.
#       - Create a '-g' switch to install the GUI (make sure this sets up
#         'virt-manager'). Install 'virt-manager'
#       - Add a firefox desktop icon when the GUI is installed for http://localhost
#       - Configure avahi to announce newly build nodes and strikers and have
#         striker listen for newly built nodes. 
#         (broadcast 'I am $hostname on ip $ip' once per second, and then have
#          striker stop this when it first starts to configure the node).
#       - When installing without --rhel-iso or --centos-iso, look for existing
#         source in /var/www/html/{c6,rhel6} and, if so, setup kickstart/PXE.
#         
# BUG: - ISO for PXE isn't mounted properly.
# 

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

use strict;
use warnings;
use File::Path qw(make_path);

# No capes!^H^H^H^Hbuffers!
$| = 1;

my $conf = {
	daemons		=>	{
		# These will be both chkconfig on'ed and started after
		# 'disable' is processes.
		# NOTE: 'haldaemon' needs to restart before 'acpid' will work,
		#       if 'acpid' was just installed.
		#enable			=>	["iptables", "httpd", "haldaemon", "acpid", "tomcat6", "guacd", "network", "ntpd", "xinetd"],
		enable			=>	["iptables", "httpd", "haldaemon", "acpid", "network", "ntpd", "xinetd"],
		# These will be both chkconfig off'ed and stopped.
		disable			=>	["dhcpd", "ip6tables", "NetworkManager"],
	},
	directory	=>	{
		apache			=>	"/etc/httpd",
		apache_manifests	=>	"/var/www/html/manifests",
		apache_subdirs		=>	["archive", "cache", "media", "status"],
		centos_pxe_web		=>	"html/c6",			# Appeanded to 'document_root' + arch appended after
		centos_tftp_boot	=>	"c6",				# Appeanded to 'pxelinux_boot' + arch
		document_root		=>	"/var/www/",
# 		guac_classpath		=>	"/var/lib/guacamole/classpath",
# 		guac_etc		=>	"/etc/guacamole",
# 		guac_lib		=>	"/var/lib/guacamole",
# 		guac_tomcat		=>	"/usr/share/tomcat6/.guacamole",
		media			=>	"/var/www/home/media",
		pxelinux_config		=>	"/var/lib/tftpboot/pxelinux.cfg",
		pxelinux_boot		=>	"/var/lib/tftpboot/boot",	# TODO: Make this and _config subdirtories of 'pxelinux'
		pxelinux		=>	"/var/lib/tftpboot/",
		pxe_iso_subdirs		=>	["iso", "img", "ks", "files"],	# appended to {centos,rhel}_pxe_web + arch
		rhel_pxe_web		=>	"html/rhel6",			# Appeanded to 'document_root' + arch appended after
		rhel_tftp_boot		=>	"rhel6",			# Appeanded to 'pxelinux_boot' + arch
		source			=>	"",
		yum_repos		=>	"/etc/yum.repos.d",
	},
	executable	=>	{
		cp			=>	"/bin/cp",
		chkconfig		=>	"/sbin/chkconfig",
		'chmod'			=>	"/bin/chmod",
		'chown'			=>	"/bin/chown",
		curl			=>	"/usr/bin/curl",
		echo			=>	"/bin/echo",
		git			=>	"/usr/bin/git",
		htpasswd		=>	"/usr/bin/htpasswd",
		ifup			=>	"/sbin/ifup",
		ip			=>	"/sbin/ip",
		iptables		=>	"/sbin/iptables",
		'iptables-save'		=>	"/sbin/iptables-save",
		ln			=>	"/bin/ln",
		lspci			=>	"/sbin/lspci",
		mount			=>	"/bin/mount",
		passwd			=>	"/usr/bin/passwd",
		restorecon		=>	"/sbin/restorecon",
		'rhn-channel'		=>	"/usr/sbin/rhn-channel",
		rhnreg_ks		=>	"/usr/sbin/rhnreg_ks",
		rsync			=>	"/usr/bin/rsync",
		sed			=>	"/bin/sed",
		semanage		=>	"/usr/sbin/semanage",
		setenforce		=>	"/usr/sbin/setenforce",
		setsebool		=>	"/usr/sbin/setsebool",
		'ssh-keygen'		=>	"/usr/bin/ssh-keygen",
		su			=>	"/bin/su",
		tar			=>	"/bin/tar",
		umount			=>	"/bin/umount",
		unzip			=>	"/usr/bin/unzip",
		wget			=>	"/usr/bin/wget",
		yum			=>	"/usr/bin/yum",
	},
	packages	=>	{
		# These get set to '1' when their found to be installed.
		to_install	=>	{
			acpid				=>	0,
			ccs				=>	0, 
			'perl-YAML-Tiny'		=>	0, 
			'cyrus-sasl'			=>	0, 
			'cyrus-sasl-plain'		=>	0,
			dhcp				=>	0,
			expect				=>	0, 
			'fence-agents'			=>	0, 
			#guacd				=>	0, 
			httpd				=>	0, 
			libcdio				=>	0, 
			#'libguac-client-rdp'		=>	0,
			#'libguac-client-ssh'		=>	0, 
			#'libguac-client-vnc'		=>	0, 
			man				=>	0, 
			mlocate				=>	0, 
			mod_ssl				=>	0,
			ntp				=>	0,
			pciutils			=>	0,
			'perl-CGI'			=>	0, 
			'perl-CPAN'			=>	0, 
			'perl-Net-SSH2'			=>	0,
			'perl-Net-SSLeay'		=>	0, 
			'perl-TermReadKey'		=>	0,
			'perl-Test-Simple'		=>	0,
			'perl-XML-Simple'		=>	0,
			'policycoreutils-python'	=>	0, 
			postfix				=>	0, 
			rsync				=>	0,
			screen				=>	0, 
			syslinux			=>	0, 
			'syslinux-tftpboot'		=>	0,
			'openssl-devel'			=>	0,
			'tftp-server'			=>	0,
			#tomcat6				=>	0, 
			unzip				=>	0,
			'vim-common'			=>	0, 
			'vim-enhanced'			=>	0, 
			wget				=>	0,
			xinetd				=>	0,
		},
		ipmi_packages	=>	{
			freeipmi			=>	0,
			'freeipmi-bmc-watchdog'		=>	0,
			'freeipmi-ipmidetectd'		=>	0,
			ipmitool			=>	0,
			#NetworkManager			=>	0,
			#'NetworkManager-gnome'		=>	0,
			OpenIPMI			=>	0,
			'OpenIPMI-libs'			=>	0,
		},
		gui_packages	=>	{
			'abyssinica-fonts'		=>	0,
			'alsa-plugins-pulseaudio'	=>	0,
			'at-spi'			=>	0,
			'cjkuni-uming-fonts'		=>	0,
			'control-center'		=>	0,
			'control-center-extra'		=>	0,
			'dejavu-sans-fonts'		=>	0,
			'dejavu-sans-mono-fonts'	=>	0,
			'dejavu-serif-fonts'		=>	0,
			dbus				=>	0,
			eog				=>	0,
			firefox				=>	0,
			gdm				=>	0,
			'gdm-plugin-fingerprint'	=>	0,
			'gdm-user-switch-applet'	=>	0,
			'glx-utils'			=>	0,
			'gnome-applets'			=>	0,
			'gnome-media'			=>	0,
			'gnome-packagekit'		=>	0,
			'gnome-panel'			=>	0,
			'gnome-power-manager'		=>	0,
			'gnome-screensaver'		=>	0,
			'gnome-session'			=>	0,
			'gnome-terminal'		=>	0,
			'gnome-vfs2-smb'		=>	0,
			'google-crosextra-caladea-fonts'	=>	0,
			'google-crosextra-carlito-fonts'	=>	0,
			'gvfs-archive'			=>	0,
			'gvfs-fuse'			=>	0,
			'gvfs-smb'			=>	0,
			hal				=>	0,
			'jomolhari-fonts'		=>	0,
			'khmeros-base-fonts'		=>	0,
			'kurdit-unikurd-web-fonts'	=>	0,
			'liberation-mono-fonts'		=>	0,
			'liberation-sans-fonts'		=>	0,
			'liberation-serif-fonts'	=>	0,
			'lklug-fonts'			=>	0,
			'lohit-assamese-fonts'		=>	0,
			'lohit-bengali-fonts'		=>	0,
			'lohit-devanagari-fonts'	=>	0,
			'lohit-gujarati-fonts'		=>	0,
			'lohit-kannada-fonts'		=>	0,
			'lohit-oriya-fonts'		=>	0,
			'lohit-punjabi-fonts'		=>	0,
			'lohit-tamil-fonts'		=>	0,
			'lohit-telugu-fonts'		=>	0,
			'madan-fonts'			=>	0,
			metacity			=>	0,
			nautilus			=>	0,
			'notification-daemon'		=>	0,
			'openssh-askpass'		=>	0,
			'paktype-naqsh-fonts'		=>	0,
			'paktype-tehreer-fonts'		=>	0,
			'plymouth-system-theme'		=>	0,
			'polkit-gnome'			=>	0,
			'pulseaudio-module-gconf'	=>	0,
			'pulseaudio-module-x11'		=>	0,
			'sil-padauk-fonts'		=>	0,
			'smc-meera-fonts'		=>	0,
			'spice-vdagent'			=>	0,
			'stix-fonts'			=>	0,
			'thai-scalable-waree-fonts'	=>	0,
			'tibetan-machine-uni-fonts'	=>	0,
			'un-core-dotum-fonts'		=>	0,
			vino				=>	0,
			'virt-manager'			=>	0,
			'vlgothic-fonts'		=>	0,
			wdaemon				=>	0,
			'wqy-zenhei-fonts'		=>	0,
			'xdg-user-dirs-gtk'		=>	0,
			'xorg-x11-drivers'		=>	0,
			'xorg-x11-server-utils'		=>	0,
			'xorg-x11-server-Xorg'		=>	0,
			'xorg-x11-utils'		=>	0,
			'xorg-x11-xauth'		=>	0,
			'xorg-x11-xinit'		=>	0,
			xvattr				=>	0,
			yelp				=>	0,
		},
		# This is populated by 'get_list_of_installed_packages()' and
		# uses the found package name as the key and sets the value to
		# '1'.
		installed	=>	{},
	},
	path		=>	{
		an_repo			=>	"/etc/yum.repos.d/an.repo",
		apache_config		=>	"/etc/httpd/conf/httpd.conf",
		apache_home		=>	"/var/www/home",
		apache_htpasswd		=>	"/var/www/home/htpasswd",
		apache_manifest_conf	=>	"/etc/httpd/conf.d/manifest.conf",
		apache_shell		=>	"/bin/bash",
		backups			=>	"/root/anvil",
		dhcpd_conf		=>	"/etc/dhcp/dhcpd.conf",
		#guac_noauth		=>	"/var/lib/guacamole/classpath/guacamole-auth-noauth-#!guac_version!#.jar",
		#guac_noauth_config	=>	"/etc/guacamole/noauth-config.xml",
		#guac_properties		=>	"/etc/guacamole/guacamole.properties",
		#guac_properties_symlink	=>	"/usr/share/tomcat6/.guacamole/guacamole.properties",
		#guac_war		=>	"/var/lib/guacamole/guacamole-#!guac_version!#.war",
		#guac_war_symlink	=>	"/var/lib/tomcat6/webapps/guacamole.war",
		hostname		=>	"/etc/sysconfig/network",
		inittab			=>	"/etc/inittab",
		iptables		=>	"/etc/sysconfig/iptables",
		network_configs		=>	"/etc/sysconfig/network-scripts",
		os_release		=>	"/etc/redhat-release",
		passwd			=>	"/etc/passwd",
		persistent_net		=>	"/etc/udev/rules.d/70-persistent-net.rules",
		power_sh		=>	"/etc/acpi/actions/power.sh",
		pxe_background_source	=>	"/var/www/html/skins/alteeve/images/pxe_splash_1024_768.png",
		pxe_default_config	=>	"/var/lib/tftpboot/pxelinux.cfg/default",
		rhn_file		=>	"/etc/sysconfig/rhn/systemid",
		selinux_config		=>	"/etc/selinux/config",
		sshd_config		=>	"/etc/ssh/sshd_config",
		striker_config		=>	"/etc/striker/striker.conf",
		striker_log		=>	"/var/log/striker.log",
		#tomcat_server		=>	"/etc/tomcat6/server.xml",
		xinetd_tftp_config	=>	"/etc/xinetd.d/tftp",
	},
	permissions	=>	{
		dhcpd_dir		=>	{
			path			=>	"/etc/dhcp",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"0755",
			recursive		=>	0,
		},
		document_root		=>	{
			path			=>	"/var/www",
			owner			=>	"apache",
			group			=>	"apache",
			mode			=>	"g+w",
			recursive		=>	1,
		},
		striker_log		=>	{
			path			=>	"/var/log/striker.log",
			owner			=>	"apache",
			group			=>	"apache",
			mode			=>	"g+w",
			recursive		=>	0,
			selinux			=>	"httpd_sys_content_t",
		},
		striker_config_dir	=>	{
			path			=>	"/etc/striker",
			owner			=>	"apache",
			group			=>	"apache",
			mode			=>	"g+w",
			recursive		=>	1,
		},
		striker_config	=>	{
			path			=>	"/etc/striker/striker.conf",
			owner			=>	"apache",
			group			=>	"apache",
			mode			=>	"0660",
			recursive		=>	0,
			selinux			=>	"httpd_sys_content_t",
		},
		ssh_config		=>	{
			path			=>	"/etc/ssh/ssh_config",
			owner			=>	"root",
			group			=>	"apache",
			mode			=>	"g+w",
			recursive		=>	0,
			selinux			=>	"httpd_sys_content_t",
		},
		hosts			=>	{
			path			=>	"/etc/hosts",
			owner			=>	"root",
			group			=>	"apache",
			mode			=>	"g+w",
			recursive		=>	0,
			selinux			=>	"httpd_sys_content_t",
		},
# 		guac_noauth_config	=>	{
# 			path			=>	"/etc/guacamole/noauth-config.xml",
# 			owner			=>	"root",
# 			group			=>	"apache",
# 			mode			=>	"0664",
# 			recursive		=>	0,
# 			selinux			=>	"httpd_sys_content_t",
# 		},
		pxelinux		=>	{
			path			=>	"/var/lib/tftpboot/pxelinux.cfg",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"755",
			recursive		=>	0,
		},
		# The following entries must sort last to ensure the setuid
		# doesn't get changed by a change to the parent directory.
		z_control_dhcpd		=>	{
			path			=>	"/var/www/tools/control_dhcpd",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"6755",
			recursive		=>	0,
		},
# 		z_restart_tomcat	=>	{
# 			path			=>	"/var/www/tools/restart_tomcat6",
# 			owner			=>	"root",
# 			group			=>	"root",
# 			mode			=>	"6755",
# 			recursive		=>	0,
# 		},
# 		z_restart_guacd	=>	{
# 			path			=>	"/var/www/tools/restart_guacd",
# 			owner			=>	"root",
# 			group			=>	"root",
# 			mode			=>	"6755",
# 			recursive		=>	0,
# 		},
		z_check_dvd		=>	{
			path			=>	"/var/www/tools/check_dvd",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"6755",
			recursive		=>	0,
		},
		z_do_dd			=>	{
			path			=>	"/var/www/tools/do_dd",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"6755",
			recursive		=>	0,
		},
		'z_call_gather-system-info'	=>	{
			path			=>	"/var/www/tools/call_gather-system-info",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"6755",
			recursive		=>	0,
		},
		'z_touch_striker.log'	=>	{
			path			=>	"/var/www/tools/touch_striker.log",
			owner			=>	"root",
			group			=>	"root",
			mode			=>	"6755",
			recursive		=>	0,
		},
	},
	sys		=>	{
		apache_group		=>	"apache",
		apache_timeout		=>	"60000",	# This will go away with AJAX
		apache_user		=>	"apache",
		create_bonds		=>	0,		# Gets set to '1' if 4 NICs are found.
		customer		=>	"Striker Dashboard",
		#guac_version		=>	"0.9.2",
		hostname		=>	"",
		ipmi_gateway		=>	"",
		ipmi_ip			=>	"",
		ipmi_netmask		=>	"",
		ipmi_password		=>	"",
		ipmi_user		=>	"",
		is_rhel			=>	0,
		mail_server		=>	"",
		mail_user		=>	"",
		mail_password		=>	"",
		mtu			=>	1500,
		reboot_needed		=>	0,
		rhn_user		=>	"",
		rhn_password		=>	"",
		skip_hostname		=>	0,
		skip_mail		=>	0,
		skip_network		=>	0,
		stable_version		=>	"1.1.6",
		striker_user		=>	"admin",
		striker_pass		=>	"",		# no default password, evar!
		switch_count		=>	0,
		tarball_dir		=>	"striker-#!striker_version!#",
	},
	url		=>	{
		git_master	=>	"https://github.com/digimer/striker/archive/master.zip",
		striker		=>	"https://github.com/digimer/striker/archive/#!striker_version!#.zip",
	},
	# This will be changed to have two of each link if four NICs are found.
	nics		=>	["bcn_link1", "ifn_link1"],
	network		=>	{
		bcn		=>	{
			ip		=>	"",
			netmask		=>	"",
		},
		ifn		=>	{
			ip		=>	"",
			netmask		=>	"",
			gateway		=>	"",
			dns1		=>	"8.8.8.8",
			dns2		=>	"8.8.4.4",
		},
	},
	pxe		=>	{
		centos		=>	{
			enabled		=>	0,
			node1_ks	=>	"anvil-m2-node01_centos.ks",
			node2_ks	=>	"anvil-m2-node02_centos.ks",
			striker1_ks	=>	"anvil-m2-striker01_centos.ks",
			striker2_ks	=>	"anvil-m2-striker02_centos.ks",
			short_name	=>	"c6",
		},
		rhel		=>	{
			enabled		=>	0,
			node1_ks	=>	"anvil-m2-node01_rhel.ks",
			node2_ks	=>	"anvil-m2-node02_rhel.ks",
			striker1_ks	=>	"anvil-m2-striker01_rhel.ks",
			striker2_ks	=>	"anvil-m2-striker02_rhel.ks",
			short_name	=>	"rhel6",
		}
	},
};

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	print "[ Error ] - I am sorry, but this program must be run as the root user.\n\n";
	exit(17);
}

# Make sure we got what we needed from the command line.
get_switches($conf);
if (not $conf->{sys}{switch_count})
{
	print_usage($conf);
	exit(10);
}

system('clear');
# Credit to Martin Allchin for this ASCII art!
print q`
 ##############################################################################
 #   ___ _       _ _                                    The Anvil! Dashboard  #
 #  / __| |_ _ _(_) |_____ _ _                                 -=] Installer  #
 #  \__ \  _| '_| | / / -_) '_|                                               #
 #  |___/\__|_| |_|_\_\___|_|                                                 #
 #                                               https://alteeve.ca/w/Striker #
 ##############################################################################

`;

# This sanity-checks the passed in command line switches and returns '1' if
# any problems were found.
if (sanity_check_switches($conf))
{
	exit(9);
}

# Make sure we're on EL6.x
verify_os($conf);

# Add the user's repo if specified
if ($conf->{switches}{r})
{
	add_repo($conf);
}

# Go into the loop that asks the user to unplug cables until they are happy 
# with their selection. When it exits, we go to work.
if (not $conf->{sys}{skip_network})
{
	# Make backups, of course.
	backup_original_files($conf);
	
	# Freeze NetworkManager if it is running.
	freeze_networkmanager($conf);
	
	# Make sure all NICs are up. If any aren't, start them.
	start_all_nics($conf);
	
	# Now ask the user to map their network.
	until(select_nics($conf))
	{
		sleep 1;
	}
}

# If passed, set the hostname.
if (not $conf->{sys}{skip_hostname})
{
	set_hostname($conf);
}

# TODO: See if we can set contexts on files when selinux is disabled entirely.
#       If not, and if relabeling is needed, write a run-once script to relabel
#       our stuff on the next boot.
# Now configure the Striker dashboard.
setup_striker($conf);

# The network needs to be configured last because, if the user installed a GUI,
# NetworkManager would try to reconfigure the network immediately and mess
# things up. By this point, now, NetworkManager should be disabled.
if (not $conf->{sys}{skip_network})
{
	# If we're here, the user has OK'ed the changes.
	reconfigure_network($conf);
}

# If the user should reboot, tell them.
if ($conf->{sys}{reboot_needed})
{
	print "\n[ Note ] - Some of the changes require a reboot to take effect.\n";
	print "[ Note ]   When you are ready, type 'reboot' and press <enter>.\n\n";
}
print "Installation of Striker is complete!\n\n";
exit(0);


###############################################################################
# Here be function!                                                           #
###############################################################################

# This checks to see if NetworkManager is running and if the active interface
# is NM_CONTROLLER="yes". If so, it sets it to 'no' and restarts NetworkManager
sub freeze_networkmanager
{
	my ($conf) = @_;
	
	print "Checking if we need to freeze NetworkManager on the active interface.\n";
	my $nm_running   = 0;
	my $active_iface = "";
	
	my $shell_call = "if [ -e '/etc/init.d/NetworkManager' ];
			then
				/etc/init.d/NetworkManager status;
				echo rc:\$?
			else
				echo rc:1
			fi";
	#print "[ Debbug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		#print "[ Debug ] - line: [$line]\n";
		if ($line =~ /^rc:(\d+)/)
		{
			my $rc = $1;
			if ($rc eq "0")
			{
				print "- NetworkManager is running, will examine interfaces.\n";
				$nm_running = 1;
			}
			else
			{
				# '3' is stopped
				print "- NetworkManager isn't running, freeze not needed.\n";
			}
		}
	}
	close $file_handle;
	
	my $freeze = {};
	if ($nm_running)
	{
		# Check running interfaces for IP addresses, check their
		# ifcfg-X file for 'NM_CONTROLLED' and see if it is 'yes'. If
		# so, queue it up for switch to 'no'.
		check_nic_states($conf);
		foreach my $iface (sort {$a cmp $b} keys %{$conf->{nic}{by_name}})
		{
			# See if it is up already.
			my $link_state = $conf->{nic}{by_name}{$iface}{link_state};
			my $mac        = $conf->{nic}{by_name}{$iface}{mac};
			my $ip         = $conf->{nic}{by_name}{$iface}{ip};
			# Link states:
			# 0 = Up no no link
			# 1 = Up with link
			# 2 = Down
			
			# I only care about the interface the user might be
			# using to run the install, so if the NIC isn't up with
			# an IP address, I can ignore it.
			if (($link_state eq "1") && ($ip))
			{
				# Link is up. Check it's config file.
				my $nm_controlled = "";
				   $shell_call    = "cat $conf->{path}{network_configs}/ifcfg-$iface";
				open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					#print "[ Debug ] - line: [$line]\n";
					if ($line =~ /^NM_CONTROLLED=(.*)/)
					{
						$nm_controlled = $1;
						$nm_controlled =~ s/"//;
						$nm_controlled = lc($nm_controlled);
						if ($nm_controlled =~ /yes/i)
						{
							$freeze->{$iface} = 1;
						}
					}
				}
			}
			else
			{
				# These links we'll disable in NetworkManager
				# now.
				my $shell_call = "";
			}
		}
		
		# Now for each interface to freeze, switch 'ONBOOT' to yes,
		# 'NM_CONTROLLED' to 'no' and then restart NetworkManager.
		my $shell_call = "";
		my $message    = "Freezing interfaces: ";
		foreach my $iface (sort {$a cmp $b} keys %{$freeze})
		{
			my $nic_file    = "$conf->{path}{network_configs}/ifcfg-$iface";
			   $shell_call .= "$conf->{executable}{sed} -i 's/ONBOOT=.*/ONBOOT=\"yes\"/\' $nic_file; ";
			   $shell_call .= "$conf->{executable}{sed} -i 's/NM_CONTROLLED=.*/NM_CONTROLLED=\"no\"/\' $nic_file; ";
			   $message    .= "$iface, ";
		}
		# If I had any, append the restart
		if ($shell_call)
		{
			$message =~ s/, $//;
			print "- $message\n";
			print "- Note: Other interfaces may go down temporarily.\n";
			$shell_call .= "/etc/init.d/NetworkManager stop; /etc/init.d/network start";
			#print "[ Debbug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] - line: [$line]\n";
			}
			close $file_handle;
		}
		else
		{
			# Nothing needed to be frozen.
			print "- No NICs needed to be frozen.\n";
		}
	}
	print "Done\n\n";
	
	return(0);
}

# This adds a repo if it doesn't already exist.
sub add_repo
{
	my ($conf) = @_;
	
	print "Adding custom repositories:\n";
	#print "[ Debug ] - repositories: [$conf->{switches}{r}]\n";
	foreach my $url (split/,/, $conf->{switches}{r})
	{
		my $repo_file = ($url =~ /^.*\/(.*?)$/)[0];
		#print "[ Debug ] - repo_file: [$repo_file], url: [$url]\n";
		if (not $repo_file)
		{
			print "[ Error ] - Unable to parse repository file from path:\n";
			print "[ Error ]   [$url]\n";
			exit(24);
		}
		
		if (-e "$conf->{directory}{yum_repos}/$repo_file")
		{
			print "- Already downloaded, skipping.\n";
			next;
		}
		else
		{
			print "- Downloading: [$url]\n";
			my $shell_call = "$conf->{executable}{curl} $url > $conf->{directory}{yum_repos}/$repo_file && $conf->{executable}{yum} clean all";
			#print "[ Debbug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			print "==============================================================================\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "- Output: [$line]\n";
			}
			print "==============================================================================\n";
			close $file_handle;
			
			if (-e "$conf->{directory}{yum_repos}/$repo_file")
			{
				print "- Success!\n";
			}
			else
			{
				print "[ Error ] - It would appear that the repository download failed.\n";
				exit(25);
			}
		}
	}
	print "Done.\n\n";
	
	return(0);
}

# This handles the rest of the install (everything except the network).
sub setup_striker
{
	my ($conf) = @_;
	
	print "-=] Beginning configuration and installation processes now. [=-\n\n";
	
	# First up, install RPMs to make sure we've got everything we need.
	install_packages($conf);
	
	# If requested, this will install and configure the GUI.
	configure_gui($conf);
	
	# Download Striker, if needed.
	download_striker($conf);
	
	# Configure apache.
	configure_apache($conf);
	
	# Configure Tomcat
	#configure_tomcat($conf);
	
	# Configure guacamole
	#configure_guacamole($conf);
	
	# Configure SSH to allow faster logins when there is not Internet
	# access. Also, create an SSH RSA keyset for apache, though it
	# probably isn't needed anymore and might go away in a later update.
	configure_ssh($conf);
	
	# Configure iptables to allow incoming HTTP and HTTPS traffic.
	configure_iptables($conf);
	
	# Copy Striker files into place
	install_striker_files($conf);
	
	# Configure PXE and dhcpd stuff
	configure_pxe($conf);
	
	# Set owners and file modes.
	set_file_ownership_and_modes($conf);
	
	# Configure IPMI
	configure_ipmi($conf);
	
	# (Re)start daemons.
	manage_daemons($conf);
	
	# Make sure that selinux is enabled. This runs after the main installer so that
	# we can ensure any files we created or installed have the right
	# labels/contexts.
	configure_selinux($conf);
	
	# NOTE: Always call this last. If the password gets set, there is a
	#       notice box informing the user that we want to ensure doesn't
	#       get scrolled off the screen.
	# Set the root user's password.
	set_root_password($conf);
	
	return(0);
}

# This installs a GUI and configures it, if requested.
sub configure_gui
{
	my ($conf) = @_;
	
	if (not $conf->{switches}{gui})
	{
		# GUI not requested.
		return(0);
	}
	
	print "Configuring Striker to use a graphical interface.\n";
	my $stop_NetworkManager = 0;
	my $to_install          = "";
	foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{gui_packages}})
	{
		if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
		{
			$conf->{packages}{gui_packages}{$package} = 1;
			print "- GUI Package: [$package] already installed.\n";
		}
		else
		{
			print "- Package: [$package] needs to be installed.\n";
			$to_install .= "$package ";
			if ($package eq "NetworkManager")
			{
				$stop_NetworkManager = 1;
			}
		}
	}
	
	# Install anything needed.
	if ($to_install)
	{
		# Install the packages, then verify they actually installed.
		print "- Installing IPMI packages now. Please be patient.\n";
		#print "- [ Note ] Please be patient! It may appear that nothing is happening for a\n";
		#print "- [ Note ] while. This is likely because of how buffering is handled. If you\n";
		#print "- [ Note ] really think nothing is happening, please open a new terminal and\n";
		#print "- [ Note ] look for activity using 'top' or 'ps aux'.\n";
		my $shell_call = "$conf->{executable}{yum} -y install $to_install";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		print "==============================================================================\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			print $_;
		}
		print "==============================================================================\n";
		close $file_handle;
		print "- Done.\n";
		
		# Verify that everything is installed.
		sleep 5;
		get_list_of_installed_packages($conf);
		print "- Verifying that everything is installed now.\n";
		my $missing = 0;
		foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{gui_packages}})
		{
			# Watch for autovivication...
			if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
			{
				$conf->{packages}{gui_packages}{$package} = 1;
				print "- Package: [$package] installed.\n";
			}
			else
			{
				print "[ Error ] - GUI Package: [$package] failed to install!\n";
				$missing = 1;
			}
		}
		# If anything is missing, fail.
		if ($missing)
		{
			print "[ Error ] - Not all required packages for the GUI installed properly.\n";
			exit(28);
		}
		else
		{
			print "- All required packages are now installed.\n\n";
		}
		
		# Immediately disable NetworkManager.
		if ($stop_NetworkManager)
		{
			print "- Disabling the just-installed NetworkManager.\n";
			my $shell_call = "/etc/init.d/NetworkManager stop";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				print $_;
			}
			close $file_handle;
		}
	}
	else
	{
		print "- All required packages already installed.\n";
	}
	
	### Now configure the desktop.
	# First, ensure the GUI loads on boot.
	if (-e $conf->{path}{inittab})
	{
		print "- Enabling GUI on boot.\n";
		backup_file($conf, $conf->{path}{inittab});
		my $shell_call = "sed -i 's/id:3:initdefault/id:5:initdefault/' $conf->{path}{inittab}";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			print $_;
		}
		print "==============================================================================\n";
		close $file_handle;
	}
	
	# Add a system user.
	if (1)
	{
		# See if the user exists.
		my $striker_user = $conf->{sys}{striker_user};
		my $striker_pass = $conf->{sys}{striker_pass};
		my $create_user  = 1;
		
		print "- Checking if the system user: [$striker_user] exists.\n";
		open (my $file_handle, "<", $conf->{path}{passwd}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{passwd}], the error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			
			# Update the apache user entry.
			if ($line =~ /^$striker_user:/)
			{
				print "- User found.\n";
				$create_user = 0;
			}
		}
		close $file_handle;
		
		# Create the user account if needed.
		if ($create_user)
		{
			print "- Creating the user account: [$striker_user]\n";
			my $shell_call = "useradd $striker_user -m";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "- Output: [$line]\n";
			}
			close $file_handle;
			print "- Done.\n";
		}
		
		# Create the ssh key if needed.
		if (not -e "/home/$striker_user/.ssh/id_rsa")
		{
			### BUG: This isn't working...
			print "- Creating the SSH RSA key for: [$striker_user]\n";
			my $shell_call = "$conf->{executable}{su} $striker_user -c \"$conf->{executable}{'ssh-keygen'} -t rsa -N \\\"\\\" -b 8191 -f ~/.ssh/id_rsa\"";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "- Output: [$line]\n";
			}
			close $file_handle;
			print "- Done.\n";
		}
		
		# Set the password.
		if (1)
		{
			print "- Setting the system password for: [$striker_user]\n";
			my $shell_call = "$conf->{executable}{echo} \"$striker_pass\" | $conf->{executable}{passwd} $striker_user --stdin";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "- Output: [$line]\n";
			}
			close $file_handle;
			print "- Done.\n";
		}
	}
	
	# Force instant shutdown in the GUI instead of waiting 60 seconds
	if (-e $conf->{path}{power_sh})
	{
		print "- Configuring immediate shut down in GUI.\n";
		backup_file($conf, $conf->{path}{power_sh});
		my $power_sh =  "#!/bin/sh\n\n";
		   $power_sh .= "PATH=/sbin:/bin:/usr/bin\n";
		   $power_sh .= "shutdown -h now\n";
		   
		my $shell_call = "$conf->{path}{power_sh}";
		open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
		print $file_handle $power_sh;
		close $file_handle;
		print "- Done.\n";
	}
	
	# Desktop icons
	print "- Configuring desktop icons:\n";
	my $desktop = "/home/$conf->{sys}{striker_user}/Desktop";
	if (not -e $desktop)
	{
		# Create the directory.
		print "- Creating the desktop directory: [$desktop]\n";
		mkdir $desktop or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$desktop]. The error was: $!\n";
		$conf->{permissions}{user_desktop}{path}      = "$desktop";
		$conf->{permissions}{user_desktop}{owner}     = "$conf->{sys}{striker_user}";
		$conf->{permissions}{user_desktop}{group}     = "$conf->{sys}{striker_user}",
		$conf->{permissions}{user_desktop}{mode}      = "755";
		$conf->{permissions}{user_desktop}{recursive} = 0;
	}
	if (1)
	{
		# Icon files
		my $firefox_shortcut      = "$desktop/firefox.desktop";
		my $virt_manager_shortcut = "$desktop/virt-manager.desktop";
		#print "[ Debug ] ".__LINE__." - virt_manager_shortcut: [$virt_manager_shortcut]\n";
		
		### Add them to the permission setting hash
		# Firefox
		$conf->{permissions}{user_firefox_icon}{path}      = "$desktop/firefox.desktop";
		$conf->{permissions}{user_firefox_icon}{owner}     = "$conf->{sys}{striker_user}";
		$conf->{permissions}{user_firefox_icon}{group}     = "$conf->{sys}{striker_user}",
		$conf->{permissions}{user_firefox_icon}{mode}      = "755";
		$conf->{permissions}{user_firefox_icon}{recursive} = 0;
		
		# Virtual Machine Manager
		$conf->{permissions}{user_virt_manager_icon}{path}      = "$desktop/virt-manager.desktop";
		$conf->{permissions}{user_virt_manager_icon}{owner}     = "$conf->{sys}{striker_user}";
		$conf->{permissions}{user_virt_manager_icon}{group}     = "$conf->{sys}{striker_user}",
		$conf->{permissions}{user_virt_manager_icon}{mode}      = "755";
		$conf->{permissions}{user_virt_manager_icon}{recursive} = 0;
		#print "[ Debug ] ".__LINE__." - permissions::user_virt_manager_icon::path: [$conf->{permissions}{user_virt_manager_icon}{path}]\n";
		
		### Icon contents
		# Firefox
		my $firefox_body      =  "[Desktop Entry]\n";
		   $firefox_body      .= "Version=1.0\n";
		   $firefox_body      .= "Encoding=UTF-8\n";
		   $firefox_body      .= "Name=Firefox Web Browser\n";
		   $firefox_body      .= "GenericName=Web Browser\n";
		   $firefox_body      .= "Comment=Browse the Web\n";
		   $firefox_body      .= "Exec=firefox http://localhost/\n";
		   $firefox_body      .= "Icon=firefox\n";
		   $firefox_body      .= "Terminal=false\n";
		   $firefox_body      .= "Type=Application\n";
		   $firefox_body      .= "StartupWMClass=Firefox-bin\n";
		   $firefox_body      .= "MimeType=text/html;text/xml;application/xhtml+xml;application/vnd.mozilla.xul+xml;text/mml;\n";
		   $firefox_body      .= "StartupNotify=true\n";
		   $firefox_body      .= "X-Desktop-File-Install-Version=0.15\n";
		   $firefox_body      .= "Categories=Network;WebBrowser;\n";
		   $firefox_body      .= "GenericName[en_US.UTF-8]=Firefox - Striker Dashboard\n";
		   $firefox_body      .= "Comment[en_US.UTF-8]=Connect to the Striker Dashboard\n";
		   $firefox_body      .= "Name[en_US]=Striker Dashboard\n";
		
		# Virt-manager
		my $virt_manager_body =  "#!/usr/bin/env xdg-open\n\n";
		   $virt_manager_body .= "[Desktop Entry]\n";
		   $virt_manager_body .= "Name=Virtual Machine Manager\n";
		   $virt_manager_body .= "Comment=Manage virtual machines\n";
		   $virt_manager_body .= "Icon=virt-manager\n";
		   $virt_manager_body .= "Exec=virt-manager\n";
		   $virt_manager_body .= "Type=Application\n";
		   $virt_manager_body .= "Terminal=false\n";
		   $virt_manager_body .= "Encoding=UTF-8\n";
		   $virt_manager_body .= "Categories=System;\n";
		   
		### Write them out.
		# Firefox
		my $shell_call = "$firefox_shortcut";
		open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
		print $file_handle $firefox_body;
		close $file_handle;
		
		# Virt-manager
		$shell_call = "$virt_manager_shortcut";
		#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
		open ($file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
		print $file_handle $virt_manager_body;
		close $file_handle;
		print "- Done.\n";
	}
	
	# Configure virt-manager to not connect to localhost on start.
	if (1)
	{
		# Make the parent directories if needed.
		print "- Configuring Virtual Machine Manager:\n";
		if (not -e "/home/$conf->{sys}{striker_user}/.gconf")
		{
			print "- Creating directory: [/home/$conf->{sys}{striker_user}/.gconf]\n";
			mkdir "/home/$conf->{sys}{striker_user}/.gconf" or die "$THIS_FILE ".__LINE__."; Failed to create: [/home/$conf->{sys}{striker_user}/.gconf], error was: $!\n";
			$conf->{permissions}{user_gconf}{path}      = "/home/$conf->{sys}{striker_user}/.gconf";
			$conf->{permissions}{user_gconf}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{user_gconf}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{user_gconf}{mode}      = "700";
			$conf->{permissions}{user_gconf}{recursive} = 0;
		}
		if (not -e "/home/$conf->{sys}{striker_user}/.gconf/apps")
		{
			print "- Creating directory: [/home/$conf->{sys}{striker_user}/.gconf/apps]\n";
			mkdir "/home/$conf->{sys}{striker_user}/.gconf/apps" or die "$THIS_FILE ".__LINE__."; Failed to create: [/home/$conf->{sys}{striker_user}/.gconf/apps], error was: $!\n";
			$conf->{permissions}{user_apps}{path}      = "/home/$conf->{sys}{striker_user}/.gconf/apps";
			$conf->{permissions}{user_apps}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{user_apps}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{user_apps}{mode}      = "700";
			$conf->{permissions}{user_apps}{recursive} = 0;
		}
		# This file has to exist, but it's created empty.
		my $apps_gconf = "/home/$conf->{sys}{striker_user}/.gconf/apps/\%gconf.xml";
		if (not -e $apps_gconf)
		{
			print "- Touching file: [$apps_gconf]\n";
			my $shell_call = "$apps_gconf";
			open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
			close $file_handle;
			$conf->{permissions}{apps_conf}{path}      = "$apps_gconf";
			$conf->{permissions}{apps_conf}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{apps_conf}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{apps_conf}{mode}      = "600";
			$conf->{permissions}{apps_conf}{recursive} = 0;
		}
		if (not -e "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager")
		{
			print "- Creating directory: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager]\n";
			mkdir "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager" or die "$THIS_FILE ".__LINE__."; Failed to create: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager], error was: $!\n";
			$conf->{permissions}{user_virt_manager_dir}{path}      = "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager";
			$conf->{permissions}{user_virt_manager_dir}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{user_virt_manager_dir}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{user_virt_manager_dir}{mode}      = "700";
			$conf->{permissions}{user_virt_manager_dir}{recursive} = 1;
		}
		if (not -e "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/connections")
		{
			print "- Creating directory: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/connections]\n";
			mkdir "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/connections" or die "$THIS_FILE ".__LINE__."; Failed to create: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/connections], error was: $!\n";
		}
		if (not -e "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/stats")
		{
			print "- Creating directory: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/stats]\n";
			mkdir "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/stats" or die "$THIS_FILE ".__LINE__."; Failed to create: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/stats], error was: $!\n";
		}
		if (not -e "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/vmlist-fields")
		{
			print "- Creating directory: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/vmlist-fields]\n";
			mkdir "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/vmlist-fields" or die "$THIS_FILE ".__LINE__."; Failed to create: [/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/vmlist-fields], error was: $!\n";
		}
		
		# First up, the main virt-manager gconf
		my $vm_connections_file = "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/connections/\%gconf.xml";
		if (not -e $vm_connections_file)
		{
			my $vm_connections_config =  "<?xml version=\"1.0\"?>\n";
			   $vm_connections_config .= "<gconf>\n";
			   $vm_connections_config .= "	<entry name=\"autoconnect\" mtime=\"1422033743\" type=\"list\" ltype=\"string\">\n";
			   $vm_connections_config .= "	</entry>\n";
			   $vm_connections_config .= "	<entry name=\"uris\" mtime=\"1422033710\" type=\"list\" ltype=\"string\">\n";
			   $vm_connections_config .= "		<li type=\"string\">\n";
			   $vm_connections_config .= "			<stringvalue>qemu:///system</stringvalue>\n";
			   $vm_connections_config .= "		</li>\n";
# 			   $vm_connections_config .= "		<li type=\"string\">\n";
# 			   $vm_connections_config .= "			<stringvalue>qemu+ssh://root\@node01.cobra05.bcn/system</stringvalue>\n";
# 			   $vm_connections_config .= "		</li>\n";
# 			   $vm_connections_config .= "		<li type=\"string\">\n";
# 			   $vm_connections_config .= "			<stringvalue>qemu+ssh://root\@node02.cobra05.bcn/system</stringvalue>\n";
# 			   $vm_connections_config .= "		</li>\n";
			   $vm_connections_config .= "	</entry>\n";
			   $vm_connections_config .= "</gconf>\n";
			
			my $shell_call = "$vm_connections_file";
			open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
			print $file_handle $vm_connections_config;
			close $file_handle;
			$conf->{permissions}{vm_connections}{path}      = "$vm_connections_file";
			$conf->{permissions}{vm_connections}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{vm_connections}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{vm_connections}{mode}      = "600";
			$conf->{permissions}{vm_connections}{recursive} = 0;
		}
		
		# Second, the stats gconf
		my $stats_file = "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/stats/\%gconf.xml";
		if (not -e $stats_file)
		{
			my $stats_config =  "<?xml version=\"1.0\"?>\n";
			   $stats_config .= "<gconf>\n";
			   $stats_config .= "	<entry name=\"enable-net-poll\" mtime=\"1422035543\" type=\"bool\" value=\"true\"/>\n";
			   $stats_config .= "	<entry name=\"enable-disk-poll\" mtime=\"1422035543\" type=\"bool\" value=\"true\"/>\n";
			   $stats_config .= "</gconf>\n";
			
			my $shell_call = "$stats_file";
			open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
			print $file_handle $stats_config;
			close $file_handle;
			$conf->{permissions}{vm_stats}{path}      = "$stats_file";
			$conf->{permissions}{vm_stats}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{vm_stats}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{vm_stats}{mode}      = "600";
			$conf->{permissions}{vm_stats}{recursive} = 0;
		}
		
		# Third, the connections file
		my $vmlist_file = "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/vmlist-fields/\%gconf.xml";
		if (not -e $vmlist_file)
		{
			my $vmlist_config =  "<?xml version=\"1.0\"?>\n";
			   $vmlist_config .= "<gconf>\n";
			   $vmlist_config .= "	<entry name=\"network_traffic\" mtime=\"1422035552\" type=\"bool\" value=\"true\"/>\n";
			   $vmlist_config .= "	<entry name=\"disk_usage\" mtime=\"1422035549\" type=\"bool\" value=\"true\"/>\n";
			   $vmlist_config .= "</gconf>\n";
			
			my $shell_call = "$vmlist_file";
			open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
			print $file_handle $vmlist_config;
			close $file_handle;
			$conf->{permissions}{vm_vmlist}{path}      = "$vmlist_file";
			$conf->{permissions}{vm_vmlist}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{vm_vmlist}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{vm_vmlist}{mode}      = "600";
			$conf->{permissions}{vm_vmlist}{recursive} = 0;
		}
		
		# Fourth, the main config file with the window position info.
		my $vm_core_file = "/home/$conf->{sys}{striker_user}/.gconf/apps/virt-manager/\%gconf.xml";
		if (not -e $vm_core_file)
		{
			my $vm_core_config =  "<?xml version=\"1.0\"?>\n";
			   $vm_core_config .= "<gconf>\n";
			   $vm_core_config .= "	<entry name=\"manager_window_height\" mtime=\"1422049529\" type=\"int\" value=\"620\"/>\n";
			   $vm_core_config .= "	<entry name=\"manager_window_width\" mtime=\"1422049529\" type=\"int\" value=\"700\"/>\n";
			   $vm_core_config .= "</gconf>\n";
			
			my $shell_call = "$vm_core_file";
			open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
			print $file_handle $vm_core_config;
			close $file_handle;
			$conf->{permissions}{vm_core}{path}      = "$vm_core_file";
			$conf->{permissions}{vm_core}{owner}     = "$conf->{sys}{striker_user}";
			$conf->{permissions}{vm_core}{group}     = "$conf->{sys}{striker_user}",
			$conf->{permissions}{vm_core}{mode}      = "600";
			$conf->{permissions}{vm_core}{recursive} = 0;
		}
	}
	
	# Configure the desktop to be 1280 x 1024 (1280 x 960 atm)
	if (1)
	{
		# If this is a QXL-based VM, setup a higher resolution.
		my $is_qxl     = 0;
		my $shell_call = "$conf->{executable}{lspci} -m";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			#print "[ Debug ] - line: [$line]\n";
			if ($line =~ /QXL/i)
			{
				$is_qxl = 1;
				print "- KVM server with QXL graphics detected.\n";
				last;
			}
		}
		close $file_handle;
		
		### TODO: This isn't working yet, fix it later.
		if ($is_qxl)
		{
			print "- Configuring Desktop screen size:\n";
			my $config_dir = "/home/$conf->{sys}{striker_user}/.config";
			if (not -e $config_dir)
			{
				print "- Creating directory: [$config_dir]\n";
				mkdir "$config_dir" or die "$THIS_FILE ".__LINE__."; Failed to create: [$config_dir], error was: $!\n";
				$conf->{permissions}{user_config}{path}      = "$config_dir";
				$conf->{permissions}{user_config}{owner}     = "$conf->{sys}{striker_user}";
				$conf->{permissions}{user_config}{group}     = "$conf->{sys}{striker_user}",
				$conf->{permissions}{user_config}{mode}      = "755";
				$conf->{permissions}{user_config}{recursive} = 0;
			}
			
			my $monitors_file = "/home/$conf->{sys}{striker_user}/.config/monitors.xml";
			if (not -e $monitors_file)
			{
				print "- Creating monitor configuration file: [$monitors_file]\n";
				# First up, the main virt-manager gconf
				my $monitor_config =  "<monitors version=\"1\">\n";
				   $monitor_config .= "  <configuration>\n";
				   $monitor_config .= "      <clone>no</clone>\n";
				   $monitor_config .= "      <output name=\"qxl-0\">\n";
				   $monitor_config .= "          <vendor>Generic</vendor>\n";
				   $monitor_config .= "          <product>0x0000</product>\n";
				   $monitor_config .= "          <serial>0x00000000</serial>\n";
				   $monitor_config .= "          <width>1280</width>\n";
				   $monitor_config .= "          <height>960</height>\n";
				   $monitor_config .= "          <rate>60</rate>\n";
				   $monitor_config .= "          <x>0</x>\n";
				   $monitor_config .= "          <y>0</y>\n";
				   $monitor_config .= "          <rotation>normal</rotation>\n";
				   $monitor_config .= "          <reflect_x>no</reflect_x>\n";
				   $monitor_config .= "          <reflect_y>no</reflect_y>\n";
				   $monitor_config .= "          <primary>no</primary>\n";
				   $monitor_config .= "      </output>\n";
				   $monitor_config .= "      <output name=\"qxl-1\">\n";
				   $monitor_config .= "      </output>\n";
				   $monitor_config .= "      <output name=\"qxl-2\">\n";
				   $monitor_config .= "      </output>\n";
				   $monitor_config .= "      <output name=\"qxl-3\">\n";
				   $monitor_config .= "      </output>\n";
				   $monitor_config .= "  </configuration>\n";
				   $monitor_config .= "</monitors>\n";
				
				my $shell_call = "$monitors_file";
				open (my $file_handle, ">", "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to write to: [$shell_call], error was: $!\n";
				print $file_handle $monitor_config;
				close $file_handle;
				$conf->{permissions}{monitor_config}{path}      = "$monitors_file";
				$conf->{permissions}{monitor_config}{owner}     = "$conf->{sys}{striker_user}";
				$conf->{permissions}{monitor_config}{group}     = "$conf->{sys}{striker_user}",
				$conf->{permissions}{monitor_config}{mode}      = "664";
				$conf->{permissions}{monitor_config}{recursive} = 0;
			}
		}
	}
	
	# Make sure NetworkManager is disabled.
	if (1)
	{
		print "- Disabling 'NetworkManager'\n";
		my $shell_call = "chkconfig NetworkManager off";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call 2>&1") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/\n//;
			   $line =~ s/\r//;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	
	# Make sure network is enabled.
	if (1)
	{
		print "- Enabling 'network'\n";
		my $shell_call = "chkconfig network on";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call 2>&1") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/\n//;
			   $line =~ s/\r//;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	
	print "Done!\n\n";
	
	return(0);
}

# If the user has requested IPMI be configured, do so.
sub configure_ipmi
{
	my ($conf) = @_;
	
	if ((not $conf->{sys}{ipmi_user}) && (not $conf->{sys}{ipmi_ip}))
	{
		# The user hasn't asked for IPMI, so we're out.
		return(0);
	}
	
	# Ok, still alive. We now need to install the packages for IPMI.
	my $ipmi_ok = 1;
	
	print "Configuring IPMI:\n";
	my $to_install = "";
	foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{ipmi_packages}})
	{
		#print "[ Debug ] - packages::installed::$package: [$conf->{packages}{installed}{$package}]\n";
		if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
		{
			$conf->{packages}{ipmi_packages}{$package} = 1;
			print "- IPMI Package: [$package] already installed.\n";
		}
		else
		{
			print "- Package: [$package] needs to be installed.\n";
			$to_install .= "$package ";
		}
	}
	
	# Install anything needed.
	if ($to_install)
	{
		# Install the packages, then verify they actually installed.
		print "- Installing IPMI packages now. Please be patient.\n";
		#print "- [ Note ] Please be patient! It may appear that nothing is happening for a\n";
		#print "- [ Note ] while. This is likely because of how buffering is handled. If you\n";
		#print "- [ Note ] really think nothing is happening, please open a new terminal and\n";
		#print "- [ Note ] look for activity using 'top' or 'ps aux'.\n";
		my $shell_call = "$conf->{executable}{yum} -y install $to_install";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		print "==============================================================================\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			print $_;
		}
		print "==============================================================================\n";
		close $file_handle;
		print "- Done.\n";
		
		# Verify that everything is installed.
		sleep 5;
		get_list_of_installed_packages($conf);
		print "- Verifying that everything is installed now.\n";
		my $missing = 0;
		foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{ipmi_packages}})
		{
			# Watch for autovivication...
			if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
			{
				$conf->{packages}{ipmi_packages}{$package} = 1;
				print "- Package: [$package] installed.\n";
			}
			else
			{
				print "[ Error ] - IPMI Package: [$package] failed to install!\n";
				$missing = 1;
			}
		}
		# If anything is missing, fail.
		if ($missing)
		{
			print "[ Error ] - Not all required packages for IPMI installed properly.\n";
			print "[ Error ]   The install will continue, but please note that IPMI has not been\n";
			print "[ Error ]   configured.\n";
			$ipmi_ok = 0;
		}
		else
		{
			print "- All required packages are now installed.\n\n";
		}
	}
	else
	{
		print "- All required packages already installed.\n";
	}
	
	# Start the ipmi daemon and check that the IPMI device is found.
	if ($ipmi_ok)
	{
		my $shell_call = "if [ ! -e '/dev/ipmi0' ]; 
				then 
					/etc/init.d/ipmi start; 
					if [ ! -e '/dev/ipmi0' ]; 
					then 
						echo 'Failed to start IPMI'; 
						echo 'rc:2'
					else 
						echo 'IPMI started successfully.'; 
						echo 'rc:0'
					fi; 
				else 
					echo 'IPMI already running.'; 
					echo 'rc:1'
				fi";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /^rc:(\d+)/)
			{
				my $rc = $1;
				if ($rc eq "0")
				{
					print "- IPMI daemon started successfully.\n";
				}
				elsif ($rc eq "1")
				{
					print "- IPMI daemon was already running.\n";
				}
				elsif ($rc eq "2")
				{
					print "[ Error ] - IPMI daemon failed to start.\n";
					$ipmi_ok = 0;
				}
			}
			else
			{
				#print "[ Debug ] - output: [$line]\n";
			}
		}
		close $file_handle;
	}
	
	# Configure IPMI.
	my $channel       = 0;
	my $channel_found = 0;
	if ($ipmi_ok)
	{
		print "- Seaching for IPMI LAN channel:\n";
		while (not $channel_found)
		{
			#print "[ Debug ] - channel: [$channel]\n";
			if ($channel > 20)
			{
				# Give up...
				print "[ Error ] - Failed to find the IPMI LAN channel! Giving up.\n";
				$ipmi_ok = 0;
				return($ipmi_ok);
			}
			
			# check to see if this is the write channel
			my $rc         = "";
			my $shell_call = "ipmitool lan print $channel 2>&1; echo rc:\$?";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] - line: [$line]\n";
				if ($line =~ /Invalid channel: /)
				{
					#print "[ Debug ] - Wrong LAN channel: [$channel]\n";
				}
				elsif ($line =~ "rc:0")
				{
					# Found it!
					$channel_found = 1;
					print "- Found the LAN channel: [$channel]!\n";
				}
			}
			close $file_handle;
			$channel++ if not $channel_found;
		}
		#print "[ Debug ] - LAN channel: [$channel]\n";
	}
	
	# Now find the requested user ID number.
	my $user_id       = 0;
	my $user_id_found = 0;
	if (($conf->{sys}{ipmi_user}) && ($ipmi_ok))
	{
		print "- Searching for the user ID for: [$conf->{sys}{ipmi_user}]\n";
		while (not $user_id_found)
		{
			#print "[ Debug ] - user_id: [$user_id]\n";
			if ($user_id > 20)
			{
				# Give up...
				print "[ Warning ] - Failed to find the IPMI admin user ID for: [$conf->{sys}{ipmi_user}].\n";
				$user_id = 0;
				last;
			}
			
			# check to see if this is the write channel
			my $rc         = "";
			my $ipmi_user  = $conf->{sys}{ipmi_user};
			my $shell_call = "ipmitool user list $channel 2>&1";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $filehandle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
			while (<$filehandle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] - line: [$line]\n";
				$line =~ s/\s+/ /g;
				if ($line =~ /^(\d+) $ipmi_user /)
				{
					$user_id       = $1;
					$user_id_found = 1;
					#print "[ Debug ] - Found the user ID: [$user_id]\n";
				}
			}
			$user_id++ if not $user_id_found;
		}
		# Set the password.
		print "- Setting the password for: [$conf->{sys}{ipmi_user} ($user_id)]:\n";
		
		# Set the password.
		my $shell_call = "ipmitool user set password $user_id '$conf->{sys}{ipmi_password}'";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#print "[ Debug ] - line: [$line]\n";
		}
		close $file_handle;
		
		if ($ipmi_ok)
		{
			# Test the password. If this fails with '16', try '20'.
			my $password_ok = 0;
			my $try_20      = 0;
			my $shell_call  = "ipmitool user test $user_id 16 '$conf->{sys}{ipmi_password}'";
			open (my $file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] - line: [$line]\n";
				if ($line =~ /Success/i)
				{
					# Woo!
					print "- IPMI password for: [$conf->{sys}{ipmi_user}] set successfully as a 16-byte string!\n";
				}
				elsif ($line =~ /wrong password size/i)
				{
					$try_20 = 1;
					#print "[ Debug ] - IPMI password is not a 16-byte string, will try 20-byte.\n";
				}
				elsif ($line =~ /password incorrect/i)
				{
					# Password didn't take. :(
					print "[ Error ] - IPMI password failed to be set properly.\n";
					$ipmi_ok = 0;
				}
			}
			close $file_handle;
			
			if ($try_20)
			{
				my $shell_call = "ipmitool user test $user_id 20 '$conf->{sys}{ipmi_password}'";
				#print "[ Debug ] - shell_call: [$shell_call]\n";
				open (my $file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
				while (<$file_handle>)
				{
					chomp;
					my $line = $_;
					#print "[ Debug ] - line: [$line]\n";
					if ($line =~ /Success/i)
					{
						# Woo!
						print "- IPMI password for: [$conf->{sys}{ipmi_user}] set successfully as a 20-byte string!\n";
					}
					elsif ($line =~ /password incorrect/i)
					{
						# Password didn't take. :(
						print "[ Error ] - IPMI password failed to be set properly.\n";
						$ipmi_ok = 0;
					}
				}
				close $file_handle;
			}
		}
	}
	
	# Set the IPMI address if requested.
	if (($conf->{sys}{ipmi_ip}) && ($ipmi_ok))
	{
		# Setup the IPMI IP to static
		my $shell_call = "ipmitool lan set $channel ipsrc static";
		#print "[ Debug ] shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#print "[ Debug ] - return line: [$line]\n";
		}
		close $file_handle;
		
		# Now set the IP
		$shell_call = "ipmitool lan set $channel ipaddr $conf->{sys}{ipmi_ip}";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open ($file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#print "[ Debug ] - return line: [$line]\n";
		}
		close $file_handle;
		
		# Now the netmask
		$shell_call = "ipmitool lan set $channel netmask $conf->{sys}{ipmi_netmask}";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open ($file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#print "[ Debug ] - return line: [$line]\n";
		}
		
		# If the user has specified a gateway, set it
		if ($conf->{sys}{ipmi_gateway})
		{
			my $shell_call = "ipmitool lan set $channel defgw ipaddr $conf->{sys}{ipmi_gateway}";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] - return line: [$line]\n";
			}
			close $file_handle;
		}
		
		### Now read it back.
		# Now the netmask
		$shell_call = "ipmitool lan print $channel";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open ($file_handle, '-|', $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $?\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#print "[ Debug ] - >> return line: [$line]\n";
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			#print "[ Debug ] - << return line: [$line]\n";
			if ($line =~ /IP Address Source/i)
			{
				if ($line =~ /Static/i)
				{
					print "- IPMI IP is static now.\n";
				}
				else
				{
					print "[ Error ] - IPMI IP is NOT static!\n";
					$ipmi_ok = 0;
				}
			}
			if ($line =~ /IP Address :/i)	# Needs the ' :' to not match 'IP Address Source'
			{
				my $ip = ($line =~ /(\d+\.\d+\.\d+\.\d+)$/)[0];
				if ($ip eq $conf->{sys}{ipmi_ip})
				{
					print "- IPMI IP is now: [$conf->{sys}{ipmi_ip}]\n";
				}
				else
				{
					print "[ Error ] - IPMI reported IP: [$ip] doesn't match desired IP: [$conf->{sys}{ipmi_ip}]!\n";
					$ipmi_ok = 0;
				}
			}
			if ($line =~ /Subnet Mask/i)
			{
				my $ip = ($line =~ /(\d+\.\d+\.\d+\.\d+)$/)[0];
				if ($ip eq $conf->{sys}{ipmi_netmask})
				{
					print "- IPMI subnet is now: [$conf->{sys}{ipmi_netmask}]\n";
				}
				else
				{
					print "[ Error ] - IPMI reported subnet: [$ip] doesn't match desired subnet: [$conf->{sys}{ipmi_netmask}]!\n";
					$ipmi_ok = 0;
				}
			}
			if (($line =~ /Default Gateway IP/i) && ($conf->{sys}{ipmi_gateway}))
			{
				my $ip = ($line =~ /(\d+\.\d+\.\d+\.\d+)$/)[0];
				if ($ip eq $conf->{sys}{ipmi_gateway})
				{
					print "- IPMI gateway is now: [$conf->{sys}{ipmi_gateway}]\n";
				}
				else
				{
					print "[ Error ] - IPMI reported gateway: [$ip] doesn't match desired gateway: [$conf->{sys}{ipmi_gateway}]!\n";
					$ipmi_ok = 0;
				}
			}
		}
		close $file_handle;
	}
	
	if ($ipmi_ok)
	{
		print "Done.\n\n";
	}
	else
	{
		print "\n##############################################################################\n";
		print "# [ Error ] - IPMI configuration failed. Please configure IPMI manually!     #\n";
		print "# [ Error ] - Install will attempt to continue.                              #\n";
		print "##############################################################################\n\n";
		sleep 10;
	}
	
	return(0);
}

# This configures DHCP and PXE servers.
sub configure_pxe
{
	my ($conf) = @_;
	
	# Expand these by prepending the docroot.
	$conf->{directory}{centos_pxe_web} = "$conf->{directory}{document_root}/$conf->{directory}{centos_pxe_web}";
	$conf->{directory}{rhel_pxe_web}   = "$conf->{directory}{document_root}/$conf->{directory}{rhel_pxe_web}";
	if ($conf->{switches}{p} eq "none")
	{
		print "PXE configuration disabled, skipping.\n";
	}
	else
	{
		configure_dhcp($conf);
		configure_xinetd($conf);
		configure_iso_source($conf);
		configure_pxe_config($conf);
	}
	
	return(0);
}

# This sets up the install ISOs, if available.
sub configure_iso_source
{
	my ($conf) = @_;
	
	print "Setting up the install ISOs for PXE installs.\n";
	if ($conf->{switches}{'centos-iso'})
	{
		my $file_name  = "";
		my $local_copy = "";
		if ($conf->{switches}{'centos-iso'} eq "none")
		{
			print "- CentOS disabled, skipping.\n";
		}
		else
		{
			print "- CentOS source defined, configuring.\n";
			# Setup the directories.
			my @subdirectories = ($conf->{directory}{centos_pxe_web}, "$conf->{directory}{centos_pxe_web}/x86_64");
			foreach my $subdirectory (@{$conf->{directory}{pxe_iso_subdirs}})
			{
				#print "[ Debug ] - directory::centos_pxe_web: [$conf->{directory}{centos_pxe_web}], subdirectory: [$subdirectory], combined: [$conf->{directory}{centos_pxe_web}/x86_64/$subdirectory]\n";
				push @subdirectories, "$conf->{directory}{centos_pxe_web}/x86_64/$subdirectory";
			}
			foreach my $directory (@subdirectories)
			{
				#print "[ Debug ] - directory: [$directory]\n";
				if (-e $directory)
				{
					print "- Directory already exists: [$directory]\n";
				}
				else
				{
					mkdir $directory or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$directory], error was: $!\n";
					print "- Created: [$directory]\n";
				}
			}
			
			# Ok, acquire it!
			if ($conf->{switches}{'centos-iso'} eq "dvd")
			{
				print "- A CentOS ISO will be generated from the disk in the optical drive.\n";
				my ($rc, $local_copy) = generate_iso($conf, "$conf->{directory}{centos_pxe_web}/x86_64/iso/", "centos");
				# 0 == OK
				# 1 == Rip failed.
				# 2 == Wrong disk.
				# 3 == Device not found
				# 4 == No disc in drive
				# 5 == Resulting image too small
				if ($rc)
				{
					### Errors will already be reported.
					exit(22);
				}
				else
				{
					# \o/
				}
			}
			elsif ($conf->{switches}{'centos-iso'} =~ /:\/\//)
			{
				print "- CentOS ISO appears to be a URL, will attempt to download now...\n";
				   $file_name  = ($conf->{switches}{'centos-iso'} =~ /^.*\/(.*?)$/)[0];
				   $local_copy = "$conf->{directory}{centos_pxe_web}/x86_64/iso/$file_name";
				my $shell_call = "$conf->{executable}{wget} -c $conf->{switches}{'centos-iso'} -O $local_copy";
				#print "[ Debbug ] - shell_call: [$shell_call]\n";
				open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
				print "==============================================================================\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					print "- Output: [$line]\n";
				}
				print "==============================================================================\n";
				close $file_handle;
				
				# Make sure it downloaded.
				if (-e $local_copy)
				{
					print "- Download successful.\n";
				}
				else
				{
					print "[ Error ] - Failed to download: [$conf->{switches}{'centos-iso'}]\n";
					exit(22);
				}
			}
			elsif (-e $conf->{switches}{'centos-iso'})
			{
				print "- CentOS ISO is local, will copy into place.\n";
				$file_name  = ($conf->{switches}{'centos-iso'} =~ /^.*\/(.*?)$/)[0];
				$local_copy = "$conf->{directory}{centos_pxe_web}/x86_64/iso/$file_name";
				if ($local_copy eq $conf->{switches}{'centos-iso'})
				{
					print "- Local copy already in the right place.\n";
				}
				else
				{
					print "- Copying the local ISO into the apache directory.\n";
					rsync_files($conf, "$conf->{switches}{'centos-iso'}", "$conf->{directory}{centos_pxe_web}/x86_64/iso/");
				}
			}
			else
			{
				print "[ Error ] - The CentOS ISO doesn't appear to be valid. Is this right?:\n";
				print "[ Error ]   [$conf->{switches}{'centos-iso'}]\n";
				exit(22);
			}
			
			# If I'm here, we're ready to configure.
			print "- Mounting the ISO: [$local_copy]\n";
			print "- At mount point:   [$conf->{directory}{centos_pxe_web}/x86_64/img/]\n";
			mount_iso($conf, $local_copy, "$conf->{directory}{centos_pxe_web}/x86_64/img/");
			
			# copy the isolinux directory.
			print "- Copying isolinux boot files to TFTP.\n";
			my $isolinux_source = "$conf->{directory}{centos_pxe_web}/x86_64/img/isolinux/*";
			my $isolinux_target = "$conf->{directory}{pxelinux_boot}/$conf->{directory}{centos_tftp_boot}/x86_64/";
			if (not -e $isolinux_target)
			{
				print "- Creating tftp boot target: [$isolinux_target]\n";
				make_path($isolinux_target);
				if (-e $isolinux_target)
				{
					print "- target created.\n";
				}
				else
				{
					print "[ Error ] - Failed!\n";
				}
			}
			rsync_files($conf, "$isolinux_source", "$isolinux_target");
			$conf->{pxe}{centos}{enabled} = 1;
			
			# Write out the kickstart files.
			my $centos_node1_ks         = generate_kickstart($conf, "centos", "node", 1);
			my $centos_node2_ks         = generate_kickstart($conf, "centos", "node", 2);
			my $centos_striker1_ks      = generate_kickstart($conf, "centos", "striker", 1);
			my $centos_striker2_ks      = generate_kickstart($conf, "centos", "striker", 2);
			my $centos_node1_ks_file    = "$conf->{directory}{centos_pxe_web}/x86_64/ks/$conf->{pxe}{centos}{node1_ks}";
			my $centos_node2_ks_file    = "$conf->{directory}{centos_pxe_web}/x86_64/ks/$conf->{pxe}{centos}{node2_ks}";
			my $centos_striker1_ks_file = "$conf->{directory}{centos_pxe_web}/x86_64/ks/$conf->{pxe}{centos}{striker1_ks}";
			my $centos_striker2_ks_file = "$conf->{directory}{centos_pxe_web}/x86_64/ks/$conf->{pxe}{centos}{striker2_ks}";
			
			# Write out the files.
			print "- Writing out CentOS node 01 kickstart file.\n";
			open (my $file_handle, ">", $centos_node1_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$centos_node1_ks_file], the error was: $!\n";
			print $file_handle $centos_node1_ks;
			close $file_handle;
			print "- Wrote: [$centos_node1_ks_file].\n";
			
			print "- Writing out CentOS node 02 kickstart file.\n";
			open ($file_handle, ">", $centos_node2_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$centos_node2_ks_file], the error was: $!\n";
			print $file_handle $centos_node2_ks;
			close $file_handle;
			print "- Wrote: [$centos_node2_ks_file].\n";

			print "- Writing out CentOS striker 01 kickstart file.\n";
			open ($file_handle, ">", $centos_striker1_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$centos_striker1_ks_file], the error was: $!\n";
			print $file_handle $centos_striker1_ks;
			close $file_handle;
			print "- Wrote: [$centos_striker1_ks_file].\n";

			print "- Writing out CentOS striker 02 kickstart file.\n";
			open ($file_handle, ">", $centos_striker2_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$centos_striker2_ks_file], the error was: $!\n";
			print $file_handle $centos_striker2_ks;
			close $file_handle;
			print "- Wrote: [$centos_striker2_ks_file].\n";
			print "- CentOS PXE configuration complete.\n";
		}
	}

	# Now RHEL
	if ($conf->{switches}{'rhel-iso'})
	{
		my $file_name  = "";
		my $local_copy = "";
		if ($conf->{switches}{'rhel-iso'} eq "none")
		{
			print "- RHEL disabled, skipping.\n";
		}
		else
		{
			print "- RHEL source defined, configuring.\n";
			# Setup the directories.
			my @subdirectories = ($conf->{directory}{rhel_pxe_web}, "$conf->{directory}{rhel_pxe_web}/x86_64");
			foreach my $subdirectory (@{$conf->{directory}{pxe_iso_subdirs}})
			{
				push @subdirectories, "$conf->{directory}{rhel_pxe_web}/x86_64/$subdirectory";
			}
			foreach my $directory (@subdirectories)
			{
				if (-e $directory)
				{
					print "- Directory already exists: [$directory]\n";
				}
				else
				{
					mkdir $directory or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$directory], error was: $!\n";
					print "- Created: [$directory]\n";
				}
			}
			
			# Ok, acquire it!
			if ($conf->{switches}{'rhel-iso'} eq "dvd")
			{
				print "- A RHEL ISO will be generated from the disk in the optical drive.\n";
				(my $rc, $local_copy) = generate_iso($conf, "$conf->{directory}{rhel_pxe_web}/x86_64/iso/", "rhel");
				# 0 == OK
				# 1 == Rip failed.
				# 2 == Wrong disk.
				# 3 == Device not found
				# 4 == No disc in drive
				# 5 == Resulting image too small
				if ($rc)
				{
					### Errors will already be reported.
					exit(22);
				}
				else
				{
					# \o/
				}
			}
			elsif ($conf->{switches}{'rhel-iso'} =~ /:\/\//)
			{
				print "- RHEL ISO appears to be a URL, will attempt to download now...\n";
				   $file_name  = ($conf->{switches}{'rhel-iso'} =~ /^.*\/(.*?)$/)[0];
				   $local_copy = "$conf->{directory}{rhel_pxe_web}/x86_64/iso/$file_name";
				my $shell_call = "$conf->{executable}{wget} -c $conf->{switches}{'rhel-iso'} -O $local_copy";
				#print "[ Debbug ] - shell_call: [$shell_call]\n";
				open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
				print "==============================================================================\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					print "- Output: [$line]\n";
				}
				print "==============================================================================\n";
				close $file_handle;
				
				# Make sure it downloaded.
				if (-e $local_copy)
				{
					print "- Download successful.\n";
				}
				else
				{
					print "[ Error ] - Failed to download: [$conf->{switches}{'rhel-iso'}]\n";
					exit(22);
				}
			}
			elsif (-e $conf->{switches}{'rhel-iso'})
			{
				print "- RHEL ISO is local, will copy into place.\n";
				$file_name  = ($conf->{switches}{'rhel-iso'} =~ /^.*\/(.*?)$/)[0];
				$local_copy = "$conf->{directory}{rhel_pxe_web}/x86_64/iso/$file_name";
				if ($local_copy eq $conf->{switches}{'rhel-iso'})
				{
					print "- Local copy already in the right place.\n";
				}
				else
				{
					print "- Copying the local ISO into the apache directory.\n";
					rsync_files($conf, "$conf->{switches}{'rhel-iso'}", "$conf->{directory}{rhel_pxe_web}/x86_64/iso/");
				}
			}
			else
			{
				print "[ Error ] - The RHEL ISO doesn't appear to be valid. Is this right?:\n";
				print "[ Error ]   [$conf->{switches}{'rhel-iso'}]\n";
				exit(22);
			}
			
			# If I'm here, we're ready to configure.
			print "- Mounting the ISO: [$local_copy]\n";
			print "- At mount point:   [$conf->{directory}{rhel_pxe_web}/x86_64/img/]\n";
			mount_iso($conf, $local_copy, "$conf->{directory}{rhel_pxe_web}/x86_64/img/");
			
			# copy the isolinux directory.
			print "- Copying isolinux boot files to TFTP.\n";
			my $isolinux_source = "$conf->{directory}{rhel_pxe_web}/x86_64/img/isolinux/*";
			my $isolinux_target = "$conf->{directory}{pxelinux_boot}/$conf->{directory}{rhel_tftp_boot}/x86_64/";
			if (not -e $isolinux_target)
			{
				print "- Creating tftp boot target: [$isolinux_target]\n";
				make_path($isolinux_target);
				if (-e $isolinux_target)
				{
					print "- target created.\n";
				}
				else
				{
					print "[ Error ] - Failed!\n";
				}
			}
			rsync_files($conf, "$isolinux_source", "$isolinux_target");
			$conf->{pxe}{rhel}{enabled} = 1;
			
			# Write out the kickstart files.
			my $rhel_node1_ks         = generate_kickstart($conf, "rhel", "node", 1);
			my $rhel_node2_ks         = generate_kickstart($conf, "rhel", "node", 2);
			my $rhel_striker1_ks      = generate_kickstart($conf, "rhel", "striker", 1);
			my $rhel_striker2_ks      = generate_kickstart($conf, "rhel", "striker", 2);
			my $rhel_node1_ks_file    = "$conf->{directory}{rhel_pxe_web}/x86_64/ks/$conf->{pxe}{rhel}{node1_ks}";
			my $rhel_node2_ks_file    = "$conf->{directory}{rhel_pxe_web}/x86_64/ks/$conf->{pxe}{rhel}{node2_ks}";
			my $rhel_striker1_ks_file = "$conf->{directory}{rhel_pxe_web}/x86_64/ks/$conf->{pxe}{rhel}{striker1_ks}";
			my $rhel_striker2_ks_file = "$conf->{directory}{rhel_pxe_web}/x86_64/ks/$conf->{pxe}{rhel}{striker2_ks}";
			
			# Write out the files.
			print "- Writing out RHEL node 01 kickstart file.\n";
			open (my $file_handle, ">", $rhel_node1_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$rhel_node1_ks_file], the error was: $!\n";
			print $file_handle $rhel_node1_ks;
			close $file_handle;
			print "- Wrote: [$rhel_node1_ks_file].\n";
			
			print "- Writing out RHEL node 02 kickstart file.\n";
			open ($file_handle, ">", $rhel_node2_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$rhel_node2_ks_file], the error was: $!\n";
			print $file_handle $rhel_node2_ks;
			close $file_handle;
			print "- Wrote: [$rhel_node2_ks_file].\n";

			print "- Writing out RHEL striker 01 kickstart file.\n";
			open ($file_handle, ">", $rhel_striker1_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$rhel_striker1_ks_file], the error was: $!\n";
			print $file_handle $rhel_striker1_ks;
			close $file_handle;
			print "- Wrote: [$rhel_striker1_ks_file].\n";

			print "- Writing out RHEL striker 02 kickstart file.\n";
			open ($file_handle, ">", $rhel_striker2_ks_file) or die "$THIS_FILE ".__LINE__."; Failed to write: [$rhel_striker2_ks_file], the error was: $!\n";
			print $file_handle $rhel_striker2_ks;
			close $file_handle;
			print "- Wrote: [$rhel_striker2_ks_file].\n";
			print "- RHEL PXE configuration complete.\n";
		}
	}
	print "Done!\n\n";

	return(0);
}

# This generates an ISO from the disc in an optical drive.
sub generate_iso
{
	my ($conf, $output_directory, $distro) = @_;
	
	# 0 == OK
	# 1 == Rip failed.
	# 2 == Wrong disk.
	# 3 == Device not found
	# 4 == No disc in drive
	# 5 == Resulting image too small
	my $return_code = 0;
	
	# Some variables.
	my $device      = "";
	my $volume      = "";
	my $file_name   = "";
	
	if ($distro eq "rhel")
	{
		print "- Generating a RHEL disk image from the DVD in the optical drive.\n";
	}
	elsif ($distro eq "centos")
	{
		print "- Generating a CentOS disk image from the DVD in the optical drive.\n";
	}
	# To divine the file name, and to confirm the disc is still available,
	# I need to check the disc.
	my $shell_call = "cd-info --dvd --no-cddb --no-device-info --no-disc-mode --no-vcd";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /CD location\s+:\s+(.*)/i)
		{
			$device = $1;
		}
		elsif ($line =~ /Volume\s+:\s+(.*)/i)
		{
			$volume = $1;
		}
		elsif ($line =~ /No medium found/i)
		{
			print "[ Error ] - No disc found in the optical drive.\n";
			$return_code = 4;
			last;
		}
		else
		{
			#print " cd-info:$line\n";
		}
	}
	close $file_handle;
	
	# Now make sure we're sane.
	if (not $device)
	{
		print "[ Error ] - Unable to find an optical drive.\n";
		$return_code = 3;
	}
	elsif ($volume)
	{
		if (($distro eq "rhel") && ($volume !~ /RHEL-6/i))
		{
			# Not a RHEL 6 disk.
			$return_code = 2;
			print "[ Error ] - Disk in drive is labelled: [$volume],\n";
			print "[ Error ]   which does not appear to be a RHEL 6 disk.\n";
		}
		elsif (($distro eq "centos") && ($volume !~ /CentOS_6/))
		{
			# Not a CentOS 6 disk.
			$return_code = 2;
			print "[ Error ] - Disk in drive is labelled: [$volume],\n";
			print "[ Error ]   which does not appear to be a CentOS 6 disk.\n";
		}
	}
	
	# Are we ready?
	if (not $return_code)
	{
		# Yup!
		print "- Creating image of optical disk.\n";
		$volume    =~ s/ /_/g;
		$file_name =  "$output_directory/$volume.iso";
		if (-e $file_name)
		{
			print "- Output file: [$file_name]\n";
			print "  already exists, skipping ISO generation.\n";
		}
		else
		{
			print "  Please be patient as this might take a few minutes.\n";
			my $iso_size   = 0;
			my $shell_call = "dd if=$device of=$file_name bs=1M";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				#print "[ Debug ] - line: [$line]\n";
				if ($line =~ /(\d+) bytes/)
				{
					$iso_size = $1;
					#print "[ Debug ] - iso_size: [$iso_size]\n";
				}
			}
			close $file_handle;
			
			# Make sure it's at least 50 MiB
			if (-e $file_name)
			{
				#print "[ Debug ] - iso_size: [$iso_size]\n";
				#	        3782213632
				if ($iso_size > 52428800)
				{
					# Looks good!
					print "- Output file: [$file_name]\n";
					print "  Write complete!\n";
				}
				else
				{
					print "- Output file: [$file_name]\n";
					print "[ Error ] - Write appears to be too small.\n";
					$return_code = 5;
				}
			}
			else
			{
				print "[ Error ] - Write appears to have failed. The output file:\n";
				print "[ Error ]   [$file_name] wasn't created.\n";
				$return_code = 1;
			}
		}
	}
	
	return($return_code, $file_name);
}

### NOTE: Not used currently.
# Unmounts an ISO
sub unmount_iso
{
	my ($conf, $target) = @_;
	
	# First make sure the target isn't already mounted.
	my $shell_call = "$conf->{executable}{umount} $target; echo \"umount:\$?\"";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^umount:(\d+)/)
		{
			my $rc = $1;
			if ($rc == 0)
			{
				print "- Unmounted successfully\n";
			}
			elsif ($rc == 1)
			{
				print "- Was already unmounted!\n";
			}
		}
		#print "- Output: [$line]\n";
	}
	close $file_handle;
	
	return(0);
}

# Mounts an ISO at the specified path, if not already mounted.
sub mount_iso
{
	my ($conf, $source, $target) = @_;
	
	# First make sure the target isn't already mounted.
	   $source     =~ s/\/\//\//g;
	my $iso_file   =  ($source =~ /^.*\/(.*)$/)[0];
	my $shell_call =  "if \$(grep -q $source /etc/fstab);
			then
				echo 'already added to /etc/fstab';
			else
				echo '$source $target auto loop 0 0' >> /etc/fstab;
				echo 'added ISO to /etc/fstab';
			fi;
			if \$(mount | grep -q $iso_file);
			then
				echo 'already mounted';
			else
				mount $target;
				echo mount:$?; 
			fi";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /already added/)
		{
			print "- ISO file: [$iso_file] already in '/etc/fstab'.\n";
		}
		if ($line =~ /added ISO/)
		{
			print "- ISO file: [$iso_file] added to '/etc/fstab'.\n";
		}
		if ($line =~ /already mounted/)
		{
			print "- ISO file: [$iso_file] Was already mounted!\n";
		}
		if ($line =~ /^mount:(\d+)/)
		{
			my $rc = $1;
			if ($rc == 0)
			{
				print "- ISO file: [$iso_file] was mounted successfully.\n";
			}
			else
			{
				print "[ Warning ] - ISO file: [$iso_file] appears to have NOT mounted!\n";
				print "[ Warning ]   Return code was: [$rc], expected '0'.\n";
			}
		}
		#print "- Output: [$line]\n";
	}
	close $file_handle;
	
	return(0);
}

# This generates a kickstart file.
sub generate_kickstart
{
	my ($conf, $os, $machine, $number) = @_;
	
	my $short_os_name = $conf->{pxe}{centos}{short_name};
	my $machine_name  = "new-node0$number";
	if ($os eq "rhel")
	{
		$short_os_name = $conf->{pxe}{rhel}{short_name};
	}
	if ($machine eq "striker")
	{
		$machine_name = "new-striker0$number";
	}
	
	my $domain_name = ($conf->{sys}{hostname} =~ /^.*?\.(.*)$/)[0];
	   $domain_name = "localdomain" if not $domain_name;
	
	# Common part.
	my $kickstart = "
# Generated by: [$THIS_FILE] on: [".get_date($conf)."].

### Setup values.
# Doing a full, text-based install.
install
text

# This is the web server with the installation image.
url --url=http://$conf->{network}{bcn}{ip}/$short_os_name/x86_64/img/

# Set the language and keyboard to en_US, UTF-8. Adjust as needed.
lang en_US.UTF-8
keyboard us

# Set the timezone to Eastern Standard/Daylight Time. To get your preferred
# time zone, run 'tzselect'. When finished, looks for the line like:
# - Therefore TZ='America/Toronto' will be used.
# Take the value in \"TZ='...'\" and use it below.
timezone --utc America/Toronto

# This sets the (first) ethernet device. There is currently no way to map
# device names to physical interfaces. For this reason, I use DHCP for install
# and configure the network manually post-install.
network --device eth0 --bootproto dhcp --onboot yes --hostname $machine_name.$domain_name

# This is the root user's password, which is \"Initial1\". To change this, set
# the password you want for a user on an existing system. Once set, look in
# '/etc/shadow' for the line starting with the user name whom you set the
# password for.
authconfig --enableshadow --passalgo=sha512 --enablefingerprint
rootpw --iscrypted \$6\$W8AdoMvC\$ZX87YTlVdutpsmsISVEqEkblJLPilP46PNTACN2r2MRzH2xgBOFciZgFsx7f5i07scC/fjNuR/B5Y2eOLXpz31

# In a production system, you will likely want to enable a firewall and
# SELinux. Given that this script is likely to be used while learning though,
# I turn them both off to reduce potential problems. Please be sure to build a
# firewall (Shorewall is good) and to re-enable SELinux as final steps before
# going into production. This way you will be able to focus on resolving issues
# specific to firewalling and SELinux without wondering if problems are caused
# by the general configuration.
firewall --service=ssh
";
	if ($machine eq "striker")
	{
		$kickstart .= "selinux --permissive\n";
	}
	else
	{
		$kickstart .= "selinux --enforcing\n";
	}
	$kickstart .= "
	
# Given how often I rebuild machines, I like to pre-define the initial user and
# thus skip 'firstboot' to save time.
firstboot --disable

# We don't enable auto-reboot because we want the user to stop the DHCP server
# on the BCN before rebooting to make sure the first boot picks up an IP from
# the normal, Internet-connected DHCP server.
#reboot

# This runs a script (below) that generates the partitioning information
# depending on a rudamentary test for available storage devices.
\%include /tmp/part-include

# This is a very, very minimal installation. It's suitable for testing install
# programs or for machines with the minimal attack surface area.
\%packages
\@core
\@server-policy
perl
\%end

# Tell the machine to save downloaded RPM updates (for possible distribution to
# other machines for low-bandwidth users). It also makes sure all NICs start on
# boot.
\%post
sed -i 's/keepcache=0/keepcache=1/g' /etc/yum.conf
#for nic in \$(ls /etc/sysconfig/network-scripts/ifcfg-eth*); do sed -i 's/ONBOOT=.*/ONBOOT=\"yes\"/' \$nic; done

# Disable DNS lookup for SSH so that logins are quick when there is not Internet
# access.
sed -i 's/#UseDNS yes/UseDNS no/' /etc/ssh/sshd_config 
sed -i 's/#GSSAPIAuthentication no/GSSAPIAuthentication no/' /etc/ssh/sshd_config
sed -i 's/GSSAPIAuthentication yes/#GSSAPIAuthentication yes/' /etc/ssh/sshd_config

# Show details on boot.
plymouth-set-default-theme details -R

";
	
	my $os_directory = "c6";
	my $say_os       = "CentOS";
	if ($os eq "rhel")
	{
		$os_directory = "rhel6";
		$say_os       = "RHEL";
	}
	### TODO: Enable an option to setup this machine as a local repo
	if (0)
	{
		$kickstart .= "
# Add local repos
cat > /etc/yum.repos.d/striker-$conf->{sys}{hostname}-$os.repo << EOF
[striker-$conf->{sys}{hostname}-bcn_$os]
name=Striker $conf->{sys}{hostname}'s $say_os 6 BCN repo.
baseurl=http://$conf->{network}{bcn}{ip}/$os_directory/x86_64/img/
enabled=1
gpgcheck=0

[striker-$conf->{sys}{hostname}-ifn_$os]
name=Striker $conf->{sys}{hostname}'s $say_os 6 IFN repo.
baseurl=http://$conf->{network}{ifn}{ip}/$os_directory/x86_64/img/
enabled=1
gpgcheck=0
EOF
";
	}
	$kickstart .= "
\%end

### Script to setup partitions.
\%pre --log=/tmp/ks-preinstall.log

#!/bin/sh

# Prepare the disks in the script below. It checks '/proc/partitions' to see
# what configuration to use. It's obviously just a basic script, and should 
# be customized for each use-case. IE: RAID 5 doesn't make sense with disks >
# 1 TB... etc.
";

	if ($machine eq "node")
	{
		$kickstart .= "
###############################################################################
# Below is for 40 GiB / partitions with the balance of free space to be       #
# configured later.                                                           #
###############################################################################

DRIVE=\"sda\";

### SATA disks
# EeeBox machine
if grep -q sdb /proc/partitions; then
	DRIVE=\"sdb\"
# /dev/vda KVM virtual machine
elif grep -q vda /proc/partitions; then
	DRIVE=\"vdb\"
fi

# Zero-out the first 100GB to help avoid running into problems when a node that
# was previously in a cluster gets rebuilt.
dd if=/dev/zero of=/dev/\${DRIVE} bs=4M count=25000

# Now write the partition script
cat >> /tmp/part-include <<END

zerombr
clearpart --all --drives=\${DRIVE}
ignoredisk --only-use=\${DRIVE}
bootloader --location=mbr --driveorder=\${DRIVE}

part     /boot --fstype ext4 --size=512   --asprimary --ondisk=\${DRIVE}
part     swap  --fstype swap --size=4096  --asprimary --ondisk=\${DRIVE}
part     /     --fstype ext4 --size=40960 --asprimary --ondisk=\${DRIVE}

END

\%end
";
	}
	elsif ($machine eq "striker")
	{
		# This is the storage for nodes with all remaining space.
		$kickstart .= "
###############################################################################
# Below is for full disk / partitions suitable for striker dashboards and     #
# generic VMs.                                                                #
###############################################################################

DRIVE=\"sda\";

### SATA disks
# EeeBox machine
if grep -q sdb /proc/partitions; then
	DRIVE=\"sdb\";
# /dev/vda KVM virtual machine
elif grep -q vda /proc/partitions; then
	DRIVE=\"vda\";
fi

cat >> /tmp/part-include <<END

zerombr
clearpart --all --drives=sdb
ignoredisk --only-use=sdb
bootloader --location=mbr --driveorder=sdb

part     /boot --fstype ext4 --size=512  --asprimary --ondisk=sdb
part     swap  --fstype swap --size=4096 --asprimary --ondisk=sdb
part     /     --fstype ext4 --size=100  --asprimary --ondisk=sdb --grow

END

\%end
";
	}
	
	return($kickstart);
}

# This configures the PXE server itself.
sub configure_pxe_config
{
	my ($conf) = @_;
	
	print "Configuring PXE server configuration files.\n";
	if (-e $conf->{path}{pxe_default_config})
	{
		backup_file($conf, $conf->{path}{pxe_default_config});
	}
	
	my $pxe_background = ($conf->{path}{pxe_background_source} =~ /^.*\/(.*)$/)[0];
	my $default_config = "
# Use the high-colour menu system.
UI vesamenu.c32
 
# Time out and use the default menu option. Defined as tenths of a second.
TIMEOUT 600
 
# Prompt the user. Set to '1' to automatically choose the default option. This
# is really meant for files matched to MAC addresses.
PROMPT 0
 
# Set the boot menu to be 1024x768 with a nice background image. Be careful to
# ensure that all your user's can see this resolution! Default is 640x480.
MENU RESOLUTION 1024 768

# The background image
MENU BACKGROUND $pxe_background
 
# These do not need to be set. I set them here to show how you can customize or
# localize your PXE server's dialogue.
MENU TITLE    Anvil! node and Striker dashboard install server

# Below, the hash (#) character is replaced with the countdown timer. The
# '{,s}' allows for pluralizing a word and is used when the value is >= '2'.
MENU AUTOBOOT Will boot the next device as configured in your BIOS in # second{,s}.
MENU TABMSG   Press the <tab> key to edit the boot parameters of the highlighted option.
MENU NOTABMSG Editing of this option is disabled.
 
# The following options set the various colours used in the menu. All possible
# options are specified except for F# help options. The colour is expressed as
# two hex characters between '00' and 'ff' for alpha, red, green and blue
# respectively (#AARRGGBB).
# Format is: MENU COLOR <Item> <ANSI Seq.> <foreground> <background> <shadow type>
MENU COLOR screen      0  #80ffffff #00000000 std      # background colour not covered by the splash image
MENU COLOR border      0  #ffffffff #ee000000 std      # The wire-frame border
MENU COLOR title       0  #ffff3f7f #ee000000 std      # Menu title text
MENU COLOR sel         0  #ff00dfdf #ee000000 std      # Selected menu option
MENU COLOR hotsel      0  #ff7f7fff #ee000000 std      # The selected hotkey (set with ^ in MENU LABEL)
MENU COLOR unsel       0  #ffffffff #ee000000 std      # Unselected menu options
MENU COLOR hotkey      0  #ff7f7fff #ee000000 std      # Unselected hotkeys (set with ^ in MENU LABEL)
MENU COLOR tabmsg      0  #c07f7fff #00000000 std      # Tab text
MENU COLOR timeout_msg 0  #8000dfdf #00000000 std      # Timout text
MENU COLOR timeout     0  #c0ff3f7f #00000000 std      # Timout counter
MENU COLOR disabled    0  #807f7f7f #ee000000 std      # Disabled menu options, including SEPARATORs
MENU COLOR cmdmark     0  #c000ffff #ee000000 std      # Command line marker - The '> ' on the left when editing an option
MENU COLOR cmdline     0  #c0ffffff #ee000000 std      # Command line - The text being edited
# Options below haven't been tested, descriptions may be lacking.
MENU COLOR scrollbar   0  #407f7f7f #00000000 std      # Scroll bar
MENU COLOR pwdborder   0  #80ffffff #20ffffff std      # Password box wire-frame border
MENU COLOR pwdheader   0  #80ff8080 #20ffffff std      # Password box header
MENU COLOR pwdentry    0  #80ffffff #20ffffff std      # Password entry field
MENU COLOR help        0  #c0ffffff #00000000 std      # Help text, if set via 'TEXT HELP ... ENDTEXT'
 
### Now define the menu options
 
# I feel it is safest to return booting to the client as the first and default
# option. This entry below will do just that.
LABEL next
	MENU LABEL ^1) Boot the next device as configured in your BIOS
	MENU DEFAULT
	localboot
";
	my $centos_short = $conf->{pxe}{centos}{short_name};
	my $rhel_short   = $conf->{pxe}{rhel}{short_name};
	my $i = 1;
	if ($conf->{pxe}{centos}{enabled})
	{
		$i++;
		$default_config .= "
LABEL generic-centos-anvil-node1
        MENU LABEL ^$i) Anvil! m2 Node 01 - CentOS 6
	TEXT HELP
		Installs a generic Anvil! m2 node 01 using CentOS 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, 40 GiB /.
	ENDTEXT
        KERNEL boot/$centos_short/x86_64/vmlinuz
        APPEND initrd=boot/$centos_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/ks/$conf->{pxe}{centos}{node1_ks}
";
		$i++;
		$default_config .= "
LABEL generic-centos-anvil-node2
        MENU LABEL ^$i) Anvil! m2, Node 02 - CentOS 6
	TEXT HELP
		Installs a generic Anvil! m2 node 02 using CentOS 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, 40 GiB /.
	ENDTEXT
        KERNEL boot/$centos_short/x86_64/vmlinuz
        APPEND initrd=boot/$centos_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/ks/$conf->{pxe}{centos}{node2_ks}
";
	}
	if ($conf->{pxe}{rhel}{enabled})
	{
		$i++;
		$default_config .= "
LABEL generic-rhel-anvil-node
        MENU LABEL ^$i) Anvil! m2, Node 01 - RHEL 6
	TEXT HELP
		Installs a generic Anvil! m2 node 01 using RHEL 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, 40 GiB /.
	ENDTEXT
        KERNEL boot/$rhel_short/x86_64/vmlinuz
        APPEND initrd=boot/$rhel_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/ks/$conf->{pxe}{rhel}{node1_ks}
";
		$i++;
		$default_config .= "
LABEL generic-rhel-anvil-node
        MENU LABEL ^$i) Anvil! m2, Node 02 - RHEL 6
	TEXT HELP
		Installs a generic Anvil! m2 node 02 using RHEL 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, 40 GiB /.
	ENDTEXT
        KERNEL boot/$rhel_short/x86_64/vmlinuz
        APPEND initrd=boot/$rhel_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/ks/$conf->{pxe}{rhel}{node2_ks}
";
	}
	if ($conf->{pxe}{centos}{enabled})
	{
		$i++;
		$default_config .= "
LABEL generic-centos-striker
        MENU LABEL ^$i) Striker 01 Dashboard - CentOS 6
	TEXT HELP
		Installs a generic Striker 01 dashboard using CentOS 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, remainder for /.
	ENDTEXT
        KERNEL boot/$centos_short/x86_64/vmlinuz
        APPEND initrd=boot/$centos_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/ks/$conf->{pxe}{centos}{striker1_ks}
";
		$i++;
		$default_config .= "
LABEL generic-centos-striker
        MENU LABEL ^$i) Striker 02 Dashboard - CentOS 6
	TEXT HELP
		Installs a generic Striker 02 dashboard using CentOS 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, remainder for /.
	ENDTEXT
        KERNEL boot/$centos_short/x86_64/vmlinuz
        APPEND initrd=boot/$centos_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$centos_short/x86_64/ks/$conf->{pxe}{centos}{striker2_ks}
";
	}
	if ($conf->{pxe}{rhel}{enabled})
	{
		$i++;
		$default_config .= "
LABEL generic-rhel-striker
        MENU LABEL ^$i) Striker 01 Dashboard - RHEL 6
	TEXT HELP
		Installs a generic Striker 01 dashboard using RHEL 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, remainder for /.
	ENDTEXT
        KERNEL boot/$rhel_short/x86_64/vmlinuz
        APPEND initrd=boot/$rhel_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/ks/$conf->{pxe}{rhel}{striker1_ks}
";
		$i++;
		$default_config .= "
LABEL generic-rhel-striker
        MENU LABEL ^$i) Striker 02 Dashboard - RHEL 6
	TEXT HELP
		Installs a generic Striker 02 dashboard using RHEL 6. Will create a
		traditional /boot + MBR install for systems with traditional BIOSes.
		Partition will be 0.5 GiB /boot, 4 GiB <swap>, remainder for /.
	ENDTEXT
        KERNEL boot/$rhel_short/x86_64/vmlinuz
        APPEND initrd=boot/$rhel_short/x86_64/initrd.img inst.repo=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/img/ ks=http://$conf->{network}{bcn}{ip}/$rhel_short/x86_64/ks/$conf->{pxe}{rhel}{striker2_ks}
";
	}
	
	# Write out the new one.
	print "- Writing out dhcp daemon configuration file.\n";
	open (my $file_handle, ">", $conf->{path}{pxe_default_config}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{pxe_default_config}], the error was: $!\n";
	print $file_handle $default_config;
	close $file_handle;
	
	# Copy the PXE menu background into place.
	print "- Copying PXE server's wallpaper into place.\n";
	rsync_files($conf, "$conf->{path}{pxe_background_source}", "$conf->{directory}{pxelinux}/");
	
	print "Done.\n\n";
	
	return(0);
}

# Configure xinetd to enable tftp access.
sub configure_xinetd
{
	my ($conf) = @_;
	
	print "Configuring xinetd/tftp server for PXE installs.\n";
	if (-e $conf->{path}{xinetd_tftp_config})
	{
		backup_file($conf, $conf->{path}{xinetd_tftp_config});
	}
	
	print "- Reading in current: [$conf->{path}{xinetd_tftp_config}]\n";
	my $xinetd_tftp_config = "";
	my $shell_call         = $conf->{path}{xinetd_tftp_config};
	open (my $file_handle, "<", $shell_call) or die "$THIS_FILE ".__LINE__."; Failed to read: [$shell_call], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		#print "[ Debug ] >> line: [$line]\n";
		$line =~ s/^(\s+)disable(\s+)=.*$/${1}disable${2}= no/;
		#print "[ Debug ] << line: [$line]\n";
		
		$xinetd_tftp_config .= "$line\n";
	}
	close $file_handle;
	# Next, write it out.
	print "- Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{xinetd_tftp_config}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{xinetd_tftp_config}], the error was: $!\n";
	print $file_handle $xinetd_tftp_config;
	close $file_handle;
	
	print "- Verifying the PXE config directory exists.\n";
	if (not -e $conf->{directory}{pxelinux_config})
	{
		mkdir $conf->{directory}{pxelinux_config} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{pxelinux_config}], error was: $!\n";
		print "- Created: [$conf->{directory}{pxelinux_config}]\n";
	}
	
	print "- Verifying the PXE boot directory exists.\n";
	if (not -e $conf->{directory}{pxelinux_boot})
	{
		mkdir $conf->{directory}{pxelinux_boot} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{pxelinux_boot}], error was: $!\n";
		print "- Created: [$conf->{directory}{pxelinux_boot}]\n";
	}
	print "Done.\n\n";
	
	return(0);
}

# This sets up DHCP
sub configure_dhcp
{
	my ($conf) = @_;
	
	print "Configuring DHCP server for PXE installs.\n";
	# Backup any existing config.
	if (-e $conf->{path}{dhcpd_conf})
	{
		backup_file($conf, $conf->{path}{dhcpd_conf});
	}
	
	# If the user didn't specify a BCN IP, then read it from the config
	# file. If that doesn't exist, fail.
	my $ifcfg_file = "";
	#print "[ Debug ] ".__LINE__."; - network::bcn::ip: [$conf->{network}{bcn}{ip}]\n";
	if (not $conf->{network}{bcn}{ip})
	{
		# BCN not specified.
		if (-e "$conf->{path}{network_configs}/ifcfg-bcn_bond1")
		{
			# Read in the IP from the bond file.
			   $ifcfg_file = "$conf->{path}{network_configs}/ifcfg-bcn_bond1";
			my $shell_call = "grep -e IPADDR -e NETMASK $ifcfg_file";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				   $line =~ s/"//g;
				#print "[ Debug ] - line: [$line]\n";
				if ($line =~ /IPADDR=(\d+\.\d+\.\d+\.\d+)/i)
				{
					$conf->{network}{bcn}{ip} = $1;
					#print "[ Debug ] ".__LINE__."; - network::bcn::ip: [$conf->{network}{bcn}{ip}]\n";
				}
				if ($line =~ /NETMASK=(\d+\.\d+\.\d+\.\d+)/i)
				{
					$conf->{network}{bcn}{netmask} = $1;
					#print "[ Debug ] ".__LINE__."; - network::bcn::netmask: [$conf->{network}{bcn}{netmask}]\n";
				}
			}
			close $file_handle;
		}
		elsif (-e "$conf->{path}{network_configs}/ifcfg-bcn_link1")
		{
			# Read in the IP from the link file
			   $ifcfg_file = "$conf->{path}{network_configs}/ifcfg-bcn_link1";
			my $shell_call = "grep IPADDR $ifcfg_file";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				   $line =~ s/"//g;
				#print "[ Debug ] - line: [$line]\n";
				if ($line =~ /IPADDR=(\d+\.\d+\.\d+\.\d+)/i)
				{
					$conf->{network}{bcn}{ip} = $1;
					#print "[ Debug ] ".__LINE__."; - network::bcn::ip: [$conf->{network}{bcn}{ip}]\n";
				}
				if ($line =~ /NETMASK=(\d+\.\d+\.\d+\.\d+)/i)
				{
					$conf->{network}{bcn}{netmask} = $1;
					#print "[ Debug ] ".__LINE__."; - network::bcn::netmask: [$conf->{network}{bcn}{netmask}]\n";
				}
			}
			close $file_handle;
		}
		else
		{
			# Error out.
			print "[ Error ] - PXE configuration was requested but the BCN IP wasn't specified.\n";
			print "[ Error ]   Tried to read the current BCN IP from either config file:\n";
			print "[ Error ]   - Bond: [$conf->{path}{network_configs}/ifcfg-bcn_bond1]\n";
			print "[ Error ]   - Link: [$conf->{path}{network_configs}/ifcfg-bcn_link1]\n";
			print "[ Error ]   Neither was found, so the BCN IP can not be determined. There is\n";
			print "[ Error ]   no way to configure the DHCP server.\n";
			print "[ Error ] - Install exiting.\n\n";
			exit(26);
		}
	}
	
	# See if we have the IP now.
	#print "[ Debug ] ".__LINE__."; - network::bcn::ip: [$conf->{network}{bcn}{ip}]\n";
	if (not $conf->{network}{bcn}{ip})
	{
		# Error out.
		print "[ Error ] - PXE configuration was requested but the BCN IP wasn't specified.\n";
		print "[ Error ]   Tried to read the IP from: [$ifcfg_file]\n";
		print "[ Error ]   but the IP address wasn't defined (or found).\n";
		print "[ Error ] - Install exiting.\n\n";
		exit(27);
	}
	
	### TODO: I have no checks yet to verify that the lease range is in the
	###       BCN subnet... Fix that.
	my $domain_name = ($conf->{sys}{hostname} =~ /^.*?\.(.*)$/)[0];
	   $domain_name = "localdomain" if not $domain_name;
	my $bcn_network = "";
	if ($conf->{network}{bcn}{netmask} eq "255.255.0.0")
	{
		$bcn_network =  ($conf->{network}{bcn}{ip} =~ /^(\d+\.\d+\.)/)[0];
		$bcn_network .= "0.0";
	}
	if ($conf->{network}{bcn}{netmask} eq "255.255.255.0")
	{
		$bcn_network =  ($conf->{network}{bcn}{netmask} =~ /^(\d+\.\d+\.\d+\.)/)[0];
		$bcn_network .= "0";
	}
	#print "[ Debug ] ".__LINE__."; - network::bcn::netmask: [$conf->{network}{bcn}{netmask}]\n";
	my $dhcpd_config = "
# Generated by: [$THIS_FILE] on: [".get_date($conf)."].
# DHCP Daemon config for PXE-based installs of nodes and striker dashboards.

### Global options
# General domain information
option domain-name \"$domain_name\";
option domain-name-servers $conf->{network}{ifn}{dns1}, $conf->{network}{ifn}{dns2};
 
# Tell the server that it's authoritative on our network.
authoritative;
 
# This controls how dynamic DNS updating is handled. In our case, we aren't
# concerned about DDNS so we'll set it to 'none'.
ddns-update-style none;
 
### Subnet options
subnet $bcn_network netmask $conf->{network}{bcn}{netmask} {
	# These two options tell clients where to go to get the file needed to
	# start the boot process.
        next-server $conf->{network}{bcn}{ip};
        filename \"pxelinux.0\";
 
	# Our servers are installed on the BCN where they have no Internet
	# access, so this value is largely meaningless. We set it to this
	# machine for reasons.
	option routers $conf->{network}{bcn}{ip};
 
	# Set our range. This can be whatever you want so long as it fits in
	# your netmask.
        range $conf->{switches}{lease_start} $conf->{switches}{lease_end};
 
	# If clients don't ask, make the lease available for the following
	# number of seconds. If the client does ask, allow up to this number of
	# seconds. Being that we're only handing out IPs long enough to install
	# an OS, we can keep this quite short. One hour is more than enough.
	default-lease-time 3600;
	max-lease-time 3600;
}
\n";
	
	# Write out the new one.
	print "- Writing out dhcp daemon configuration file.\n";
	open (my $file_handle, ">", $conf->{path}{dhcpd_conf}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{dhcpd_conf}], the error was: $!\n";
	print $file_handle $dhcpd_config;
	close $file_handle;
	print "Done.\n\n";
	
	return(0);
}

# This is call restart or stop on daemons and makes sure they're set to (not)
# run on boot.
sub manage_daemons
{
	my ($conf) = @_;
	
	print "Configuring daemons to start/stop on boot and start/stop daemons.\n";
	foreach my $daemon (@{$conf->{daemons}{disable}})
	{
		# No sense proceeding if the daemon doesn't exist.
		next if not -e "/etc/init.d/$daemon";
		my $shell_call = "$conf->{executable}{chkconfig} $daemon off && /etc/init.d/$daemon stop";
		if ($daemon eq "NetworkManager")
		{
			$shell_call = "$conf->{executable}{chkconfig} $daemon off";
			print "- Disabling: [$daemon] on boot but NOT stopping it.\n";
		}
		else
		{
			print "- Disabling: [$daemon] on boot and stopping it.\n";
		}
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call 2>&1") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\n//g;
			$line =~ s/\r//g;
			#print "- Output: [$line]\n";
		}
		close $file_handle;
		sleep 1;
	}
	foreach my $daemon (@{$conf->{daemons}{enable}})
	{
		# No sense proceeding if the daemon doesn't exist.
		next if not -e "/etc/init.d/$daemon";
		my $shell_call = "$conf->{executable}{chkconfig} $daemon on && /etc/init.d/$daemon restart";
		if ($daemon eq "network")
		{
			# Checkconfig only
			$shell_call = "$conf->{executable}{chkconfig} $daemon on";
			print "- Enabling: [$daemon] on boot but NOT restarting it.\n";
		}
		else
		{
			print "- Enabling: [$daemon] on boot and (re)starting it.\n";
		}
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call 2>&1") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\n//g;
			$line =~ s/\r//g;
			#print "- Output: [$line]\n";
			if (($line =~ /FAILED/i) && ($daemon eq "dhcpd"))
			{
				print "[ Note ] - Starting DHCP daemon will fail if the BCN IP changed and the system\n";
				print "[ Note ]   hasn't rebooted yet. It should work after the reboot.\n";
			}
		}
		close $file_handle;
		sleep 1;
	}
	print "Done.\n\n";
	
	return(0);
}

# Set the owning user and group for various files and set the mode/permissions
# as well.
sub set_file_ownership_and_modes
{
	my ($conf) = @_;
	
	print "Setting ownership and permissions/modes on Striker files.\n";
	# I make shell calls here because it's too tricky to handle the
	# recursive calls in native perl.
	foreach my $file (sort {$a cmp $b} keys %{$conf->{permissions}})
	{
		my $path      = $conf->{permissions}{$file}{path};
		my $owner     = $conf->{permissions}{$file}{owner};
		my $group     = $conf->{permissions}{$file}{group};
		my $mode      = $conf->{permissions}{$file}{mode};
		my $recursive = $conf->{permissions}{$file}{recursive} ? "-R" : "";
		my $selinux   = $conf->{permissions}{$file}{selinux};
		print "- Setting ownership and mode to: [$owner:$group] and: [$mode] ($conf->{permissions}{$file}{recursive}) on: [$path]\n";
		my $shell_call = "$conf->{executable}{chown} $recursive $owner:$group $path";
		#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
		open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line !~ /Read-only file system/i)
			{
				print "- chown output: [$line]\n";
			}
		}
		close $file_handle;
		$shell_call = "$conf->{executable}{chmod} $recursive $mode $path";
		#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
		open ($file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line !~ /Read-only file system/i)
			{
				print "- chmod output: [$line]\n";
			}
		}
		close $file_handle;
		
		# NOTE: Disabled until I get the media library tools working
		#       with selinux.
		#if ($selinux)
		if (0)
		{
			#[root@striker ~]# semanage fcontext -a -t httpd_sys_content_t /var/log/striker.log 
			#[root@striker ~]# restorecon /var/log/striker.log 
			print "  Setting selinux context to: [$selinux].\n";
			my $shell_call = "$conf->{executable}{semanage} fcontext -a -t $selinux $path && $conf->{executable}{restorecon} $path";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "- Output: [$line]\n";
			}
			close $file_handle;
		}
	}
	
	# Allow httpd to make outbound network connections.
	if (0)
	{
		print "- Giving apache permission to create network connections.\n";
		my $shell_call = "$conf->{executable}{setsebool} -P httpd_can_network_connect 1";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	print "Done.\n\n";
	
	return(0);
}

# Copy the files for Striker from the source directory into the apache
# directory.
sub install_striker_files
{
	my ($conf) = @_;
	
	# Copy the 'html' directory
	print "Copying Striker program files into place.\n";
	
	if (-e "$conf->{path}{backups}/www")
	{
		print "- Backup already made, skipping.\n";
	}
	else
	{
		my $www_directory =  $conf->{directory}{document_root};
		   $www_directory =~ s/\/$//;
		print "- Backing up: [$www_directory].\n";
		backup_file($conf, $www_directory);
	}
	
	print "- Copying HTML files and skins.\n";
	rsync_files($conf, "$conf->{directory}{source}/html",    $conf->{directory}{document_root});
	
	print "- Copying executable files and languages.\n";
	rsync_files($conf, "$conf->{directory}{source}/cgi-bin", $conf->{directory}{document_root});
	
	print "- Copying tools.\n";
	rsync_files($conf, "$conf->{directory}{source}/tools",   $conf->{directory}{document_root});
	
	# Split the directory from the file.
	my ($striker_conf_dir, $striker_conf_file) = ($conf->{path}{striker_config} =~ /^(.*)\/(.*)$/);
	if (-e "$conf->{path}{striker_config}")
	{
		print "- Existing Striker configuration file found, not replacing it.\n";
	}
	else
	{
		# Make sure the striker /etc/ directory exists.
		my $parent_dir       = ($striker_conf_dir =~ /^.*\/(.*)$/)[0];
		if (-d $striker_conf_dir)
		{
			print "- Striker configuration directory already exists.\n";
		}
		else
		{
			print "- Creating the Striker configuration directory.\n";
			mkdir $striker_conf_dir or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$striker_conf_dir], error was: $!\n";
		}
		
		print "- Copying base Striker configuration file.\n";
		my $source      = "$conf->{directory}{source}/$striker_conf_file";
		my $destination = $striker_conf_dir;
		copy_file($conf, $source, $destination);
		print "- Copying: [$source]\n";
		print "       to: [$destination]\n";
		copy_file($conf, $source, $destination);
	}
	
	# Update the mail settings if the user passed any.
	if (($conf->{sys}{mail_server}) || ($conf->{sys}{mail_user}) || ($conf->{sys}{mail_password}))
	{
		# Update the striker.conf file with the user's selected mail server
		# values.
		my $mail_server;
		my $mail_port;
		if ($conf->{sys}{mail_server} =~ /^(.*?):(\d+)$/)
		{
			$mail_server = $1;
			$mail_port   = $2;
		}
		elsif ($conf->{sys}{mail_server})
		{
			$mail_server = $conf->{sys}{mail_server};
		}
		
		print "- Updating mail server values in Striker's configuration file.\n";
		#print "[ Debug ] - mail_server: [$mail_server], mail_port: [$mail_port]\n";
		#print "[ Debug ] - mail user: [$conf->{sys}{mail_user}], password: [$conf->{sys}{mail_password}]\n";
		#print "[ Debug ] - Reading: [$conf->{path}{striker_config}]\n";
		my $striker_config = "";
		open (my $file_handle, "<", $conf->{path}{striker_config}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{striker_config}], the error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			
			#print "[ Debug ] >> line: [$line]\n";
			$line =~ s/^smtp::server(\s+)=(\s+).*$/smtp::server$1=$2$mail_server/;
			$line =~ s/^smtp::port(\s+)=(\s+).*$/smtp::port$1=$2$mail_port/;
			$line =~ s/^smtp::username(\s+)=(\s+).*$/smtp::username$1=$2$conf->{sys}{mail_user}/     if $conf->{sys}{mail_user};
			$line =~ s/^smtp::password(\s+)=(\s+).*$/smtp::password$1=$2$conf->{sys}{mail_password}/ if $conf->{sys}{mail_password};
			#print "[ Debug ] << line: [$line]\n";
			
			$striker_config .= "$line\n";
		}
		close $file_handle;
		# Next, write it out.
		print "- Writing out the new version.\n";
		open ($file_handle, ">", $conf->{path}{striker_config}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{striker_config}], the error was: $!\n";
		print $file_handle $striker_config;
		close $file_handle;
		print "- Done.\n";
	}
	
	# Create an empty log file
	print "- Creating empty Striker log file.\n";
	open (my $file_handle, ">", $conf->{path}{striker_log}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{striker_log}], the error was: $!\n";
	print $file_handle "";
	close $file_handle;
	
	print "Done.\n\n";
	
	return(0);
}

# This copies multiple files using rsync
sub rsync_files
{
	my ($conf, $source, $destination) = @_;
	
	my $shell_call = "$conf->{executable}{rsync} -a $source $destination";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	
	# Verify it copied successfully.
	if ($source !~ /\*$/)
	{
		my $file = ($source =~ /^.*\/(.*)$/)[0];
		$file = "$destination/$file";
		if (not -e $file)
		{
			print "[ Error ] - Failed to rsync: [$source]\n";
			print "[ Error ]                to: [$destination]\n";
			exit(21);
		}
	}
}

# Configure guacamole.
# sub configure_guacamole
# {
# 	my ($conf) = @_;
# 	
# 	print "Configuring guacamole\n";
# 	
# 	# Create the guacamole directory if needed.
# 	if (-e $conf->{directory}{guac_etc})
# 	{
# 		print "- Guacamole configuration directory already exists.\n";
# 	}
# 	else
# 	{
# 		print "- Creating the Guacamole configuration directory.\n";
# 		mkdir $conf->{directory}{guac_etc} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{guac_etc}], error was: $!\n";
# 	}
# 	
# 	# Make sure gacamole tomcat diretory exists
# 	if (-e $conf->{directory}{guac_tomcat})
# 	{
# 		print "- Guacamole Tomcat directory already exists.\n";
# 	}
# 	else
# 	{
# 		print "- Creating the Guacamole Tomcat directory.\n";
# 		mkdir $conf->{directory}{guac_tomcat} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{guac_tomcat}], error was: $!\n";
# 	}
# 	
# 	# Make sure the library path directory exists (before we check classpath}.
# 	if (-e $conf->{directory}{guac_lib})
# 	{
# 		print "- Guacamole library directory already exists.\n";
# 	}
# 	else
# 	{
# 		print "- Creating the Guacamole library directory.\n";
# 		mkdir $conf->{directory}{guac_lib} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{guac_lib}], error was: $!\n";
# 	}
# 	
# 	# Make sure the class path directory exists.
# 	if (-e $conf->{directory}{guac_classpath})
# 	{
# 		print "- Guacamole classpath directory already exists.\n";
# 	}
# 	else
# 	{
# 		print "- Creating the Guacamole classpath directory.\n";
# 		mkdir $conf->{directory}{guac_classpath} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{guac_classpath}], error was: $!\n";
# 	}
# 	
# 	# insert guacamole version into path names.
# 	$conf->{path}{guac_noauth} =~ s/#!guac_version!#/$conf->{sys}{guac_version}/;
# 	$conf->{path}{guac_war}    =~ s/#!guac_version!#/$conf->{sys}{guac_version}/;
# 	
# 	# Now start copying things into place.
# 	if (-e $conf->{path}{guac_noauth})
# 	{
# 		print "- The 'auth-noauth' module is already in place.\n";
# 	}
# 	else
# 	{
# 		print "- Copying the 'auth-noauth' module into place.\n";
# 		my $noauth_file =  ($conf->{path}{guac_noauth} =~ /^.*\/(.*)$/)[0];
# 		my $destination =  $conf->{path}{guac_noauth};
# 		   $destination =~ s/$noauth_file$//;
# 		my $source      =  "$conf->{directory}{source}/guacamole/$noauth_file";
# 		print "- Copying: [$source]\n";
# 		print "       to: [$destination]\n";
# 		copy_file($conf, $source, $destination);
# 	}
# 	
# 	# Create the noauth config, if needed.
# 	if (-e $conf->{path}{guac_noauth_config})
# 	{
# 		print "- The 'noauth' config already exists.\n";
# 	}
# 	else
# 	{
# 		print "- Copying the 'auth-noauth' module into place.\n";
# 		my $noauth_file =  ($conf->{path}{guac_noauth_config} =~ /^.*\/(.*)$/)[0];
# 		my $destination =  $conf->{path}{guac_noauth_config};
# 		   $destination =~ s/$noauth_file$//;
# 		my $source      =  "$conf->{directory}{source}/guacamole/$noauth_file";
# 		print "- Copying: [$source]\n";
# 		print "       to: [$destination]\n";
# 		copy_file($conf, $source, $destination);
# 	}
# 	
# 	# Copy the .war file and symlink it.
# 	if (-e $conf->{path}{guac_war})
# 	{
# 		print "- Guacamole web archive file already in place.\n";
# 	}
# 	else
# 	{
# 		# Delete the symlink if it exists.
# 		if (-l $conf->{path}{guac_war_symlink})
# 		{
# 			print "- Deleting the existing symlink.\n";
# 			unlink $conf->{path}{guac_war_symlink} or die "$THIS_FILE ".__LINE__."; Failed to delete the symlink: [$conf->{path}{guac_war_symlink}]\n";
# 		}
# 		
# 		# Now copy.
# 		my ($destination, $war_file) = ($conf->{path}{guac_war} =~ /^(.*)\/(.*)$/);
# 		my $source                   = "$conf->{directory}{source}/guacamole/$war_file";
# 		print "- Copying: [$source]\n";
# 		print "       to: [$destination]\n";
# 		copy_file($conf, $source, $destination);
# 		
# 		# If I am here, the copy succeeded.
# 		print "- Creating guacamole web archive symlink.\n";
# 		my $shell_call = "$conf->{executable}{ln} -s $destination/$war_file $conf->{path}{guac_war_symlink}";
# 		#print "[ Debug ] - shell_call: [$shell_call]\n";
# 		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
# 		while(<$file_handle>)
# 		{
# 			chomp;
# 			my $line = $_;
# 			print "- Output: [$line]\n";
# 		}
# 		close $file_handle;
# 		
# 		if (-l $conf->{path}{guac_war_symlink})
# 		{
# 			print "- Symlink created successfully.\n";
# 		}
# 		else
# 		{
# 			print "[ Error ] - I was unable to link: [$destination/$war_file]\n";
# 			print "[ Error ]                     to: [$conf->{path}{guac_war_symlink}]\n";
# 			exit(20);
# 		}
# 	}
# 	
# 	# Copy the guacamoly properties file into place.
# 	if (-e $conf->{path}{guac_properties})
# 	{
# 		print "- Properties file already in place.\n";
# 	}
# 	else
# 	{
# 		my $properties_file =  ($conf->{path}{guac_properties} =~ /^.*\/(.*)$/)[0];
# 		my $destination     =  $conf->{path}{guac_properties};
# 		   $destination     =~ s/$properties_file$//;
# 		my $source          =  "$conf->{directory}{source}/guacamole/$properties_file";
# 		print "- Copying: [$source]\n";
# 		print "       to: [$destination]\n";
# 		copy_file($conf, $source, $destination);
# 		
# 		# Create the symlink, if needed.
# 		print "- Creating guacamole properties symlink.\n";
# 		my $shell_call = "$conf->{executable}{ln} -s $destination/$properties_file $conf->{path}{guac_properties_symlink}";
# 		#print "[ Debug ] - shell_call: [$shell_call]\n";
# 		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
# 		while(<$file_handle>)
# 		{
# 			chomp;
# 			my $line = $_;
# 			print "- Output: [$line]\n";
# 		}
# 		close $file_handle;
# 		
# 		if (-l $conf->{path}{guac_properties_symlink})
# 		{
# 			print "- Symlink created successfully.\n";
# 		}
# 		else
# 		{
# 			print "[ Error ] - I was unable to link: [$destination/$properties_file]\n";
# 			print "[ Error ]                     to: [$conf->{path}{guac_properties_symlink}]\n";
# 			exit(20);
# 		}
# 	}
# 	
# 	print "Done.\n\n";
# 	
# 	return(0);
# }

# This copies a file... Hey, what it says on the tin.
sub copy_file
{
	my ($conf, $source, $destination) = @_;
	
	my $shell_call = "$conf->{executable}{cp} -af $source $destination";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	
	# Verify it copied successfully.
	my $file = ($source =~ /^.*\/(.*)$/)[0];
	   $file = "$destination/$file";
	if (not -e $file)
	{
		print "[ Error ] - Failed to copy: [$source]\n";
		print "[ Error ]               to: [$destination]\n";
		exit(19);
	}
	
	return(0);
}

# Download Striker, if needed.
sub download_striker
{
	my ($conf) = @_;
	
	print "Downloading Striker, if needed.\n";
	my $extract  = "";
	my $download = "";
	if ($conf->{sys}{install_version} eq "git")
	{
		print "- Downloading the developer version from github.\n";
		$download                  = $conf->{url}{git_master};
		$extract                   = ($conf->{url}{git_master} =~ /^.*\/(.*)$/)[0];
		$conf->{directory}{source} = "./striker-master";
		#print "[ Debug ] - directory::source: [$conf->{directory}{source}]\n";
	}
	else
	{
		if (-e "./version")
		{
			my $version;
			print "- Version file exists, checking if it matches the requested version.\n";
			open (my $file_handle, "<", "./version") or die "$THIS_FILE ".__LINE__."; Failed to read: [./version], the error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				$version = $_;
			}
			close $file_handle;
			
			if ($version eq $conf->{sys}{install_version})
			{
				print "- Download not needed, files already available.\n";
				$conf->{directory}{source} = "./";
			}
			else
			{
				print "- Local version: [$version] doesn't match requested version: [$conf->{sys}{install_version}]\n";
				print "- Downloading requested version from: [$conf->{url}{striker}]\n";
				$download                  = $conf->{url}{striker};
				$extract                   = ($conf->{url}{striker} =~ /^.*\/(.*)$/)[0];
				$conf->{directory}{source} = "./striker-".$conf->{sys}{install_version};
			}
		}
		else
		{
			# Download needed.
			print "- Downloading version: [$conf->{sys}{install_version}] from: [$conf->{url}{striker}]\n";
			$download                  = $conf->{url}{striker};
			$extract                   = ($conf->{url}{striker} =~ /^.*\/(.*)$/)[0];
			$conf->{directory}{source} = "./striker-".$conf->{sys}{install_version};
		}
	}
	
	# Download, if needed
	if ($download)
	{
		# See if it's already downloaded.
		if (-e "./$extract")
		{
			print "- The source: [$extract] already exists, skipping.\n";
		}
		else
		{
			my $shell_call = "$conf->{executable}{wget} -c $download";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			print "==============================================================================\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "- Output: [$line]\n";
			}
			print "==============================================================================\n";
			close $file_handle;
			
			# Make sure it downloaded.
			if (not -e $extract)
			{
				print "[ Error ] - The download failed!\n";
				print "[ Error ] - Does: [$download] exist?\n";
				print "[ Error ] - Is there a working network connection?\n";
				exit(18);
			}
			else
			{
				print "- Download complete.\n";
			}
		}
	}
	
	# Extract, if needed.
	if ($extract)
	{
		print "- Extracting: [$extract]\n";
		#print "[ Debug ] - Checking if the directory: [$conf->{directory}{source}] exists already.\n";
		if (-d $conf->{directory}{source})
		{
			print "- The source appears to already be extracted, skipping.\n";
		}
		else
		{
			my $source_dir_found = 0;
			my $shell_call       = "$conf->{executable}{tar} -xvf $extract";
			if ($extract =~ /\.zip$/)
			{
				$shell_call = "$conf->{executable}{unzip} $extract";
			}
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				if (($line =~ /^(.*?)\/$/) && (not $source_dir_found))
				{
					#print __LINE__."; [ Debug ] - line: [$line]\n";
					# This overrides anything set above
					# (though those need to be set in-case
					# extraction wasn't needed).
					my $source = $1;
					#print __LINE__."; [ Debug ] - source: [$source]\n";
					# When using 'unzip', the line as 'creating:' in it.
					if ($line =~ /creating: (.*?\/)$/)
					{
						$source = $1;
						#print __LINE__."; [ Debug ] - source: [$source]\n";
					}
					$conf->{directory}{source} = "./$source";
					#print __LINE__."; [ Debug ] - directory::source: [$conf->{directory}{source}]\n";
					$source_dir_found          = 1;
				}
				print "- Output: [$line]\n";
			}
			close $file_handle;
		}
	}
	print "- Will use the source directory: [$conf->{directory}{source}]\n";
	print "Done.\n\n";
	
	return(0);
}

# Configure iptables to allow incoming HTTP and HTTPS traffic.
sub configure_iptables
{
	my ($conf) = @_;
	
	# Read in the current rules so we don't recreate rules that already exist.
	print "Configuring the firewall to allow normal and secure web access.\n";
	if (-e "$conf->{path}{backups}/iptables")
	{
		print "- Backup already made, skipping.\n";
	}
	else
	{
		print "- Backing up: [$conf->{path}{iptables}].\n";
		backup_file($conf, $conf->{path}{iptables});
	}
	
	my $tftp_open  = 0;
	my $http_open  = 0;
	my $https_open = 0;
	print "- Reading the current firewall configuration.\n";
	my $shell_call = "$conf->{executable}{'iptables-save'}";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		#print "- Output: [$line]\n";
		if (($line =~ /--state NEW/) && ($line =~ /--dport 69/) && ($line =~ /ACCEPT/))
		{
			print "- Trivial FTP is already enabled.\n";
			$tftp_open = 1;
		}
		if (($line =~ /--state NEW/) && ($line =~ /--dport 80/) && ($line =~ /ACCEPT/))
		{
			print "- Standard web access is already enabled.\n";
			$http_open = 1;
		}
		if (($line =~ /--state NEW/) && ($line =~ /--dport 443/) && ($line =~ /ACCEPT/))
		{
			print "- Secure web access is already enabled.\n";
			$https_open = 1;
		}
	}
	close $file_handle;
	
	if (not $tftp_open)
	{
		print "- Opening access for trivial FTP (needed for PXE booting).\n";
		my $shell_call =  "$conf->{executable}{iptables} -I INPUT -m state --state NEW -p tcp --dport 69 -j ACCEPT && ";
		   $shell_call .= "$conf->{executable}{iptables} -I INPUT -m state --state NEW -p udp --dport 69 -j ACCEPT";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	if (not $http_open)
	{
		print "- Opening access for standard web access.\n";
		my $shell_call = "$conf->{executable}{iptables} -I INPUT -m state --state NEW -p tcp --dport 80 -j ACCEPT";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	if (not $https_open)
	{
		print "- Opening access for secure web access.\n";
		my $shell_call = "$conf->{executable}{iptables} -I INPUT -m state --state NEW -p tcp --dport 443 -j ACCEPT";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	if ((not $http_open) || (not $https_open))
	{
		# Save the changes.
		print "- Saving the new iptables configuration.\n";
		my $shell_call = "/etc/init.d/iptables save";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			# The formatting here isn't nice.
			$line =~ s/\n//g;
			$line =~ s/\r//g;
			#print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	print "Done.\n\n";
	
	return(0);
}

# Configre SSH to disable IP lookup to enable faster SSH access when there is
# no Internet access. Also, create the apache user's RSA keys.
sub configure_ssh
{
	my ($conf) = @_;
	
	print "Configuring SSH daemon to allow faster logins.\n";
	        
	if (-e "$conf->{path}{backups}/sshd_config")
	{
		print "- Backup already made, skipping.\n";
	}
	else
	{
		print "- Backing up: [$conf->{path}{sshd_config}].\n";
		backup_file($conf, $conf->{path}{sshd_config});
	}
	
	# Read in and then write out the server.xml file to enable UTF-8
	my $sshd_config = "";
	print "- Reading in the existing ssh daemon configuration file.\n";
	open (my $file_handle, "<", $conf->{path}{sshd_config}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{sshd_config}], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		# Change the lines, if needed.
		$line =~ s/#GSSAPIAuthentication no/GSSAPIAuthentication no/;
		$line =~ s/GSSAPIAuthentication yes/#GSSAPIAuthentication yes/;
		$line =~ s/#UseDNS yes/UseDNS no/;
		
		$sshd_config .= "$line\n";
	}
	close $file_handle;
	# Next, write it out.
	print "- Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{sshd_config}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{sshd_config}], the error was: $!\n";
	print $file_handle $sshd_config;
	close $file_handle;
	
	if (-e "$conf->{path}{apache_home}/.ssh/id_rsa")
	{
		print "- SSH RSA keys for: [$conf->{sys}{apache_user}] already created, skipping.\n";
	}
	else
	{
		print "- Generating: [$conf->{sys}{apache_user}]'s RSA keys.\n";
		print "- [ Note ] Please be patient! It might take time to collect entropy.\n";
		my $shell_call = "$conf->{executable}{su} apache -c \"$conf->{executable}{'ssh-keygen'} -t rsa -N \\\"\\\" -b 8191 -f ~/.ssh/id_rsa\"";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	print "Done.\n\n";
	
	return(0);
}

# This configures Tomcat, which we use for Guacamole.
# sub configure_tomcat
# {
# 	my ($conf) = @_;
# 	
# 	print "Configuring Tomcat.\n";
# 	        
# 	if (-e "$conf->{path}{backups}/server.xml")
# 	{
# 		print "- Backup already made, skipping.\n";
# 	}
# 	else
# 	{
# 		print "- Backing up: [$conf->{path}{tomcat_server}].\n";
# 		backup_file($conf, $conf->{path}{tomcat_server});
# 	}
# 	
# 	# Read in and then write out the server.xml file to enable UTF-8
# 	my $tomcat_config = "";
# 	print "- Reading in the existing tomcat server configuration server.\n";
# 	#print "[ Debug ] - Reading: [$conf->{path}{tomcat_server}]\n";
# 	open (my $file_handle, "<", $conf->{path}{tomcat_server}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{tomcat_server}], the error was: $!\n";
# 	while(<$file_handle>)
# 	{
# 		chomp;
# 		my $line = $_;
# 		
# 		# Avoid multiple 'URIEncoding="UTF-8"' entries
# 		#print "[ Debug ] >> line: [$line]\n";
# 		next if $line =~ /^\s+URIEncoding="UTF-8"$/;
# 		
# 		# Insert the UTF-8 string
# 		if ($line =~ /<Connector port="8080" protocol="HTTP\/1.1"/)
# 		{
# 			$tomcat_config .= "$line\n";
# 			$tomcat_config .= "               URIEncoding=\"UTF-8\"\n";
# 		}
# 		else
# 		{
# 			$tomcat_config .= "$line\n";
# 		}
# 	}
# 	close $file_handle;
# 	# Next, write it out.
# 	print "- Writing out the new version.\n";
# 	open ($file_handle, ">", $conf->{path}{tomcat_server}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{tomcat_server}], the error was: $!\n";
# 	print $file_handle $tomcat_config;
# 	close $file_handle;
# 	print "Done.\n\n";
# 	
# 	return(0);
# }

# This makes sure that selinux is enabled.
sub configure_selinux
{
	my ($conf) = @_;
	
	### TODO: Get the media library stuff working... ;_;
	#print "Making sure that selinux is enabled.\n";
	print "Making sure that selinux is permissive.\n";
	if (-e "$conf->{path}{backups}/config")
	{
		print "- Backup already made, skipping.\n";
	}
	else
	{
		print "- Backing up: [$conf->{path}{selinux_config}].\n";
		backup_file($conf, $conf->{path}{selinux_config});
	}
	
	# If selinux is off, warn the user that the next boot might be slow.
	my $current_policy = "";
	my $selinux_config = "";
	print "- Reading in the existing selinux config file.\n";
	open (my $file_handle, "<", $conf->{path}{selinux_config}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{selinux_config}], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		# Update the SELinux policy.
		if ($line =~ /^SELINUX=(.*)/)
		{
			# Record the current policy in case we want to alert
			# the user.
			$current_policy =  $1;
			#$selinux_config .= "SELINUX=enforcing\n";
			$selinux_config .= "SELINUX=permissive\n";
		}
		else
		{
			$selinux_config .= "$line\n";
		}
	}
	close $file_handle;
	
	# If the old policy was 'disabled', want that the next reboot could be
	# slow.
	if ($current_policy eq "disabled")
	{
		print "[ Warning ] - It looks like selinux was disabled.\n";
		print "[ Warning ]   The next reboot might take longer than normal if a filesystem\n";
		print "[ Warning ]   relabel is required.\n";
		sleep 5;
	}
	elsif ($current_policy eq "enforcing")
	{
		# Set enforcing to 0.
		print "- Setting selinux to 'permissive'.\n";
		my $shell_call = "$conf->{executable}{setenforce} 0";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
	}
	
	# Next, write it out.
	print "- Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{selinux_config}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{selinux_config}], the error was: $!\n";
	print $file_handle $selinux_config;
	close $file_handle;
	print "Done.\n\n";
	
	# TODO: Set labels here.
	
	return(0);
}

# This sets the hostname of the system.
sub set_hostname
{
	my ($conf) = @_;
	
	# First, edit the hostname file.
	print "Configuring this system's host name.\n";
	print "- Reading in the existing hostname file.\n";
	my $hostname = "";
	open (my $file_handle, "<", $conf->{path}{hostname}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{hostname}], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		# Update the apache user entry.
		if ($line =~ /^HOSTNAME=/)
		{
			# Now insert our new authentication lines
			$hostname .= "HOSTNAME=$conf->{sys}{hostname}\n";
		}
		else
		{
			$hostname .= "$line\n";
		}
	}
	close $file_handle;
	
	# Next, write it out.
	print "- Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{hostname}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{hostname}], the error was: $!\n";
	print $file_handle $hostname;
	close $file_handle;
	print "Done.\n\n";
	
	# And finally, change the hostname for the current session.
	system("hostname $conf->{sys}{hostname}");
	
	return(0);
}

# This handles configuring apache.
sub configure_apache
{
	my ($conf) = @_;
	
	print "Configuring Apache.\n";
	
	# Start by backing things up.
	if (-e "$conf->{path}{backups}/httpd")
	{
		print "- Backup already made, skipping.\n";
	}
	else
	{
		print "- Backing up original files.\n";
		backup_file($conf, $conf->{directory}{apache});
	}
	
	# Enable the 'apache' user.
	enable_apache_user($conf);
	
	# Create the apache user's home directory and sub-directories.
	create_apache_home_directories($conf);
	
	# Create the htpasswd file.
	create_apache_htpasswd($conf);
	
	# Now to start updating.
	print "- Reading in the existing config file and adjusting as needed.\n";
	#my $in_guacamole  = 0;
	my $apache_config = "";
	open (my $file_handle, "<", $conf->{path}{apache_config}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{apache_config}], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		# Skip lines from previous htpasswd configs.
		next if $line =~ /^\s+# Password login/;
		next if $line =~ /^\s+AuthType /;
		next if $line =~ /^\s+AuthName /;
		next if $line =~ /^\s+AuthUserFile /;
		next if $line =~ /^\s+Require user /;
		
		# Skip prior proxy entries.
# 		if ($line =~ /^<Location \/guacamole\/>/)
# 		{
# 			$in_guacamole = 1;
# 		}
# 		if ($line =~ /CustomLog \/var\/log\/httpd\/guac.log/)
# 		{
# 			$in_guacamole = 0;
# 			next;
# 		}
# 		next if $in_guacamole;
		
		### TODO: Set SSL as default and add an option for a user to
		###       load their own certs.
		# Now insert and/or modify things.
		if ($line =~ /<Directory "\/var\/www\/cgi-bin/)
		{
			# Now insert our new authentication lines
			$apache_config .= "$line\n";
			$apache_config .= "    # Password login\n";
			$apache_config .= "    AuthType Basic\n";
			$apache_config .= "    AuthName \"Striker - $conf->{sys}{customer}\"\n";
			$apache_config .= "    AuthUserFile $conf->{path}{apache_htpasswd}\n";
			$apache_config .= "    Require user $conf->{sys}{striker_user}\n";
		}
# 		elsif ($line =~ /#<\/Proxy>/)
# 		{
# 			$apache_config .= "$line\n";
# 			$apache_config .= "<Location /guacamole/>\n";
# 			$apache_config .= "    Order allow,deny\n";
# 			$apache_config .= "    Allow from all\n";
# 			$apache_config .= "    ProxyPass http://localhost:8080/guacamole/ max=20 flushpackets=on\n";
# 			$apache_config .= "    ProxyPassReverse http://localhost:8080/guacamole/\n";
# 			$apache_config .= "</Location>\n";
# 			$apache_config .= "SetEnvIf Request_URI \"^/guacamole/tunnel\" dontlog\n";
# 			$apache_config .= "CustomLog /var/log/httpd/guac.log common env=!dontlog\n";
# 		}
		elsif ($line =~ /^Timeout /)
		{
			$apache_config .= "Timeout $conf->{sys}{apache_timeout}\n";
		}
		else
		{
			$apache_config .= "$line\n";
		}
	}
	close $file_handle;
	
	# Now write it out.
	print "- Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{apache_config}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{apache_config}], the error was: $!\n";
	print $file_handle $apache_config;
	close $file_handle;
	print "Done.\n\n";
	
	# Write out the manifest.conf file
	print "- Writing out the apache manifest configuration file.\n";
	if (-e $conf->{path}{apache_manifest_conf})
	{
		print "- Apache manifest configuration file already exists.\n";
	}
	else
	{
		open ($file_handle, ">", $conf->{path}{apache_manifest_conf}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{apache_manifest_conf}], the error was: $!\n";
		print $file_handle "<Directory \"/var/www/html/manifests/\">\n";
		print $file_handle "  <FilesMatch \"\.xml\$\">\n";
		print $file_handle "    Header set Content-Disposition attachment\n";
		print $file_handle "  </FilesMatch>\n";
		print $file_handle "</Directory>\n";
		close $file_handle;
		print "Done.\n\n";
	}
	
	return(0);
}

# This edits the passwd file to enable logins by apache.
sub enable_apache_user
{
	my ($conf) = @_;
	
	print "- Reading in the existing system user file.\n";
	my $passwd = "";
	open (my $file_handle, "<", $conf->{path}{passwd}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{passwd}], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		# Update the apache user entry.
		if ($line =~ /apache:x:(\d+):(\d+):(.*?):(.*?):(.*)/)
		{
			# Now insert our new authentication lines
			my $uid  = $1;
			my $gid  = $2;
			my $name = $3;	# I don't care about this
			my $home = $4;	# or this.
			$passwd .= "apache:x:$uid:$gid:$name:$conf->{path}{apache_home}:$conf->{path}{apache_shell}\n";
		}
		else
		{
			$passwd .= "$line\n";
		}
	}
	close $file_handle;
	
	# Now write it out.
	print "- Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{passwd}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{passwd}], the error was: $!\n";
	print $file_handle $passwd;
	close $file_handle;
	
	return(0);
}

# This sets the local 'root' user's password.
sub set_root_password
{
	my ($conf) = @_;
	
	print "Setting root user's password.\n";
	if ($conf->{sys}{striker_pass})
	{
		$conf->{sys}{striker_pass} =~ s/"/\\"/g;
		my $shell_call = "$conf->{executable}{echo} \"$conf->{sys}{striker_pass}\" | $conf->{executable}{passwd} root --stdin";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
		print "Done!\n\n";
		print " ##############################################################################\n";
		print " # NOTE: Your 'root' user password is now the same as the Striker user's      #\n";
		print " #       password you just specified. If you want a different password,       #\n";
		print " #       change it now with 'passwd'!                                         #\n";
		print " ##############################################################################\n\n";
	}
	else
	{
		print "- Password not set, leaving it unchanged.\n";
		print "Done!\n\n";
	}
	
	return(0);
}

# Create the htpasswd file.
sub create_apache_htpasswd
{
	my ($conf) = @_;
	
	print "- Setting up Striker's authentication via Apache's htpasswd...\n";
	if (-e $conf->{path}{apache_htpasswd})
	{
		print "- Old: [$conf->{path}{apache_htpasswd}] found, deleting it.\n";
		unlink $conf->{path}{apache_htpasswd} or die "$THIS_FILE ".__LINE__."; Failed to delete: [$conf->{path}{apache_htpasswd}], error was: $!\n";
	}
	
	# Escape any single-quotes in the user's password.
	$conf->{sys}{striker_pass} =~ s/"/\\\\\\\"/g;
	print "- Generating: [$conf->{sys}{striker_user}]'s: [$conf->{path}{apache_htpasswd}] password file.\n";
	my $shell_call = "$conf->{executable}{su} apache -c \"$conf->{executable}{htpasswd} -cdb $conf->{path}{apache_htpasswd} $conf->{sys}{striker_user} \\\"$conf->{sys}{striker_pass}\\\"\"";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	
	return(0);
}

# This creates the apache home directories and sets their permissions.
sub create_apache_home_directories
{
	my ($conf) = @_;
	
	print "- Creating the apache home directories.\n";
	my @dirs;
	push @dirs, $conf->{path}{apache_home};
	if (not -e $conf->{path}{apache_home})
	{
		print "- Creating: [$conf->{path}{apache_home}].\n";
		mkdir $conf->{path}{apache_home} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{path}{apache_home}], the error was: $!\n";
	}
	else
	{
		print "- Home already exists: [$conf->{path}{apache_home}].\n";
	}
	foreach my $directory (@{$conf->{directory}{apache_subdirs}})
	{
		my $full_path = "$conf->{path}{apache_home}/$directory";
		push @dirs, $full_path;
		if (not -e $full_path)
		{
			print "- Creating: [$full_path].\n";
			mkdir $full_path or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$full_path], the error was: $!\n";
		}
		else
		{
			print "- Already exists: [$full_path].\n";
		}
	}
	
	# Make sure the directory that install manifests will be stored in is available.
	if (not -e $conf->{directory}{apache_manifests})
	{
		print "- Creating: [$conf->{directory}{apache_manifests}].\n";
		mkdir $conf->{directory}{apache_manifests} or die "$THIS_FILE ".__LINE__."; Failed to create the directory: [$conf->{directory}{apache_manifests}], the error was: $!\n";
	}
	else
	{
		print "- Install manifests directory already exists: [$conf->{directory}{apache_manifests}].\n";
	}
	
	print "- Setting ownership to: [$conf->{sys}{apache_user}:$conf->{sys}{apache_group}].\n";
	my $apache_uid = getpwnam($conf->{sys}{apache_user}); 
	my $apache_gid = getgrnam($conf->{sys}{apache_group});
	my $dir_mode   = 0775;
	if (not $apache_uid)
	{
		print "[ Error ] - Unable to get the User ID for the apache user: [$conf->{sys}{apache_user}]\n";
		print "[ Error ]   Did apache actually install properly?\n";
		exit(15);
	}
	if (not $apache_gid)
	{
		print "[ Error ] - Unable to get the Group ID for the apache group: [$conf->{sys}{apache_group}]\n";
		print "[ Error ]   Did apache actually install properly?\n";
		exit(16);
	}
	chown $apache_uid, $apache_gid, @dirs;
	print "- Setting mode to: [".sprintf("%04o", $dir_mode)."].\n";
	chmod $dir_mode, @dirs;
	
	return(0);
}

# This verifies that this is running on a RHEL 6 (or derivative) OS.
sub verify_os
{
	my ($conf) = @_;
	
	# If the release file doesn't exist, it's most likely not EL.
	print "Checking the operating system to ensure it is compatible.\n";
	if (not -e $conf->{path}{os_release})
	{
		print "[ Error ] - This does not appear to be a RHEL (based) operating system.\n";
		print "[ Error ]   At this time, only RHEL and derivatives version 6.x are supported.\n";
		exit(13);
	}
	
	# Read the release file and dig out the version.
	my $major   = -1;
	my $minor   = -1;
print "- We're on a RHEL (based) OS, good. Checking version.\n";
	open (my $file_handle, "<", $conf->{path}{os_release}) or die "$THIS_FILE ".__LINE__."; Failed to read: [$conf->{path}{os_release}], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /release (\d+)\.(.*)/)
		{
			$major = $1;
			$minor = $2;
			# CentOS uses 'CentOS Linux release 7.0.1406 (Core)', 
			# so I need to parse off the second '.' and whatever 
			# is after it.
			$minor =~ s/\..*$//;
			
			# Some have 'x.y (Final)', this strips that last bit off.
			$minor =~ s/\ \(.*?\)$//;
		}
		if ($line =~ /Red Hat Enterprise Linux Server/)
		{
			$conf->{sys}{is_rhel} = 1;
		}
	}
	close $file_handle;
	
	if ($major == 6)
	{
		# We're ok, but warn if minor is < 5
		if ($minor < 5)
		{
			print "[ Warning ] - This OS appears to be a little old, you are on: [$major.$minor].\n";
			print "[ Warning ]   Upgrading to at least version 6.5 is recommended, though not\n";
			print "[ Warning ]   strictly required. If you encounter issues, please update before\n";
			print "[ Warning ]   before filing a bug. Thank you.\n\n";
			sleep 5;
		}
		else
		{
			print "- Looks good! You're on: [$major.$minor]\n";
		}
	}
	elsif ($major > 6)
	{
		print "[ Error ] - I am sorry, but EL$major is not yet supported.\n";
		print "[ Error ]   Please use RHEL 6.x or similar.\n";
		exit(14);
	}
	else
	{
		print "[ Error ] - I am sorry, but EL$major is not supported.\n";
		print "[ Error ]   Please use RHEL 6.x or similar.\n";
		exit(14);
	}
	
	# If the OS is RHEL proper, see if the OS needs to be activated and do
	# so if the user has passed the --rhn switch.
	if ($conf->{sys}{is_rhel})
	{
		print "- This OS is RHEL proper.\n";
		if (-e $conf->{path}{rhn_file})
		{
			print "- The system appears to already be registered with RHN.\n";
		}
		elsif (($conf->{sys}{rhn_user}) && ($conf->{sys}{rhn_password}))
		{
			### TODO: Escape bash special vars in passwords.
			print "- RHN credentials given. Attempting to register now.\n";
			print "- [ Note ] Please be patient, this might take a minute...\n";
			my $shell_call = "$conf->{executable}{rhnreg_ks} --username '$conf->{sys}{rhn_user}' --password '$conf->{sys}{rhn_password}' --force --profilename '$conf->{sys}{hostname}'; echo rhnreg_ks:\$?";
			#print "[ Debug ] - sys::rhn_user: [$conf->{sys}{rhn_password}]\n";
			#print "[ Debug ] - sys::rhn_user: [$conf->{sys}{rhn_user}]\n";
			#print "[ Debug ] - shell_call: [$shell_call]\n";
			my $registered = 0;
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				if ($line =~ /rhnreg_ks:(\d+)/)
				{
					my $exit_code = $1;
					if ($exit_code == 0)
					{
						$registered = 1;
						print "- Registration was successful.\n";
					}
					else
					{
						print "[ Warning ] - Registration with RHN appears to have failed!\n";
						print "[ Warning ]   Exit code was: [$exit_code], expected '0'.\n";
					}
				}
				else
				{
					print "- Output: [$line]\n";
				}
			}
			close $file_handle;
			if ($registered)
			{
				print "- Adding 'Optional' channel...\n";
				my $shell_call = "$conf->{executable}{'rhn-channel'} --add --user '$conf->{sys}{rhn_user}' --password '$conf->{sys}{rhn_password}' --channel=rhel-x86_64-server-optional-6; echo rhn-channel:\$?";
				#print "[ Debug ] - sys::rhn_user: [$conf->{sys}{rhn_password}]\n";
				#print "[ Debug ] - sys::rhn_user: [$conf->{sys}{rhn_user}]\n";
				#print "[ Debug ] - shell_call: [$shell_call]\n";
				open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					if ($line =~ /rhn-channel:(\d+)/)
					{
						my $exit_code = $1;
						if ($exit_code == 0)
						{
							$registered = 1;
							print "- 'Optional' channel added successfully.\n";
						}
						else
						{
							print "[ Warning ] - Adding the 'Optional' RHN channel appears to have failed!\n";
							print "[ Warning ]   Exit code was: [$exit_code], expected '0'.\n";
						}
					}
					else
					{
						print "- Output: [$line]\n";
					}
				}
				close $file_handle;
			}
			else
			{
				print "[ Warning ] - Registration failed, skipping 'Optional' channel addition.\n";
			}
		}
		else
		{
			print "[ Warning ] - This system does not appear to be registered with RHN and no RHN\n";
			print "[ Warning ]   credentials have been given. The install will likely fail if any\n";
			print "[ Warning ]   packages need to be installed and are not locally available!\n";
			sleep 2;
		}
	}
	
	print "Done.\n\n";
	
	return(0);
}

# This looks at the list of installed RPMs, compares them against the list of
# needed RPMs and installs any that are missing.
sub install_packages
{
	my ($conf) = @_;
	
	print "Checking if anything needs to be installed.\n";
	
	# First up, has the 'an-repo' been added?
	configure_an_repo($conf);
	
	# Check for OS updates.
	update_os($conf);
	
	# Get a list of already installed packages.
	get_list_of_installed_packages($conf);
	
	# Install missing packages, if any.
	install_missing_packages($conf);
	
	return(0);
}

# This will compare the list of required packages against the list of installed
# packages and, if any are missing, install them
sub install_missing_packages
{
	my ($conf) = @_;
	
	print "Checking to see if any packages need to be installed.\n";
	my $to_install = "";
	foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{to_install}})
	{
		# Watch for autovivication...
		if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
		{
			$conf->{packages}{to_install}{$package} = 1;
			print "- Package: [$package] already installed.\n";
		}
		else
		{
			print "- Package: [$package] needs to be installed.\n";
			$to_install .= "$package ";
		}
	}
	print "- Done\n\n";
	
	if ($to_install)
	{
		# Install the packages, then verify they actually installed.
		print "Installing missing packages now. Please be patient.\n";
		#print "- [ Note ] Please be patient! It may appear that nothing is happening for a\n";
		#print "- [ Note ] while. This is likely because of how buffering is handled. If you\n";
		#print "- [ Note ] really think nothing is happening, please open a new terminal and\n";
		#print "- [ Note ] look for activity using 'top' or 'ps aux'.\n";
		my $shell_call = "$conf->{executable}{yum} -y install $to_install";
		#print "[ Debug ] - shell_call: [$shell_call]\n";
		print "==============================================================================\n";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			print $_;
		}
		print "==============================================================================\n";
		close $file_handle;
		print "Done.\n\n";
		
		# Verify that everything is installed.
		sleep 5;
		get_list_of_installed_packages($conf);
		print "Verifying that everything is installed now.\n";
		my $missing = 0;
		foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{to_install}})
		{
			# Watch for autovivication...
			if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
			{
				$conf->{packages}{to_install}{$package} = 1;
				print "- Package: [$package] installed.\n";
			}
			else
			{
				print "[ Error ] - Package: [$package] failed to install!\n";
				$missing = 1;
			}
		}
		# If anything is missing, fail.
		if ($missing)
		{
			print "[ Error ] - Not all required packages installed properly.\n";
			print "[ Error ]   I am sorry, but this is a fatal error.\n";
			print "[ Error ]   If you are on RHEL, is this machine registered?\n";
			print "[ Error ]   If there was a problem accessing the repos, please check the\n";
			print "[ Error ]   network connection and try again.\n\n";
			exit(12);
		}
		else
		{
			print "- All required packages are now installed.\n\n";
		}
	}
	
	return(0);
}

# This updates the OS, if needed.
sub update_os
{
	my ($conf) = @_;
	
	print "Checking for OS updates.\n";
	#print "- [ Note ] Please be patient! It may appear that nothing is happening for a\n";
	#print "- [ Note ] while. This is likely because of how buffering is handled. If you\n";
	#print "- [ Note ] really think nothing is happening, please open a new terminal and\n";
	#print "- [ Note ] look for activity using 'top' or 'ps aux'.\n";
	my $shell_call = "$conf->{executable}{yum} clean all && $conf->{executable}{yum} -y update";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	print "==============================================================================\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "$line\n";
		if ($line =~ /Installing : kernel/)
		{
			$conf->{sys}{reboot_needed} = 1;
		}
	}
	close $file_handle;
	print "==============================================================================\n";
	print "Done.\n\n";
	
	return(0);
}

# This gets a list of installed packages
sub get_list_of_installed_packages
{
	my ($conf) = @_;
	
	# TODO: Use 'tput cols' to get the user's screen width.
	my $dots = 0;
	print "Getting a list of currently installed packages.\n- ";
	my $shell_call = "$conf->{executable}{yum} list installed";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if $line =~ /^Loaded plugins/;
		next if $line =~ /^Loading mirror/;
		next if $line =~ /^Installed Packages/;
		next if $line =~ /^\s/;
		#print "[ Debug ] - line: [$line]\n";
		if ($line =~ /^(.*?)\.(.*?)\s+(.*?)\s+\@/)
		{
			my $package   = $1;
			my $arch      = $2;
			my $version   = $3;
			# NOTE: Someday record the arch and version, but for
			#       now, we don't care.
			$conf->{packages}{installed}{$package} = 1;
			#print "[ Debug ] - a) Package: [$package], arch: [$arch], version: [$version]\n";
			if ($dots > 75)
			{
				print "\n- .";
				$dots = 0;
			}
			else
			{
				print ".";
				$dots++;
			}
		}
		elsif ($line =~ /^(.*?)\.(.*?)\s+(.*)/)
		{
			my $package   = $1;
			my $arch      = $2;
			my $version   = $3;
			$conf->{packages}{installed}{$package} = 1;
			#print "[ Debug ] - b) Package: [$package], arch: [$arch], version: [$version]\n";
			if ($dots > 75)
			{
				print "\n- .";
				$dots = 0;
			}
			else
			{
				print ".";
				$dots++;
			}
		}
		elsif ($line =~ /^(.*?)\.(\S*)$/)
		{
			my $package   = $1;
			my $arch      = $2;
			$conf->{packages}{installed}{$package} = 1;
			#print "[ Debug ] - c) Package: [$package], arch: [$arch]\n";
			if ($dots > 75)
			{
				print "\n- .";
				$dots = 0;
			}
			else
			{
				print ".";
				$dots++;
			}
		}
	}
	close $file_handle;
	print "\nDone!\n\n";
	
	return(0);
}

# This installs the AN!Repo if needed.
sub configure_an_repo
{
	my ($conf) = @_;
	
	print "Checking AN! software repository.\n";
	if (-e $conf->{path}{an_repo})
	{
		if ($conf->{switches}{'no-an-repo'})
		{
			print "- AN! repo unselected but exists, removing it.\n";
			unlink $conf->{path}{an_repo} or die "Unable to delete: [$conf->{path}{an_repo}]. The error was: $!\n";
			print "- removed.\n";
		}
		else
		{
			print "- The AN!Repo is already installed.\n";
		}
	}
	elsif ($conf->{switches}{'no-an-repo'})
	{
		print "- AN! software repository not requested, skipping.\n";
	}
	else
	{
		# Create the repo
		print "- The AN!Repo hasn't been added yet, adding it now.\n";
		open (my $file_handle, ">", $conf->{path}{an_repo}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{an_repo}], the error was: $!\n";
		print $file_handle "[an-repo]\n";
		print $file_handle "name=AN! Repo for Anvil! stuff\n";
		print $file_handle "baseurl=https://alteeve.ca/repo/el6/\n";
		print $file_handle "enabled=1\n";
		print $file_handle "gpgcheck=0\n";
		print $file_handle "protect=1\n";
		close $file_handle;
		
		# No clear yum's cache
		print "- Added. Clearing yum's cache.\n";
		my $shell_call = "$conf->{executable}{yum} clean all";
		open ($file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- output: [$line]\n";
		}
		close $file_handle;
	}
	print "- Done!\n\n";
	
	return(0);
}

# This configures the local RHEL repo, if supported.
sub configure_striker_rhel_repo
{
	my ($conf) = @_;
	
	return(0) if not $conf->{pxe}{rhel}{enabled};
	
	if (-e $conf->{path}{an_repo})
	{
		print "- The Striker RHEL repo is already configured.\n";
	}
	else
	{
		# Create the repo
		print "- The local Striker RHEL repo hasn't been added yet, adding it now.\n";
		open (my $file_handle, ">", $conf->{path}{an_repo}) or die "$THIS_FILE ".__LINE__."; Failed to write: [$conf->{path}{an_repo}], the error was: $!\n";
		print $file_handle "[striker-$conf->{sys}{hostname}-bcn_rhel]\n";
		print $file_handle "name=Striker $conf->{sys}{hostname}'s RHEL repo.\n";
		print $file_handle "baseurl=http://$conf->{network}{bcn}{ip}/rhel6/x86_64/img/\n";
		print $file_handle "enabled=1\n";
		print $file_handle "gpgcheck=0\n";
		print $file_handle "\n";
		print $file_handle "[striker-$conf->{sys}{hostname}-ifn_rhel]\n";
		print $file_handle "name=Striker $conf->{sys}{hostname}'s RHEL repo.\n";
		print $file_handle "baseurl=http://$conf->{network}{ifn}{ip}/rhel6/x86_64/img/\n";
		print $file_handle "enabled=1\n";
		print $file_handle "gpgcheck=0\n";
		close $file_handle;
		
		# No clear yum's cache
		print "- Added. Clearing yum's cache.\n";
		my $shell_call = "$conf->{executable}{yum} clean all";
		open ($file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- output: [$line]\n";
		}
		close $file_handle;
		print "- Done!\n\n";
	}
	
	return(0);
}

# This looks at all NICs and 'ifup's any that are down.
sub start_all_nics
{
	my ($conf) = @_;
	
	print "Making sure all network interfaces are up.\n";
	check_nic_states($conf);
	foreach my $this_iface (sort {$a cmp $b} keys %{$conf->{nic}{by_name}})
	{
		# See if it is up already.
		my $link_state = $conf->{nic}{by_name}{$this_iface}{link_state};
		my $mac        = $conf->{nic}{by_name}{$this_iface}{mac};
		next if $link_state != 2;
		
		# If I am here, the interface is down
		my $nic       = $this_iface;
		my $nic_file = "$conf->{path}{network_configs}/ifcfg-$nic";
		print "- The network interface: [$nic] is down. It must be started for the next stage.\n";
		print "- Checking if: [$nic_file] exists.\n";
		if (not -e $nic_file)
		{
			print "- New device, writing a skeleton config file... ";
			my $shell_call = $nic_file;
			open (my $file_handle, '>', "$shell_call") or die "\nFailed to write: [$shell_call], error was: $!\n";
			print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
			print $file_handle "# Temporary configuration file for discovered NIC.\n";
			print $file_handle "HWADDR=\"$mac\"\n" if $mac;
			print $file_handle "DEVICE=\"$nic\"\n";
			print $file_handle "BOOTPROTO=\"none\"\n";
			print $file_handle "NM_CONTROLLED=\"no\"\n";
			close $file_handle;
			print "- Done.\n";
		}
		else
		{
			# It exists, edit it if needed.
			print "- Config file exists, changing BOOTPROTO to 'none'.\n";
			my $shell_call = "$conf->{executable}{sed} -i 's/BOOTPROTO=.*/BOOTPROTO=\"none\"/\' $nic_file";
			#print "[ Debug ] - Calling: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				# TODO: Should this cause the installer to bail?
				# This should not return anything, but just in case...
				chomp;
				my $line = $_;
				print "[ Warning ] - Unexpected output: [$line]\n";
			}
			close $file_handle;
		}
			
		# Now start the nic.
		print "- Attempting to bring up: [$nic]...\n";
		my $shell_call = "$conf->{executable}{ifup} $nic";
		open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			print "- Output: [$line]\n";
		}
		close $file_handle;
		
		# See that it came up.
		print "- Checking to see if it is up now.\n";
		sleep 2;
		my $is_up   = 0;
		$shell_call = "$conf->{executable}{ip} link show $nic";
		open ($file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /UP/)
			{
				$is_up = 1;
				last;
			}
		}
		close $file_handle;
		if ($is_up)
		{
			print "- The interface: [$nic] is now up!\n";
		}
		else
		{
			print "[ Error ] - Unable to bring up the interface: [$nic]!\n";
			print "[ Error ]   Please bring it up manually and try again.\n";
			exit(11);
		}
	}
	print "Done.\n\n";
	
	return(0);
}

# This is a wrapper function that calls the various task-specific functions
# that make the actual changes to the network.
sub reconfigure_network
{
	my ($conf) = @_;
	
	### TODO: Confirm that this is needed, may have to reboot anyway
	# Stop the network.
	#daemon_control($conf, "NetworkManager.service", "stop");
	
	# Write the udev file
	write_udev_persistent_net($conf);
	
	# Remove existing ifcfg-* files and then write the new ones.
	update_network_config_files($conf);
	
	return(0);
}

# This will remove all 'ifcfg-*' (save for 'ifcfg-lo') files and the writes
# the new config files.
sub update_network_config_files
{
	my ($conf) = @_;
	
	# First up, delete the old files.
	print "Deleting old network configuration files:\n"; 
	$conf->{path}{network_configs} =~ s/\/$//g;
	local(*DIRECTORY);
	opendir(DIRECTORY, $conf->{path}{network_configs});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		next if $file eq "ifcfg-lo";
		if ($file =~ /^ifcfg-/)
		{
			my $full_path = "$conf->{path}{network_configs}/$file";
			print "- Deleting file: [$full_path]\n";
			unlink $full_path or die "Unable to delete: [$full_path]. The error was: $!\n";
		}
	}
	print "Done.\n\n";
	print "Writing new network configuration files.\n";
	
	### Now write out the config files.
	# How I proceed depends on whether I am creating bonds or not.
	if ($conf->{sys}{create_bonds})
	{
		my $ifcfg_bcn_bond1_file = "$conf->{path}{network_configs}/ifcfg-bcn_bond1";
		my $ifcfg_bcn_link1_file = "$conf->{path}{network_configs}/ifcfg-bcn_link1";
		my $ifcfg_bcn_link2_file = "$conf->{path}{network_configs}/ifcfg-bcn_link2";
		my $ifcfg_ifn_bond1_file = "$conf->{path}{network_configs}/ifcfg-ifn_bond1";
		my $ifcfg_ifn_link1_file = "$conf->{path}{network_configs}/ifcfg-ifn_link1";
		my $ifcfg_ifn_link2_file = "$conf->{path}{network_configs}/ifcfg-ifn_link2";
		
		my $ifcfg_bcn_link1 =  "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		   $ifcfg_bcn_link1 .= "# Back-Channel Network - Link 1\n";
		   $ifcfg_bcn_link1 .= "DEVICE=\"bcn_link1\"\n";
		   $ifcfg_bcn_link1 .= "MTU=\"$conf->{sys}{mtu}\"\n" if $conf->{sys}{mtu} ne "1500";
		   $ifcfg_bcn_link1 .= "NM_CONTROLLED=\"no\"\n";
		   $ifcfg_bcn_link1 .= "BOOTPROTO=\"none\"\n";
		   $ifcfg_bcn_link1 .= "ONBOOT=\"yes\"\n";
		   $ifcfg_bcn_link1 .= "SLAVE=\"yes\"\n";
		   $ifcfg_bcn_link1 .= "MASTER=\"bcn_bond1\"";
		
		#$conf->{path}{nodes}{bcn_link2_config};
		my $ifcfg_bcn_link2 =  "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		   $ifcfg_bcn_link2 .= "# Back-Channel Network - Link 2\n";
		   $ifcfg_bcn_link2 .= "DEVICE=\"bcn_link2\"\n";
		   $ifcfg_bcn_link2 .= "MTU=\"$conf->{sys}{mtu}\"\n" if $conf->{sys}{mtu} ne "1500";
		   $ifcfg_bcn_link2 .= "NM_CONTROLLED=\"no\"\n";
		   $ifcfg_bcn_link2 .= "BOOTPROTO=\"none\"\n";
		   $ifcfg_bcn_link2 .= "ONBOOT=\"yes\"\n";
		   $ifcfg_bcn_link2 .= "SLAVE=\"yes\"\n";
		   $ifcfg_bcn_link2 .= "MASTER=\"bcn_bond1\"";
		
		#$conf->{path}{nodes}{bcn_bond1_config};
		my $ifcfg_bcn_bond1 =  "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		   $ifcfg_bcn_bond1 .= "# Back-Channel Network - Bond 1\n";
		   $ifcfg_bcn_bond1 .= "DEVICE=\"bcn_bond1\"\n";
		   $ifcfg_bcn_bond1 .= "MTU=\"$conf->{sys}{mtu}\"\n" if $conf->{sys}{mtu} ne "1500";
		   $ifcfg_bcn_bond1 .= "BOOTPROTO=\"static\"\n";
		   $ifcfg_bcn_bond1 .= "ONBOOT=\"yes\"\n";
		   $ifcfg_bcn_bond1 .= "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=bcn_link1\"\n";
		   $ifcfg_bcn_bond1 .= "IPADDR=\"$conf->{network}{bcn}{ip}\"\n";
		   $ifcfg_bcn_bond1 .= "NETMASK=\"$conf->{network}{bcn}{netmask}\"\n";
		   $ifcfg_bcn_bond1 .= "DEFROUTE=\"no\"";
		
		### Setup my IFN files.
		# IFN Link 1
		my $ifcfg_ifn_link1 =  "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		   $ifcfg_ifn_link1 .= "# Internet-Facing Network - Link 1\n";
		   $ifcfg_ifn_link1 .= "DEVICE=\"ifn_link1\"\n";
		   $ifcfg_ifn_link1 .= "MTU=\"$conf->{sys}{mtu}\"\n" if $conf->{sys}{mtu} ne "1500";
		   $ifcfg_ifn_link1 .= "NM_CONTROLLED=\"no\"\n";
		   $ifcfg_ifn_link1 .= "BOOTPROTO=\"none\"\n";
		   $ifcfg_ifn_link1 .= "ONBOOT=\"yes\"\n";
		   $ifcfg_ifn_link1 .= "SLAVE=\"yes\"\n";
		   $ifcfg_ifn_link1 .= "MASTER=\"ifn_bond1\"";
		
		# IFN Link 2
		my $ifcfg_ifn_link2 =  "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		   $ifcfg_ifn_link2 .= "# Internet-Facing Network - Link 2\n";
		   $ifcfg_ifn_link2 .= "DEVICE=\"ifn_link2\"\n";
		   $ifcfg_ifn_link2 .= "MTU=\"$conf->{sys}{mtu}\"\n" if $conf->{sys}{mtu} ne "1500";
		   $ifcfg_ifn_link2 .= "NM_CONTROLLED=\"no\"\n";
		   $ifcfg_ifn_link2 .= "BOOTPROTO=\"none\"\n";
		   $ifcfg_ifn_link2 .= "ONBOOT=\"yes\"\n";
		   $ifcfg_ifn_link2 .= "SLAVE=\"yes\"\n";
		   $ifcfg_ifn_link2 .= "MASTER=\"ifn_bond1\"";
		
		# IFN Bond 1
		my $ifcfg_ifn_bond1 =  "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		   $ifcfg_ifn_bond1 .= "# Internet-Facing Network - Bond 1\n";
		   $ifcfg_ifn_bond1 .= "DEVICE=\"ifn_bond1\"\n";
		   $ifcfg_ifn_bond1 .= "MTU=\"$conf->{sys}{mtu}\"\n" if $conf->{sys}{mtu} ne "1500";
		   $ifcfg_ifn_bond1 .= "BOOTPROTO=\"static\"\n";
		   $ifcfg_ifn_bond1 .= "ONBOOT=\"yes\"\n";
		   $ifcfg_ifn_bond1 .= "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=ifn_link1\"\n";
		   $ifcfg_ifn_bond1 .= "IPADDR=\"$conf->{network}{ifn}{ip}\"\n";
		   $ifcfg_ifn_bond1 .= "NETMASK=\"$conf->{network}{ifn}{netmask}\"\n";
		   $ifcfg_ifn_bond1 .= "GATEWAY=\"$conf->{network}{ifn}{gateway}\"\n";
		   $ifcfg_ifn_bond1 .= "DNS1=\"$conf->{network}{ifn}{dns1}\"\n";
		   $ifcfg_ifn_bond1 .= "DNS2=\"$conf->{network}{ifn}{dns2}\"\n";
		   $ifcfg_ifn_bond1 .= "DEFROUTE=\"yes\"";
		   
		### Don't die here! Only warn so hopefully at least one link
		### will be up in an oops.
		## Start writing!
		# BCN Bond 1
		open (my $file_handle, '>', "$ifcfg_bcn_bond1_file") || warn "Failed to write: [$ifcfg_bcn_bond1_file], error was: $!\n";
		print $file_handle $ifcfg_bcn_bond1;
		close $file_handle;
		
		# BCN Link 1
		open ($file_handle, '>', "$ifcfg_bcn_link1_file") || warn "Failed to write: [$ifcfg_bcn_link1_file], error was: $!\n";
		print $file_handle $ifcfg_bcn_link1;
		close $file_handle;
		
		# BCN Link 2
		open ($file_handle, '>', "$ifcfg_bcn_link2_file") || warn "Failed to write: [$ifcfg_bcn_link2_file], error was: $!\n";
		print $file_handle $ifcfg_bcn_link2;
		close $file_handle;
		
		# IFN Bond 1
		open ($file_handle, '>', "$ifcfg_ifn_bond1_file") || warn "Failed to write: [$ifcfg_ifn_bond1_file], error was: $!\n";
		print $file_handle $ifcfg_ifn_bond1;
		close $file_handle;
		
		# IFN Link 1
		open ($file_handle, '>', "$ifcfg_ifn_link1_file") || warn "Failed to write: [$ifcfg_ifn_link1_file], error was: $!\n";
		print $file_handle $ifcfg_ifn_link1;
		close $file_handle;
		
		# IFN Link 2
		open ($file_handle, '>', "$ifcfg_ifn_link2_file") || warn "Failed to write: [$ifcfg_ifn_link2_file], error was: $!\n";
		print $file_handle $ifcfg_ifn_link2;
		close $file_handle;
	}
	else
	{
		# BCN first
		my $bcn_link1_file = "$conf->{path}{network_configs}/ifcfg-bcn_link1";
		print "- BCN Link 1: [$bcn_link1_file]\n";
		my $shell_call = $bcn_link1_file;
		open (my $file_handle, '>', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		print $file_handle "# Back-Channel Network - Link 1\n";
		print $file_handle "DEVICE=\"bcn_link1\"\n";
		print $file_handle "BOOTPROTO=\"static\"\n";
		print $file_handle "NM_CONTROLLED=\"no\"\n";
		print $file_handle "IPADDR=\"$conf->{network}{bcn}{ip}\"\n";
		print $file_handle "NETMASK=\"$conf->{network}{bcn}{netmask}\"\n";
		print $file_handle "DEFROUTE=\"no\"\n";
		close $file_handle;
		
		# Now the IFN
		my $ifn_link1_file = "$conf->{path}{network_configs}/ifcfg-ifn_link1";
		print "- IFN Link 1: [$ifn_link1_file]\n";
		$shell_call = $ifn_link1_file;
		open ($file_handle, '>', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		print $file_handle "# Internet-Facing Network - Link 1\n";
		print $file_handle "DEVICE=\"ifn_link1\"\n";
		print $file_handle "BOOTPROTO=\"static\"\n";
		print $file_handle "NM_CONTROLLED=\"no\"\n";
		print $file_handle "IPADDR=\"$conf->{network}{ifn}{ip}\"\n";
		print $file_handle "NETMASK=\"$conf->{network}{ifn}{netmask}\"\n";
		print $file_handle "GATEWAY=\"$conf->{network}{ifn}{gateway}\"\n";
		print $file_handle "DNS1=\"$conf->{network}{ifn}{dns1}\"\n";
		print $file_handle "DNS2=\"$conf->{network}{ifn}{dns2}\"\n";
		print $file_handle "DEFROUTE=\"yes\"\n";
		close $file_handle;
		
		print "Done.\n\n";
	}
	
	# Reboot to make sure changes take effect.
	$conf->{sys}{reboot_needed} = 1;
	
	return(0);
}

# This returns the current date and time in 'YYYY/MM/DD HH:MM:SS' format. It
# always uses 24-hour time and it zero-pads single digits.
sub get_date
{
	my ($conf) = @_;
	my $date = "";
	
	# This doesn't support offsets or other advanced features.
	my %time;
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	$date = "$time{year}/$time{pad_mon}/$time{pad_mday} $time{pad_hour}:$time{pad_min}:$time{pad_sec}";
	
	return($date);
}

# This writes out the udev 70-persistent-net.rules file.
sub write_udev_persistent_net
{
	my ($conf) = @_;
	
	my $shell_call = "$conf->{path}{persistent_net}";
	print "Writing the new udev rules file: [$conf->{path}{persistent_net}]\n";
	open (my $file_handle, '>', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic = $nic;
		if    ($nic =~ /^bcn_link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^ifn_link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		my $this_mac = $conf->{nic}{name}{$nic};
		if (not $this_mac)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ]   Desired NIC: [$nic] doesn't have a referenced MAC address!\n";
			exit(1);
		}
		print $file_handle "# $say_nic\n";
		print $file_handle "SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR{address}==\"$this_mac\", NAME=\"$nic\"\n\n";
	}
	close $file_handle;
	print "Done.\n\n";
	
	return(0);
}

# This starts or stops the specified systemd service.
sub daemon_control
{
	my ($conf, $service, $task) = @_;
	
	my $message    = "";
# 	my $shell_call = "$conf->{executable}{systemctl} $task $service";
# 	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
# 	while(<$file_handle>)
# 	{
# 		chomp;
# 		my $line = $_;
# 		$message .= "$line\n";
# 		print "- Shell output: [$line]\n";
# 	}
# 	close $file_handle;
	
	return($message);
}

# This backs up the udev (if it exists) and network files before making any
# actual changes to the system.
sub backup_original_files
{
	my ($conf) = @_;
	
	print "Backing up some network related system files.\n";
	if (not $conf->{path}{backups})
	{
		print "[ Error ] - The backup directory is not defined!\n";
		print "[ Error ]   Unable to safely proceed, exiting.\n";
		exit(5);
	}
	elsif (not -e $conf->{path}{backups})
	{
		print "- The backup directory: [$conf->{path}{backups}] doesn't exist, creting it.\n";
		mkdir $conf->{path}{backups} or die warn "[ Warning ] - Failed to create the directory: [$conf->{path}{backups}].\n[ Warning ] - The error was: $!\n";
		if (not -e $conf->{path}{backups})
		{
			print "[ Error ] - The backup directory was not created.\n";
			print "[ Error ]   Unable to safely proceed, exiting.\n";
			exit(6);
		}
		else
		{
			print "- Backup directory successfully created.\n";
		}
	}
	
	# If there is already a backup created, skip it as we're probably being
	# run a second (of thirteenth) time.
	print "- Backing up: [$conf->{path}{persistent_net}]\n";
	if (-e "$conf->{path}{backups}/70-persistent-net.rules")
	{
		print "- Previous backup exists, skipping.\n";
	}
	else
	{
		# Backup '70-persistent-net.rules' if it exists.
		if (-e $conf->{path}{persistent_net})
		{
			print "- It exists, backing it up.\n";
			backup_file($conf, $conf->{path}{persistent_net});
		}
		else
		{
			print "- Doesn't exist, skipping.\n";
		}
	}
	
	# Backup the '/etc/sysconfig/network-scripts' directory.
	print "- Backing up: [$conf->{path}{network_configs}]\n";
	if (-e "$conf->{path}{backups}/network-scripts")
	{
		print "- Previous backup exists, skipping.\n";
	}
	else
	{
		if (-e $conf->{path}{network_configs})
		{
			# No need to say it exists
			backup_file($conf, $conf->{path}{network_configs});
		}
		else
		{
			# Ok, the user has bigger problems
			print "[ Error ] - The network configuration directory was not found!\n";
			print "[ Error ]   This should not be possible.\n";
			print "[ Error ]   Please check the internal path::network_configs value.\n";
			exit(8);
		}
	}
	print "Done.\n\n";
	
	return(0);
}

# This backups up a file (or directory) to the backups directory. It is
# expected that the existance of the source and backup directories are done.
sub backup_file
{
	my ($conf, $file) = @_;
	
	if (not $file)
	{
		print "[ Error ] - The backup function was called, but no source file was given.\n";
		print "[ Error ]   This is likely a program error, exiting.\n";
		exit(7);
	}
	
	# I want the source, if it is a directory, to not have a trailing
	# slash. Conversly, I want the backup directory to have a trailing
	# slash, if it doesn't have it already.
	$file =~ s/\/$//g;
	$conf->{path}{backups} .= "/" if $conf->{path}{backups} !~ /\/$/;
	
	my $shell_call = "$conf->{executable}{cp} -ab $file $conf->{path}{backups}";
	print "- Copying: [$file] to: [$conf->{path}{backups}]\n";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Shell output: [$line]\n";
	}
	close $file_handle;
	
	### TODO: Verify the backed up file exists in the backup directory.
	#print "- Done\n";
	
	return(0);
}

# This breaks out the command-line switches and varifies that their values are
# (more or less) sane
sub sanity_check_switches
{
	my ($conf) = @_;
	
	# Something has been set for all values, sanity check them.
	# This will fail out if set to '1' once all sanity checking is done.
	my $bad_value = 0;

	# The network is a little tricker
	if (($conf->{switches}{h}) or ($conf->{switches}{help}) or ($conf->{switches}{'?'}))
	{
		print_usage($conf);
		exit(0);
	}
	if (($conf->{switches}{b}) && ($conf->{switches}{i}))
	{
		# Both defined, sanity check them.
		($bad_value) = sanity_check_network($conf, $bad_value);
	}
	elsif ((not $conf->{switches}{b}) && (not $conf->{switches}{i}))
	{
		print "[ Note ] - No network details given. Skipping Network config!\n";
		my $shell_call = "$conf->{executable}{ip} addr show bcn_link1";
		open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /inet (\d+\.\d+\.\d+\.\d+)\/(\d+) /)
			{
				$conf->{network}{bcn}{ip}      = $1;
				$conf->{network}{bcn}{netmask} = convert_cidr_to_dotted_decimal($conf, $2);
				#print "[ Debug ] - BCN IP: [$conf->{network}{bcn}{ip}], netmask: [$conf->{network}{bcn}{netmask}]\n";
			}
		}
		close $file_handle;
		$conf->{sys}{skip_network} = 1;
		if ((not $conf->{network}{bcn}{ip}) || (not $conf->{network}{bcn}{netmask}))
		{
			# Might have been configured in a previous run but not
			# yet rebooted.
			if (not -e "$conf->{path}{network_configs}/ifcfg-bcn_link1")
			{
				print "[ Error ] - Network configuration is disabled, but the BCN network's IP address\n";
				print "[ Error ]   and network mask were not found. Is the device 'bcn_link1'\n";
				print "[ Error ]   configured with an IP address?\n";
				$bad_value = 1;
			}
			else
			{
				# It looks like it's already been configured,
				# so no need to panic.
			}
		}
	}
	elsif (not $conf->{switches}{b})
	{
		print "[ Error ] - The IFN settings were given, but not the BCN. I am sorry but both\n";
		print "[ Error ]   or neither network must be defined at this time.\n";
		$bad_value = 1;
	}
	elsif (not $conf->{switches}{i})
	{
		print "[ Error ] - The BCN settings were given, but not the IFN. I am sorry but both\n";
		print "[ Error ]   or neither network must be defined at this time.\n";
		$bad_value = 1;
	}
	
	# Check the DHCP/PXE stuff
	### TODO: Add some logic to make sure the DHCP lease range matches
	###       either the BCN or IFN subnet
	if ($conf->{switches}{p})
	{
		($bad_value) = sanity_check_dhcp($conf, $bad_value);
	}
	elsif (($conf->{switches}{'centos-iso'}) || ($conf->{switches}{'rhel-iso'}))
	{
		print "[ Error ] - The DHCP lease range must be defined for PXE-based installs to\n";
		print "[ Error ]   work. Note that the DHCP server will *only* run when enabled via\n";
		print "[ Error ]   the Striker dashboard. It will never start on boot.\n";
		$bad_value = 1;
	}

	# Check the hostname
	if ($conf->{switches}{n})
	{
		# Make sure the hostname is sane.
		$conf->{sys}{hostname} = $conf->{switches}{n};
		($bad_value) = sanity_check_hostname($conf, $conf->{switches}{n}, 0, $bad_value);
	}
	else
	{
		print "[ Note ] - No hostname given. Will not change it.\n";
		$conf->{sys}{skip_hostname} = 1;
	}
	
	# See if they set an owner name
	if (not $conf->{switches}{c})
	{
		print "[ Note ] - No customer/owner name given, will use: [$conf->{sys}{customer}]\n";
		# TODO: check to see if apache limits the names allowed.
	}
	else
	{
		# TODO: Does this need to be sanitized to prevent injection of
		#       malicious code? If so, how? Escape all quotes?
		$conf->{sys}{customer} = $conf->{switches}{c};
	}
	
	# See if they've asked for a specific version.
	if (not $conf->{switches}{d})
	{
		print "[ Note ] - No specific version requested, will install: [$conf->{sys}{stable_version}]\n";
		$conf->{sys}{install_version} = $conf->{sys}{stable_version};
		$conf->{url}{striker}         =~ s/#!striker_version!#/$conf->{sys}{install_version}/;
		$conf->{sys}{tarball_dir}     =~ s/#!striker_version!#/$conf->{sys}{install_version}/;
		# TODO: check to see if the requested version exists
	}
	else
	{
		# Make sure the request is sane. First check for a supported
		# version:
		$conf->{sys}{install_version} =  $conf->{switches}{d};
		$conf->{url}{striker}         =~ s/#!striker_version!#/$conf->{sys}{install_version}/;
		$conf->{sys}{tarball_dir}     =~ s/#!striker_version!#/$conf->{sys}{install_version}/;
		if (($conf->{switches}{d} eq "1.1.4") || ($conf->{switches}{d} eq "1.1.5"))
		{
			print "[ Note ] - Will install version: [$conf->{switches}{d}]\n";
		}
		elsif ($conf->{switches}{d} eq "git")
		{
			print "[ Note ] - Will install the latest version from git.\n";
			print "\n ##############################################################################\n";
			print " # [ Warning ] - Please do NOT use a git version in production!               #\n";
			print " ##############################################################################\n\n";
			#sleep 5;
		}
		else
		{
			print "[ Error ] - Unsupported Striker version requested!\n";
			print "[ Error ] - Is this installer too old?\n";
			$bad_value = 1;
		}
	}
	
	# With mail, both or neither must be provided (XNOR y'all!)
	if (($conf->{switches}{e}) && ($conf->{switches}{m}))
	{
		# Validate the mail domain
		($bad_value) = sanity_check_hostname($conf, $conf->{switches}{m}, 1, $bad_value);
		# TODO: Validate the email local user part. Note that a lot 
		#       more flexibility is allowed here than in the domain, 
		#       including UTF-8. See:
		#       https://en.wikipedia.org/wiki/Email_address#Local_part
		$conf->{sys}{mail_server}   = $conf->{switches}{m};
		if ($conf->{switches}{e} =~ /^(.*?):(.*)$/)
		{
			$conf->{sys}{mail_user}     = $1;
			$conf->{sys}{mail_password} = $2;
		}
		else
		{
			print "[ Error ] - The email switch needs to be in the format '<email>:<password>'\n";
			$bad_value = 1;
		}
	}
	elsif ((not $conf->{switches}{e}) && (not $conf->{switches}{m}))
	{
		print "[ Note ]    - Mail server information not provided.\n";
		print "[ Warning ] - If mail sending was not previously configured, you may encounter\n";
		print "[ Warning ]   problems later!\n";
		$conf->{sys}{skip_mail} = 1;
	}
	elsif (not $conf->{switches}{e})
	{
		print "[ Error ] - A mail server alone can not be specified. Please specify\n";
		print "[ Error ]   credentials to use when logging into: [$conf->{switches}{m}].\n";
		$bad_value = 1;
	}
	elsif (not $conf->{switches}{m})
	{
		print "[ Error ] - Credentials for logging into a mail server were given but the mail\n";
		print "[ Error ]   server address itself was not.\n";
		$bad_value = 1;
	}
	
	# Check to see if either the htpasswd file exists or the user is giving us a user now.
	if ((not -e $conf->{path}{apache_htpasswd}) && (not $conf->{switches}{u}))
	{
		print "[ Error ] - No apache credentials were set, and: [$conf->{path}{apache_htpasswd}]\n";
		print "[ Error ]   doesn't exist. This is required for Striker to work securely.\n";
		$bad_value = 1;
	}
	elsif ($conf->{switches}{u})
	{
		if ($conf->{switches}{u} =~ /^(.*?):(.*)$/)
		{
			$conf->{sys}{striker_user} = $1;
			$conf->{sys}{striker_pass} = $2;
		}
		else
		{
			print "[ Error ] - The Striker user name and password were not specified correctly.\n";
			print "[ Error ]   Please use '-u \"<user:password>\".\n";
			$bad_value = 1;
		}
	}
	
	# Make sure the --rhn' switch parses, if set.
	if ($conf->{switches}{rhn})
	{
		if ($conf->{switches}{rhn} =~ /^(.*?):(.*)$/)
		{
			$conf->{sys}{rhn_user}     = $1;
			$conf->{sys}{rhn_password} = $2;
		}
		else
		{
			print "[ Error ] - The Red Hat Network user name and password were not specified\n";
			print "[ Error ]   correctly. Please use '--rhn \"<user:password>\".\n";
			$bad_value = 1;
		}
	}
	
	### Sanity check IPMI if set.
	# Credentials
	if ($conf->{switches}{'ipmi-user'})
	{
		if ($conf->{switches}{'ipmi-user'} =~ /^(.*?):(.*)$/)
		{
			$conf->{sys}{ipmi_user}     = $1;
			$conf->{sys}{ipmi_password} = $2;
		}
		else
		{
			print "[ Error ] - The IPMI BMC user name and password were not specified correctly.\n";
			print "[ Error ]   Please use '--ipmi-user \"<user:password>\".\n";
			$bad_value = 1;
		}
	}
	
	# IP address
	if ($conf->{switches}{'ipmi-ip'})
	{
		# Did the user specify a gateway?
		if ($conf->{switches}{'ipmi-ip'} =~ /^(.*?)\/(.*?),dg=(.*)$/)
		{
			$conf->{sys}{ipmi_ip}      = $1;
			$conf->{sys}{ipmi_netmask} = $2;
			$conf->{sys}{ipmi_gateway} = $3;
		}
		elsif ($conf->{switches}{'ipmi-ip'} =~ /^(.*?)\/(.*)$/)
		{
			$conf->{sys}{ipmi_ip}      = $1;
			$conf->{sys}{ipmi_netmask} = $2;
		}
		else
		{
			# Unparsable
			print "[ Error ] - The IPMI BMC user name and password were not specified correctly.\n";
			print "[ Error ]   Please use '--ipmi-user \"<user:password>\".\n";
			$bad_value = 1;
		}
	
		### Verify sanity
		# IP address
		$conf->{sys}{ipmi_ip} = validate_ip_address($conf, $conf->{sys}{ipmi_ip});
		if ($conf->{sys}{ipmi_ip} eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IPMI IP address: [$conf->{sys}{ipmi_ip}] is not valid.\n";
			$bad_value = 1;
		}
		
		# Netmask
		if ($conf->{sys}{ipmi_netmask} =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$conf->{sys}{ipmi_netmask} = convert_cidr_to_dotted_decimal($conf, $conf->{sys}{ipmi_netmask});
		}
		else
		{
			$conf->{sys}{ipmi_netmask} = validate_ip_address($conf, $conf->{sys}{ipmi_netmask});
		}
		if ($conf->{sys}{ipmi_netmask} eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IPMI netmask value: [$conf->{sys}{ipmi_netmask}] is not valid.\n";
			$bad_value = 1;
		}
		
		# If defined, validate the gateway
		if ($conf->{sys}{ipmi_gateway})
		{
			$conf->{sys}{ipmi_gateway} = validate_ip_address($conf, $conf->{sys}{ipmi_gateway});
			if ($conf->{sys}{ipmi_gateway} eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IPMI gateway: [$conf->{sys}{ipmi_gateway}] is not valid.\n";
				$bad_value = 1;
			}
		}
	}

	print "Sanity checks complete.\n\n";
	return($bad_value);
}

# This checks the DHCP lease start and end range.
sub sanity_check_dhcp
{
	my ($conf, $bad_value) = @_;
	
	$conf->{switches}{lease_start} = "";
	$conf->{switches}{lease_end}   = "";
	if ($conf->{switches}{p} =~ /(\d+\.\d+\.\d+\.\d+):(\d+\.\d+\.\d+\.\d+)/)
	{
		$conf->{switches}{lease_start} = $1;
		$conf->{switches}{lease_end}   = $2;
	}
	
	if ((not $conf->{switches}{lease_start}) && (not $conf->{switches}{lease_end}))
	{
		print "[ Error ] - You need to specify the start and end IP lease range as\n";
		print "[ Error ]   '-p <start_ip>:<end_ip>'\n";
		$bad_value = 1;
	}
	elsif ((not $conf->{switches}{lease_start}) || (not $conf->{switches}{lease_end}))
	{
		print "[ Error ] - Both '<start_ip>:<end_ip>' are needed with the '-p' switch.\n";
		$bad_value = 1;
	}
	
	# Lastly, make sure the start and end range are in the same subnet.
	### TODO: Make this work across all subnet/CIDR ranges
	my $start_prefix = "";
	my $end_prefix   = "";
	if ($conf->{network}{bcn}{netmask} eq "255.255.0.0")
	{
		$start_prefix = ($conf->{switches}{lease_start} =~ /^(\d+\.\d+\.)/)[0];
		$end_prefix   = ($conf->{switches}{lease_end}   =~ /^(\d+\.\d+\.)/)[0];
	}
	elsif ($conf->{network}{bcn}{netmask} eq "255.255.255.0")
	{
		$start_prefix = ($conf->{switches}{lease_start} =~ /^(\d+\.\d+\.\d+\.)/)[0];
		$end_prefix   = ($conf->{switches}{lease_end}   =~ /^(\d+\.\d+\.\d+\.)/)[0];
	}
	if ((not $start_prefix) && (not $end_prefix))
	{
		### TODO: This is hit when the BCN isn't specified. Move the
		###       function that reads the BCN config (if it exists)
		###       into a function and call it here.
		#print "[ Warning ] - Unable to check if the start and end IPs are in the same subnet.\n";
	}
	elsif ($start_prefix ne $end_prefix)
	{
		print "[ Error ] - The DHCP lease start: [$conf->{switches}{lease_start}] and end: [$conf->{switches}{lease_end}]\n";
		print "[ Error ]   IPs do not appear to be in the same subnet: [xxx.xxx.xxx.xxx].\n";
		print "[ Note ]  - Only the BCN subnet is used for DHCP.\n";
		$bad_value = 1;
	}
	
	return($bad_value);
}

# This sanity-checks the host name.
sub sanity_check_hostname
{
	my ($conf, $hostname, $port_allowed, $bad_value) = @_;
	
	my $port;
	if ($hostname =~ /(.*?):(\d+)$/)
	{
		$hostname = $1;
		$port     = $2;
		
		if (not $port_allowed)
		{
			print "[ Error ] - A port number was set for: [$hostname]\n";
			print "[ Error ]   but it is not allowed here.\n";
			$bad_value = 1;
		}
		elsif (($port < 1) || ($port > 65535))
		{
			print "[ Error ] - The port number: [$port] is out of range!\n";
			print "[ Error ]   Port numbers must be between 1 and 65535.\n";
			$bad_value = 1;
		}
	}
	
	if ($hostname =~ /\.\./)
	{
		print "[ Error ] - The hostname: [$hostname] has multiple periods!\n";
		$bad_value = 1;
	}
	if ($hostname =~ /^\./)
	{
		print "[ Error ] - The hostname: [$hostname] starts with a period!\n";
		$bad_value = 1;
	}
	if ($hostname =~ /\.$/)
	{
		print "[ Error ] - The hostname: [$hostname] ends with a period!\n";
		$bad_value = 1;
	}
	# Now loop through the hostname's elements and make sure they're sane.
	foreach my $name (split/\./, $hostname)
	{
		if (not $name)
		{
			print "[ Error ] - The hostname: [$hostname] appears to have an empty element!\n";
			print "[ Error ]   This might be a program error.\n";
			$bad_value = 1;
		}
		if (length($name) > 255)
		{
			print "[ Error ] - The hostname: [$hostname]'s section: [$name] is too long!\n";
			$bad_value = 1;
		}
		if ($name =~ /[^0-9a-zA-Z\-]/)
		{
			print "[ Error ] - The hostname: [$hostname]'s section: [$name] contains an illegal character!\n";
			print "[ Error ]   only alpha-numeric and the '-' character are allowed\n";
			$bad_value = 1;
		}
	}
	
	return($bad_value);
}

# This sanity checks the network settings passed by the user.
sub sanity_check_network
{
	my ($conf, $bad_value) = @_;
	
	### Now sanity check passed values
	# First up, the BCN
	if ($conf->{switches}{b} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified BCN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{bcn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified BCN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{bcn}{netmask} = $netmask;
		}
	}
	else
	{
		print "[ Error ] - The specified BCN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}

	# Next is the IFN, which is a little more complicated.
	if ($conf->{switches}{i} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;
		my $gateway = "";
		my $dns1    = "";
		my $dns2    = "";
		
		# The netmask should have ',dg=X' and possibly 'dns[12]=[YZ]',
		# so pull those out.
		#print "$THIS_FILE ".__LINE__."; ip: [$ip], netmask: [$netmask]\n";
		if ($netmask =~ /,dg=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dg=(.*?),/)
			{
				$gateway = $1;
				#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			}
			else
			{
				$gateway = ($netmask =~ /,dg=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			}
		}
		
		# Now the nameservers.
		if ($netmask =~ /,dns1=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dns1=(.*?),/)
			{
				$dns1 = $1;
				#print "$THIS_FILE ".__LINE__."; dns1: [$dns1]\n";
			}
			else
			{
				$dns1 = ($netmask =~ /,dns1=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; dns1: [$dns1]\n";
			}
		}
		if ($netmask =~ /,dns2=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dns2=(.*?),/)
			{
				$dns2 = $1;
				#print "$THIS_FILE ".__LINE__."; dns2: [$dns2]\n";
			}
			else
			{
				$dns2 = ($netmask =~ /,dns2=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; dns2: [$dns2]\n";
			}
		}
		
		# Now delete everything from the netmask after the ','
		$netmask =~ s/,.*$//;
		#print "$THIS_FILE ".__LINE__."; netmask: [$netmask]\n";

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IFN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{ifn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IFN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{ifn}{netmask} = $netmask;
		}
		
		# Gateway
		#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
		if ($gateway)
		{
			$gateway = validate_ip_address($conf, $gateway);
			#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			if ($gateway eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN gateway value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{gateway} = $gateway;
				#print "$THIS_FILE ".__LINE__."; network::ifn::gateway: [$conf->{network}{ifn}{gateway}]\n";
			}
		}
		else
		{
			print "[ Error ] - The IFN gateway is not specified.\n";
			$bad_value = 1;
		}
		
		# DNS 1 and 2, if defined.
		if ($dns1)
		{
			$dns1 = validate_ip_address($conf, $dns1);
			if ($dns1 eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN dns1 value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{dns1} = $dns1;
			}
		}
		if ($dns2)
		{
			$dns2 = validate_ip_address($conf, $dns2);
			if ($dns2 eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN dns2 value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{dns2} = $dns2;
			}
		}
	}
	else
	{
		print "[ Error ] - The specified IFN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}
	
	return($bad_value);
}

# This validates a string as being an IPv4 address in dotted-decimal notation.
sub validate_ip_address
{
	my ($conf, $ip) = @_;

	if ($ip =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/)
	{
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		# First octal has to be >= 1. The rest can be 0.
		if (($first_octal < 1)  || ($first_octal > 255)  ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal < 0)  || ($third_octal > 255)  ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			$ip = "#!INVALID!#";
		}
	}
	else
	{
		# Not even formatted properl.
		$ip = "#!INVALID!#";
	}

	return($ip);
}

# This takes an integer and, if it is a valid CIDR range, returns the 
# dotted-decimal equivalent. If it's not, it returns '#!INVALID!#'.
sub convert_cidr_to_dotted_decimal
{
	my ($conf, $netmask) = @_;
	
	if ($netmask =~ /^\d{1,2}$/)
	{
		# Make sure it's a (useful) CIDR
		if (($netmask >= 1) && ($netmask <= 29))
		{
			# Yes, I know that technically '0' and '30-32' are 
			# valid, but not in our case.
			if    ($netmask == 1)  { $netmask = "128.0.0.0"; }
			elsif ($netmask == 2)  { $netmask = "192.0.0.0"; }
			elsif ($netmask == 3)  { $netmask = "224.0.0.0"; }
			elsif ($netmask == 4)  { $netmask = "240.0.0.0"; }
			elsif ($netmask == 5)  { $netmask = "248.0.0.0"; }
			elsif ($netmask == 6)  { $netmask = "252.0.0.0"; }
			elsif ($netmask == 7)  { $netmask = "254.0.0.0"; }
			elsif ($netmask == 8)  { $netmask = "255.0.0.0"; }
			elsif ($netmask == 9)  { $netmask = "255.128.0.0"; }
			elsif ($netmask == 10) { $netmask = "255.192.0.0"; }
			elsif ($netmask == 11) { $netmask = "255.224.0.0"; }
			elsif ($netmask == 12) { $netmask = "255.240.0.0"; }
			elsif ($netmask == 13) { $netmask = "255.248.0.0"; }
			elsif ($netmask == 14) { $netmask = "255.252.0.0"; }
			elsif ($netmask == 15) { $netmask = "255.254.0.0"; }
			elsif ($netmask == 16) { $netmask = "255.255.0.0"; }
			elsif ($netmask == 17) { $netmask = "255.255.128.0"; }
			elsif ($netmask == 18) { $netmask = "255.255.192.0"; }
			elsif ($netmask == 19) { $netmask = "255.255.224.0"; }
			elsif ($netmask == 20) { $netmask = "255.255.240.0"; }
			elsif ($netmask == 21) { $netmask = "255.255.248.0"; }
			elsif ($netmask == 22) { $netmask = "255.255.252.0"; }
			elsif ($netmask == 23) { $netmask = "255.255.254.0"; }
			elsif ($netmask == 24) { $netmask = "255.255.255.0"; }
			elsif ($netmask == 25) { $netmask = "255.255.255.128"; }
			elsif ($netmask == 26) { $netmask = "255.255.255.192"; }
			elsif ($netmask == 27) { $netmask = "255.255.255.224"; }
			elsif ($netmask == 28) { $netmask = "255.255.255.240"; }
			elsif ($netmask == 29) { $netmask = "255.255.255.248"; }
			else
			{
				# This should never be hit.
				$netmask = "#!INVALID!#";
			}
		}
		else
		{
			$netmask = "#!INVALID!#";
		}
	}
	
	return($netmask);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = q|
 -=] Striker installer

DESCRIPTION

This program installs and configures Striker, the Anvil! dashboard, on an
almost minimal EL6 install.


SWITCHES

 -b <ip_address/netmask>
	
	This sets the IP address and subnet to be assigned to the Back-Channel
	Network interface.

 -c <customer/owner>

	This sets the name of the customer/owner of the dashboard. This is used
	by apache at the top of the input box when asking the user for their 
	credentials. If this is not set, "Striker Dashboard" will be used alone.

 --centos-iso <'none', 'dvd', local path or URL>

	This is the local path or URL of the ISO to download for setting up the
	CentOS PXE server installer options. If this is set to 'none', CentOS
	will not be configured. 
	
	If it is set to 'dvd', the disk in the optical drive will be converted
	to an ISO and used. This option is very useful if you just installed
	CentOS off of a physical DVD.

 -d <version>

	This tells the installer what version of Striker dashboard to install.
	The default is to download the latest stable version. If set to 'git',
	the latest version in github will be installed. You probably don't want
	this unless you're a developer.

 -e <user:password>

	This is the email address user and password to use when logging in to
	the mail server. This information will be recorded in postfix's
	/etc/postfix/relay_password file.

 --gui
 
	This tells striker to install a graphical interface. This considerably
	increases the size of the install.

 -h, -?, --help

	Show this dialoge and exit.

 -i <ip_address/netmask>,dg=<ip_address>[,dns1=<ip_address>,dns2=<ip_address>]

	This sets the IP address and subnet to be assigned to the 
	Internet-Facing Network interface. Unlike -b switch, this switch
	requires a default gateway be specified after the IP address via:

	dg=<ip_address>
	
		IPv4 address of the default gateway.

	Optionally, one or two DNS servers may be specified via:
	
	dns1=<ip_address>
	dns2=<ip_address>

		IPv4 addresses of the first and/or secondary DNS server. If
		these are not set, dns1 will default to 8.8.8.8 and dns2 will
		default to 8.8.4.4

 --ipmi-user <user:password>

	If specified, and if an IPMI BMC is found, the installer will set the
	IPMI BMC password for the specified user.
	
	Note: This will *not* create a user! If the specified user is not found
	      in the IPMI user list, the password will not be set and an error
	      will be printed.

 --ipmi-ip <ip_address/netmask>[,gw=<ip_address>]
 
	If specified, and if an IPMI BMC is found, the installer will set the
	IPMI BMC to have the specified IP address and network mask/subnet.
	Optionally, if 'gw' is set, the BMC's gateway will also be set.

 -m <mail server:port>

	This sets the mail server and port to use for sending email. If no port
	is set, 587 will be used. This information will be recorded in
	postfix's /etc/postfix/relay_password file.

 -n <hostname>

	This sets the host name of the Striker dashboard.

 --no-an-repo

	Use this to prevent adding the AN! software repository to this striker.
	If specified and if the repo exists, it will be removed.

 -p <start_ip:end_ip>
 
	This sets the DHCP range that this Striker dashboard will offer IPs on
	for new machines being installed off of the local PXE server. If set to
	'none', PXE will not be configured.

	NOTE: This lease range must be in the BCN subet. We do not want to
	      interfere with existing DHCP servers on the IFN!

 -r <repo>

	This allows for a repository to be added to the system. This must be
	either a network path (http, https or ftp). Multiple repos can be
	specified by using comma-separated URLs.

 --rhel-iso <'none', 'dvd', local path or URL>

	This is the local path or URL of the ISO to download for setting up the
	Red Hat Enterprise Linux PXE server installer options. If this is set
	to 'none', RHEL will not be configured. 
	
	If it is set to 'dvd', the disk in the optical drive will be converted
	to an ISO and used. This option is very useful if you just installed
	RHEL off of a physical DVD.

 --rhn <user:password>

	When installing on a RHEL server, these credentials can be passed to
	add the machine to yout RHN account. If you do not pass this and if
	your machine is not already activated, the install will fail.

 -u <user:password>

	This is the user name and password to set for Striker. This will be
	used in apache's htpasswd authentication and will be stored in the
|;
	$help .= "	$conf->{path}{apache_htpasswd} file.\n";
	$help .= q|

	NOTE: This also sets the 'root' user's password on the striker
	      appliance! 

 -y

	Automatically answers "yes" to prompts. Specifically, this prevents
	confirmation request for network remapping, so it should only be used
	by scripts.


NOTE: that all IP addresses must be IPv4 in dotted-decimal notation. The
netmask can be in CIDR or dotted-decimal notation. Do not leave a space
between the IP address and netmask


EXAMPLE

Normal install, downloading ISOs from local web server:

 ./striker-installer -c "Alteeve's Niche\!" \
                  -e "foo@alteeve.ca:secret password" \
                  -m mail.alteeve.ca:587 \
                  -n an-m01.alteeve.ca \
                  -u "admin:secret password" \
                  -p 10.20.10.200:10.20.10.210 \
                  -r http://10.255.255.254/repo/rhel6/local.repo \
                  --centos-iso http://10.255.255.254/c6/x86_64/iso/CentOS-6.6-x86_64-bin-DVD1.iso \
                  --rhel-iso http://10.255.255.254/rhel6/x86_64/iso/rhel-server-6.6-x86_64-dvd.iso \
                  -b 10.20.4.1/16 \
                  -i 10.255.4.1/16,dg=10.255.255.254,dns1=8.8.8.8,dns2=8.8.4.4

Developer install, using local copies of ISOs:

 ./striker-installer -c "Alteeve's Niche\!" \
                  -e "foo@alteeve.ca:secret password" \
                  -m mail.alteeve.ca:587 \
                  -n an-m01.alteeve.ca \
                  -d git \
                  -u "admin:secret password" \
                  -p 10.20.10.200:10.20.10.210 \
                  --centos-iso ./iso/CentOS-6.6-x86_64-bin-DVD1.iso \
                  --rhel-iso ./iso/rhel-server-6.6-x86_64-dvd.iso \
                  -b 10.20.4.1/16 \
                  -i 10.255.4.1/16,dg=10.255.255.254,dns1=8.8.8.8,dns2=8.8.4.4

Install without configuring the network or PXE server:

 ./striker-installer -c "Alteeve's Niche\!" \
                  -e "foo@alteeve.ca:secret password" \
                  -m mail.alteeve.ca:587 \
                  -n an-m01.alteeve.ca \
                  -p none \
                  -u "admin:secret password"

Note: As with any bash call, you must escape '!' characters with '\!'.

                  
SUPPORT

https://alteeve.ca/w/Support

							      Alteeve's Niche!
|;
	open (my $file_handle, ">", "/tmp/striker-installer-help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/striker-installer-help");

	return(0);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}}) { print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# This asks the user to unplug (and plug back in) NICs to identify which
# physical interface they want to use for a given role.
sub select_nics
{
	my ($conf) = @_;

	print "-=] Configuring network to enable access to Anvil! systems.\n\n";
	print "Beginning NIC identification...\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $plug_in_message_printed = 0;
		while (my $down_links = check_nic_states($conf))
		{
			if (not $plug_in_message_printed)
			{
				print "- Please plug in all network cables to proceed.\n";
				$plug_in_message_printed = 1;
			}
			#print "MAC address of down links: [$down_links]\n";
			sleep 1;
		}
		my $say_nic = $nic;
		if    ($nic =~ /^bcn_link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^ifn_link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		print "- Please unplug the interface you want to make:\n";
		print "  [$say_nic]\n";
		my $last_conflict = "";
		while(1)
		{
			my $down_links = check_nic_states($conf);
			if (($down_links) && ($down_links !~ /,/))
			{
				if ($conf->{nic}{mac}{$down_links}{new_name})
				{
					print "- The NIC with MAC address: [$down_links] is already allocated to: [$conf->{nic}{mac}{$down_links}{new_name}]\n" if ($last_conflict ne $down_links);
					$last_conflict = $down_links;
				}
				else
				{
					$conf->{nic}{mac}{$down_links}{new_name} = $nic;
					$conf->{nic}{name}{$nic}                 = $down_links;
					print "- NIC with MAC: [$down_links] will become: [$conf->{nic}{mac}{$down_links}{new_name}]\n";
					print "  (it is currently: [$conf->{nic}{mac}{$down_links}{current_name}])\n";
					last;
				}
			}
			sleep 1;
		}
	}
	my $plug_in_message_printed = 0;
	while (my $down_links = check_nic_states($conf))
	{
		if (not $plug_in_message_printed)
		{
			print "- Please plug in all network cables to proceed.\n";
			$plug_in_message_printed = 1;
		}
		sleep 1;
	}

	my $proceed = 1;
	print "\nHere is what you selected:\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic = $nic;
		if    ($nic =~ /^bcn_link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^ifn_link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		my $this_mac = $conf->{nic}{name}{$nic};
		if (not $this_mac)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ]   Desired NIC: [$nic] doesn't have a referenced MAC address!\n";
			exit(1);
		}
		my $current_name = $conf->{nic}{mac}{$this_mac}{current_name};
		if (not $current_name)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ]   Desired NIC: [$nic] doesn't have a referenced interface!\n";
			exit(2);
		}
		print "- Interface: [".uc($this_mac)."], currently named: [$current_name],\n";
		print "  will be renamed to: [$nic]\n";
		#print "- $say_nic will use the NIC with MAC: [$this_mac] ($current_name -> $nic)\n";
	}
	my $bcn_ip      = $conf->{network}{bcn}{ip};
	my $bcn_netmask = $conf->{network}{bcn}{netmask};
	print "\nThe Back-Channel Network interface will be set to:\n";
	print "- IP:      [$bcn_ip]\n";
	print "- Netmask: [$bcn_netmask]\n\n";
	my $ifn_ip      = $conf->{network}{ifn}{ip};
	my $ifn_netmask = $conf->{network}{ifn}{netmask};
	my $ifn_gateway = $conf->{network}{ifn}{gateway};
	my $ifn_dns1    = $conf->{network}{ifn}{dns1};
	my $ifn_dns2    = $conf->{network}{ifn}{dns2};
	print "The Internet-Facing Network interface will be set to:\n";
	print "- IP:      [$ifn_ip]\n";
	print "- Netmask: [$ifn_netmask]\n";
	print "- Gateway: [$ifn_gateway]\n";
	print "- DNS1:    [$ifn_dns1]\n";
	print "- DNS2:    [$ifn_dns2]\n\n";
	print "Shall I proceed? [Y/n] ";
	if ($conf->{switches}{y})
	{
		print "\n- Auto-yes used, proceeding.\n\n";
	}
	else
	{
		my $answer = <STDIN>;
		chomp($answer);
		if (($answer) && (lc($answer) =~ /^n/))
		{
			$proceed = 0;
			print "- Ok, starting over.\n";
			sleep 2;
			system('clear');
		}
		else
		{
			print "- Thank you, I will start to work now.\n\n";
		}
	}

	return($proceed);
}

sub check_nic_states
{
	my ($conf) = @_;
	
	my $unplugged_macs  = "";
	my $this_iface      = "";
	my $this_mac        = "";
	my $this_link_state = "";
	my $this_ip         = "";
	my $shell_call = "$conf->{executable}{ip} addr";
	open (my $file_handle, '-|', "$shell_call") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^\d+: (.*?): <(.*?)>/)
		{
			$this_iface      = $1;
			$this_link_state = $2;
			$this_mac        = "";
			if ($this_link_state =~ /UP/)
			{
				# This will be either BROADCAST or NO-CARRIER
				$this_link_state =~ s/,.*//;
			}
			else
			{
				# The interface has been 'ifdown'ed or was not
				# started on boot.
				$this_link_state = "DOWN";
			}
			next;
		}
		next if not $this_iface;
		next if $this_iface eq "lo";
		next if $this_iface =~ /wlan/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		if ($line =~ /ether ([0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2})/)
		{
			# Link states:
			# 0 = Up no no link
			# 1 = Up with link
			# 2 = Down
			$this_mac = $1;
			#print "this_mac: [$this_mac]\n";
			if ($this_link_state eq "DOWN")
			{
				$this_link_state = 2;
			}
			else
			{
				$this_link_state = $this_link_state eq "NO-CARRIER" ? 0 : 1;
			}
			$conf->{nic}{mac}{$this_mac}{current_name}     = $this_iface;
			$conf->{nic}{mac}{$this_mac}{link_state}       = $this_link_state;
			$conf->{nic}{by_name}{$this_iface}{link_state} = $this_link_state;
			$conf->{nic}{by_name}{$this_iface}{mac}        = $this_mac;
		}
		if ($line =~ /inet (.*?)\/.*? brd/)
		{
			my $this_ip = $1;
			$conf->{nic}{mac}{$this_mac}{ip}       = $this_ip;
			$conf->{nic}{by_name}{$this_iface}{ip} = $this_ip;
		}
	}
	close $file_handle;

	my $nic_count = 0;
	foreach my $this_mac (sort {$a cmp $b} keys %{$conf->{nic}{mac}})
	{
		# Somewhere in the loop, an empty '$this_mac' is being created... 
		# (I'm looking at you, autovivication >_>)
		next if not $this_mac;
		my $this_iface = $conf->{nic}{mac}{$this_mac}{current_name};
		
		if (($this_iface eq "lo") || ($this_iface =~ /wlan/))
		{
			#print "[ Debug ] - Skipping interface: [$this_iface]\n";
		}
		else
		{
			$nic_count++;
			#print "[ Debug ] - NIC: [$this_iface] w/ MAC: [$this_mac]; Link: [$conf->{nic}{mac}{$this_mac}{link_state}], current name: [$conf->{nic}{mac}{$this_mac}{current_name}]\n";
		}
		if ($conf->{nic}{mac}{$this_mac}{link_state} ne "1")
		{
			$unplugged_macs .= "$this_mac,";
		}
	}
	
	# If there are four NICs, we'll want to create bonds.
	if ((not $conf->{sys}{skip_network}) && ($nic_count == 4))
	{
		# Woo! I like this user. :3
		$conf->{nics}              = ["bcn_link1", "bcn_link2", "ifn_link1", "ifn_link2"];
		$conf->{sys}{create_bonds} = 1;
	}
	
	$unplugged_macs =~ s/,$//;
	#print "- DEBUG: unpluggd_macs: [$unplugged_macs]\n";
	return($unplugged_macs);
}
