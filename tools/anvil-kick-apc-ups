#!/usr/bin/perl
# 
# This program is used to turn APC-brand UPSes with the AP9630 or AP9631 UPSes
# into watchdog timers.
# 
# The idea is that the UPS will be configured to start X minutes after turning
# off, and then schedule a shutdown Y minutes in the future. This way, if
# something causes the system to lock up (ie: bad switch config), all systems
# connected to power cycle. This way, a physically inaccessible site can
# potentially recover from unforseen problems.
# 
# For this to work, all components of the HA environment must be powered by the
# UPSes.
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# Madison Kelly - mkelly@alteeve.ca
# https://alteeve.ca
# 
# Exit codes:
# 0  = Normal exit
# 1  = Failed to translate a given host name to an IP address.
# 2  = Failed to find any UPSes.
# 3  = Exited on SIGnal.
# 4  = One or more UPSes didn't cancel their shutdown timer.
# 5  = The program was not run as root.
# 

# OIDs
=pod
UPS Serial number:	.1.3.6.1.4.1.318.1.1.1.1.2.3.0		ie: AS1038232403
UPS Part number:	.1.3.6.1.4.1.318.1.1.1.1.2.5.0		ie: SMT1500
UPS Basic type:		.1.3.6.1.4.1.318.1.1.1.1.1.1.0		ie: SmartUPS 1500
UPS Firmware:		.1.3.6.1.4.1.318.1.4.2.4.1.4.1
NMC Serial number:	.1.3.6.1.4.1.318.1.4.2.4.1.2.1
Battery Part Number:	.1.3.6.1.4.1.318.1.1.1.2.2.19.0		ie: RBC7

Date:			.1.3.6.1.4.1.318.1.1.1.2.1.3.0		(mm/dd/yyyy)
Time:			.1.3.6.1.4.1.318.2.1.6.2.0		'HH:mm:ss' or 'hh:mm:ss {am,pm}'
Estimated runtime:	.1.3.6.1.4.1.318.1.1.1.2.2.3.0		(in ticks [10ms])

UPS Basic State:	.1.3.6.1.4.1.318.1.1.1.4.1.1.0		1'	=>	"Unknown, 2'	=>	"Online, 3'	=>	"On Battery, 4'	=>	"onSmartBoost, 5'	=>	"timedSleeping, 6'	=>	"softwareBypass, 7'	=>	"off, 8'	=>	"rebooting, 9'	=>	"switchedBypass, 10'	=>	"hardwareFailureBypass, 11'	=>	"sleepingUntilPowerReturn, 12'	=>	"onSmartTrim, 13'	=>	"ecoMode, 14'	=>	"hotStandby, 15'	=>	"onBatteryTest, 15'	=>	"emergencyStaticBypass, 17'	=>	"staticBypassStandby, 18'	=>	"powerSavingMode, 19'	=>	"spotMode, 20'	=>	"eConversion
Main UPS outlet state:	.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1	1'	=>	"On, 2'	=>	"Off, 3'	=>	"Unknown
Outlet group 1 state:	.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2	1'	=>	"On, 2'	=>	"Off, 3'	=>	"Unknown
Battery health:		.1.3.6.1.4.1.318.1.1.1.2.2.4.0		1'	=>	"OK, 2'	=>	"Replacement needed


Temperature units 1:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.5.1	1'	=>	"C, 2'	=>	"F
Temperature units 2:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.5.2	1'	=>	"C, 2'	=>	"F
High Temp probe 1:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.3.1	integer of alarm threshold of UPS probe 1 (C or F set above)
High Temp probe 2:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.3.2	integer of alarm threshold of UPS probe 2 (C or F set above)
Battery Temp in 1/10*C:	.1.3.6.1.4.1.318.1.1.1.2.3.2.0		ie: 333'	=>	"33.3 *C
Battery Temp in *C	.1.3.6.1.4.1.318.1.1.1.2.2.2.0		ie: 33'	=>	"33 *C
Battery Volt in 1/10v:	.1.3.6.1.4.1.318.1.1.1.2.3.4.0		ie: 271'	=>	"27.1 vDC
Battery Volt:		.1.3.6.1.4.1.318.1.1.1.2.2.8.0		ie: 27 (vDC)

Turn off the UPS:	.1.3.6.1.4.1.318.1.1.1.6.2.1.0		2'	=>	"turnUpsOff (no delay), 3'	=>	"turnUpsOffGracefully (use delay), always returns '1'
Turn on the UPS:	.1.3.6.1.4.1.318.1.1.1.6.2.6.0		2'	=>	"turn on (no delay), always returns '1'.
Sleep time:		.1.3.6.1.4.1.318.1.1.1.5.2.11.0		Time in ticks to sleep after turning off. Once timer expires, UPS boots. The UPS only recognizes 1/10 of an hour increments. The provided value will be rounded to the closest 1/10 of an hour with one exception: Any value entered between 1 and 540 seconds will be rounded to 360 seconds (or 6 minutes).
Put the UPS to sleep:	.1.3.6.1.4.1.318.1.1.1.6.2.3.0		2'	=>	"Put to sleep for 'upsAdvConfigUpsSleepTime' then turn on, 3'	=>	"same as '2', but with shutdown delay
Power off delay:	.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2	-1'	=>	"Never (if supported), integer in seconds (not ticks) to delay shutdown.
Shut off delay (??):	.1.3.6.1.4.1.318.1.1.1.5.2.10.0		Time in ticks to delay shut off, ie: 2000'	=>	"20 seconds (not sure how this differs from above). Adjust to closest acceptible time (1/10th hour?)
Reboot delay, main UPS:	.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1	integer in seconds to wait before powering back on. '8' is default
Reboot delay, Group 1:	.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2	integer in seconds to wait before powering back on. '8' is default

Info:
Last transfer reason:	.1.3.6.1.4.1.318.1.1.1.3.2.5.0		1'	=>	"noTransfer, 2'	=>	"highLineVoltage, 3'	=>	"brownout, 4'	=>	"blackout, 5 = smallMomentarySag, 6'	=>	"deepMomentarySag, 7 = smallMomentarySpike, 8'	=>	"largeMomentarySpike, 9'	=>	"selfTest, 10'	=>	"rateOfVoltageChange
Identify UPS:		.1.3.6.1.4.1.318.1.1.1.6.2.5.0		2'	=>	"Flash LCD and beep then stop, 4'	=>	"Flash LCD and beep until cancelled, 5'	=>	"Cancel flash and beep
UPS Input Sensitivity:	.1.3.6.1.4.1.318.1.1.1.5.2.7.0		1'	=>	"Auto, 2'	=>	"Low, 3'	=>	"Medium, 4'	=>	"High
LCD Panel Language	.1.3.6.1.4.1.318.1.1.1.5.2.46.0		1'	=>	"english, 2'	=>	"french, 3'	=>	"italian, 4'	=>	"german, 5'	=>	"spanish, 6'	=>	"portuguese, 7'	=>	"japanese
Green mode:		.1.3.6.1.4.1.318.1.1.1.5.2.45.0		1'	=>	"Disable, 2'	=>	"Enable
Battery state:		.1.3.6.1.4.1.318.1.1.1.2.1.1.0		1'	=>	"unknown, 2'	=>	"batteryNormal, 3'	=>	"batteryLow, 4'	=>	"batteryInFaultCondition
User-set name:		.1.3.6.1.4.1.318.1.1.1.1.1.2.0		8-byte ID string set by the user.
NMC MAC address:	.1.3.6.1.4.1.318.1.4.2.6.1.4.14		ie: C0-A8-01-01-00-A2
Input Hz in 1/10ths	.1.3.6.1.4.1.318.1.1.1.3.3.4.0		ie: 600'	=>	"60Hz
Input Hz is 1Hz:	.1.3.6.1.4.1.318.1.1.1.3.2.4.0		ie: 60 (Hz)
Output Hz in 1/10ths:	.1.3.6.1.4.1.318.1.1.1.4.2.2.0		ie: 600'	=>	"60Hz
Output Hz is 1Hz:	.1.3.6.1.4.1.318.1.1.1.4.2.2.0		ie: 60 (Hz)
Output in 10 Wh		.1.3.6.1.4.1.318.1.1.1.4.3.6.0		?? guage
High Xfer Volt:		.1.3.6.1.4.1.318.1.1.1.5.2.2.0		127 (vAC)
Low Xfer Volt:		.1.3.6.1.4.1.318.1.1.1.5.2.3.0		106 (vAC)
Input Volt in 1/10v:	.1.3.6.1.4.1.318.1.1.1.3.3.1.0		ie: 1245'	=>	"124.5 vAC
Input Volt:		.1.3.6.1.4.1.318.1.1.1.3.2.1.0		ie: 124 (vAC)
60s Max input in 1/10v:	.1.3.6.1.4.1.318.1.1.1.3.3.2.0		ie: 1245'	=>	"124.5 vAC max seen in last 60sec
60s Max input:		.1.3.6.1.4.1.318.1.1.1.3.2.2.0		ie: 124 (vAC)
60s Min input in 1/10v:	.1.3.6.1.4.1.318.1.1.1.3.3.3.0		ie: 1245'	=>	"124.5 vAC min seen in last 60sec
60s Min input:		.1.3.6.1.4.1.318.1.1.1.3.2.3.0		ie: 124 (vAC)
Output Volt in 1/10v:	.1.3.6.1.4.1.318.1.1.1.4.3.1.0		ie: 1245'	=>	"124.5 vAC
Output Volt:		.1.3.6.1.4.1.318.1.1.1.4.2.1.0		ie: 124 (vAC)
Nominal output volt:	.1.3.6.1.4.1.318.1.1.1.5.2.1.0		ie: 120 (vAC)
Remaining batt 1/10%:	.1.3.6.1.4.1.318.1.1.1.2.3.1.0		ie: 1000'	=>	"100.0% charge
Remaining battery %:	.1.3.6.1.4.1.318.1.1.1.2.2.1.0		ie: 100 (%) charge
AC restore boot delay:	.1.3.6.1.2.1.33.1.2.4.0			Ticks after AC restore before UPS powers on (ie: 1000'	=>	"10 seconds)
UPS Manufacture date:	.1.3.6.1.4.1.318.1.1.1.1.2.2.0		in 'mm/dd/yy' or 'mm/dd/yyyy' format.
Battery replaced date:	.1.3.6.1.4.1.318.1.1.1.2.1.3.0		in 'mm/dd/yy' or 'mm/dd/yyyy' format.
Est. next replace date:	.1.3.6.1.4.1.318.1.1.1.2.2.21.0		in 'mm/dd/yy' or 'mm/dd/yyyy' format.
ASCII state string:	.1.3.6.1.4.1.318.1.1.1.11.1.1.0		64 values; See MIB for values.
Time on batteries:	.1.3.6.1.4.1.318.1.1.1.2.1.2.0		Time in ticks since transfer to batteries (0 if on AC)
Current load in 1/10%:	.1.3.6.1.4.1.318.1.1.1.4.3.3.0		(guage) ie: 58'	=>	"5.8%
Current load in %:	.1.3.6.1.4.1.318.1.1.1.4.2.3.0		(guage) ie: 5 (%)

Tests:
Calibrate UPS:		.1.3.6.1.4.1.318.1.1.1.7.2.5.0		2'	=>	"If battery is 100%, will drain to 25%, 3'	=>	"Cancel calibration
Last calibration:	.1.3.6.1.4.1.318.1.1.1.7.2.6.0		1'	=>	"OK, 2'	=>	"Invalid, 3'	=>	"Calibration in progress
Last calibration date:	.1.3.6.1.4.1.318.1.1.1.7.2.7.0		"Unknown" or mm/dd/yyyy
Test Schedule:		.1.3.6.1.4.1.318.1.1.1.7.2.1.0		1'	=>	"unknown, 2'	=>	"biweekly, 3'	=>	"weekly, 4'	=>	"atTurnOn, 5'	=>	"never, 6'	=>	"fourWeeks, 7'	=>	"twelveWeeks, 8'	=>	"biweeklySinceLastTest, 9'	=>	"weeklySinceLastTest, 10 = eightWeeks, 11 = twentysixWeeks, 12'	=>	"fiftytwoWeeks
Last diagnostics:	.1.3.6.1.4.1.318.1.1.1.7.2.3.0		1'	=>	"OK, 2'	=>	"Failed, 3'	=>	"Invalid, 4'	=>	"Test in progress
Last diagnostics date:	.1.3.6.1.4.1.318.1.1.1.7.2.4.0		"Unknown" or mm/dd/yyyy

There is a upsAdvConfigMinReturnRuntime that should be set to say 10 minutes or so. the kick script is currently NOT using this.
upsAdvConfigMinReturnRunTime   .1.3.6.1.4.1.318.1.1.1.5.2.29 (The minimum amount of run time in seconds required before the output will be turned on, using power
calculation catpured at start of last shutdown. The reason is that if power goes up and down frequently within a few minutes, you don't want the UPS turning on and off.

snmpget -v 2c -c public ups1 .1.3.6.1.4.1.318.1.1.1.5.2.29.0


Subu's UPSes
Return Delay		.1.3.6.1.4.1.318.1.1.1.5.2.9.0		ie: 1000 = 10sec, 3000 = 30sec (ticks)

=cut

# Play safe!
use strict;
use warnings;

# IO::Handle is used for logging and communicating with the Raritan device
# via the snmp command line tools. Net::SNMP is not used to do availability
# issues with EL6.
use IO::Handle;

# Catch signals for clean exits.
$SIG{INT}  = \&_catch_sig;
$SIG{TERM} = \&_catch_sig;

# Some variables.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# These are the default values and will be over-written by the config file's
# variables which in turn can, in some cases, be over-written by command line
# arguments.
my $conf = {
	hosts		=>	{
		by_name		=>	{},
		by_ip		=>	{},
	},
	path		=>	{
		cron_root	=>	"/var/spool/cron/root",
		gethostip	=>	"/usr/bin/gethostip",
		hosts		=>	"/etc/hosts",
		logger		=>	"/bin/logger",
		snmpget		=>	"/usr/bin/snmpget",
		snmpset		=>	"/usr/bin/snmpset",
		striker_conf	=>	"/etc/striker/striker.conf",
	},
	snmp		=>	{
		min_return_time	=>	{
			oid		=>	'.1.3.6.1.4.1.318.1.1.1.5.2.29.0',
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
		},
		model_number	=>	{
			oid		=>	'.1.3.6.1.4.1.318.1.1.1.1.2.5.0',
			value		=>	"",
		},
		oid_name	=>	{
			'.1.3.6.1.4.1.318.1.1.1.4.1.1.0'	=>	"UPS Basic State",
			'.1.3.6.1.4.1.318.1.1.1.1.2.5.0'	=>	"Model Number",
			'.1.3.6.1.4.1.318.1.1.1.5.2.29.0'	=>	"Minimum Mains Return Time",	# how long to wait after the AC mains return before restoring power
			'.1.3.6.1.4.1.318.1.1.1.6.2.3.0'	=>	"Power-Off",
			'.1.3.6.1.4.1.318.1.1.1.6.2.6.0'	=>	"Power-On",
			'.1.3.6.1.4.1.318.1.1.1.5.2.9.0'	=>	"Return Delay",
			'.1.3.6.1.4.1.318.1.1.1.5.2.10.0'	=>	"Shut-Off Delay",			# SURTD5000RMXLT3U, ticks
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2'	=>	"Power-Off delay",			# SMT1500, int, secs
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1'	=>	"Sleep Time; Main Outlet Group",
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2'	=>	"Sleep Time; Outlet Group 1",
		},
		return_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.9.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"t",
		},
		sleep_time	=>	{
			main_ups	=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
			},
			group_one	=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
			},
		},
		power_off_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"i",
		},
		shut_off_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.10.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"t",
		},
		power_on	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.6.0",
			on_integer	=>	2,
		},
		power_off	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.3.0",
			off_integer	=>	3,
		},
		current_state	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.4.1.1.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			'values'	=>	{
				'1' 		=>	"Unknown",
				'2'		=>	"Online",
				'3'		=>	"On Battery",
				'4'		=>	"Smart Boost",
				'5'		=>	"Timed Sleeping",
				'6'		=>	"Software Bypass",
				'7'		=>	"Off",
				'8'		=>	"Rebooting",
				'9'		=>	"Switched Bypass",
				'10'		=>	"Hardware Failure Bypass",
				'11'		=>	"Sleeping Until Power Returns",
				'12'		=>	"Smart Trim",
				'13'		=>	"EcoMode",
				'14'		=>	"Hot Standby",
				'15'		=>	"Testing Battery",
				'15'		=>	"Emergency Static Bypass",
				'17'		=>	"Static Bypass Standby",
				'18'		=>	"Power-Saving Mode",
				'19'		=>	"Spot Mode",
				'20'		=>	"eConversion",
			},
		},
		community	=>	{
			'read'		=>	"public",
			'write'		=>	"private",
		},
	},
	sys	=>	{
		apc		=>	{
			ups		=>	{
				device			=>	{},
				devices			=>	[],
				poweroff_delay		=>	600,
				sleep_time		=>	300,	# Minutes; will be converted to seconds and then divided by timeticks when set.
				min_return_time		=>	60000,	# Ten minutes, in time ticks (-t)
				ticks			=>	10,	# ms
				use_shut_off_delay	=>	0,	# Gets set to '1' if the power_off_delay OID fails to be read
				kick_every_minutes	=>	2,	# Sets the cron job to run this script (kick the UPS) every X minutes
			},
		},
		debug		=>	0,
		log_file	=>	"/var/log/$THIS_FILE.log",
		version		=>	"1.0",
	},
};

# No switches is OK, we'll try to detect UPSes via /etc/hosts.
get_switches($conf);
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}) || 
    (($conf->{switches}{sleep_time}) && ($conf->{switches}{sleep_time} =~ /\D/)) || 
    (($conf->{switches}{poweroff_delay}) && ($conf->{switches}{poweroff_delay} =~ /\D/)))
{
	print_usage($conf);
	exit(0);
}

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	logger($conf, $THIS_FILE, __LINE__, "I am sorry, but $THIS_FILE program must be run as the 'root' user.");
	exit(5);
}

# Set the timers if the user defined them
$conf->{sys}{apc}{ups}{sleep_time}     = $conf->{switches}{sleep_time}     if $conf->{switches}{sleep_time};
$conf->{sys}{apc}{ups}{poweroff_delay} = $conf->{switches}{poweroff_delay} if $conf->{switches}{poweroff_delay};

# Enable debugging if requested.
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};

# Read the Striker config.
read_configuration($conf);

# Figure out what UPS(es) we're using.
get_ups_ips($conf);

# If I've been called with --cancel, send only to 'power-on' call.
if ($conf->{switches}{cancel})
{
	my $exit = 0;
	logger($conf, $THIS_FILE, __LINE__, "Cancelling the UPS power-off sequence.");
	foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
	{
		my ($poweroff_return, $shell_call) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
		if ($poweroff_return ne $conf->{snmp}{power_on}{on_integer})
		{
			logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups]");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The command to abort pending power-off actions returned: [$poweroff_return], expected: [$conf->{snmp}{power_on}{on_integer}].");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   Tried to call: [$shell_call]");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   The UPS may still be running its poweroff-timer!");
			$exit = 4;
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups] power-off cancelled.");
		}
	}
	manage_cron_entry($conf, "remove");
	logger($conf, $THIS_FILE, __LINE__, "- Done.");
	logger($conf, $THIS_FILE, __LINE__, "[ Note ] - Make sure you cancel on the other node, too!");
	exit($exit);
}

# We're ready to start.
logger($conf, $THIS_FILE, __LINE__, "Will now attempt to delay the reboot of the following UPS(es):");
foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
{
	logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups]");
	
	# Report/record the current values
	get_current_settings($conf, $ups, "old");
	my $current_state = $conf->{snmp}{current_state}{value}{old};
	my $say_state     = $conf->{snmp}{current_state}{'values'}{$current_state};
	logger($conf, $THIS_FILE, __LINE__, "  - Current outlet state:                 [$say_state ($current_state)]");
	logger($conf, $THIS_FILE, __LINE__, "  - Minimum Runtime before Power-On:      [".convert_ticks_to_seconds($conf, $conf->{snmp}{min_return_time}{value}{old})." seconds ($conf->{snmp}{min_return_time}{value}{old} ticks)]");
	if ($conf->{sys}{apc}{ups}{use_shut_off_delay})
	{
		logger($conf, $THIS_FILE, __LINE__, "  - Current main outlet group sleep time: [$conf->{snmp}{sleep_time}{main_ups}{value}{old} seconds]");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "  - Current main outlet group sleep time: [$conf->{snmp}{sleep_time}{main_ups}{value}{old} seconds]");
		logger($conf, $THIS_FILE, __LINE__, "  - Current outlet group one sleep time:  [$conf->{snmp}{sleep_time}{group_one}{value}{old} seconds]");
	}
	if ($conf->{snmp}{power_off_delay}{value}{old})
	{
		logger($conf, $THIS_FILE, __LINE__, "  - Current power-off delay timer:        [$conf->{snmp}{power_off_delay}{value}{old} seconds]");
	}
	### TODO: Add shut-off delay
	
	if ($current_state eq "1")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is in an unknown state! Proceeding would be dangerous, skipping this UPS.");
	}
	elsif ($current_state eq "5")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off in a timed sleep. There is no reason to proceed, skipping this UPS.");
	}
	elsif ($current_state eq "7")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off. There is no reason to proceed, skipping this UPS.");
	}
	elsif ($current_state eq "8")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is rebooting, skipping this UPS.");
	}
	else
	{
		# How I do this depends on the UPS type.
		if ($conf->{sys}{apc}{ups}{use_shut_off_delay})
		{
			### SURTD style
			# The UPS is on, so abort any existing power-off value.
			logger($conf, $THIS_FILE, __LINE__, "  - Aborting any pending 'power-off' actions.");
			my ($poweroff_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
			if ($poweroff_return ne $conf->{snmp}{power_on}{on_integer})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The command to abort pending power-off actions returned: [$poweroff_return], expected: [$conf->{snmp}{power_on}{on_integer}]. The UPS may still be in a prior poweroff-timer!");
			}
			
			# Set the sleep time for the UPS (no groups).
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the UPS outlets sleep time to: [$conf->{sys}{apc}{ups}{sleep_time} seconds].");
			$conf->{sys}{apc}{ups}{sleep_time} = convert_seconds_to_ticks($conf, $conf->{sys}{apc}{ups}{sleep_time});
			my ($sleep_time_mains_ups) = set_oid_ticks($conf, $ups, $conf->{snmp}{sleep_time}{main_ups}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
			
			# Set the power-off (really, 'Shut-Off') delay
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the Shut-off delay to: [$conf->{sys}{apc}{ups}{poweroff_delay} seconds].");
			$conf->{sys}{apc}{ups}{poweroff_delay} = convert_seconds_to_ticks($conf, $conf->{sys}{apc}{ups}{poweroff_delay});
			my ($power_off_delay) = set_oid_integer($conf, $ups, $conf->{snmp}{shut_off_delay}{oid}, $conf->{sys}{apc}{ups}{poweroff_delay});
			
			# Do the needful
			logger($conf, $THIS_FILE, __LINE__, "  - Initiating timed power off!");
			my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off}{oid}, $conf->{snmp}{power_off}{off_integer});
		}
		else
		{
			### SMT style
			# The UPS is on, so abort any existing power-off value.
			logger($conf, $THIS_FILE, __LINE__, "  - Aborting any pending 'power-off' actions.");
			my ($poweroff_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
			if ($poweroff_return ne $conf->{snmp}{power_on}{on_integer})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The command to abort pending power-off actions returned: [$poweroff_return], expected: [$conf->{snmp}{power_on}{on_integer}]. The UPS may still be in a prior poweroff-timer!");
			}
			
			# Set the sleep time for the main UPS outlets and group 1 outlets.
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the UPS Main outlets and Group 1 outlets sleep time to: [$conf->{sys}{apc}{ups}{sleep_time} seconds].");
			my ($sleep_time_mains_ups) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{main_ups}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
			my ($sleep_time_group_one) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group_one}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
			
			# Set the power-off delay
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the Power-off delay to: [$conf->{sys}{apc}{ups}{poweroff_delay} seconds].");
			my ($power_off_delay) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{oid}, $conf->{sys}{apc}{ups}{poweroff_delay});
			
			# Set the minimum return time delay.
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the minimum return time delay to: [$conf->{sys}{apc}{ups}{min_return_time} ticks] (1 tick = 10ms).");
			my ($min_return_time) = set_oid_ticks($conf, $ups, $conf->{snmp}{min_return_time}{oid}, $conf->{sys}{apc}{ups}{min_return_time});
			
			# Do the needful
			logger($conf, $THIS_FILE, __LINE__, "  - Initiating timed power off!");
			my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off}{oid}, $conf->{snmp}{power_off}{off_integer});
		}
	}
}

# Add the program to root's crontab, if needed.
manage_cron_entry($conf, "add");
logger($conf, $THIS_FILE, __LINE__, "Run complete, exiting.");


exit(0);

# This reads in the root user's cron table file and if the program isn't there,
# adds it or removes it, depending on the $task ("add" or "remove").
sub manage_cron_entry
{
	my ($conf, $task) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - manage_cron_entry(); task: [$task]") if $conf->{sys}{debug};
	
	my $changed  = 0;
	my $raw_cron = "";
	
	# Make sure the cron file exists.
	my $shell_call = "
if [ ! -e '$conf->{path}{cron_root}' ]
then
	touch $conf->{path}{cron_root}
	chown root:root $conf->{path}{cron_root}
	chmod 600 $conf->{path}{cron_root}
fi";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
	}
	close $file_handle;
	
	# Now read the file (even if it's blank).
	$shell_call = "$conf->{path}{cron_root}";
	open ($file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /$THIS_FILE/)
		{
			# Skip it as we'll add it back later.
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Found existing root cron table entry: [$line]. Removing it.") if $conf->{sys}{debug};
			$changed = 1;
		}
		else
		{
			$raw_cron .= "$line\n";
		}
	}
	close $file_handle;
	
	# If the line wasn't found, add it.
	if ($task eq "add")
	{
		# $0 contains the actual path and program name in use at runtime
		my $call = $0;
		if ($call =~ /^\.\//)
		{
			# Prepend the PWD environment variable.
			my $pwd = $ENV{PWD};
			$call =~ s/^\.\//$pwd\//;
		}
		if ($conf->{switches}{ups})
		{
			$call .= " --ups $conf->{switches}{ups}";
		}
		if ($conf->{switches}{sleep_time})
		{
			$call .= " --sleep_time $conf->{switches}{sleep_time}";
		}
		if ($conf->{switches}{poweroff_delay})
		{
			$call .= " --poweroff_delay $conf->{switches}{poweroff_delay}";
		}
		$raw_cron .= "*/$conf->{sys}{apc}{ups}{kick_every_minutes} * * * * $call\n";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Added entry: [$call].") if $conf->{sys}{debug};
		$changed = 1;
	}
	
	# Write out the updated crontab.
	if ($changed)
	{
		# Tell the user.
		if ($task eq "add")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Adding $THIS_FILE to run every five minutes in the 'root' user's cron table.");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- Removing $THIS_FILE from root's cron table.");
		}
		my $shell_call = "$conf->{path}{cron_root}";
		open (my $file_handle, ">$shell_call") or die "Failed to write: [$shell_call], error was: $!\n";
		print $file_handle $raw_cron;
		close $file_handle;
	}
	
	return(0);
}

# This sets an OID with to an integer value.
sub set_oid_integer
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_integer(); ups: [$ups], oid: [$oid], value: [$value]") if $conf->{sys}{debug};
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid i $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value]") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value, $shell_call);
}

# This sets an OID with to a time tick (-t, 10ms) value.
sub set_oid_ticks
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_ticks(); ups: [$ups], oid: [$oid], value: [$value]") if $conf->{sys}{debug};
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid t $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			   $value     = $1;
			my $say_value = ($value / 100);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value] ($say_value seconds)") if $conf->{sys}{debug};
		}
		if ($line =~ /Failed object/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], not set! Does this OID exist on your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value, $shell_call);
}

# This calls the UPS and tries to get the current settings.
sub get_current_settings
{
	my ($conf, $ups, $type) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_current_settings(); ups: [$ups]") if $conf->{sys}{debug};
	
	# First, main UPS outlet group. This is our first call, so verify we
	# got a returned value.
	my ($current_state) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{oid});
	if ($current_state eq "#!no_connection!#")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
		return(1);
	}
	
	# Get the minimum return time
	my ($min_return_time) = read_oid_ticks($conf, $ups, $conf->{snmp}{min_return_time}{oid});
	
	# This will be empty on some UPSes.
	my $sleep_time_mains_ups = "--";
	my $sleep_time_group_one = "--";
	my $power_off_delay      = "--";
	if ($conf->{sys}{apc}{ups}{use_shut_off_delay})
	{
		# If this is the first read, and if this OID is not found on
		# the UPS, it will return '--'.
		$power_off_delay = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{oid});
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off_delay: [$power_off_delay] (seconds, integer)") if $conf->{sys}{debug};
	if ((not $power_off_delay) || ($power_off_delay eq "--"))
	{
		# Try reading the This is in ticks
		$conf->{sys}{apc}{ups}{use_shut_off_delay} = 1;
		($power_off_delay) = read_oid_ticks($conf, $ups, $conf->{snmp}{shut_off_delay}{oid});
		$power_off_delay   = convert_ticks_to_seconds($conf, $power_off_delay);
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off_delay: [$power_off_delay] (seconds, converted from ticks)") if $conf->{sys}{debug};
		
		# This UPS won't have sleep time, either, so we'll get the time
		# in ticks and convert it. Also, these UPSes don't have groups.
		($sleep_time_mains_ups) = read_oid_ticks($conf, $ups, $conf->{snmp}{return_delay}{oid});
		 $sleep_time_mains_ups  = convert_ticks_to_seconds($conf, $sleep_time_mains_ups);
	}
	else
	{
		# UPS supports sleep time.
		($sleep_time_mains_ups) = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{main_ups}{oid});
		($sleep_time_group_one) = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group_one}{oid});
	}
	
	$conf->{snmp}{min_return_time}{value}{$type}       = $min_return_time;
	$conf->{snmp}{current_state}{value}{$type}         = $current_state;
	$conf->{snmp}{sleep_time}{main_ups}{value}{$type}  = $sleep_time_mains_ups;
	$conf->{snmp}{sleep_time}{group_one}{value}{$type} = $sleep_time_group_one;
	$conf->{snmp}{power_off_delay}{value}{$type}       = $power_off_delay;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - snmp::min_return_time::value::$type: [$conf->{snmp}{min_return_time}{value}{$type}], snmp::current_state::value::$type: [$conf->{snmp}{current_state}{value}{$type}], snmp::sleep_time::main_ups::value::$type: [$conf->{snmp}{sleep_time}{main_ups}{value}{$type}], snmp::sleep_time::group_one::value::$type: [$conf->{snmp}{sleep_time}{group_one}{value}{$type}], snmp::power_off_delay::value::$type: [$conf->{snmp}{power_off_delay}{value}{$type}]") if $conf->{sys}{debug};
	
	return(0);
}

# Convert ticks to seconds.
sub convert_ticks_to_seconds
{
	my ($conf, $ticks) = @_;
	logger($conf, $THIS_FILE, __LINE__, "convert_ticks_to_seconds(); ticks: [$ticks]") if $conf->{sys}{debug};
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $seconds          = ($ticks / $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "seconds: [$seconds]") if $conf->{sys}{debug};
	return($seconds);
}

# Convert seconds to ticks.
sub convert_seconds_to_ticks
{
	my ($conf, $seconds) = @_;
	logger($conf, $THIS_FILE, __LINE__, "convert_seconds_to_ticks(); seconds: [$seconds]") if $conf->{sys}{debug};
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $ticks            = ($seconds * $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "ticks: [$ticks]") if $conf->{sys}{debug};
	return($ticks);
}

# This reads an OID with an ticks value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# ticks is read, "#!no_value!#" is returned.
sub read_oid_ticks
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_ticks(); ups: [$ups], oid: [$oid]") if $conf->{sys}{debug};
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value);
}

# This reads an OID with an integer value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_integer
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_integer(); ups: [$ups], oid: [$oid]") if $conf->{sys}{debug};
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value);
}

# This determines what UPSes to talk to, by IP address.
sub get_ups_ips
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_ups_ips()") if $conf->{sys}{debug};
	
	# Did the user specify the UPSes?
	$conf->{switches}{ups} = "" if not defined $conf->{switches}{ups};
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - switches::ups: [$conf->{switches}{ups}]") if $conf->{sys}{debug};
	if ($conf->{switches}{ups})
	{
		# Yup!
		foreach my $ups (split/,/, $conf->{switches}{ups})
		{
			next if not $ups;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ups: [$ups]") if $conf->{sys}{debug};
			if (is_string_ipv4($conf, $ups))
			{
				# It's already an IP.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP address given, recording.") if $conf->{sys}{debug};
				push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
			}
			else
			{
				# Try to resolve it.
				my ($ip) = get_host_ip($conf, $ups);
				if ($ip)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups] has IP: [$ip], recording.") if $conf->{sys}{debug};
					push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The UPS: [$ups] could not be translated to an IP address.");
					exit(1);
				}
			}
		}
	}
	else
	{
		# Nope. Parse /etc/hosts.
		parse_hosts($conf);
	}
	
	# Now if I have some UPSes, we're ok to proceed.
	if (@{$conf->{sys}{apc}{ups}{devices}} < 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - No UPSes were found, unable to proceed.");
		exit(2);
	}
	
	return(0);
}

# This looks through /etc/hosts and pushes the IPs for each entry with 'ups'
# in the name that it finds.
sub parse_hosts
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parse_hosts()") if $conf->{sys}{debug};
	
	my $shell_call = "$conf->{path}{hosts}";
	open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		$line =~ s/#.*//;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /ups/)
		{
			# Oh looky looky!
			my ($ip, $names) = ($line =~ /^(\d+\.\d+\.\d+\.\d+) (.*)/);
			next if ((not $ip) || (not $names));
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], names: [$names]") if $conf->{sys}{debug};
			foreach my $name (split/ /, $names)
			{
				next if not $name;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], name: [$name]") if $conf->{sys}{debug};
				$conf->{hosts}{by_name}{$name} = $ip;
				push @{$conf->{hosts}{by_ip}{$ip}}, $name;
			}
		}
	}
	close $file_handle;
	
	# Now record the IPs in the central hash.
	foreach my $ip (sort {$a cmp $b} keys %{$conf->{hosts}{by_ip}})
	{
		if (@{$conf->{hosts}{by_ip}{$ip}} == 1)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with name: [$conf->{hosts}{by_ip}{$ip}->[0]].") if $conf->{sys}{debug};
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with names:") if $conf->{sys}{debug};
			foreach my $name (sort {$a cmp $b} @{$conf->{hosts}{by_ip}{$ip}})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - name: [$name]") if $conf->{sys}{debug};
			}
		}
		push @{$conf->{sys}{apc}{ups}{devices}}, $ip;
	}
	
	return(0);
}

# This tries to resolve a name to an IP address. Returns '0' if lookup failed.
sub get_host_ip
{
	my ($conf, $host) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_host_ip(); host: [$host]") if $conf->{sys}{debug};
	
	my $ip = 0;
	
	my $shell_call = "$conf->{path}{gethostip} -d $host";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		$ip = $_;
		# This should only ever print the IP address. Anything else
		# will be treated as a failure.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$ip]") if $conf->{sys}{debug};
	}
	close $file_handle;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]") if $conf->{sys}{debug};
	
	# Make sure the IP is sane.
	if (not is_string_ipv4($conf, $ip))
	{
		# It's already an IP.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Returned IP address is not valid.") if $conf->{sys}{debug};
		$ip = 0;
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]") if $conf->{sys}{debug};
	return($ip);
}

# Checks if the passed-in string is an IPv4 address (with or without a subnet
# mask). Returns '1' if OK, 0 if not.
sub is_string_ipv4
{
	my ($conf, $ip) = @_;
	my $valid  = 1;
	
	if ($ip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/)
	{
		# It's in the right format.
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		
		if (($first_octal  < 0) || ($first_octal  > 255) ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal  < 0) || ($third_octal  > 255) ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			# One of the octals is out of range.
			$valid = 0;
		}
	}
	else
	{
		# Not in the right format.
		$valid = 0;
	}
	
	return($valid);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}}) { print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	if (not -e $conf->{path}{striker_conf})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Striker configuration file not found.") if $conf->{sys}{debug};
	}
	else
	{
		my $shell_call = "$conf->{path}{striker_conf}";
		open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			next if $line !~ /=/;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			next if $line =~ /^#/;
			next if not $line;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			next if (not $var);
			_make_hash_reference($conf, $var, $val);
		}
		close $file_handle;
	}
	
	return(0);
}
# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Use APC-brand UPSes as an external watchdog timer

DESCRIPTION

This program uses one or more APC-brand UPSes as a form of Anvil!-wide watchdog
timer. In essence, this program will run every five minutes, and on each run,
it will tell the UPSes to turn off in 15 minutes, stary off for 5 minutes, and
then power back on. In this way, if something catastrophic happens, the system
will reboot all devices. With luck, that will return the system to an operating
state autonomously.

So long as at least one node is operating, it will 


Note:

For this to work properly, you need to setup your dashboards to automatically
boot when the power is applied to them. Exactly how you do this will depend on
your hardware, but usually it is configured under power settings in the system
BIOS.

Further; The dashboards must be running the Scanner 'nodemonitor' scan agent.
This way, when the nodes boot, they will check the UPS and environmental
temperatures and if/when good, boot the nodes.

Further; The nodes must be configured to run the 'safe_anvil_start' tool. This
way, when the nodes boot, they will autonomously form the cluster and boot the
servers.


SWITCHES

 --cancel

	This will cancel any previous power-off timer. This should be used
	either when you want a controlled cold-stop of the Anvil!, or when
	you plan to do maintenance that would interrupt the connection to the
	UPS(es).
	
	NOTE: Remember to cancel on the other node(s) and to remove or disable
	      this program in your cron table! Failure to do so could cause
	      the power-off timer to restart!

 --debug

	This enables debug mode, generating a lot more output than usual.

 --disable

	This disables the 'auto-off after X seconds' function. This should be
	used on both nodes before power the entire system down for a cold-stop.

 -h, -?, --help

	Show this dialoge and exit.

 --poweroff_delay <seconds>

	This controls how far in the future to tell the UPSes to power off.
	
	The default is '600' (10 minutes). This can be changed by setting:
	
	sys::apc::ups::poweroff_delay = <seconds>

 --sleep_time <seconds>

	This controls how long the UPSes should stay off for. After this number
	of seconds, the UPSes will automatically restore power to their
	outlets.
	
	The default is '300' (five minutes). This can be changed by setting:
	
	sys::apc::ups::sleep_time = <seconds>

 --ups <ups1>[,<ups2>,...,<upsN>]

	Define the specific UPS(es) to work on. If host names are used, they
	must be convertable to IP addresses. Two or more UPSes can be defined
	using commas and *no* spaces to separate them.


NOTES

When run, this program will add itself to the root user's crontab
automatically. It will be configured to run every five minutes until cancelled.
The switches passwd when calling the program will be used in the crontab entry.

When called with '--cancel', it will remove the cron table entry automatically,
preventing it from restarting the countdown. 


EXAMPLE

Run with all default values, using all UPSes found in /etc/hosts with 'ups' in
their name.

 ./$THIS_FILE

Run with two specifically defined UPSes set to cut power in ten minutes 
and then power up after one minute.

 ./$THIS_FILE --ups an-ups01,an-ups02 --sleep_time 600 --poweroff_delay 60

Stop the timer entirely on all UPSes found in /etc/hosts

 ./$THIS_FILE --disable

                  
SUPPORT

https://alteeve.ca/w/Support

                                                              Alteeve's Niche!
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/$THIS_FILE");

	return(0);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message) = @_;
	
	# Print the message to the screen.
	print "$file $line_number: $message\n";
	
	# We split on new-lines so that multi-line message render better in
	# syslog.
	my $is_debug = $message =~ /\[ Debug \]/ ? 1 : 0;
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		if (($is_debug) && ($line !~ /\[ Debug \]/))
		{
			$line = "[ Debug ]   $line";
		}
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "$conf->{path}{logger}", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $file $line_number: $message]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

# Catch SIG, move zig!
sub _catch_sig
{
	my $signame = shift;
	
	logger($conf, $THIS_FILE, __LINE__, "Process with PID $$ Exiting on SIG${signame}.");
	exit(3);
}
