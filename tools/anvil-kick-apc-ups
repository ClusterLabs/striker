#!/usr/bin/perl
# 
# This program is used to turn APC-brand UPSes with the AP9630 or AP9631 UPSes
# into watchdog timers.
# 
# The idea is that the UPS will be configured to start X minutes after turning
# off, and then schedule a shutdown Y minutes in the future. This way, if
# something causes the system to lock up (ie: bad switch config), all systems
# connected to power cycle. This way, a physically inaccessible site can
# potentially recover from unforseen problems.
# 
# For this to work, all components of the HA environment must be powered by the
# UPSes.
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# Madison Kelly - mkelly@alteeve.ca
# https://alteeve.ca
# 
# Exit codes:
# 0  = Normal exit
# 1  = Failed to translate a given host name to an IP address.
# 2  = Failed to find any UPSes.
# 3  = Exited on SIGnal.
# 4  = One or more UPSes didn't cancel their shutdown timer.
# 5  = The program was not run as root.
# 6  = Disable was called and the cancel succeeded, but failed to update striker.conf
# 7  = Failed to enable in striker.conf.
# 8  = Time since last run was too short.
# 
# TODO
# 

# Play safe!
use strict;
use warnings;

# IO::Handle is used for logging and communicating with the Raritan device via the snmp command line tools. 
# Net::SNMP is not used to do availability issues with EL6.
use IO::Handle;
use Data::Dumper;

# Catch signals for clean exits.
$SIG{INT}  = \&_catch_sig;
$SIG{TERM} = \&_catch_sig;

# Some variables.
my $THIS_FILE         = ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# These are the default values and will be over-written by the config file's variables which in turn can, in
# some cases, be over-written by command line arguments.
my $conf = {
	hosts		=>	{
		by_name		=>	{},
		by_ip		=>	{},
	},
	path		=>	{
		gethostip	=>	"/usr/bin/gethostip",
		'grep'		=>	"/bin/grep",
		hosts		=>	"/etc/hosts",
		logger		=>	"/bin/logger",
		ping		=>	"/bin/ping",
		ps		=>	"/bin/ps",
		sed		=>	"/bin/sed",
		snmpget		=>	"/usr/bin/snmpget",
		snmpset		=>	"/usr/bin/snmpset",
		striker_config	=>	"/etc/striker/striker.conf",
		timing		=>	"/tmp/${THIS_FILE}.timing",	# The name of the UPS will be appended to this file.
	},
	snmp		=>	{
		model_number	=>	{
			oid		=>	'.1.3.6.1.4.1.318.1.1.1.1.2.5.0',
			value		=>	"",
		},
		oid_name	=>	{
			'.1.3.6.1.4.1.318.1.1.1.12.3.2.1.3.1'	=>	"Group 1 State",
			'.1.3.6.1.4.1.318.1.1.1.12.3.2.1.3.2'	=>	"Group 2 State",
			
			# Seems to be ignored entirely
			'.1.3.6.1.4.1.318.1.1.1.5.2.9.0'	=>	"Return Delay",
			'.1.3.6.1.4.1.318.1.1.1.5.2.10.0'	=>	"Shut-Off Delay",		# Power off delay in ticks
			'.1.3.6.1.4.1.318.1.1.1.5.2.29.0'	=>	"Minimum Mains Return Time",	# how long to wait after the AC mains return before restoring power
			
			# Appear to be useful
			'.1.3.6.1.4.1.318.2.1.6.2.0'		=>	"UPS Time",			# 
			'.1.3.6.1.4.1.318.1.1.1.1.2.5.0'	=>	"Model Number",
			
			#---
			'.1.3.6.1.4.1.318.1.1.1.5.2.11.0'	=>	"Sleep time",			# Time in ticks to sleep after turning off. Once timer expires, UPS boots. The UPS only recognizes 1/10 of an hour increments. The provided value will be rounded to the closest 1/10 of an hour with one exception: Any value entered between 1 and 540 seconds will be rounded to 360 seconds (or 6 minutes).
			'.1.3.6.1.4.1.318.1.1.1.6.2.1.0'	=>	"Turn Off UPS",			# 2 => turnUpsOff (no delay), 3 => turnUpsOffGracefully (use delay), always returns '1'
			'.1.3.6.1.4.1.318.1.1.1.6.2.2.0'	=>	"Reboot UPS",			# 2 == Reboot now, 3 == Reboot gracefully
			
			# Use these
			'.1.3.6.1.4.1.318.1.1.1.6.2.6.0'	=>	"Power-On / Cancel Sleep",
			'.1.3.6.1.4.1.318.1.1.1.6.2.3.0'	=>	"Put UPS to Sleep",		# Gracefully go to sleep (after a delay period) then return after a sleep period.
			'.1.3.6.1.4.1.318.1.1.1.4.1.1.0'	=>	"UPS Basic State",
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1'	=>	"Outlet Group 1 State",
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2'	=>	"Outlet Group 2 State",
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.1'	=>	"Group 1 Power Off Delay",	# Seems to override above
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2'	=>	"Group 2 Power Off Delay",	# Seems to override above
			# Setting either one controls both groups it seems. Set both at the same time to be safe.
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1'	=>	"Sleep Time; Outlet Group 1",	# Called 'Main Outlet Group' on SMT1500
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2'	=>	"Sleep Time; Outlet Group 2",	# Called 'Outlet Group 1' on SMT1500
			# Check/set the group states
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1'	=>	"Energize State; Group 1",	# Called 'Main Outlet Group' on SMT1500, '1' => "Online", '2' => "Offline", '3' => "Unknown"
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2'	=>	"Energize State; Group 2",	# Called 'Outlet Group 1' on SMT1500,    '1' => "Online", '2' => "Offline", '3' => "Unknown"
			### May be useful later
			# Alarm control
			'.1.3.6.1.4.1.318.1.1.1.5.2.4.0'	=>	"Audible Alarm",		# 1 = Time after fail (see: upsAdvConfigAlarmTimer), 2 = At low battery, 3 = Disable audible alarm, 4 = Mute the alarm for a time
		},
		reboot_ups	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.2.0",
		},
		ups_time	=>	{
			oid		=>	".1.3.6.1.4.1.318.2.1.6.2.0",
		},
		return_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.9.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"i",
		},
		sleep_time	=>	{
			group1		=>	{	# 'Main Outlet Group' on SMT1500
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				unit		=>	"t",
			},
			group2		=>	{	# 'Outlet Group 1' on SMT1500
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				unit		=>	"t",
			},
		},
		power_off_delay	=>	{
			group1		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.1",
				unit		=>	"i",
			},
			group2		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2",
				unit		=>	"i",
			},
		},
		shut_off_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.10.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"t",
		},
		power_on	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.6.0",
			on_integer	=>	2,
		},
		power_off	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.1.0",
			off_integer	=>	{
				immediate	=>	2,
				delay		=>	3,
			},
		},
		sleep_ups	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.3.0",
			off_integer	=>	3,
		},
		group1		=>	{
			# Note; control is 12.3, status is 12.1
			oid		=>	".1.3.6.1.4.1.318.1.1.1.12.3.2.1.3.1",
			on_integer	=>	1,
			off_integer	=>	2, 
		},
		group2		=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.12.3.2.1.3.2",
			on_integer	=>	1,
			off_integer	=>	2, 
		},
		current_state	=>	{
			group1		=>	{
				oid			=>	".1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Online",
					'2'		=>	"Offline",
					'3'		=>	"Unknown",
				},
			},
			group2		=>	{
				oid			=>	".1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Online",
					'2'		=>	"Offline",
					'3'		=>	"Unknown",
				},
			},
			ups		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.4.1.1.0",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Unknown",
					'2'		=>	"Online",
					'3'		=>	"On Battery",
					'4'		=>	"Smart Boost",
					'5'		=>	"Timed Sleeping",
					'6'		=>	"Software Bypass",
					'7'		=>	"Off",
					'8'		=>	"Rebooting",
					'9'		=>	"Switched Bypass",
					'10'		=>	"Hardware Failure Bypass",
					'11'		=>	"Sleeping Until Power Returns",
					'12'		=>	"Smart Trim",
					'13'		=>	"EcoMode",
					'14'		=>	"Hot Standby",
					'15'		=>	"Testing Battery",
					'15'		=>	"Emergency Static Bypass",
					'17'		=>	"Static Bypass Standby",
					'18'		=>	"Power-Saving Mode",
					'19'		=>	"Spot Mode",
					'20'		=>	"eConversion",
				},
			},
		},
		community	=>	{
			'read'		=>	"public",
			'write'		=>	"private",
		},
	},
	switches	=>	{
		cancel		=>	"",
		debug		=>	"",
		disable		=>	"",
		force		=>	"",
		'h'		=>	"",
		help		=>	"",
		power_off_delay	=>	"", # <seconds>
		reboot		=>	"",
		'shutdown'	=>	"",
		sleep_time	=>	"", # <seconds>
		ups		=>	"", # <ups1>[,<ups2>,...,<upsN>]
	},
	sys		=>	{
		apc		=>	{
			ups		=>	{
				device			=>	{},
				devices			=>	[],
				power_off_delay		=>	600,
				sleep_time		=>	300,	# How long to sleep once the UPS is off, in seconds
				ticks			=>	10,	# ms
				kick_every_minutes	=>	2,	# Sets the cron job to run this script (kick the UPS) every X minutes
			},
			### NOTE: If you change these, also change in Common.pm!
			reboot		=>	{
				power_off_delay		=>	60,
				sleep_time		=>	60,
			},
			'shutdown'	=>	{
				power_off_delay		=>	60,
			},
		},
		debug		=>	0,
		version		=>	"1.0",
		connections	=>	0,
	},
};

# No switches is OK, we'll try to detect UPSes via /etc/hosts.
get_switches($conf);
if (($conf->{switches}{h})    or 
    ($conf->{switches}{'?'})  or
    ($conf->{switches}{help}) or 
    (($conf->{switches}{sleep_time})      && ($conf->{switches}{sleep_time} =~ /\D/)) or 
    (($conf->{switches}{power_off_delay}) && ($conf->{switches}{power_off_delay} =~ /\D/)))
{
	print_usage($conf);
	exit(0);
}

# Set the timers if the user defined them
$conf->{sys}{apc}{ups}{sleep_time}      = $conf->{switches}{sleep_time}      if $conf->{switches}{sleep_time};
$conf->{sys}{apc}{ups}{power_off_delay} = $conf->{switches}{power_off_delay} if $conf->{switches}{power_off_delay};

# Enable debugging if requested.
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};

# Read the Striker config.
read_configuration($conf);

# Cancel is always allowed.
if ($conf->{switches}{cancel})
{
	logger($conf, $THIS_FILE, __LINE__, "Cancelling the UPS watchdog timer.");
	get_ups_ips($conf);
	my $ok   = cancel_countdown($conf);
	my $exit = $ok ? 0 : 4;
	exit($exit);
}

# All-On is always allowed.
if ($conf->{switches}{'all-on'})
{
	logger($conf, $THIS_FILE, __LINE__, "Energizing all outlet groups on all UPSes.");
	get_ups_ips($conf);
	energize_upses($conf);
	exit(0);
}

# Disabling is also always allowed.
if (($conf->{switches}{'state'}) or ($conf->{switches}{status}))
{
	report_state($conf);
	exit(0);
}

# Disabling is also always allowed.
if ($conf->{switches}{disable})
{
	logger($conf, $THIS_FILE, __LINE__, "Cancelling and disabling the UPS watchdog timer.");
	get_ups_ips($conf);
	my $ok   = cancel_countdown($conf);
	my $exit = 0;
	if ($ok)
	{
		my $ok = update_configuration($conf, "disable");
		if (not $ok)
		{
			$exit = 6;
		}
	}
	exit($exit);
}

# If the user enabled the program, update the cron table and exit so that it starts in the background.
if ($conf->{switches}{enable})
{
	logger($conf, $THIS_FILE, __LINE__, "Enabling the UPS watchdog timer.");
	my $exit = 0;
	my $ok   = update_configuration($conf, "enable");
	if (not $ok)
	{
		$exit = 7;
	}
	exit($exit);
}

# Enable the program if 'force' used.
if ($conf->{switches}{force})
{
	$conf->{tools}{'anvil-kick-apc-ups'}{enabled} = 1;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Anvil! Kick APC UPS has been forced, ignoring 'tools::anvil-kick-apc-ups::enabled'.");
}
elsif (not $conf->{tools}{'anvil-kick-apc-ups'}{enabled})
{
	# We're disabled, exit.
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Anvil! Kick APC UPS has been disabled, exiting.");
	exit(0);
}

# Figure out what UPS(es) we're using.
get_ups_ips($conf);

# If the user is using timing, check that it's time to kick each UPS.
logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sys::apc::ups::kick_frequency: [$conf->{sys}{apc}{ups}{kick_frequency}].");
if ($conf->{sys}{apc}{ups}{kick_frequency})
{
	# We've not been forced and the user has asked for timed kicks. Read 'path::timing', if it exists. If
	# it doesn't, create it with the current time. If it does, read the time in that file, subtract it 
	# from the current time and if the difference is less that sys::apc::ups::kick_frequency, exit.
	check_timing($conf);
}

# We're ready to start.
logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Kicking the following UPSes:");
foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
{
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups]");
	
	# Can we ping it? Whether or not we'll kick it, we want to detect and log when access is lost. We'll
	# do a single ping with a 1 second timeout.
	my $pinged     = 0;
	my $shell_call = $conf->{path}{'ping'}." -W 1 -n $ups -c 1";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /(\d+) packets transmitted, (\d+) received/)
		{
			# This isn't really needed, but might help folks watching the logs.
			my $pings_sent     = $1;
			my $pings_received = $2;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - pings_sent: [$pings_sent], pings_received: [$pings_received]");
			if ($pings_received)
			{
				# Contact!
				$pinged = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - pinged: [$pinged]");
			}
		}
	}
	close $file_handle;
	if (not $pinged)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Failed to ping the UPS: [$ups], skipping it.");
		next;
	}
	
	# If this UPS was processed too recently, skip it.
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sys::apc::ups::target::${ups}::kick: [$conf->{sys}{apc}{ups}{target}{$ups}{kick}].");
	if (not $conf->{sys}{apc}{ups}{target}{$ups}{kick})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - The UPS: [$ups] is not scheduled to be kicked on this pass, skipping it.");
		next;
	}
	
	# Report/record the current values
	if (get_current_settings($conf, $ups, "old"))
	{
		$conf->{sys}{connections}++;
		my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
		my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
		my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
		my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
		my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
		my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
		my $power_off_delay_group1 = $conf->{snmp}{power_off_delay}{group1}{value}{old};
		my $power_off_delay_group2 = $conf->{snmp}{power_off_delay}{group2}{value}{old};
		my $sleep_time_group1      = $conf->{snmp}{sleep_time}{group1}{value}{old};
		my $sleep_time_group2      = $conf->{snmp}{sleep_time}{group2}{value}{old};
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - General UPS state: ...... [$say_state_ups ($current_state_ups)]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Output state; Group 1: .. [$say_state_group1 ($current_state_group1)]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Output state; Group 2: .. [$say_state_group2 ($current_state_group2)]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Power off delay; Group 1: [$power_off_delay_group1 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Power off delay; Group 2: [$power_off_delay_group2 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Sleep time; Group 1: .... [$sleep_time_group1 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Sleep time; Group 2: .... [$sleep_time_group2 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Setting power off delay to: [$conf->{sys}{apc}{ups}{power_off_delay} seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Setting sleep time to: .... [$conf->{sys}{apc}{ups}{sleep_time} seconds]");
		
		# Make sure the UPS is healty enough
		if ($current_state_ups eq "1")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is in an unknown state! Proceeding would be dangerous, skipping this UPS.");
		}
		elsif ($current_state_ups eq "5")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off in a timed sleep. There is no reason to proceed, skipping this UPS.");
		}
		elsif ($current_state_ups eq "7")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off. The UPS will be turned on and outlet group(s) energized.");
			
			### NOTE: Sometimes, after a total discharge and a UPS shuts down, it will NOT come
			###       back up when the power is restored (despite being configured to do so). 
			###       This helps by turning the other UPS on, so long as at least one gets power
			###       again.
			# Turn on the UPS
			my ($poweron_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - poweron_return: [$poweron_return]");
			
			# Energize group 1 / Main group
			my ($group1_on_return) = set_oid_integer($conf, $ups, $conf->{snmp}{group1}{oid}, $conf->{snmp}{group1}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - group1_on_return: [$group1_on_return]");
			
			# Energize group2 / group 1
			my ($group2_on_return) = set_oid_integer($conf, $ups, $conf->{snmp}{group2}{oid}, $conf->{snmp}{group2}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - group2_on_return: [$group2_on_return]");
		}
		elsif ($current_state_ups eq "8")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is rebooting, skipping this UPS.");
		}
		else
		{
			# We're good.
			logger($conf, $THIS_FILE, __LINE__, "- Watchdog timer is kicking the UPS: [$conf->{hosts}{by_ip}{$ups}->[0]] ($ups).");
		
			# Cancel a pending shut-off
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Cancelling any pending power off.");
			my ($poweron_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - poweron_return: [$poweron_return]");
			
			# Explicitely call the groups on.
			my ($group1_on_return) = set_oid_integer($conf, $ups, $conf->{snmp}{group1}{oid}, $conf->{snmp}{group1}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - group1_on_return: [$group1_on_return]");
			
			my ($group2_on_return) = set_oid_integer($conf, $ups, $conf->{snmp}{group2}{oid}, $conf->{snmp}{group2}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - group2_on_return: [$group2_on_return]");
			
			if ($conf->{switches}{reboot})
			{
				### If the user has asked for a hard reboot, set the power off delay and 
				### sleep time and then exit.
				
				# Set the sleep time for the outlet groups.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the sleep timer to: [$conf->{sys}{apc}{reboot}{sleep_time}] seconds.");
				my ($set_sleep_time_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid}, $conf->{sys}{apc}{reboot}{sleep_time});
				my ($set_sleep_time_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid}, $conf->{sys}{apc}{reboot}{sleep_time});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_sleep_time_group1: [$set_sleep_time_group1], set_sleep_time_group2: [$set_sleep_time_group2]");
				
				# Set the power-off delay
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the shut down timer to: [$conf->{sys}{apc}{reboot}{power_off_delay}] seconds.");
				my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{reboot}{power_off_delay});
				my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{reboot}{power_off_delay});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]");
				
				# Do the needful
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Initiating timed sleep.");
				my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_ups}{oid}, $conf->{snmp}{sleep_ups}{off_integer});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]");
				
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - NOTE: Nodes will be rebooted when power is restored.\n");
			}
			elsif ($conf->{switches}{'shutdown'})
			{
				### If the user has asked for a complete 
				### shutdown, set the disable the sleep timer, 
				### set the power off delay and initiate the 
				### power down.
				
				# Set the power-off delay
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the shut down timer to: [$conf->{sys}{apc}{reboot}{power_off_delay}] seconds.");
				my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{'shutdown'}{power_off_delay});
				my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{'shutdown'}{power_off_delay});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]");
				
				# Do the needful
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Shutting down.");
				my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off}{oid}, $conf->{snmp}{power_off}{off_integer}{delay});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]");
				
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Done.\n");
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - NOTE: Nodes will be rebooted when power is restored.\n");
			}
			else
			{
				### Normal loop
				# Set the sleep time for the outlet groups.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the outlet groups' sleep time to: [$conf->{sys}{apc}{ups}{sleep_time} seconds].");
				my ($set_sleep_time_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
				my ($set_sleep_time_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_sleep_time_group1: [$set_sleep_time_group1], set_sleep_time_group2: [$set_sleep_time_group2]");
				
				# Set the power-off delay
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the power-off delay to: ......... [$conf->{sys}{apc}{ups}{power_off_delay} seconds].");
				my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{ups}{power_off_delay});
				my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{ups}{power_off_delay});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]");
				
				# Do the needful
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Initiating timed sleep.");
				my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_ups}{oid}, $conf->{snmp}{sleep_ups}{off_integer});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]");
			}
		}
	}
}

logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Run complete.");

# Only set this to '1' for debugging.
if ($conf->{sys}{connections})
{
	#logger($conf, $THIS_FILE, __LINE__, "Monitoring, press <ctrl> + <c> to end.");
	while (0)
	{
		foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
		{
			get_current_settings($conf, $ups, "old");
			my $say_date               = get_date($conf);
			my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
			my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
			my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
			my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
			my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
			my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
			my $power_off_delay_group1 = $conf->{snmp}{power_off_delay}{group1}{value}{old};
			my $power_off_delay_group2 = $conf->{snmp}{power_off_delay}{group2}{value}{old};
			my $sleep_time_group1      = $conf->{snmp}{sleep_time}{group1}{value}{old};
			my $sleep_time_group2      = $conf->{snmp}{sleep_time}{group2}{value}{old};
			logger($conf, $THIS_FILE, __LINE__, "[ $say_date ] - UPS: [$ups], states; general: [$say_state_ups ($current_state_ups)], group 1: [$say_state_group1 ($current_state_group1)], group 2: [$say_state_group2 ($current_state_group2)]");
		}
		sleep 5;
	}
}
logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Exiting.");

exit(0);


###############################################################################
# Functions                                                                   #
###############################################################################

# This calls each UPS and tells it to turn on its outlet group(s);
sub energize_upses
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - report_state();");
	
	my $problem = 0;
	foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups]");
		if (get_current_settings($conf, $ups, "old"))
		{
			$conf->{sys}{connections}++;
			my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
			my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
			my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
			my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
			my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
			my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - General UPS state: ...... [$say_state_ups ($current_state_ups)]");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Output state; Group 1: .. [$say_state_group1 ($current_state_group1)]");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Output state; Group 2: .. [$say_state_group2 ($current_state_group2)]");
			
			# Make sure the UPS is healty enough
			my $power_on_ups    = 0;
			my $energize_group1 = 0;
			my $energize_group2 = 0;
			if ($current_state_ups eq "1")
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS: [$ups] is in an unknown state! Proceeding would be dangerous, skipping this UPS.");
				$problem = 1;
			}
			elsif ($current_state_ups eq "5")
			{
				logger($conf, $THIS_FILE, __LINE__, "- The UPS is off in a timed sleep. It will be turned on now.");
				$power_on_ups = 1;
			}
			elsif ($current_state_ups eq "7")
			{
				logger($conf, $THIS_FILE, __LINE__, "- The UPS is off. It will be turned on now.");
				$power_on_ups = 1;
			}
			elsif ($current_state_ups eq "8")
			{
				logger($conf, $THIS_FILE, __LINE__, "- The UPS: [$ups] is rebooting, We will wait until it is on.");
				my $start_time = time;
				my $wait       = 1;
				while ($wait)
				{
					sleep 1;
					get_current_settings($conf, $ups, "old");
					if ($current_state_ups ne "8")
					{
						# TODO: Make sure it's actually on.
						logger($conf, $THIS_FILE, __LINE__, "- The UPS: [$ups] is no longer rebooting, proceeding.");
						$wait = 0;
					}
					else
					{
						# have I been waiting over a minute?
						if ((time - $start_time) > 60)
						{
							logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS: [$ups] is still in 'reboot' and we've waited a minute now. Something is wrong, skipping this UPS.");
							$wait    = 0;
							$problem = 1;
						}
						else
						{
							logger($conf, $THIS_FILE, __LINE__, "[ Note ] - The UPS: [$ups] is still rebooting, waiting.");
						}
					}
				}
			}
			
			# Skip to the next UPS if we have a problem.
			if ($problem)
			{
				next;
			}
			
			# We're good. Do we need to turn on the UPS?
			if ($power_on_ups)
			{
				logger($conf, $THIS_FILE, __LINE__, "- Powering on: [$conf->{hosts}{by_ip}{$ups}->[0]] ($ups).");
				my ($poweron_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - poweron_return: [$poweron_return]");
				if ($poweron_return ne $conf->{snmp}{power_on}{on_integer})
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to power on the UPS: [$ups]! Skipping this UPS");
					$problem = 1;
					next;
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups] powered on.");
					# Give the UPS a moment to come up.
					sleep 5;
				}
			}
			
			# Now energize the outlet groups.
			if ($current_state_group1 eq "2")
			{
				my ($group1_on_return) = set_oid_integer($conf, $ups, $conf->{snmp}{group1}{oid}, $conf->{snmp}{group1}{on_integer});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - group1_on_return: [$group1_on_return]");
				if ($group1_on_return eq "1")
				{
					logger($conf, $THIS_FILE, __LINE__, "- Group 1 ('Main Group' on some models) was turned on successfully.");
				}
				else
				{
					$problem = 1;
					logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Group 1 ('Main Group' on some models) failed to turn on! State is: [$group1_on_return], should be '1'.");
				}
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "- Group 1 ('Main Group' on some models) is already on.");
			}
			if ($current_state_group2 eq "2")
			{
				my ($group2_on_return) = set_oid_integer($conf, $ups, $conf->{snmp}{group2}{oid}, $conf->{snmp}{group2}{on_integer});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - group2_on_return: [$group2_on_return]");
				if ($group2_on_return eq "1")
				{
					logger($conf, $THIS_FILE, __LINE__, "- Group 2 ('Group 1' on models that call group 1 'Main group') was turned on successfully.");
				}
				else
				{
					$problem = 1;
					logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Group 2 ('Group 1' on models that call group 1 'Main group') failed to turn on! State is: [$group2_on_return], should be '1'.");
				}
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "- Group 2 ('Group 1' on models that call group 1 'Main group') is already on.");
			}
		}
	}
	
	return(0);
}

# This checks to see if an instance of the program is running. It also checks to see if the program is 
# configured to run on boot.
sub report_state
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - report_state();");
	
	# Is it enabled on boot?
	my $shell_call = "
if \$($conf->{path}{'grep'} -q '^tools::anvil-kick-apc-ups::enabled\\s*=\\s*1' $conf->{path}{striker_config});
then 
    echo enabled; 
else 
    echo disabled;
fi";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "$THIS_FILE: [$line]\n";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
	}
	close $file_handle;
	
	# Is it running now?
	my $pids       = [];
	my $my_pid     = $$;
	   $shell_call = $conf->{path}{ps}." aux";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]");
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+/ /g;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /^\S+ \d+ /)
		{
			my ($user, $pid, $cpu, $memory, $virtual_memory_size, $resident_set_size, $control_terminal, $state_codes, $start_time, $time, $command) = ($line =~ /^(\S+) (\d+) (.*?) (.*?) (.*?) (.*?) (.*?) (.*?) (.*?) (.*?) (.*)$/);
			if ($command =~ /$THIS_FILE/)
			{
				# Don't count ourself.
				if ($pid ne $my_pid)
				{
					push @{$pids}, $pid;
				}
			}
		}
	}
	close $file_handle;
	
	my $count = @{$pids};
	if ($count)
	{
		# Yup.
		print "$THIS_FILE: [running]\n";
		foreach my $pid (sort {$a cmp $b} @{$pids})
		{
			print "- pid: [$pid]\n";
		}
	}
	else
	{
		print "$THIS_FILE: [not running].\n";
	}
	
	return(0);
}

# This reads 'path::timing', if it exists. If it doesn't, it is created with the current time. If it does, it
# reads the time in that file, subtracts it from the current time and if the difference is less than
# sys::apc::ups::kick_frequency, it exits.
sub check_timing
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check_timing();");
	
	foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups].");
		
		# If this is set to 0, the UPS won't be kicked.
		$conf->{sys}{apc}{ups}{target}{$ups}{kick} = 1;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sys::apc::ups::target::${ups}::kick: [$conf->{sys}{apc}{ups}{target}{$ups}{kick}].");
		
		my $last_run    = 0;
		my $timing_file = $conf->{path}{timing}.".".$ups;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups], path::timing: [$conf->{path}{timing}], timing_file: [$timing_file].");
		if (-e $timing_file)
		{
			my $shell_call = $timing_file;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
			open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /^\d+$/)
				{
					$last_run = $line;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - last_run: [$last_run]");
					last;
				}
			}
			close $file_handle;
		}
		
		if ($last_run)
		{
			my $time_now              = time;
			my $second_since_last_run = $time_now - $last_run;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - time_now: [$time_now], second_since_last_run: [$second_since_last_run], sys::apc::ups::kick_frequency: [$conf->{sys}{apc}{ups}{kick_frequency}]");
			if ($second_since_last_run < $conf->{sys}{apc}{ups}{kick_frequency})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Note ] - The last kick of: [$ups] was too recent. The last run was: [$second_since_last_run] seconds ago and we need to wait at least: [$conf->{sys}{apc}{ups}{kick_frequency}] between runs.");
				
				$conf->{sys}{apc}{ups}{target}{$ups}{kick} = 0;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sys::apc::ups::target::${ups}::kick: [$conf->{sys}{apc}{ups}{target}{$ups}{kick}].");
			}
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - timing_file: [$timing_file], sys::apc::ups::target::${ups}::kick: [$conf->{sys}{apc}{ups}{target}{$ups}{kick}].");
		if ((not -e $timing_file) or ($conf->{sys}{apc}{ups}{target}{$ups}{kick}))
		{
			# If we're going to proceed with the run for this UPS, update its timing file.
			my $shell_call = $timing_file;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
			open (my $file_handle, ">$shell_call") or die "Failed to write: [$shell_call], error was: $!\n";
			print $file_handle time."\n";
			close $file_handle;
		}
	}
	
	return(0);
}

# This cancels the pending count-down.
sub cancel_countdown
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cancel_countdown();");
	
	my $ok = 1;
	foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
	{
		my ($poweron_return, $shell_call) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
		if ($poweron_return ne $conf->{snmp}{power_on}{on_integer})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Critical ] - Failed to cancel the shutdown sequence on the UPS: [$ups]!");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The command to abort pending power-off actions returned: [$poweron_return], expected: [$conf->{snmp}{power_on}{on_integer}].");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   Tried to call: [$shell_call]");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   The UPS may still be running its poweroff-timer!");
			$ok = 0;
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, " - UPS: [$ups] power-off cancelled.");
			
			# Unlink the timing file.
			my $timing_file = $conf->{path}{timing}.".".$ups;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups], path::timing: [$conf->{path}{timing}], timing_file: [$timing_file].");
			if (-e $timing_file)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Removing the timing file: [$timing_file]");
				unlink $timing_file or die "Failed to unlink: [$timing_file]\n";;
			}
		}
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Done.");
	
	return($ok);
}

# This updates striker.conf to enable or disable anvil-kick-apc-ups.
sub update_configuration
{
	my ($conf, $do) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - update_configuration(); do: [$do]");
	
	my $ok = 1;
	my $shell_call  = "$conf->{path}{sed} -i 's/^tools::anvil-kick-apc-ups::enabled\\(\\s*\\)=\\(\\s*\\)1/tools::anvil-kick-apc-ups::enabled\\1=\\20/' $conf->{path}{striker_config}\n";
	if ($do eq "enable")
	{
		$shell_call = "$conf->{path}{sed} -i 's/^tools::anvil-kick-apc-ups::enabled\\(\\s*\\)=\\(\\s*\\)0/tools::anvil-kick-apc-ups::enabled\\1=\\21/' $conf->{path}{striker_config}\n";
	}
	$shell_call .= "
if \$($conf->{path}{'grep'} -q '^tools::anvil-kick-apc-ups::enabled\\s*=\\s*1' $conf->{path}{striker_config});
then 
    echo enabled; 
else 
    echo disabled;
fi";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /enabled/)
		{
			# Did I want this?
			if ($do eq "enable")
			{
				# Good!
				logger($conf, $THIS_FILE, __LINE__, "Anvil! Kick APC UPS watchdog timer enabled successfully (it will start in a minute).");
			}
			else
			{
				# Woops...
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to disable!");
				$ok = 0;
			}
		}
		elsif ($line =~ /disabled/)
		{
			# Did I want this?
			if ($do eq "disable")
			{
				# Good!
				logger($conf, $THIS_FILE, __LINE__, "Anvil! Kick APC UPS watchdog timer disabled successfully.");
			}
			else
			{
				# Woops...
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to enable!");
				$ok = 0;
			}
		}
	}
	close $file_handle;
	
	return($ok);
}

# This returns the current date and time in 'YYYY/MM/DD HH:MM:SS' format. It
# always uses 24-hour time and it zero-pads single digits.
sub get_date
{
	my ($conf) = @_;
	my $date = "";
	
	# This doesn't support offsets or other advanced features.
	my %time;
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	$date = "$time{year}/$time{pad_mon}/$time{pad_mday} $time{pad_hour}:$time{pad_min}:$time{pad_sec}";
	
	return($date);
}

# This sets an OID with to an integer value.
sub set_oid_integer
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_integer(); ups: [$ups], oid: [$oid], value: [$value]");
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid i $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value]");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value, $shell_call);
}

# This sets an OID with to a time tick (-t, 10ms) value.
sub set_oid_ticks
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_ticks(); ups: [$ups], oid: [$oid], value: [$value]");
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid t $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			   $value     = $1;
			my $say_value = ($value / 100);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value] ($say_value seconds)");
		}
		if ($line =~ /Failed object/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], not set! Does this OID exist on your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value, $shell_call);
}

# This calls the UPS and tries to get the current settings.
sub get_current_settings
{
	my ($conf, $ups, $type) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_current_settings(); ups: [$ups], type: [$type]");
	
	# First, main UPS outlet group. This is our first call, so verify we
	# got a returned value.
	my ($current_state_ups) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{ups}{oid});
	if ($current_state_ups eq "#!no_connection!#")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Note ] - SNMP connection to UPS: [$ups] timed out!");
		return(0);
	}
	# Still alive? Good!
	my ($current_state_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{group1}{oid});
	my ($current_state_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{group2}{oid});
	
	# Get the power off delays and sleep times
	my ($power_off_delay_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid});
	my ($power_off_delay_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid});
	my ($sleep_time_group1)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid});
	my ($sleep_time_group2)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid});
	
	# Record the values in the hash
	$conf->{snmp}{current_state}{ups}{value}{$type}      = $current_state_ups;
	$conf->{snmp}{current_state}{group1}{value}{$type}   = $current_state_group1;
	$conf->{snmp}{current_state}{group2}{value}{$type}   = $current_state_group2;
	$conf->{snmp}{power_off_delay}{group1}{value}{$type} = $power_off_delay_group1;
	$conf->{snmp}{power_off_delay}{group2}{value}{$type} = $power_off_delay_group2;
	$conf->{snmp}{sleep_time}{group1}{value}{$type}      = $sleep_time_group1;
	$conf->{snmp}{sleep_time}{group2}{value}{$type}      = $sleep_time_group2;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - snmp::current_state::ups::value::$type: [$conf->{snmp}{current_state}{ups}{value}{$type}], snmp::current_state::group1::value::$type: [$conf->{snmp}{current_state}{group1}{value}{$type}], snmp::current_state::group2::value::$type: [$conf->{snmp}{current_state}{group2}{value}{$type}], snmp::power_off_delay::group1::value::$type: [$conf->{snmp}{power_off_delay}{group1}{value}{$type}], snmp::power_off_delay::group2::value::$type: [$conf->{snmp}{power_off_delay}{group2}{value}{$type}], snmp::sleep_time::group1::value::$type: [$conf->{snmp}{sleep_time}{group1}{value}{$type}], snmp::sleep_time::group2::value::$type: [$conf->{snmp}{sleep_time}{group2}{value}{$type}]");

	return(1);
}

# Convert ticks to seconds.
sub convert_ticks_to_seconds
{
	my ($conf, $ticks) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - convert_ticks_to_seconds(); ticks: [$ticks]");
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $seconds          = ($ticks / $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - seconds: [$seconds]");
	return($seconds);
}

# Convert seconds to ticks.
sub convert_seconds_to_ticks
{
	my ($conf, $seconds) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - convert_seconds_to_ticks(); seconds: [$seconds]");
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $ticks            = ($seconds * $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ticks: [$ticks]");
	return($ticks);
}

# This reads an OID with an ticks value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# ticks is read, "#!no_value!#" is returned.
sub read_oid_ticks
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_ticks(); ups: [$ups], oid: [$oid]");
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value);
}

# This reads an OID with an integer value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_integer
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_integer(); ups: [$ups], oid: [$oid]");
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value);
}

# This reads an OID with a string value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_string
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_string(); ups: [$ups], oid: [$oid]");
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /STRING: "(.*)"$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value);
}

# This determines what UPSes to talk to, by IP address.
sub get_ups_ips
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_ups_ips()");
	
	# Did the user specify the UPSes?
	$conf->{switches}{ups} = "" if not defined $conf->{switches}{ups};
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - switches::ups: [$conf->{switches}{ups}]");
	if ($conf->{switches}{ups})
	{
		# Yup!
		foreach my $ups (split/,/, $conf->{switches}{ups})
		{
			next if not $ups;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ups: [$ups]");
			if (is_string_ipv4($conf, $ups))
			{
				# It's already an IP.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP address given, recording.");
				push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
			}
			else
			{
				# Try to resolve it.
				my ($ip) = get_host_ip($conf, $ups);
				if ($ip)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups] has IP: [$ip], recording.");
					push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The UPS: [$ups] could not be translated to an IP address.");
					exit(1);
				}
			}
		}
	}
	else
	{
		# Nope. Parse /etc/hosts.
		parse_hosts($conf);
	}
	
	# Now if I have some UPSes, we're ok to proceed.
	if (@{$conf->{sys}{apc}{ups}{devices}} < 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - No UPSes were found, unable to proceed.");
		exit(2);
	}
	
	return(0);
}

# This looks through /etc/hosts and pushes the IPs for each entry with 'ups'
# in the name that it finds.
sub parse_hosts
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parse_hosts()");
	
	my $shell_call = "$conf->{path}{hosts}";
	open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		$line =~ s/#.*//;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /ups/)
		{
			# Oh looky looky!
			my ($ip, $names) = ($line =~ /^(\d+\.\d+\.\d+\.\d+) (.*)/);
			next if ((not $ip) || (not $names));
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], names: [$names]");
			foreach my $name (split/ /, $names)
			{
				next if not $name;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], name: [$name]");
				$conf->{hosts}{by_name}{$name} = $ip;
				push @{$conf->{hosts}{by_ip}{$ip}}, $name;
			}
		}
	}
	close $file_handle;
	
	# Now record the IPs in the central hash.
	foreach my $ip (sort {$a cmp $b} keys %{$conf->{hosts}{by_ip}})
	{
		if (@{$conf->{hosts}{by_ip}{$ip}} == 1)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with name: [$conf->{hosts}{by_ip}{$ip}->[0]].");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with names:");
			foreach my $name (sort {$a cmp $b} @{$conf->{hosts}{by_ip}{$ip}})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - name: [$name]");
			}
		}
		push @{$conf->{sys}{apc}{ups}{devices}}, $ip;
	}
	
	return(0);
}

# This tries to resolve a name to an IP address. Returns '0' if lookup failed.
sub get_host_ip
{
	my ($conf, $host) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_host_ip(); host: [$host]");
	
	my $ip = 0;
	
	my $shell_call = "$conf->{path}{gethostip} -d $host";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		$ip = $_;
		# This should only ever print the IP address. Anything else
		# will be treated as a failure.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$ip]");
	}
	close $file_handle;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]");
	
	# Make sure the IP is sane.
	if (not is_string_ipv4($conf, $ip))
	{
		# It's already an IP.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Returned IP address is not valid.");
		$ip = 0;
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]");
	return($ip);
}

# Checks if the passed-in string is an IPv4 address (with or without a subnet
# mask). Returns '1' if OK, 0 if not.
sub is_string_ipv4
{
	my ($conf, $ip) = @_;
	my $valid  = 1;
	
	if ($ip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/)
	{
		# It's in the right format.
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		
		if (($first_octal  < 0) || ($first_octal  > 255) ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal  < 0) || ($third_octal  > 255) ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			# One of the octals is out of range.
			$valid = 0;
		}
	}
	else
	{
		# Not in the right format.
		$valid = 0;
	}
	
	return($valid);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	if ($conf->{sys}{debug})
	{
		foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}})
		{
			print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n";
		}
	}
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	if (not -e $conf->{path}{striker_config})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Striker configuration file not found.");
	}
	else
	{
		my $shell_call = "$conf->{path}{striker_config}";
		open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			next if $line !~ /=/;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			next if $line =~ /^#/;
			next if not $line;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			next if (not $var);
			_make_hash_reference($conf, $var, $val);
		}
		close $file_handle;
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Use APC-brand UPSes as an external watchdog timer

DESCRIPTION

This program uses one or more APC-brand UPSes as a form of Anvil!-wide watchdog
timer. In essence, this program will run every five minutes, and on each run,
it will tell the UPSes to turn off in 15 minutes, stary off for 5 minutes, and
then power back on. In this way, if something catastrophic happens, the system
will reboot all devices. With luck, that will return the system to an operating
state autonomously.

So long as at least one node is operating, it will 


Note:

For this to work properly, you need to setup your dashboards to automatically
boot when the power is applied to them. Exactly how you do this will depend on
your hardware, but usually it is configured under power settings in the system
BIOS.

Further; The dashboards must be running the Scanner 'nodemonitor' scan agent.
This way, when the nodes boot, they will check the UPS and environmental
temperatures and if/when good, boot the nodes.

Further; The nodes must be configured to run the 'anvil-kick-apc-ups' tool. This
way, when the nodes boot, they will autonomously form the cluster and boot the
servers.


SWITCHES

 --all-on

	This will ask all accessible UPSes to turn on their outlet group(s) if
	they aren't on already.
	
	WARNING: Be sure no one is maintaining connected equipment! Failure to
	         check could cause injury or death!

 --cancel

	This will cancel any previous power-off timer. This should be used
	either when you want a controlled cold-stop of the Anvil!, or when
	you plan to do maintenance that would interrupt the connection to the
	UPS(es).
	
	NOTE: Remember to cancel on the other node!

 --debug

	This enables debug mode, generating a lot more output than usual.

 --disable

	This disables the 'auto-off after X seconds' function. This should be
	used on both nodes before power the entire system down for a cold-stop.
	This cancels the current kick counter and then exits.

 --enable

	This enables the program. It will start up within two minutes of being
	enabled. It does the same thing as manually editing 
	$conf->{path}{striker_config} and changing setting:
	tools::anvil-kick-apc-ups::enabled = 1
	
	WARNING: Be sure to affix a warning on the UPS outlets indicating that
	         the outlets may become energized automatically. Failure to 
	         warn maintenance personel may result in injury or death!

 --force

	This tells the program to run, even if 
	'tools::anvil-kick-apc-ups::enabled = 0' is set. 

 -h, -?, --help

	Show this dialoge and exit.

 --power_off_delay <seconds>

	This controls how far in the future to tell the UPSes to power off.
	
	The default is '600' (10 minutes). This can be changed by setting:
	
	sys::apc::ups::power_off_delay = <seconds>

 --reboot

	This tells all UPSes to power off in $conf->{sys}{apc}{reboot}{power_off_delay} seconds, stay off for $conf->{sys}{apc}{reboot}{sleep_time}
	seconds, and then power back on. The effect of this is that all
	equipment powered by the Anvil!'s UPSes will be hard power cycled.
	
	Use with caution!
	
	The power off delay and sleep timers can be adjusted in striker.conf
	by setting;
	
	sys::apc::reboot::power_off_delay = x
	sys::apc::reboot::sleep_time      = x
	
	Where 'x' is the desired time in seconds.

 --state, --status

	Reports whether the program is enabled or disabled and whether any 
	instance of this program is currently running.

 --shutdown

	This tells all UPSes to power off in $conf->{sys}{apc}{'shutdown'}{power_off_delay} and stay off. The effect of
	this is that everything powered by the Anvil!'s UPSes will shut down
	entirely and stay off until power is manually restored.
	
	Use with caution!
	
	The power off delay can be adjusted in striker.conf by setting;
	
	sys::apc::shutdown::power_off_delay = x
	
	Where 'x' is the desired time in seconds.

 --sleep_time <seconds>

	This controls how long the UPSes should stay off for. After this number
	of seconds, the UPSes will automatically restore power to their
	outlets.
	
	The default is '300' (five minutes). This can be changed by setting:
	
	sys::apc::ups::sleep_time = <seconds>

 --ups <ups1>[,<ups2>,...,<upsN>]

	Define the specific UPS(es) to work on. If host names are used, they
	must be convertable to IP addresses. Two or more UPSes can be defined
	using commas and *no* spaces to separate them.


NOTES

When run, this program will add itself to the root user's crontab
automatically. It will be configured to run every five minutes until cancelled.
The switches passwd when calling the program will be used in the crontab entry.

When called with '--cancel', it will remove the cron table entry automatically,
preventing it from restarting the countdown. 


EXAMPLE

Run with all default values, using all UPSes found in /etc/hosts with 'ups' in
their name.

 ./$THIS_FILE

Run with two specifically defined UPSes set to cut power in ten minutes 
and then power up after one minute.

 ./$THIS_FILE --ups an-ups01,an-ups02 --sleep_time 600 --power_off_delay 60

Stop the timer entirely on all UPSes found in /etc/hosts

 ./$THIS_FILE --disable

                  
SUPPORT

https://alteeve.ca/w/Support

                                                              Alteeve's Niche!
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message) = @_;
	
	# We split on new-lines so that multi-line message render better in syslog.
	if ((($message =~ /\[ Debug \]/i) or ($message =~ /\[ Note \]/i)) && (not $conf->{sys}{debug}))
	{
		# User is suppressing debug messages.
		return(0);
	}
	
	# Print the message to the screen.
	print "$file $line_number: $message\n";
	
	# If the message spans lines and if it is a debug message, intent the subsequent lines.
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "$conf->{path}{logger}", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $file $line_number: $message]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

# Catch SIG, move zig!
sub _catch_sig
{
	my $signame = shift;
	
	logger($conf, $THIS_FILE, __LINE__, "Process with PID $$ Exiting on SIG${signame}.");
	exit(3);
}
