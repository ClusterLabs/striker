#!/usr/bin/perl
# 
# This program is used to turn APC-brand UPSes with the AP9630 or AP9631 UPSes
# into watchdog timers.
# 
# The idea is that the UPS will be configured to start X minutes after turning
# off, and then schedule a shutdown Y minutes in the future. This way, if
# something causes the system to lock up (ie: bad switch config), all systems
# connected to power cycle. This way, a physically inaccessible site can
# potentially recover from unforseen problems.
# 
# For this to work, all components of the HA environment must be powered by the
# UPSes.
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# Madison Kelly - mkelly@alteeve.ca
# https://alteeve.ca
# 
# Exit codes:
# 0  = Normal exit
# 1  = Failed to translate a given host name to an IP address.
# 2  = Failed to find any UPSes.
# 3  = Exited on SIGnal.
# 4  = One or more UPSes didn't cancel their shutdown timer.
# 5  = The program was not run as root.
# 

# OIDs
=pod
UPS Serial number:	.1.3.6.1.4.1.318.1.1.1.1.2.3.0		ie: AS1038232403
UPS Part number:	.1.3.6.1.4.1.318.1.1.1.1.2.5.0		ie: SMT1500
UPS Basic type:		.1.3.6.1.4.1.318.1.1.1.1.1.1.0		ie: SmartUPS 1500
UPS Firmware:		.1.3.6.1.4.1.318.1.4.2.4.1.4.1
NMC Serial number:	.1.3.6.1.4.1.318.1.4.2.4.1.2.1
Battery Part Number:	.1.3.6.1.4.1.318.1.1.1.2.2.19.0		ie: RBC7

Date:			.1.3.6.1.4.1.318.1.1.1.2.1.3.0		(mm/dd/yyyy)
Time:			.1.3.6.1.4.1.318.2.1.6.2.0		'HH:mm:ss' or 'hh:mm:ss {am,pm}'
Estimated runtime:	.1.3.6.1.4.1.318.1.1.1.2.2.3.0		(in ticks [10ms])

UPS Basic State:	.1.3.6.1.4.1.318.1.1.1.4.1.1.0		1'	=>	"Unknown, 2'	=>	"Online, 3'	=>	"On Battery, 4'	=>	"onSmartBoost, 5'	=>	"timedSleeping, 6'	=>	"softwareBypass, 7'	=>	"off, 8'	=>	"rebooting, 9'	=>	"switchedBypass, 10'	=>	"hardwareFailureBypass, 11'	=>	"sleepingUntilPowerReturn, 12'	=>	"onSmartTrim, 13'	=>	"ecoMode, 14'	=>	"hotStandby, 15'	=>	"onBatteryTest, 15'	=>	"emergencyStaticBypass, 17'	=>	"staticBypassStandby, 18'	=>	"powerSavingMode, 19'	=>	"spotMode, 20'	=>	"eConversion
Main UPS outlet state:	.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1	1'	=>	"On, 2'	=>	"Off, 3'	=>	"Unknown
Outlet group 1 state:	.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2	1'	=>	"On, 2'	=>	"Off, 3'	=>	"Unknown
Battery health:		.1.3.6.1.4.1.318.1.1.1.2.2.4.0		1'	=>	"OK, 2'	=>	"Replacement needed


Temperature units 1:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.5.1	1'	=>	"C, 2'	=>	"F
Temperature units 2:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.5.2	1'	=>	"C, 2'	=>	"F
High Temp probe 1:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.3.1	integer of alarm threshold of UPS probe 1 (C or F set above)
High Temp probe 2:	.1.3.6.1.4.1.318.1.1.10.1.2.2.1.3.2	integer of alarm threshold of UPS probe 2 (C or F set above)
Battery Temp in 1/10*C:	.1.3.6.1.4.1.318.1.1.1.2.3.2.0		ie: 333'	=>	"33.3 *C
Battery Temp in *C	.1.3.6.1.4.1.318.1.1.1.2.2.2.0		ie: 33'	=>	"33 *C
Battery Volt in 1/10v:	.1.3.6.1.4.1.318.1.1.1.2.3.4.0		ie: 271'	=>	"27.1 vDC
Battery Volt:		.1.3.6.1.4.1.318.1.1.1.2.2.8.0		ie: 27 (vDC)

Turn off the UPS:	.1.3.6.1.4.1.318.1.1.1.6.2.1.0		2'	=>	"turnUpsOff (no delay), 3'	=>	"turnUpsOffGracefully (use delay), always returns '1'
Turn on the UPS:	.1.3.6.1.4.1.318.1.1.1.6.2.6.0		2'	=>	"turn on (no delay), always returns '1'.
Sleep time:		.1.3.6.1.4.1.318.1.1.1.5.2.11.0		Time in ticks to sleep after turning off. Once timer expires, UPS boots. The UPS only recognizes 1/10 of an hour increments. The provided value will be rounded to the closest 1/10 of an hour with one exception: Any value entered between 1 and 540 seconds will be rounded to 360 seconds (or 6 minutes).
Put the UPS to sleep:	.1.3.6.1.4.1.318.1.1.1.6.2.3.0		2'	=>	"Put to sleep for 'upsAdvConfigUpsSleepTime' then turn on, 3'	=>	"same as '2', but with shutdown delay
Power off delay:	.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2	-1'	=>	"Never (if supported), integer in seconds (not ticks) to delay shutdown.
Shut off delay (??):	.1.3.6.1.4.1.318.1.1.1.5.2.10.0		Time in ticks to delay shut off, ie: 2000'	=>	"20 seconds (not sure how this differs from above). Adjust to closest acceptible time (1/10th hour?)
Reboot delay, main UPS:	.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1	integer in seconds to wait before powering back on. '8' is default
Reboot delay, Group 1:	.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2	integer in seconds to wait before powering back on. '8' is default

Info:
Last transfer reason:	.1.3.6.1.4.1.318.1.1.1.3.2.5.0		1'	=>	"noTransfer, 2'	=>	"highLineVoltage, 3'	=>	"brownout, 4'	=>	"blackout, 5 = smallMomentarySag, 6'	=>	"deepMomentarySag, 7 = smallMomentarySpike, 8'	=>	"largeMomentarySpike, 9'	=>	"selfTest, 10'	=>	"rateOfVoltageChange
Identify UPS:		.1.3.6.1.4.1.318.1.1.1.6.2.5.0		2'	=>	"Flash LCD and beep then stop, 4'	=>	"Flash LCD and beep until cancelled, 5'	=>	"Cancel flash and beep
UPS Input Sensitivity:	.1.3.6.1.4.1.318.1.1.1.5.2.7.0		1'	=>	"Auto, 2'	=>	"Low, 3'	=>	"Medium, 4'	=>	"High
LCD Panel Language	.1.3.6.1.4.1.318.1.1.1.5.2.46.0		1'	=>	"english, 2'	=>	"french, 3'	=>	"italian, 4'	=>	"german, 5'	=>	"spanish, 6'	=>	"portuguese, 7'	=>	"japanese
Green mode:		.1.3.6.1.4.1.318.1.1.1.5.2.45.0		1'	=>	"Disable, 2'	=>	"Enable
Battery state:		.1.3.6.1.4.1.318.1.1.1.2.1.1.0		1'	=>	"unknown, 2'	=>	"batteryNormal, 3'	=>	"batteryLow, 4'	=>	"batteryInFaultCondition
User-set name:		.1.3.6.1.4.1.318.1.1.1.1.1.2.0		8-byte ID string set by the user.
NMC MAC address:	.1.3.6.1.4.1.318.1.4.2.6.1.4.14		ie: C0-A8-01-01-00-A2
Input Hz in 1/10ths	.1.3.6.1.4.1.318.1.1.1.3.3.4.0		ie: 600'	=>	"60Hz
Input Hz is 1Hz:	.1.3.6.1.4.1.318.1.1.1.3.2.4.0		ie: 60 (Hz)
Output Hz in 1/10ths:	.1.3.6.1.4.1.318.1.1.1.4.2.2.0		ie: 600'	=>	"60Hz
Output Hz is 1Hz:	.1.3.6.1.4.1.318.1.1.1.4.2.2.0		ie: 60 (Hz)
Output in 10 Wh		.1.3.6.1.4.1.318.1.1.1.4.3.6.0		?? guage
High Xfer Volt:		.1.3.6.1.4.1.318.1.1.1.5.2.2.0		127 (vAC)
Low Xfer Volt:		.1.3.6.1.4.1.318.1.1.1.5.2.3.0		106 (vAC)
Input Volt in 1/10v:	.1.3.6.1.4.1.318.1.1.1.3.3.1.0		ie: 1245'	=>	"124.5 vAC
Input Volt:		.1.3.6.1.4.1.318.1.1.1.3.2.1.0		ie: 124 (vAC)
60s Max input in 1/10v:	.1.3.6.1.4.1.318.1.1.1.3.3.2.0		ie: 1245'	=>	"124.5 vAC max seen in last 60sec
60s Max input:		.1.3.6.1.4.1.318.1.1.1.3.2.2.0		ie: 124 (vAC)
60s Min input in 1/10v:	.1.3.6.1.4.1.318.1.1.1.3.3.3.0		ie: 1245'	=>	"124.5 vAC min seen in last 60sec
60s Min input:		.1.3.6.1.4.1.318.1.1.1.3.2.3.0		ie: 124 (vAC)
Output Volt in 1/10v:	.1.3.6.1.4.1.318.1.1.1.4.3.1.0		ie: 1245'	=>	"124.5 vAC
Output Volt:		.1.3.6.1.4.1.318.1.1.1.4.2.1.0		ie: 124 (vAC)
Nominal output volt:	.1.3.6.1.4.1.318.1.1.1.5.2.1.0		ie: 120 (vAC)
Remaining batt 1/10%:	.1.3.6.1.4.1.318.1.1.1.2.3.1.0		ie: 1000'	=>	"100.0% charge
Remaining battery %:	.1.3.6.1.4.1.318.1.1.1.2.2.1.0		ie: 100 (%) charge
AC restore boot delay:	.1.3.6.1.2.1.33.1.2.4.0			Ticks after AC restore before UPS powers on (ie: 1000'	=>	"10 seconds)
UPS Manufacture date:	.1.3.6.1.4.1.318.1.1.1.1.2.2.0		in 'mm/dd/yy' or 'mm/dd/yyyy' format.
Battery replaced date:	.1.3.6.1.4.1.318.1.1.1.2.1.3.0		in 'mm/dd/yy' or 'mm/dd/yyyy' format.
Est. next replace date:	.1.3.6.1.4.1.318.1.1.1.2.2.21.0		in 'mm/dd/yy' or 'mm/dd/yyyy' format.
ASCII state string:	.1.3.6.1.4.1.318.1.1.1.11.1.1.0		64 values; See MIB for values.
Time on batteries:	.1.3.6.1.4.1.318.1.1.1.2.1.2.0		Time in ticks since transfer to batteries (0 if on AC)
Current load in 1/10%:	.1.3.6.1.4.1.318.1.1.1.4.3.3.0		(guage) ie: 58'	=>	"5.8%
Current load in %:	.1.3.6.1.4.1.318.1.1.1.4.2.3.0		(guage) ie: 5 (%)

Tests:
Calibrate UPS:		.1.3.6.1.4.1.318.1.1.1.7.2.5.0		2'	=>	"If battery is 100%, will drain to 25%, 3'	=>	"Cancel calibration
Last calibration:	.1.3.6.1.4.1.318.1.1.1.7.2.6.0		1'	=>	"OK, 2'	=>	"Invalid, 3'	=>	"Calibration in progress
Last calibration date:	.1.3.6.1.4.1.318.1.1.1.7.2.7.0		"Unknown" or mm/dd/yyyy
Test Schedule:		.1.3.6.1.4.1.318.1.1.1.7.2.1.0		1'	=>	"unknown, 2'	=>	"biweekly, 3'	=>	"weekly, 4'	=>	"atTurnOn, 5'	=>	"never, 6'	=>	"fourWeeks, 7'	=>	"twelveWeeks, 8'	=>	"biweeklySinceLastTest, 9'	=>	"weeklySinceLastTest, 10 = eightWeeks, 11 = twentysixWeeks, 12'	=>	"fiftytwoWeeks
Last diagnostics:	.1.3.6.1.4.1.318.1.1.1.7.2.3.0		1'	=>	"OK, 2'	=>	"Failed, 3'	=>	"Invalid, 4'	=>	"Test in progress
Last diagnostics date:	.1.3.6.1.4.1.318.1.1.1.7.2.4.0		"Unknown" or mm/dd/yyyy

There is a upsAdvConfigMinReturnRuntime that should be set to say 10 minutes or so. the kick script is currently NOT using this.
upsAdvConfigMinReturnRunTime   .1.3.6.1.4.1.318.1.1.1.5.2.29 (The minimum amount of run time in seconds required before the output will be turned on, using power
calculation catpured at start of last shutdown. The reason is that if power goes up and down frequently within a few minutes, you don't want the UPS turning on and off.

=cut

# Play safe!
use strict;
use warnings;

# IO::Handle is used for logging and communicating with the Raritan device
# via the snmp command line tools. Net::SNMP is not used to do availability
# issues with EL6.
use IO::Handle;

# Catch signals for clean exits.
$SIG{INT}  = \&_catch_sig;
$SIG{TERM} = \&_catch_sig;

# Some variables.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# These are the default values and will be over-written by the config file's
# variables which in turn can, in some cases, be over-written by command line
# arguments.
my $conf = {
	hosts		=>	{
		by_name		=>	{},
		by_ip		=>	{},
	},
	path		=>	{
		cron_root	=>	"/var/spool/cron/root",
		gethostip	=>	"/usr/bin/gethostip",
		hosts		=>	"/etc/hosts",
		logger		=>	"/bin/logger",
		snmpget		=>	"/usr/bin/snmpget",
		snmpset		=>	"/usr/bin/snmpset",
		striker_conf	=>	"/etc/striker/striker.conf",
	},
	snmp		=>	{
		model_number	=>	{
			oid		=>	'.1.3.6.1.4.1.318.1.1.1.1.2.5.0',
			value		=>	"",
		},
		oid_name	=>	{
			# Seems to be ignored entirely
			'.1.3.6.1.4.1.318.1.1.1.5.2.9.0'	=>	"Return Delay",
			'.1.3.6.1.4.1.318.1.1.1.5.2.10.0'	=>	"Shut-Off Delay",		# Power off delay in ticks
			'.1.3.6.1.4.1.318.1.1.1.5.2.29.0'	=>	"Minimum Mains Return Time",	# how long to wait after the AC mains return before restoring power
			
			# Appear to be useful
			'.1.3.6.1.4.1.318.2.1.6.2.0'		=>	"UPS Time",			# 
			'.1.3.6.1.4.1.318.1.1.1.1.2.5.0'	=>	"Model Number",
			
			#---
			'.1.3.6.1.4.1.318.1.1.1.5.2.11.0'	=>	"Sleep time",			# Time in ticks to sleep after turning off. Once timer expires, UPS boots. The UPS only recognizes 1/10 of an hour increments. The provided value will be rounded to the closest 1/10 of an hour with one exception: Any value entered between 1 and 540 seconds will be rounded to 360 seconds (or 6 minutes).
			'.1.3.6.1.4.1.318.1.1.1.6.2.1.0'	=>	"Turn Off UPS",			# 2 => turnUpsOff (no delay), 3 => turnUpsOffGracefully (use delay), always returns '1'
			'.1.3.6.1.4.1.318.1.1.1.6.2.2.0'	=>	"Reboot UPS",			# 2 == Reboot now, 3 == Reboot gracefully
			
			# Use these
			'.1.3.6.1.4.1.318.1.1.1.6.2.6.0'	=>	"Power-On / Cancel Sleep",
			'.1.3.6.1.4.1.318.1.1.1.6.2.3.0'	=>	"Put UPS to Sleep",		# Gracefully go to sleep (after a delay period) then return after a sleep period.
			'.1.3.6.1.4.1.318.1.1.1.4.1.1.0'	=>	"UPS Basic State",
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1'	=>	"Outlet Group 1 State",
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2'	=>	"Outlet Group 2 State",
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.1'	=>	"Group 1 Power Off Delay",	# Seems to override above
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2'	=>	"Group 2 Power Off Delay",	# Seems to override above
			# Setting either one controls both groups it seems. Set both at the same time to be safe.
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1'	=>	"Sleep Time; Outlet Group 1",	# Called 'Main Outlet Group' on SMT1500
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2'	=>	"Sleep Time; Outlet Group 2",	# Called 'Outlet Group 1' on SMT1500
			
			
			
#UPS Basic State:	.1.3.6.1.4.1.318.1.1.1.4.1.1.0		1'	=>	"Unknown, 2'	=>	"Online, 3'	=>	"On Battery, 4'	=>	"onSmartBoost, 5'	=>	"timedSleeping, 6'	=>	"softwareBypass, 7'	=>	"off, 8'	=>	"rebooting, 9'	=>	"switchedBypass, 10'	=>	"hardwareFailureBypass, 11'	=>	"sleepingUntilPowerReturn, 12'	=>	"onSmartTrim, 13'	=>	"ecoMode, 14'	=>	"hotStandby, 15'	=>	"onBatteryTest, 15'	=>	"emergencyStaticBypass, 17'	=>	"staticBypassStandby, 18'	=>	"powerSavingMode, 19'	=>	"spotMode, 20'	=>	"eConversion
#Main UPS outlet state:	.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1	1'	=>	"On, 2'	=>	"Off, 3'	=>	"Unknown
#Outlet group 1 state:	.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2	1'	=>	"On, 2'	=>	"Off, 3'	=>	"Unknown
		},
		reboot_ups	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.2.0",
		},
		ups_time	=>	{
			oid		=>	".1.3.6.1.4.1.318.2.1.6.2.0",
		},
		return_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.9.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"i",
		},
		sleep_time	=>	{
			group1		=>	{	# 'Main Outlet Group' on SMT1500
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				unit		=>	"t",
			},
			group2		=>	{	# 'Outlet Group 1' on SMT1500
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				unit		=>	"t",
			},
		},
		power_off_delay	=>	{
			group1		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.1",
				unit		=>	"i",
			},
			group2		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2",
				unit		=>	"i",
			},
		},
		shut_off_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.10.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"t",
		},
		power_on	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.6.0",
			on_integer	=>	2,
		},
		sleep_ups	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.3.0",
			off_integer	=>	3,
		},
		current_state	=>	{
			group1		=>	{
				oid			=>	".1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Online",
					'2'		=>	"Offline",
					'3'		=>	"Unknown",
				},
			},
			group2		=>	{
				oid			=>	".1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Online",
					'2'		=>	"Offline",
					'3'		=>	"Unknown",
				},
			},
			ups		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.4.1.1.0",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Unknown",
					'2'		=>	"Online",
					'3'		=>	"On Battery",
					'4'		=>	"Smart Boost",
					'5'		=>	"Timed Sleeping",
					'6'		=>	"Software Bypass",
					'7'		=>	"Off",
					'8'		=>	"Rebooting",
					'9'		=>	"Switched Bypass",
					'10'		=>	"Hardware Failure Bypass",
					'11'		=>	"Sleeping Until Power Returns",
					'12'		=>	"Smart Trim",
					'13'		=>	"EcoMode",
					'14'		=>	"Hot Standby",
					'15'		=>	"Testing Battery",
					'15'		=>	"Emergency Static Bypass",
					'17'		=>	"Static Bypass Standby",
					'18'		=>	"Power-Saving Mode",
					'19'		=>	"Spot Mode",
					'20'		=>	"eConversion",
				},
			},
		},
		community	=>	{
			'read'		=>	"public",
			'write'		=>	"private",
		},
	},
	sys	=>	{
		apc		=>	{
			ups		=>	{
				device			=>	{},
				devices			=>	[],
				power_off_delay		=>	600,
				sleep_time		=>	300,	# How long to sleep once the UPS is off, in seconds
				ticks			=>	10,	# ms
				kick_every_minutes	=>	2,	# Sets the cron job to run this script (kick the UPS) every X minutes
			},
		},
		debug		=>	0,
		log_file	=>	"/var/log/$THIS_FILE.log",
		version		=>	"1.0",
		connections	=>	0,
	},
};

# No switches is OK, we'll try to detect UPSes via /etc/hosts.
get_switches($conf);
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}) || 
    (($conf->{switches}{sleep_time}) && ($conf->{switches}{sleep_time} =~ /\D/)) || 
    (($conf->{switches}{power_off_delay}) && ($conf->{switches}{power_off_delay} =~ /\D/)))
{
	print_usage($conf);
	exit(0);
}

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	logger($conf, $THIS_FILE, __LINE__, "I am sorry, but $THIS_FILE program must be run as the 'root' user.");
	exit(5);
}

# Set the timers if the user defined them
$conf->{sys}{apc}{ups}{sleep_time}      = $conf->{switches}{sleep_time}      if $conf->{switches}{sleep_time};
$conf->{sys}{apc}{ups}{power_off_delay} = $conf->{switches}{power_off_delay} if $conf->{switches}{power_off_delay};

# Enable debugging if requested.
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};

# Read the Striker config.
#read_configuration($conf);

# Figure out what UPS(es) we're using.
get_ups_ips($conf);

# If I've been called with --cancel, send only to 'power-on' call.
if ($conf->{switches}{cancel})
{
	my $exit = 0;
	logger($conf, $THIS_FILE, __LINE__, "Cancelling the UPS power-off sequence.");
	foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
	{
		my ($poweroff_return, $shell_call) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
		if ($poweroff_return ne $conf->{snmp}{power_on}{on_integer})
		{
			logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups]");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The command to abort pending power-off actions returned: [$poweroff_return], expected: [$conf->{snmp}{power_on}{on_integer}].");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   Tried to call: [$shell_call]");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   The UPS may still be running its poweroff-timer!");
			$exit = 4;
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups] power-off cancelled.");
		}
	}
	manage_cron_entry($conf, "remove");
	logger($conf, $THIS_FILE, __LINE__, "- Done.");
	logger($conf, $THIS_FILE, __LINE__, "[ Note ] - Make sure you cancel on the other node, too!");
	exit($exit);
}

# We're ready to start.
logger($conf, $THIS_FILE, __LINE__, "Will now attempt to delay the reboot of the following UPS(es):");
foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
{
	logger($conf, $THIS_FILE, __LINE__, "- UPS: [$ups]");
	
=pod
	# Reboot (.1.3.6.1.4.1.318.1.1.1.6.2.2.0 i 3) seems to be the best option.
	
	my ($model_number)           = read_oid_string($conf, $ups, $conf->{snmp}{model_number}{oid});
	my ($power_off_delay_ups)    = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{ups}{oid});
	my ($power_off_delay_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid});
	my ($power_off_delay_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid});
	my ($shut_off_delay)         = read_oid_ticks($conf, $ups, $conf->{snmp}{shut_off_delay}{oid});
	my ($sleep_time_group1)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid});
	my ($sleep_time_group2)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid});
	my ($sleep_time_ups)         = read_oid_ticks($conf, $ups, $conf->{snmp}{sleep_time}{ups}{oid});
	logger($conf, $THIS_FILE, __LINE__, "Model Number: [$model_number]");
	logger($conf, $THIS_FILE, __LINE__, "-=] Shut down timers");
	logger($conf, $THIS_FILE, __LINE__, "- Power off delay; UPS:    [$power_off_delay_ups] seconds.");
	logger($conf, $THIS_FILE, __LINE__, "- Power off delay; Group1: [$power_off_delay_group1] seconds.");
	logger($conf, $THIS_FILE, __LINE__, "- Power off delay; Group2: [$power_off_delay_group2] seconds.");
	logger($conf, $THIS_FILE, __LINE__, "- Shut off delay:          [".convert_ticks_to_seconds($conf, $shut_off_delay)."] seconds ($shut_off_delay ticks).");
	logger($conf, $THIS_FILE, __LINE__, "- Sleep Time; UPS:         [".convert_ticks_to_seconds($conf, $sleep_time_ups)."] seconds ($sleep_time_ups ticks) (automatically rounds to 6-minute increments).");
	logger($conf, $THIS_FILE, __LINE__, "- Sleep Time; Group 1:     [$sleep_time_group1] seconds.");
	logger($conf, $THIS_FILE, __LINE__, "- Sleep Time; Group 2:     [$sleep_time_group2] seconds.");
	
	my ($return_delay)      = read_oid_ticks($conf, $ups, $conf->{snmp}{return_delay}{oid});
	logger($conf, $THIS_FILE, __LINE__, "-=] Restart timers");
	logger($conf, $THIS_FILE, __LINE__, "- Return delay:            [".convert_ticks_to_seconds($conf, $return_delay)."] seconds ($return_delay ticks).");
	
	
	# Set the shutdown delay to 60 seconds and both outlet groups to startup in 30 seconds.
# 	my ($new_power_off_delay)    = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{oid}, 60);
# 	my ($new_sleep_time_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid}, 30);
# 	my ($new_sleep_time_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid}, 30);
# 	logger($conf, $THIS_FILE, __LINE__, "- New Power off delay: [$new_power_off_delay] seconds.") if $conf->{sys}{debug};
# 	logger($conf, $THIS_FILE, __LINE__, "- New Sleep Time; Group 1: [$new_sleep_time_group1] seconds.") if $conf->{sys}{debug};
# 	logger($conf, $THIS_FILE, __LINE__, "- New Sleep Time; Group 2: [$new_sleep_time_group2] seconds.") if $conf->{sys}{debug};
	
# 	
# 	# Tel the UPS to shut off.
# 	logger($conf, $THIS_FILE, __LINE__, "- Initiating timed power off!");
# 	my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off}{oid}, $conf->{snmp}{power_off}{off_integer});
	
	# Watch the state.
	while (1)
	{
		my ($current_state)        = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{oid});
		my ($group1_current_state) = read_oid_integer($conf, $ups, $conf->{snmp}{group1_current_state}{oid});
		my ($group2_current_state) = read_oid_integer($conf, $ups, $conf->{snmp}{group2_current_state}{oid});
		my ($ups_time)             = read_oid_string($conf, $ups, $conf->{snmp}{ups_time}{oid});

		logger($conf, $THIS_FILE, __LINE__, "- Time: [$ups_time], UPS State: [$conf->{snmp}{current_state}{values}{$current_state}], Group 1 current state: [$conf->{snmp}{group1_current_state}{values}{$group1_current_state}], Group 2 current state: [$conf->{snmp}{group2_current_state}{values}{$group2_current_state}]");
		sleep 1;
	}
	
=cut
	
	# Report/record the current values
	if (get_current_settings($conf, $ups, "old"))
	{
		$conf->{sys}{connections}++;
		my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
		my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
		my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
		my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
		my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
		my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
		my $power_off_delay_group1 = $conf->{snmp}{power_off_delay}{group1}{value}{old};
		my $power_off_delay_group2 = $conf->{snmp}{power_off_delay}{group2}{value}{old};
		my $sleep_time_group1      = $conf->{snmp}{sleep_time}{group1}{value}{old};
		my $sleep_time_group2      = $conf->{snmp}{sleep_time}{group2}{value}{old};
		logger($conf, $THIS_FILE, __LINE__, "  - General UPS state: ...... [$say_state_ups ($current_state_ups)]");
		logger($conf, $THIS_FILE, __LINE__, "  - Output state; Group 1: .. [$say_state_group1 ($current_state_group1)]");
		logger($conf, $THIS_FILE, __LINE__, "  - Output state; Group 2: .. [$say_state_group2 ($current_state_group2)]");
		logger($conf, $THIS_FILE, __LINE__, "  - Power off delay; Group 1: [$power_off_delay_group1 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "  - Power off delay; Group 2: [$power_off_delay_group2 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "  - Sleep time; Group 1: .... [$sleep_time_group1 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "  - Sleep time; Group 2: .... [$sleep_time_group2 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "- Setting power off delay to: [$conf->{sys}{apc}{ups}{power_off_delay} seconds]");
		logger($conf, $THIS_FILE, __LINE__, "- Setting sleep time to: .... [$conf->{sys}{apc}{ups}{sleep_time} seconds]");
		#die "$THIS_FILE ".__LINE__."; testing...\n";
		
		# Make sure the UPS is healty enough
		if ($current_state_ups eq "1")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is in an unknown state! Proceeding would be dangerous, skipping this UPS.");
		}
		elsif ($current_state_ups eq "5")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off in a timed sleep. There is no reason to proceed, skipping this UPS.");
		}
		elsif ($current_state_ups eq "7")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off. There is no reason to proceed, skipping this UPS.");
		}
		elsif ($current_state_ups eq "8")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is rebooting, skipping this UPS.");
		}
		else
		{
			# We're good.
			$conf->{sys}{debug} = 1;
			logger($conf, $THIS_FILE, __LINE__, "\nBeginning.");

			# Cancel a pending shut-off
			logger($conf, $THIS_FILE, __LINE__, "- Cancelling any pending power off.");
			my ($poweroff_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - poweroff_return: [$poweroff_return]") if $conf->{sys}{debug};
			
			# Set the sleep time for the outlet groups.
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the outlet groups' sleep time to: [$conf->{sys}{apc}{ups}{sleep_time} seconds].");
			my ($set_sleep_time_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
			my ($set_sleep_time_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_sleep_time_group1: [$set_sleep_time_group1], set_sleep_time_group2: [$set_sleep_time_group2]") if $conf->{sys}{debug};
			
			# Set the power-off delay
			logger($conf, $THIS_FILE, __LINE__, "  - Setting the power-off delay to: ......... [$conf->{sys}{apc}{ups}{power_off_delay} seconds].");
			my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{ups}{power_off_delay});
			my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{ups}{power_off_delay});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]") if $conf->{sys}{debug};
			
			# Do the needful
			logger($conf, $THIS_FILE, __LINE__, "  - Initiating timed sleep.");
			my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_ups}{oid}, $conf->{snmp}{sleep_ups}{off_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]") if $conf->{sys}{debug};
			$conf->{sys}{debug} = 0;
		}
	}
}

# Add the program to root's crontab, if needed.
manage_cron_entry($conf, "add");
logger($conf, $THIS_FILE, __LINE__, "Run complete.");

# Only set this to '1' for debugging.
if ($conf->{sys}{connections})
{
	logger($conf, $THIS_FILE, __LINE__, "Monitoring, press <ctrl> + <c> to end.");
	while (1)
	{
		foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
		{
			get_current_settings($conf, $ups, "old");
			my $say_date               = get_date($conf);
			my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
			my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
			my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
			my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
			my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
			my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
			my $power_off_delay_group1 = $conf->{snmp}{power_off_delay}{group1}{value}{old};
			my $power_off_delay_group2 = $conf->{snmp}{power_off_delay}{group2}{value}{old};
			my $sleep_time_group1      = $conf->{snmp}{sleep_time}{group1}{value}{old};
			my $sleep_time_group2      = $conf->{snmp}{sleep_time}{group2}{value}{old};
			logger($conf, $THIS_FILE, __LINE__, "[ $say_date ] - UPS: [$ups], states; general: [$say_state_ups ($current_state_ups)], group 1: [$say_state_group1 ($current_state_group1)], group 2: [$say_state_group2 ($current_state_group2)]");
		}
		sleep 5;
	}
}
logger($conf, $THIS_FILE, __LINE__, "Exiting.");

exit(0);



# This returns the current date and time in 'YYYY/MM/DD HH:MM:SS' format. It
# always uses 24-hour time and it zero-pads single digits.
sub get_date
{
	my ($conf) = @_;
	my $date = "";
	
	# This doesn't support offsets or other advanced features.
	my %time;
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	$date = "$time{year}/$time{pad_mon}/$time{pad_mday} $time{pad_hour}:$time{pad_min}:$time{pad_sec}";
	
	return($date);
}

# This reads in the root user's cron table file and if the program isn't there,
# adds it or removes it, depending on the $task ("add" or "remove").
sub manage_cron_entry
{
	my ($conf, $task) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - manage_cron_entry(); task: [$task]") if $conf->{sys}{debug};
	
	# Disabled for now.
	return(0);
	
	my $changed  = 0;
	my $raw_cron = "";
	
	# Make sure the cron file exists.
	my $shell_call = "
if [ ! -e '$conf->{path}{cron_root}' ]
then
	touch $conf->{path}{cron_root}
	chown root:root $conf->{path}{cron_root}
	chmod 600 $conf->{path}{cron_root}
fi";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
	}
	close $file_handle;
	
	# Now read the file (even if it's blank).
	$shell_call = "$conf->{path}{cron_root}";
	open ($file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /$THIS_FILE/)
		{
			# Skip it as we'll add it back later.
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Found existing root cron table entry: [$line]. Removing it.") if $conf->{sys}{debug};
			$changed = 1;
		}
		else
		{
			$raw_cron .= "$line\n";
		}
	}
	close $file_handle;
	
	# If the line wasn't found, add it.
	if ($task eq "add")
	{
		# $0 contains the actual path and program name in use at runtime
		my $call = $0;
		if ($call =~ /^\.\//)
		{
			# Prepend the PWD environment variable.
			my $pwd = $ENV{PWD};
			$call =~ s/^\.\//$pwd\//;
		}
		if ($conf->{switches}{ups})
		{
			$call .= " --ups $conf->{switches}{ups}";
		}
		if ($conf->{switches}{sleep_time})
		{
			$call .= " --sleep_time $conf->{switches}{sleep_time}";
		}
		if ($conf->{switches}{power_off_delay})
		{
			$call .= " --power_off_delay $conf->{switches}{power_off_delay}";
		}
		$raw_cron .= "*/$conf->{sys}{apc}{ups}{kick_every_minutes} * * * * $call\n";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Added entry: [$call].") if $conf->{sys}{debug};
		$changed = 1;
	}
	
	# Write out the updated crontab.
	if ($changed)
	{
		# Tell the user.
		if ($task eq "add")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Adding $THIS_FILE to run every five minutes in the 'root' user's cron table.");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- Removing $THIS_FILE from root's cron table.");
		}
		my $shell_call = "$conf->{path}{cron_root}";
		open (my $file_handle, ">$shell_call") or die "Failed to write: [$shell_call], error was: $!\n";
		print $file_handle $raw_cron;
		close $file_handle;
	}
	
	return(0);
}

# This sets an OID with to an integer value.
sub set_oid_integer
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_integer(); ups: [$ups], oid: [$oid], value: [$value]") if $conf->{sys}{debug};
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid i $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value]") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value, $shell_call);
}

# This sets an OID with to a time tick (-t, 10ms) value.
sub set_oid_ticks
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_ticks(); ups: [$ups], oid: [$oid], value: [$value]") if $conf->{sys}{debug};
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid t $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			   $value     = $1;
			my $say_value = ($value / 100);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value] ($say_value seconds)") if $conf->{sys}{debug};
		}
		if ($line =~ /Failed object/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], not set! Does this OID exist on your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value, $shell_call);
}

# This calls the UPS and tries to get the current settings.
sub get_current_settings
{
	my ($conf, $ups, $type) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_current_settings(); ups: [$ups], type: [$type]") if $conf->{sys}{debug};
	
	# First, main UPS outlet group. This is our first call, so verify we
	# got a returned value.
	my ($current_state_ups) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{ups}{oid});
	if ($current_state_ups eq "#!no_connection!#")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
		return(0);
	}
	# Still alive? Good!
	my ($current_state_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{group1}{oid});
	my ($current_state_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{group2}{oid});
	
	# Get the power off delays and sleep times
	my ($power_off_delay_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid});
	my ($power_off_delay_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid});
	my ($sleep_time_group1)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid});
	my ($sleep_time_group2)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid});
	
	# Record the values in the hash
	$conf->{snmp}{current_state}{ups}{value}{$type}      = $current_state_ups;
	$conf->{snmp}{current_state}{group1}{value}{$type}   = $current_state_group1;
	$conf->{snmp}{current_state}{group2}{value}{$type}   = $current_state_group2;
	$conf->{snmp}{power_off_delay}{group1}{value}{$type} = $power_off_delay_group1;
	$conf->{snmp}{power_off_delay}{group2}{value}{$type} = $power_off_delay_group2;
	$conf->{snmp}{sleep_time}{group1}{value}{$type}      = $sleep_time_group1;
	$conf->{snmp}{sleep_time}{group2}{value}{$type}      = $sleep_time_group2;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - snmp::current_state::ups::value::$type: [$conf->{snmp}{current_state}{ups}{value}{$type}], snmp::current_state::group1::value::$type: [$conf->{snmp}{current_state}{group1}{value}{$type}], snmp::current_state::group2::value::$type: [$conf->{snmp}{current_state}{group2}{value}{$type}], snmp::power_off_delay::group1::value::$type: [$conf->{snmp}{power_off_delay}{group1}{value}{$type}], snmp::power_off_delay::group2::value::$type: [$conf->{snmp}{power_off_delay}{group2}{value}{$type}], snmp::sleep_time::group1::value::$type: [$conf->{snmp}{sleep_time}{group1}{value}{$type}], snmp::sleep_time::group2::value::$type: [$conf->{snmp}{sleep_time}{group2}{value}{$type}]") if $conf->{sys}{debug};

	return(1);
}

# Convert ticks to seconds.
sub convert_ticks_to_seconds
{
	my ($conf, $ticks) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "convert_ticks_to_seconds(); ticks: [$ticks]") if $conf->{sys}{debug};
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $seconds          = ($ticks / $ticks_per_second);
	
	#logger($conf, $THIS_FILE, __LINE__, "seconds: [$seconds]") if $conf->{sys}{debug};
	return($seconds);
}

# Convert seconds to ticks.
sub convert_seconds_to_ticks
{
	my ($conf, $seconds) = @_;
	logger($conf, $THIS_FILE, __LINE__, "convert_seconds_to_ticks(); seconds: [$seconds]") if $conf->{sys}{debug};
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $ticks            = ($seconds * $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "ticks: [$ticks]") if $conf->{sys}{debug};
	return($ticks);
}

# This reads an OID with an ticks value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# ticks is read, "#!no_value!#" is returned.
sub read_oid_ticks
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_ticks(); ups: [$ups], oid: [$oid]") if $conf->{sys}{debug};
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value);
}

# This reads an OID with an integer value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_integer
{
	my ($conf, $ups, $oid) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_integer(); ups: [$ups], oid: [$oid]") if $conf->{sys}{debug};
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		
		if ($line =~ /No Response/i)
		{
			#logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value);
}

# This reads an OID with a string value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_string
{
	my ($conf, $ups, $oid) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_string(); ups: [$ups], oid: [$oid]") if $conf->{sys}{debug};
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		
		if ($line =~ /No Response/i)
		{
			#logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /STRING: "(.*)"$/i)
		{
			$value = $1;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			#logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?") if $conf->{sys}{debug};
		}
	}
	close $file_handle;
	
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]") if $conf->{sys}{debug};
	return($value);
}

# This determines what UPSes to talk to, by IP address.
sub get_ups_ips
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_ups_ips()") if $conf->{sys}{debug};
	
	# Did the user specify the UPSes?
	$conf->{switches}{ups} = "" if not defined $conf->{switches}{ups};
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - switches::ups: [$conf->{switches}{ups}]") if $conf->{sys}{debug};
	if ($conf->{switches}{ups})
	{
		# Yup!
		foreach my $ups (split/,/, $conf->{switches}{ups})
		{
			next if not $ups;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ups: [$ups]") if $conf->{sys}{debug};
			if (is_string_ipv4($conf, $ups))
			{
				# It's already an IP.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP address given, recording.") if $conf->{sys}{debug};
				push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
			}
			else
			{
				# Try to resolve it.
				my ($ip) = get_host_ip($conf, $ups);
				if ($ip)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups] has IP: [$ip], recording.") if $conf->{sys}{debug};
					push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The UPS: [$ups] could not be translated to an IP address.");
					exit(1);
				}
			}
		}
	}
	else
	{
		# Nope. Parse /etc/hosts.
		parse_hosts($conf);
	}
	
	# Now if I have some UPSes, we're ok to proceed.
	if (@{$conf->{sys}{apc}{ups}{devices}} < 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - No UPSes were found, unable to proceed.");
		exit(2);
	}
	
	return(0);
}

# This looks through /etc/hosts and pushes the IPs for each entry with 'ups'
# in the name that it finds.
sub parse_hosts
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parse_hosts()") if $conf->{sys}{debug};
	
	my $shell_call = "$conf->{path}{hosts}";
	open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		$line =~ s/#.*//;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]") if $conf->{sys}{debug};
		if ($line =~ /ups/)
		{
			# Oh looky looky!
			my ($ip, $names) = ($line =~ /^(\d+\.\d+\.\d+\.\d+) (.*)/);
			next if ((not $ip) || (not $names));
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], names: [$names]") if $conf->{sys}{debug};
			foreach my $name (split/ /, $names)
			{
				next if not $name;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], name: [$name]") if $conf->{sys}{debug};
				$conf->{hosts}{by_name}{$name} = $ip;
				push @{$conf->{hosts}{by_ip}{$ip}}, $name;
			}
		}
	}
	close $file_handle;
	
	# Now record the IPs in the central hash.
	foreach my $ip (sort {$a cmp $b} keys %{$conf->{hosts}{by_ip}})
	{
		if (@{$conf->{hosts}{by_ip}{$ip}} == 1)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with name: [$conf->{hosts}{by_ip}{$ip}->[0]].") if $conf->{sys}{debug};
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with names:") if $conf->{sys}{debug};
			foreach my $name (sort {$a cmp $b} @{$conf->{hosts}{by_ip}{$ip}})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - name: [$name]") if $conf->{sys}{debug};
			}
		}
		push @{$conf->{sys}{apc}{ups}{devices}}, $ip;
	}
	
	return(0);
}

# This tries to resolve a name to an IP address. Returns '0' if lookup failed.
sub get_host_ip
{
	my ($conf, $host) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_host_ip(); host: [$host]") if $conf->{sys}{debug};
	
	my $ip = 0;
	
	my $shell_call = "$conf->{path}{gethostip} -d $host";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]") if $conf->{sys}{debug};
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		$ip = $_;
		# This should only ever print the IP address. Anything else
		# will be treated as a failure.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$ip]") if $conf->{sys}{debug};
	}
	close $file_handle;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]") if $conf->{sys}{debug};
	
	# Make sure the IP is sane.
	if (not is_string_ipv4($conf, $ip))
	{
		# It's already an IP.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Returned IP address is not valid.") if $conf->{sys}{debug};
		$ip = 0;
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]") if $conf->{sys}{debug};
	return($ip);
}

# Checks if the passed-in string is an IPv4 address (with or without a subnet
# mask). Returns '1' if OK, 0 if not.
sub is_string_ipv4
{
	my ($conf, $ip) = @_;
	my $valid  = 1;
	
	if ($ip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/)
	{
		# It's in the right format.
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		
		if (($first_octal  < 0) || ($first_octal  > 255) ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal  < 0) || ($third_octal  > 255) ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			# One of the octals is out of range.
			$valid = 0;
		}
	}
	else
	{
		# Not in the right format.
		$valid = 0;
	}
	
	return($valid);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}}) { print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	if (not -e $conf->{path}{striker_conf})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Striker configuration file not found.") if $conf->{sys}{debug};
	}
	else
	{
		my $shell_call = "$conf->{path}{striker_conf}";
		open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			next if $line !~ /=/;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			next if $line =~ /^#/;
			next if not $line;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			next if (not $var);
			_make_hash_reference($conf, $var, $val);
		}
		close $file_handle;
	}
	
	return(0);
}
# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Use APC-brand UPSes as an external watchdog timer

DESCRIPTION

This program uses one or more APC-brand UPSes as a form of Anvil!-wide watchdog
timer. In essence, this program will run every five minutes, and on each run,
it will tell the UPSes to turn off in 15 minutes, stary off for 5 minutes, and
then power back on. In this way, if something catastrophic happens, the system
will reboot all devices. With luck, that will return the system to an operating
state autonomously.

So long as at least one node is operating, it will 


Note:

For this to work properly, you need to setup your dashboards to automatically
boot when the power is applied to them. Exactly how you do this will depend on
your hardware, but usually it is configured under power settings in the system
BIOS.

Further; The dashboards must be running the Scanner 'nodemonitor' scan agent.
This way, when the nodes boot, they will check the UPS and environmental
temperatures and if/when good, boot the nodes.

Further; The nodes must be configured to run the 'safe_anvil_start' tool. This
way, when the nodes boot, they will autonomously form the cluster and boot the
servers.


SWITCHES

 --cancel

	This will cancel any previous power-off timer. This should be used
	either when you want a controlled cold-stop of the Anvil!, or when
	you plan to do maintenance that would interrupt the connection to the
	UPS(es).
	
	NOTE: Remember to cancel on the other node(s) and to remove or disable
	      this program in your cron table! Failure to do so could cause
	      the power-off timer to restart!

 --debug

	This enables debug mode, generating a lot more output than usual.

 --disable

	This disables the 'auto-off after X seconds' function. This should be
	used on both nodes before power the entire system down for a cold-stop.

 -h, -?, --help

	Show this dialoge and exit.

 --power_off_delay <seconds>

	This controls how far in the future to tell the UPSes to power off.
	
	The default is '600' (10 minutes). This can be changed by setting:
	
	sys::apc::ups::power_off_delay = <seconds>

 --sleep_time <seconds>

	This controls how long the UPSes should stay off for. After this number
	of seconds, the UPSes will automatically restore power to their
	outlets.
	
	The default is '300' (five minutes). This can be changed by setting:
	
	sys::apc::ups::sleep_time = <seconds>

 --ups <ups1>[,<ups2>,...,<upsN>]

	Define the specific UPS(es) to work on. If host names are used, they
	must be convertable to IP addresses. Two or more UPSes can be defined
	using commas and *no* spaces to separate them.


NOTES

When run, this program will add itself to the root user's crontab
automatically. It will be configured to run every five minutes until cancelled.
The switches passwd when calling the program will be used in the crontab entry.

When called with '--cancel', it will remove the cron table entry automatically,
preventing it from restarting the countdown. 


EXAMPLE

Run with all default values, using all UPSes found in /etc/hosts with 'ups' in
their name.

 ./$THIS_FILE

Run with two specifically defined UPSes set to cut power in ten minutes 
and then power up after one minute.

 ./$THIS_FILE --ups an-ups01,an-ups02 --sleep_time 600 --power_off_delay 60

Stop the timer entirely on all UPSes found in /etc/hosts

 ./$THIS_FILE --disable

                  
SUPPORT

https://alteeve.ca/w/Support

                                                              Alteeve's Niche!
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message) = @_;
	
	# Print the message to the screen.
	print "$file $line_number: $message\n";
	
	# We split on new-lines so that multi-line message render better in
	# syslog.
	my $is_debug = $message =~ /\[ Debug \]/ ? 1 : 0;
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		if (($is_debug) && ($line !~ /\[ Debug \]/))
		{
			$line = "[ Debug ]   $line";
		}
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "$conf->{path}{logger}", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $file $line_number: $message]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

# Catch SIG, move zig!
sub _catch_sig
{
	my $signame = shift;
	
	logger($conf, $THIS_FILE, __LINE__, "Process with PID $$ Exiting on SIG${signame}.");
	exit(3);
}
