#!/usr/bin/perl
# 
# This program is used to turn APC-brand UPSes with the AP9630 or AP9631 UPSes
# into watchdog timers.
# 
# The idea is that the UPS will be configured to start X minutes after turning
# off, and then schedule a shutdown Y minutes in the future. This way, if
# something causes the system to lock up (ie: bad switch config), all systems
# connected to power cycle. This way, a physically inaccessible site can
# potentially recover from unforseen problems.
# 
# For this to work, all components of the HA environment must be powered by the
# UPSes.
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# Madison Kelly - mkelly@alteeve.ca
# https://alteeve.ca
# 
# Exit codes:
# 0  = Normal exit
# 1  = Failed to translate a given host name to an IP address.
# 2  = Failed to find any UPSes.
# 3  = Exited on SIGnal.
# 4  = One or more UPSes didn't cancel their shutdown timer.
# 5  = The program was not run as root.
# 6  = Disable was called and the cancel succeeded, but failed to update striker.conf
# 7  = Failed to enable in striker.conf.
# 

# Play safe!
use strict;
use warnings;

# IO::Handle is used for logging and communicating with the Raritan device via the snmp command line tools. 
# Net::SNMP is not used to do availability issues with EL6.
use IO::Handle;

# Catch signals for clean exits.
$SIG{INT}  = \&_catch_sig;
$SIG{TERM} = \&_catch_sig;

# Some variables.
my $THIS_FILE         = ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# These are the default values and will be over-written by the config file's variables which in turn can, in
# some cases, be over-written by command line arguments.
my $conf = {
	hosts		=>	{
		by_name		=>	{},
		by_ip		=>	{},
	},
	path		=>	{
		gethostip	=>	"/usr/bin/gethostip",
		'grep'		=>	"/bin/grep",
		hosts		=>	"/etc/hosts",
		logger		=>	"/bin/logger",
		sed		=>	"/bin/sed",
		snmpget		=>	"/usr/bin/snmpget",
		snmpset		=>	"/usr/bin/snmpset",
		striker_config	=>	"/etc/striker/striker.conf",
	},
	snmp		=>	{
		model_number	=>	{
			oid		=>	'.1.3.6.1.4.1.318.1.1.1.1.2.5.0',
			value		=>	"",
		},
		oid_name	=>	{
			# Seems to be ignored entirely
			'.1.3.6.1.4.1.318.1.1.1.5.2.9.0'	=>	"Return Delay",
			'.1.3.6.1.4.1.318.1.1.1.5.2.10.0'	=>	"Shut-Off Delay",		# Power off delay in ticks
			'.1.3.6.1.4.1.318.1.1.1.5.2.29.0'	=>	"Minimum Mains Return Time",	# how long to wait after the AC mains return before restoring power
			
			# Appear to be useful
			'.1.3.6.1.4.1.318.2.1.6.2.0'		=>	"UPS Time",			# 
			'.1.3.6.1.4.1.318.1.1.1.1.2.5.0'	=>	"Model Number",
			
			#---
			'.1.3.6.1.4.1.318.1.1.1.5.2.11.0'	=>	"Sleep time",			# Time in ticks to sleep after turning off. Once timer expires, UPS boots. The UPS only recognizes 1/10 of an hour increments. The provided value will be rounded to the closest 1/10 of an hour with one exception: Any value entered between 1 and 540 seconds will be rounded to 360 seconds (or 6 minutes).
			'.1.3.6.1.4.1.318.1.1.1.6.2.1.0'	=>	"Turn Off UPS",			# 2 => turnUpsOff (no delay), 3 => turnUpsOffGracefully (use delay), always returns '1'
			'.1.3.6.1.4.1.318.1.1.1.6.2.2.0'	=>	"Reboot UPS",			# 2 == Reboot now, 3 == Reboot gracefully
			
			# Use these
			'.1.3.6.1.4.1.318.1.1.1.6.2.6.0'	=>	"Power-On / Cancel Sleep",
			'.1.3.6.1.4.1.318.1.1.1.6.2.3.0'	=>	"Put UPS to Sleep",		# Gracefully go to sleep (after a delay period) then return after a sleep period.
			'.1.3.6.1.4.1.318.1.1.1.4.1.1.0'	=>	"UPS Basic State",
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1'	=>	"Outlet Group 1 State",
			'.1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2'	=>	"Outlet Group 2 State",
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.1'	=>	"Group 1 Power Off Delay",	# Seems to override above
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2'	=>	"Group 2 Power Off Delay",	# Seems to override above
			# Setting either one controls both groups it seems. Set both at the same time to be safe.
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1'	=>	"Sleep Time; Outlet Group 1",	# Called 'Main Outlet Group' on SMT1500
			'.1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2'	=>	"Sleep Time; Outlet Group 2",	# Called 'Outlet Group 1' on SMT1500
		},
		reboot_ups	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.2.0",
		},
		ups_time	=>	{
			oid		=>	".1.3.6.1.4.1.318.2.1.6.2.0",
		},
		return_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.9.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"i",
		},
		sleep_time	=>	{
			group1		=>	{	# 'Main Outlet Group' on SMT1500
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				unit		=>	"t",
			},
			group2		=>	{	# 'Outlet Group 1' on SMT1500
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.5.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				unit		=>	"t",
			},
		},
		power_off_delay	=>	{
			group1		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.1",
				unit		=>	"i",
			},
			group2		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.12.2.2.1.4.2",
				unit		=>	"i",
			},
		},
		shut_off_delay	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.5.2.10.0",
			value		=>	{
				old		=>	"",
				new		=>	"",
			},
			unit		=>	"t",
		},
		power_on	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.6.0",
			on_integer	=>	2,
		},
		power_off	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.1.0",
			off_integer	=>	{
				immediate	=>	2,
				delay		=>	3,
			},
		},
		sleep_ups	=>	{
			oid		=>	".1.3.6.1.4.1.318.1.1.1.6.2.3.0",
			off_integer	=>	3,
		},
		current_state	=>	{
			group1		=>	{
				oid			=>	".1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.1",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Online",
					'2'		=>	"Offline",
					'3'		=>	"Unknown",
				},
			},
			group2		=>	{
				oid			=>	".1.3.6.1.4.1.318.1.1.1.12.1.2.1.3.2",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Online",
					'2'		=>	"Offline",
					'3'		=>	"Unknown",
				},
			},
			ups		=>	{
				oid		=>	".1.3.6.1.4.1.318.1.1.1.4.1.1.0",
				value		=>	{
					old		=>	"",
					new		=>	"",
				},
				'values'	=>	{
					'1' 		=>	"Unknown",
					'2'		=>	"Online",
					'3'		=>	"On Battery",
					'4'		=>	"Smart Boost",
					'5'		=>	"Timed Sleeping",
					'6'		=>	"Software Bypass",
					'7'		=>	"Off",
					'8'		=>	"Rebooting",
					'9'		=>	"Switched Bypass",
					'10'		=>	"Hardware Failure Bypass",
					'11'		=>	"Sleeping Until Power Returns",
					'12'		=>	"Smart Trim",
					'13'		=>	"EcoMode",
					'14'		=>	"Hot Standby",
					'15'		=>	"Testing Battery",
					'15'		=>	"Emergency Static Bypass",
					'17'		=>	"Static Bypass Standby",
					'18'		=>	"Power-Saving Mode",
					'19'		=>	"Spot Mode",
					'20'		=>	"eConversion",
				},
			},
		},
		community	=>	{
			'read'		=>	"public",
			'write'		=>	"private",
		},
	},
	switches	=>	{
		cancel		=>	"",
		debug		=>	"",
		disable		=>	"",
		force		=>	"",
		'h'		=>	"",
		help		=>	"",
		power_off_delay	=>	"", # <seconds>
		reboot		=>	"",
		'shutdown'	=>	"",
		sleep_time	=>	"", # <seconds>
		ups		=>	"", # <ups1>[,<ups2>,...,<upsN>]
	},
	sys		=>	{
		apc		=>	{
			ups		=>	{
				device			=>	{},
				devices			=>	[],
				power_off_delay		=>	600,
				sleep_time		=>	300,	# How long to sleep once the UPS is off, in seconds
				ticks			=>	10,	# ms
				kick_every_minutes	=>	2,	# Sets the cron job to run this script (kick the UPS) every X minutes
			},
			### NOTE: If you change these, also change in Common.pm!
			reboot		=>	{
				power_off_delay		=>	60,
				sleep_time		=>	60,
			},
			'shutdown'	=>	{
				power_off_delay		=>	60,
			},
		},
		debug		=>	0,
		version		=>	"1.0",
		connections	=>	0,
	},
};

# No switches is OK, we'll try to detect UPSes via /etc/hosts.
get_switches($conf);
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}) || 
    (($conf->{switches}{sleep_time}) && ($conf->{switches}{sleep_time} =~ /\D/)) || 
    (($conf->{switches}{power_off_delay}) && ($conf->{switches}{power_off_delay} =~ /\D/)))
{
	print_usage($conf);
	exit(0);
}

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	logger($conf, $THIS_FILE, __LINE__, "I am sorry, but $THIS_FILE program must be run as the 'root' user.");
	exit(5);
}

# Set the timers if the user defined them
$conf->{sys}{apc}{ups}{sleep_time}      = $conf->{switches}{sleep_time}      if $conf->{switches}{sleep_time};
$conf->{sys}{apc}{ups}{power_off_delay} = $conf->{switches}{power_off_delay} if $conf->{switches}{power_off_delay};

# Enable debugging if requested.
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};

# Read the Striker config.
read_configuration($conf);

# Cancel is always allowed.
if ($conf->{switches}{cancel})
{
	logger($conf, $THIS_FILE, __LINE__, "Cancelling the UPS watchdog timer.");
	get_ups_ips($conf);
	my $ok   = cancel_countdown($conf);
	my $exit = $ok ? 0 : 4;
	exit($exit);
}

# Disabling is also always allowed.
if ($conf->{switches}{disable})
{
	logger($conf, $THIS_FILE, __LINE__, "Cancelling and disabling the UPS watchdog timer.");
	get_ups_ips($conf);
	my $ok   = cancel_countdown($conf);
	my $exit = 0;
	if ($ok)
	{
		my $ok = update_configuration($conf, "disable");
		if (not $ok)
		{
			$exit = 6;
		}
	}
	exit($exit);
}

# If the user enabled the program, update the cron table and exit so that it starts in the background.
if ($conf->{switches}{enable})
{
	logger($conf, $THIS_FILE, __LINE__, "Enabling the UPS watchdog timer.");
	my $exit = 0;
	my $ok   = update_configuration($conf, "enable");
	if (not $ok)
	{
		$exit = 7;
	}
	exit($exit);
}

# Enable the program if 'force' used.
if ($conf->{switches}{force})
{
	$conf->{tools}{'anvil-kick-apc-ups'}{enabled} = 1;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Anvil! Kick APC UPS has been forced, ignoring 'tools::anvil-kick-apc-ups::enabled'.");
}
elsif (not $conf->{tools}{'anvil-kick-apc-ups'}{enabled})
{
	# We're disabled, exit.
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Anvil! Kick APC UPS has been disabled, exiting.");
	exit(0);
}

# Figure out what UPS(es) we're using.
get_ups_ips($conf);

# We're ready to start.
logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Kicking the following UPSes:");
foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
{
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups]");
	
	# Report/record the current values
	if (get_current_settings($conf, $ups, "old"))
	{
		$conf->{sys}{connections}++;
		my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
		my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
		my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
		my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
		my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
		my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
		my $power_off_delay_group1 = $conf->{snmp}{power_off_delay}{group1}{value}{old};
		my $power_off_delay_group2 = $conf->{snmp}{power_off_delay}{group2}{value}{old};
		my $sleep_time_group1      = $conf->{snmp}{sleep_time}{group1}{value}{old};
		my $sleep_time_group2      = $conf->{snmp}{sleep_time}{group2}{value}{old};
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - General UPS state: ...... [$say_state_ups ($current_state_ups)]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Output state; Group 1: .. [$say_state_group1 ($current_state_group1)]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Output state; Group 2: .. [$say_state_group2 ($current_state_group2)]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Power off delay; Group 1: [$power_off_delay_group1 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Power off delay; Group 2: [$power_off_delay_group2 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Sleep time; Group 1: .... [$sleep_time_group1 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Sleep time; Group 2: .... [$sleep_time_group2 seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Setting power off delay to: [$conf->{sys}{apc}{ups}{power_off_delay} seconds]");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Setting sleep time to: .... [$conf->{sys}{apc}{ups}{sleep_time} seconds]");
		
		# Make sure the UPS is healty enough
		if ($current_state_ups eq "1")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is in an unknown state! Proceeding would be dangerous, skipping this UPS.");
		}
		elsif ($current_state_ups eq "5")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off in a timed sleep. There is no reason to proceed, skipping this UPS.");
		}
		elsif ($current_state_ups eq "7")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is off. There is no reason to proceed, skipping this UPS.");
		}
		elsif ($current_state_ups eq "8")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The UPS is rebooting, skipping this UPS.");
		}
		else
		{
			# We're good.
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Watchdog timer is kicking the UPS: [$conf->{hosts}{by_ip}{$ups}->[0]] ($ups).");
		
			# Cancel a pending shut-off
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Cancelling any pending power off.");
			my ($poweroff_return) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - poweroff_return: [$poweroff_return]");
			
			if ($conf->{switches}{reboot})
			{
				### If the user has asked for a hard reboot, set the power off delay and 
				### sleep time and then exit.
				
				# Set the sleep time for the outlet groups.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the sleep timer to: [$conf->{sys}{apc}{reboot}{sleep_time}] seconds.");
				my ($set_sleep_time_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid}, $conf->{sys}{apc}{reboot}{sleep_time});
				my ($set_sleep_time_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid}, $conf->{sys}{apc}{reboot}{sleep_time});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_sleep_time_group1: [$set_sleep_time_group1], set_sleep_time_group2: [$set_sleep_time_group2]");
				
				# Set the power-off delay
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the shut down timer to: [$conf->{sys}{apc}{reboot}{power_off_delay}] seconds.");
				my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{reboot}{power_off_delay});
				my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{reboot}{power_off_delay});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]");
				
				# Do the needful
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Initiating timed sleep.");
				my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_ups}{oid}, $conf->{snmp}{sleep_ups}{off_integer});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]");
				
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - NOTE: Nodes will be rebooted when power is restored.\n");
			}
			elsif ($conf->{switches}{'shutdown'})
			{
				### If the user has asked for a complete 
				### shutdown, set the disable the sleep timer, 
				### set the power off delay and initiate the 
				### power down.
				
				# Set the power-off delay
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the shut down timer to: [$conf->{sys}{apc}{reboot}{power_off_delay}] seconds.");
				my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{'shutdown'}{power_off_delay});
				my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{'shutdown'}{power_off_delay});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]");
				
				# Do the needful
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Shutting down.");
				my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off}{oid}, $conf->{snmp}{power_off}{off_integer}{delay});
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]");
				
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Done.\n");
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - NOTE: Nodes will be rebooted when power is restored.\n");
			}
			else
			{
				### Normal loop
				# Set the sleep time for the outlet groups.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the outlet groups' sleep time to: [$conf->{sys}{apc}{ups}{sleep_time} seconds].");
				my ($set_sleep_time_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
				my ($set_sleep_time_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid}, $conf->{sys}{apc}{ups}{sleep_time});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_sleep_time_group1: [$set_sleep_time_group1], set_sleep_time_group2: [$set_sleep_time_group2]");
				
				# Set the power-off delay
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Setting the power-off delay to: ......... [$conf->{sys}{apc}{ups}{power_off_delay} seconds].");
				my ($set_power_off_delay_group1) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid}, $conf->{sys}{apc}{ups}{power_off_delay});
				my ($set_power_off_delay_group2) = set_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid}, $conf->{sys}{apc}{ups}{power_off_delay});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_power_off_delay_group1: [$set_power_off_delay_group1], set_power_off_delay_group2: [$set_power_off_delay_group2]");
				
				# Do the needful
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - Initiating timed sleep.");
				my ($power_off) = set_oid_integer($conf, $ups, $conf->{snmp}{sleep_ups}{oid}, $conf->{snmp}{sleep_ups}{off_integer});
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_off: [$power_off]");
			}
		}
	}
}

logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Run complete.");

# Only set this to '1' for debugging.
if ($conf->{sys}{connections})
{
	#logger($conf, $THIS_FILE, __LINE__, "Monitoring, press <ctrl> + <c> to end.");
	while (0)
	{
		foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
		{
			get_current_settings($conf, $ups, "old");
			my $say_date               = get_date($conf);
			my $current_state_ups      = $conf->{snmp}{current_state}{ups}{value}{old};
			my $current_state_group1   = $conf->{snmp}{current_state}{group1}{value}{old};
			my $current_state_group2   = $conf->{snmp}{current_state}{group2}{value}{old};
			my $say_state_ups          = $conf->{snmp}{current_state}{ups}{'values'}{$current_state_ups};
			my $say_state_group1       = $conf->{snmp}{current_state}{group1}{'values'}{$current_state_group1};
			my $say_state_group2       = $conf->{snmp}{current_state}{group2}{'values'}{$current_state_group2};
			my $power_off_delay_group1 = $conf->{snmp}{power_off_delay}{group1}{value}{old};
			my $power_off_delay_group2 = $conf->{snmp}{power_off_delay}{group2}{value}{old};
			my $sleep_time_group1      = $conf->{snmp}{sleep_time}{group1}{value}{old};
			my $sleep_time_group2      = $conf->{snmp}{sleep_time}{group2}{value}{old};
			logger($conf, $THIS_FILE, __LINE__, "[ $say_date ] - UPS: [$ups], states; general: [$say_state_ups ($current_state_ups)], group 1: [$say_state_group1 ($current_state_group1)], group 2: [$say_state_group2 ($current_state_group2)]");
		}
		sleep 5;
	}
}
logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Exiting.");

exit(0);


###############################################################################
# Functions                                                                   #
###############################################################################

# This cancels the pending count-down.
sub cancel_countdown
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cancel_countdown();");
	
	my $ok = 1;
	foreach my $ups (sort {$a cmp $b} @{$conf->{sys}{apc}{ups}{devices}})
	{
		my ($poweroff_return, $shell_call) = set_oid_integer($conf, $ups, $conf->{snmp}{power_on}{oid}, $conf->{snmp}{power_on}{on_integer});
		if ($poweroff_return ne $conf->{snmp}{power_on}{on_integer})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Critical ] - Failed to cancel the shutdown sequence on the UPS: [$ups]!");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The command to abort pending power-off actions returned: [$poweroff_return], expected: [$conf->{snmp}{power_on}{on_integer}].");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   Tried to call: [$shell_call]");
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   The UPS may still be running its poweroff-timer!");
			$ok = 0;
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups] power-off cancelled.");
		}
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Done.");
	logger($conf, $THIS_FILE, __LINE__, "[ Note ] - Anvil! Kick APC UPS watchdog timer cancelled. Cancel on the other node(s) if required!");
	
	return($ok);
}

# This updates striker.conf to enable or disable anvil-kick-apc-ups.
sub update_configuration
{
	my ($conf, $do) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - update_configuration(); do: [$do]");
	
	my $ok = 1;
	my $shell_call  = "$conf->{path}{sed} -i 's/^tools::anvil-kick-apc-ups::enabled\\(\\s*\\)=\\(\\s*\\)1/tools::anvil-kick-apc-ups::enabled\\1=\\20/' $conf->{path}{striker_config}\n";
	if ($do eq "enable")
	{
		$shell_call = "$conf->{path}{sed} -i 's/^tools::anvil-kick-apc-ups::enabled\\(\\s*\\)=\\(\\s*\\)0/tools::anvil-kick-apc-ups::enabled\\1=\\21/' $conf->{path}{striker_config}\n";
	}
	$shell_call .= "
if \$($conf->{path}{'grep'} -q '^tools::anvil-kick-apc-ups::enabled\\s*=\\s*1' $conf->{path}{striker_config});
then 
    echo enabled; 
else 
    echo disabled;
fi";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /enabled/)
		{
			# Did I want this?
			if ($do eq "enable")
			{
				# Good!
				logger($conf, $THIS_FILE, __LINE__, "Anvil! Kick APC UPS watchdog timer enabled successfully (it will start in a minute).");
			}
			else
			{
				# Woops...
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to disable!");
				$ok = 0;
			}
		}
		elsif ($line =~ /disabled/)
		{
			# Did I want this?
			if ($do eq "disable")
			{
				# Good!
				logger($conf, $THIS_FILE, __LINE__, "Anvil! Kick APC UPS watchdog timer disabled successfully.");
			}
			else
			{
				# Woops...
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to enable!");
				$ok = 0;
			}
		}
	}
	close $file_handle;
	
	return($ok);
}

# This returns the current date and time in 'YYYY/MM/DD HH:MM:SS' format. It
# always uses 24-hour time and it zero-pads single digits.
sub get_date
{
	my ($conf) = @_;
	my $date = "";
	
	# This doesn't support offsets or other advanced features.
	my %time;
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	$date = "$time{year}/$time{pad_mon}/$time{pad_mday} $time{pad_hour}:$time{pad_min}:$time{pad_sec}";
	
	return($date);
}

# This sets an OID with to an integer value.
sub set_oid_integer
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_integer(); ups: [$ups], oid: [$oid], value: [$value]");
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid i $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value]");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value, $shell_call);
}

# This sets an OID with to a time tick (-t, 10ms) value.
sub set_oid_ticks
{
	my ($conf, $ups, $oid, $value) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - set_oid_ticks(); ups: [$ups], oid: [$oid], value: [$value]");
	
	my $shell_call = "$conf->{path}{snmpset} -v 2c -c $conf->{snmp}{community}{'write'} $ups $oid t $value";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			   $value     = $1;
			my $say_value = ($value / 100);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], set to value: [$value] ($say_value seconds)");
		}
		if ($line =~ /Failed object/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], not set! Does this OID exist on your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value, $shell_call);
}

# This calls the UPS and tries to get the current settings.
sub get_current_settings
{
	my ($conf, $ups, $type) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_current_settings(); ups: [$ups], type: [$type]");
	
	# First, main UPS outlet group. This is our first call, so verify we
	# got a returned value.
	my ($current_state_ups) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{ups}{oid});
	if ($current_state_ups eq "#!no_connection!#")
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
		return(0);
	}
	# Still alive? Good!
	my ($current_state_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{group1}{oid});
	my ($current_state_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{current_state}{group2}{oid});
	
	# Get the power off delays and sleep times
	my ($power_off_delay_group1) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group1}{oid});
	my ($power_off_delay_group2) = read_oid_integer($conf, $ups, $conf->{snmp}{power_off_delay}{group2}{oid});
	my ($sleep_time_group1)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group1}{oid});
	my ($sleep_time_group2)      = read_oid_integer($conf, $ups, $conf->{snmp}{sleep_time}{group2}{oid});
	
	# Record the values in the hash
	$conf->{snmp}{current_state}{ups}{value}{$type}      = $current_state_ups;
	$conf->{snmp}{current_state}{group1}{value}{$type}   = $current_state_group1;
	$conf->{snmp}{current_state}{group2}{value}{$type}   = $current_state_group2;
	$conf->{snmp}{power_off_delay}{group1}{value}{$type} = $power_off_delay_group1;
	$conf->{snmp}{power_off_delay}{group2}{value}{$type} = $power_off_delay_group2;
	$conf->{snmp}{sleep_time}{group1}{value}{$type}      = $sleep_time_group1;
	$conf->{snmp}{sleep_time}{group2}{value}{$type}      = $sleep_time_group2;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - snmp::current_state::ups::value::$type: [$conf->{snmp}{current_state}{ups}{value}{$type}], snmp::current_state::group1::value::$type: [$conf->{snmp}{current_state}{group1}{value}{$type}], snmp::current_state::group2::value::$type: [$conf->{snmp}{current_state}{group2}{value}{$type}], snmp::power_off_delay::group1::value::$type: [$conf->{snmp}{power_off_delay}{group1}{value}{$type}], snmp::power_off_delay::group2::value::$type: [$conf->{snmp}{power_off_delay}{group2}{value}{$type}], snmp::sleep_time::group1::value::$type: [$conf->{snmp}{sleep_time}{group1}{value}{$type}], snmp::sleep_time::group2::value::$type: [$conf->{snmp}{sleep_time}{group2}{value}{$type}]");

	return(1);
}

# Convert ticks to seconds.
sub convert_ticks_to_seconds
{
	my ($conf, $ticks) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - convert_ticks_to_seconds(); ticks: [$ticks]");
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $seconds          = ($ticks / $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - seconds: [$seconds]");
	return($seconds);
}

# Convert seconds to ticks.
sub convert_seconds_to_ticks
{
	my ($conf, $seconds) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - convert_seconds_to_ticks(); seconds: [$seconds]");
	
	my $ticks_per_second = (1000 / $conf->{sys}{apc}{ups}{ticks});
	my $ticks            = ($seconds * $ticks_per_second);
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ticks: [$ticks]");
	return($ticks);
}

# This reads an OID with an ticks value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# ticks is read, "#!no_value!#" is returned.
sub read_oid_ticks
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_ticks(); ups: [$ups], oid: [$oid]");
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /Timeticks: \((\d+)\)/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value);
}

# This reads an OID with an integer value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_integer
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_integer(); ups: [$ups], oid: [$oid]");
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /INTEGER: (\d+)$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value);
}

# This reads an OID with a string value and returns the results. If the
# connection to the UPS times out, it will return '#!no_connection!#'. If no
# integer is read, "#!no_value!#" is returned.
sub read_oid_string
{
	my ($conf, $ups, $oid) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_oid_string(); ups: [$ups], oid: [$oid]");
	
	my $value      = "#!no_value!#";
	my $shell_call = "$conf->{path}{snmpget} -v 2c -c $conf->{snmp}{community}{'read'} $ups $oid";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		
		if ($line =~ /No Response/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - SNMP connection to UPS: [$ups] timed out!");
			$value = "#!no_connection!#";
		}
		if ($line =~ /STRING: "(.*)"$/i)
		{
			$value = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
		}
		if ($line =~ /No Such Instance/i)
		{
			$value = "--";
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)] not found! Is this OID supported by your UPS?");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - return; Variable: [$conf->{snmp}{oid_name}{$oid} ($oid)], value: [$value]");
	return($value);
}

# This determines what UPSes to talk to, by IP address.
sub get_ups_ips
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_ups_ips()");
	
	# Did the user specify the UPSes?
	$conf->{switches}{ups} = "" if not defined $conf->{switches}{ups};
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - switches::ups: [$conf->{switches}{ups}]");
	if ($conf->{switches}{ups})
	{
		# Yup!
		foreach my $ups (split/,/, $conf->{switches}{ups})
		{
			next if not $ups;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ups: [$ups]");
			if (is_string_ipv4($conf, $ups))
			{
				# It's already an IP.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP address given, recording.");
				push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
			}
			else
			{
				# Try to resolve it.
				my ($ip) = get_host_ip($conf, $ups);
				if ($ip)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - UPS: [$ups] has IP: [$ip], recording.");
					push @{$conf->{sys}{apc}{ups}{devices}}, $ups;
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The UPS: [$ups] could not be translated to an IP address.");
					exit(1);
				}
			}
		}
	}
	else
	{
		# Nope. Parse /etc/hosts.
		parse_hosts($conf);
	}
	
	# Now if I have some UPSes, we're ok to proceed.
	if (@{$conf->{sys}{apc}{ups}{devices}} < 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - No UPSes were found, unable to proceed.");
		exit(2);
	}
	
	return(0);
}

# This looks through /etc/hosts and pushes the IPs for each entry with 'ups'
# in the name that it finds.
sub parse_hosts
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parse_hosts()");
	
	my $shell_call = "$conf->{path}{hosts}";
	open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		$line =~ s/#.*//;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /ups/)
		{
			# Oh looky looky!
			my ($ip, $names) = ($line =~ /^(\d+\.\d+\.\d+\.\d+) (.*)/);
			next if ((not $ip) || (not $names));
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], names: [$names]");
			foreach my $name (split/ /, $names)
			{
				next if not $name;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip], name: [$name]");
				$conf->{hosts}{by_name}{$name} = $ip;
				push @{$conf->{hosts}{by_ip}{$ip}}, $name;
			}
		}
	}
	close $file_handle;
	
	# Now record the IPs in the central hash.
	foreach my $ip (sort {$a cmp $b} keys %{$conf->{hosts}{by_ip}})
	{
		if (@{$conf->{hosts}{by_ip}{$ip}} == 1)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with name: [$conf->{hosts}{by_ip}{$ip}->[0]].");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - IP: [$ip], recorded with names:");
			foreach my $name (sort {$a cmp $b} @{$conf->{hosts}{by_ip}{$ip}})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ]   - name: [$name]");
			}
		}
		push @{$conf->{sys}{apc}{ups}{devices}}, $ip;
	}
	
	return(0);
}

# This tries to resolve a name to an IP address. Returns '0' if lookup failed.
sub get_host_ip
{
	my ($conf, $host) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_host_ip(); host: [$host]");
	
	my $ip = 0;
	
	my $shell_call = "$conf->{path}{gethostip} -d $host";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		$ip = $_;
		# This should only ever print the IP address. Anything else
		# will be treated as a failure.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$ip]");
	}
	close $file_handle;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]");
	
	# Make sure the IP is sane.
	if (not is_string_ipv4($conf, $ip))
	{
		# It's already an IP.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Returned IP address is not valid.");
		$ip = 0;
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ip: [$ip]");
	return($ip);
}

# Checks if the passed-in string is an IPv4 address (with or without a subnet
# mask). Returns '1' if OK, 0 if not.
sub is_string_ipv4
{
	my ($conf, $ip) = @_;
	my $valid  = 1;
	
	if ($ip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/)
	{
		# It's in the right format.
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		
		if (($first_octal  < 0) || ($first_octal  > 255) ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal  < 0) || ($third_octal  > 255) ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			# One of the octals is out of range.
			$valid = 0;
		}
	}
	else
	{
		# Not in the right format.
		$valid = 0;
	}
	
	return($valid);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	if ($conf->{sys}{debug})
	{
		foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}})
		{
			print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n";
		}
	}
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	if (not -e $conf->{path}{striker_config})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Striker configuration file not found.");
	}
	else
	{
		my $shell_call = "$conf->{path}{striker_config}";
		open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			next if $line !~ /=/;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			next if $line =~ /^#/;
			next if not $line;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			next if (not $var);
			_make_hash_reference($conf, $var, $val);
		}
		close $file_handle;
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Use APC-brand UPSes as an external watchdog timer

DESCRIPTION

This program uses one or more APC-brand UPSes as a form of Anvil!-wide watchdog
timer. In essence, this program will run every five minutes, and on each run,
it will tell the UPSes to turn off in 15 minutes, stary off for 5 minutes, and
then power back on. In this way, if something catastrophic happens, the system
will reboot all devices. With luck, that will return the system to an operating
state autonomously.

So long as at least one node is operating, it will 


Note:

For this to work properly, you need to setup your dashboards to automatically
boot when the power is applied to them. Exactly how you do this will depend on
your hardware, but usually it is configured under power settings in the system
BIOS.

Further; The dashboards must be running the Scanner 'nodemonitor' scan agent.
This way, when the nodes boot, they will check the UPS and environmental
temperatures and if/when good, boot the nodes.

Further; The nodes must be configured to run the 'anvil-kick-apc-ups' tool. This
way, when the nodes boot, they will autonomously form the cluster and boot the
servers.


SWITCHES

 --cancel

	This will cancel any previous power-off timer. This should be used
	either when you want a controlled cold-stop of the Anvil!, or when
	you plan to do maintenance that would interrupt the connection to the
	UPS(es).
	
	NOTE: Remember to cancel on the other node!

 --debug

	This enables debug mode, generating a lot more output than usual.

 --disable

	This disables the 'auto-off after X seconds' function. This should be
	used on both nodes before power the entire system down for a cold-stop.
	This cancels the current kick counter and then exits.

 --enable

	This enables the program. It will start up within two minutes of being
	enabled. It does the same thing as manually editing 
	$conf->{path}{striker_config} and changing setting:
	tools::anvil-kick-apc-ups::enabled = 1

 --force

	This tells the program to run, even if 
	'tools::anvil-kick-apc-ups::enabled = 0' is set. 

 -h, -?, --help

	Show this dialoge and exit.

 --power_off_delay <seconds>

	This controls how far in the future to tell the UPSes to power off.
	
	The default is '600' (10 minutes). This can be changed by setting:
	
	sys::apc::ups::power_off_delay = <seconds>

 --reboot

	This tells all UPSes to power off in $conf->{sys}{apc}{reboot}{power_off_delay} seconds, stay off for $conf->{sys}{apc}{reboot}{sleep_time}
	seconds, and then power back on. The effect of this is that all
	equipment powered by the Anvil!'s UPSes will be hard power cycled.
	
	Use with caution!
	
	The power off delay and sleep timers can be adjusted in striker.conf
	by setting;
	
	sys::apc::reboot::power_off_delay = x
	sys::apc::reboot::sleep_time      = x
	
	Where 'x' is the desired time in seconds.

 --shutdown

	This tells all UPSes to power off in $conf->{sys}{apc}{'shutdown'}{power_off_delay} and stay off. The effect of
	this is that everything powered by the Anvil!'s UPSes will shut down
	entirely and stay off until power is manually restored.
	
	Use with caution!
	
	The power off delay can be adjusted in striker.conf by setting;
	
	sys::apc::shutdown::power_off_delay = x
	
	Where 'x' is the desired time in seconds.

 --sleep_time <seconds>

	This controls how long the UPSes should stay off for. After this number
	of seconds, the UPSes will automatically restore power to their
	outlets.
	
	The default is '300' (five minutes). This can be changed by setting:
	
	sys::apc::ups::sleep_time = <seconds>

 --ups <ups1>[,<ups2>,...,<upsN>]

	Define the specific UPS(es) to work on. If host names are used, they
	must be convertable to IP addresses. Two or more UPSes can be defined
	using commas and *no* spaces to separate them.


NOTES

When run, this program will add itself to the root user's crontab
automatically. It will be configured to run every five minutes until cancelled.
The switches passwd when calling the program will be used in the crontab entry.

When called with '--cancel', it will remove the cron table entry automatically,
preventing it from restarting the countdown. 


EXAMPLE

Run with all default values, using all UPSes found in /etc/hosts with 'ups' in
their name.

 ./$THIS_FILE

Run with two specifically defined UPSes set to cut power in ten minutes 
and then power up after one minute.

 ./$THIS_FILE --ups an-ups01,an-ups02 --sleep_time 600 --power_off_delay 60

Stop the timer entirely on all UPSes found in /etc/hosts

 ./$THIS_FILE --disable

                  
SUPPORT

https://alteeve.ca/w/Support

                                                              Alteeve's Niche!
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message) = @_;
	
	# We split on new-lines so that multi-line message render better in syslog.
	if (($message =~ /\[ Debug \]/i) && (not $conf->{sys}{debug}))
	{
		# User is suppressing debug messages.
		return(0);
	}
	
	# Print the message to the screen.
	print "$file $line_number: $message\n";
	
	# If the message spans lines and if it is a debug message, intent the subsequent lines.
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "$conf->{path}{logger}", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $file $line_number: $message]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

# Catch SIG, move zig!
sub _catch_sig
{
	my $signame = shift;
	
	logger($conf, $THIS_FILE, __LINE__, "Process with PID $$ Exiting on SIG${signame}.");
	exit(3);
}
