#!/usr/bin/perl
#
# This will automatically start the Anvil!'s cluster stack on boot.
# 
# If you don't know what an Anvil! is, see:
# - https://alteeve.ca/w/AN!Cluster_Tutorial_2
#
# Exit Codes:
# 0  - OK
# 1  - Couldn't find peer's host name.
# 2  - Daemon status returned unhandled return code.
# 3  - This node is not healthy, but the peer node is healthy. Exiting to let the peer's 'safe_anvil_start'
#      boot the servers.
# 4  - Both nodes have either failed services, badly mounted cluster filesystems or a combination of the two.
# 5  - Local node is not in a failed state, but it timed out waiting to become healthy.
# 6  - Failed to connect to my peer within the timeout. To proceed would risk a fence loop.
# 7  - Failed to find a daemon's init.d script
# 8  - Failed to create the rc3.d symlink
# 9  - Failed to remove the rc3.d symlink
# 
# Bugs:
# - It would seem that, in some case (which I don't yet have a reproducer for), there is a timing-based 
#   conflict starting cman/rgmanager. When this happens, cman or drbd (via rgmanager failing to start) will 
#   lead to a fence of the effected peer.
# - If /shared's dm device differs on the two nodes, VMs won't start is both nodes will think the other is not
#   healthy.
#
# TODO:
# - Check the health status file and do not initiate start up until the health is "OK" on at least one node. 
#   When deciding which node to power a server on, check if one node is "warning" and do not use it if so.
#

use strict;
use warnings;
use IO::Handle;
use File::Basename;

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;
$| = 1;

my $conf =  {
	cluster		=>	{
		name		=>	"",
	},
	daemons		=>	{
		cman		=>	"/etc/init.d/cman",
		rgmanager	=>	"/etc/init.d/rgmanager",
	},
	drbd		=>	{},
	failoverdomain	=>	{},
	lvs		=>	{},
	nodes		=>	{
		me		=>	{
			clusterfs	=>	{},
			daemon		=>	{},
			healthy		=>	0,	# 0 == not ready, 1 == healthy, 2 == fatal error, won't run Servers.
			hostname	=>	"",
			mounts		=>	{},
			short_name	=>	"",
		},
		peer		=>	{
			clusterfs	=>	{},
			daemon		=>	{},
			healthy		=>	0,
			hostname	=>	"",
			is_up		=>	0,
			mounts		=>	{},
			short_name	=>	"",
		}
	},
	path		=>	{
		clustat			=>	"/usr/sbin/clustat",
		cluster_config		=>	"/etc/cluster/cluster.conf",
		clusvcadm		=>	"/usr/sbin/clusvcadm",
		df			=>	"/bin/df",
		drbdadm			=>	"/sbin/drbdadm",
		echo			=>	"/bin/echo",
		fence_path		=>	"/usr/sbin",
		hostname		=>	"/bin/hostname",
		'kill'			=>	"/bin/kill",
		ln			=>	"/bin/ln",
		ls			=>	"/bin/ls",
		lvs			=>	"/sbin/lvs",
		pgrep			=>	"/usr/bin/pgrep",
		safe_anvil_start	=>	"/sbin/striker/safe_anvil_start",
		safe_anvil_start_link	=>	"/etc/rc3.d/S99_safe_anvil_start",
		sed			=>	"/bin/sed",
		ssh			=>	"/usr/bin/ssh",
		striker_config		=>	"/etc/striker/striker.conf",
	},
	services	=>	{},
	sys		=>	{
		bad_fence	=>	0,
		debug		=>	0,
		enabled		=>	0,
		log_level	=>	1,
		node2_sleep	=>	60,
		peer_booted	=>	0,
	},
	timeouts	=>	{
		wait_for_drbd_sync	=>	300,	# Roughly 5 minutes.
		wait_for_node_health	=>	300,	# Roughly 5 minutes.
		wait_for_peer		=>	600,	# Roughly 10 minutes.
	},
	vms		=>	{},
};

if (not -e $conf->{path}{safe_anvil_start})
{
	$conf->{path}{safe_anvil_start} = $0;
}

# TODO: Exit if another instance is running

read_configuration($conf);

# If called with 'start', enable 'safe_anvil_start' in crontab.
get_switches($conf);
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}))
{
	print_usage($conf);
	exit(0);
}

if ($conf->{switches}{start})
{
	logger($conf, $THIS_FILE, __LINE__, "- Safe Anvil! Start will run the next time cron calls it.");
	my $return_code = update_configuration($conf, "enable");
	exit(0);
}
elsif ($conf->{switches}{abort})
{
	abort_start($conf);
	exit(0);
}
elsif ($conf->{switches}{enable})
{
	# Create the rc3.d symlink
	create_symlink($conf);
	exit(0);
}
elsif ($conf->{switches}{disable})
{
	### TODO: Check the striker.conf and set it to '0' and then kill any running instances.
	# Delete the rc3.d symlink
	remove_symlink($conf);
	exit(0);
}
elsif ($conf->{switches}{force})
{
	logger($conf, $THIS_FILE, __LINE__, "\n-=] Safe Anvil! Start is now running.", 0);
	logger($conf, $THIS_FILE, __LINE__, "Run is forced, ignoring configuration file.", 0);
}
elsif (not $conf->{tools}{safe_anvil_start}{enabled})
{
	#logger($conf, $THIS_FILE, __LINE__, "- Safe Anvil! Start has been disabled, exiting.");
	exit(0);
}

# No matter what, exit if there is another instance running. Print as much if '--force' was used.
avoid_duplicate_run($conf);

logger($conf, $THIS_FILE, __LINE__, "\n-=] Safe Anvil! Start is now running.", 0);

# If I am alive, I am running. This could take a while though, so disable now to block another run from 
# starting in a minute.
my $return_code = update_configuration($conf, "disable");

# Now go to work
read_hostname($conf);
read_cluster_config($conf);

logger($conf, $THIS_FILE, __LINE__, "- Wait up to: [$conf->{timeouts}{wait_for_peer}] seconds to connect to my peer.", 1);
for (0..$conf->{timeouts}{wait_for_peer})
{
	$conf->{nodes}{peer}{is_up} = check_peer_connection($conf);
	if ($conf->{nodes}{peer}{is_up})
	{
		# Peer is up.
		logger($conf, $THIS_FILE, __LINE__, "- Peer is up!", 1);
		last;
	}
	sleep 1;
};

# If the peer wasn't reachable, then the only safe option is to exit.
if (not $conf->{nodes}{peer}{is_up})
{
	logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to peer within timeout.", 0);
	logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Proceeding would risk a fence loop. Exiting.", 0);
	exit(6);
}

# Check the state of the daemons.
check_daemons($conf);

# Now the fun starts!
start_daemon_simultaneously($conf, "cman");
sleep 2;	# This may not be needed, but is here just in case a race
		# condition is possible.
start_daemon_simultaneously($conf, "rgmanager");

# Check the health of each node's daemons, clusterfs mounts and services.
check_node_health($conf);

# Watches DRBD to see if both nodes go UpToDate within a reasonable amount of
# time.
wait_for_drbd_sync($conf);

# If I am still alive, I am healthy. Time to start the servers!
start_servers($conf);

# All done.
logger($conf, $THIS_FILE, __LINE__, "- Finished, exiting.\n", 1);
exit(0);

###############################################################################
# Here be Functions!                                                          #
###############################################################################

# This causes the script to exit if another instance is already running.
sub avoid_duplicate_run
{
	my ($conf) = @_;
	
	my $shell_call  = "$conf->{path}{pgrep} $THIS_FILE";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $pid = $_;
		logger($conf, $THIS_FILE, __LINE__, "pid: [$pid], my pid: [$$]", 2);
		if ($pid ne $$)
		{
			# Another copy is running, exit.
			close $file_handle;
			logger($conf, $THIS_FILE, __LINE__, "PID is different, another instance is running.", 2);
			if ($conf->{switches}{force})
			{
				print "[ Warning ] - The call was forced, but another instance with PID: [$pid] is running.\n";
				print "[ Notice  ] - If you want to run this instance, kill the other instance first and call it again.\n";
			}
			exit(6);
		}
	}
	close $file_handle;
	
	return (0);
}

# This cancels any running start and/or prevents a pending run.
sub abort_start
{
	my ($conf) = @_;
	
	my $ok = 1;
	
	# First, prevent any pending run from occurring.
	if (update_configuration($conf, "disable"))
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to set 'tools::safe_anvil_start::enabled = 0' in striker.conf.", 0);
		logger($conf, $THIS_FILE, __LINE__, "[ Error ]   $THIS_FILE will run next time cron calls it!", 0);
		print "[ Error ] - Failed to set 'tools::safe_anvil_start::enabled = 0' in striker.conf.\n";
		print "[ Error ]   $THIS_FILE will run next time cron calls it!\n";
		my $ok = 0;
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Success ] - Disabled $THIS_FILE from running via cron for this session.", 1);
	}
	
	# Now kill any running process.
	my $shell_call  = "$conf->{path}{pgrep} $THIS_FILE 2>&1 |";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $pid = $_;
		logger($conf, $THIS_FILE, __LINE__, "pid: [$pid], my pid: [$$]", 2);
		if ($pid ne $$)
		{
			# Another copy is running, kill it.
			logger($conf, $THIS_FILE, __LINE__, "[ Notice ] - An existing instance of $THIS_FILE is running with PID: [$pid], killing it.", 0);
			my $shell_call  = "$conf->{path}{'kill'} $pid 2>&1 |";
			logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line].", 2);
			}
			close $file_handle;
		}
	}
	close $file_handle;
	
	
	return($ok);
}

# This creates the rc3.d symlink so that this program will be set to run on boot. Exits with '8' if it fails,
# '0' otherwise.
sub create_symlink
{
	my ($conf) = @_;
	
	my $exit = 0;
	my $shell_call = "
if [ -e '$conf->{path}{safe_anvil_start_link}' ];
then
    echo '$conf->{path}{safe_anvil_start_link} already exists.'
else
    ln -s $conf->{path}{safe_anvil_start} $conf->{path}{safe_anvil_start_link}
    if [ -e '$conf->{path}{safe_anvil_start_link}' ];
    then
        echo '$conf->{path}{safe_anvil_start_link} link created.'
    else
        echo 'Failed to create $conf->{path}{safe_anvil_start_link}.'
    fi
fi";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ /Failed to create/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to create the link: [$conf->{path}{safe_anvil_start_link}] to: [$conf->{path}{safe_anvil_start_link}].", 0);
			logger($conf, $THIS_FILE, __LINE__, "[ Error ]   This link is what triggers 'safe_anvil_start' on boot!", 0);
			$exit = 8;
		}
	}
	close $file_handle;
	
	if (not $exit)
	{
		#print "Successfully set 'safe_anvil_start' to run shortly after boot.\n";
		logger($conf, $THIS_FILE, __LINE__, "Successfully set 'safe_anvil_start' to run shortly after boot.", 1);
	}
	
	exit($exit);
}

# This removes the rc3.d symlink so that this program will be set to run on boot. Exits with '9' if it fails,
# '0' otherwise.
sub remove_symlink
{
	my ($conf) = @_;
	
	my $exit = 0;
	my $shell_call = "
if [ -e '$conf->{path}{safe_anvil_start_link}' ];
then
    rm -f $conf->{path}{safe_anvil_start_link}
    if [ -e '$conf->{path}{safe_anvil_start_link}' ];
    then
        echo 'Failed to remove $conf->{path}{safe_anvil_start_link}.'
    else
        echo 'Successfully removed $conf->{path}{safe_anvil_start_link}.'
    fi
else
    echo 'Link already removed.'
fi";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ /Failed to remove/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to remove the link: [$conf->{path}{safe_anvil_start_link}] to: [$conf->{path}{safe_anvil_start_link}].", 0);
			logger($conf, $THIS_FILE, __LINE__, "[ Error ]   This link is what triggers 'safe_anvil_start' on boot!", 0);
			$exit = 9;
		}
	}
	close $file_handle;
	
	if (not $exit)
	{
		#print "Successfully disabled 'safe_anvil_start' from runnig after boot.\n";
		logger($conf, $THIS_FILE, __LINE__, "Successfully disabled 'safe_anvil_start' from runnig after boot.", 1);
	}
	
	exit($exit);
}

# This updates striker.conf to enable or disable safe_anvil_start.
sub update_configuration
{
	my ($conf, $do) = @_;
	
	my $return_code = 0;
	my $shell_call  = "$conf->{path}{sed} -i 's/^tools::safe_anvil_start::enabled\\(\\s*\\)=\\(\\s*\\)1/tools::safe_anvil_start::enabled\\1=\\20/' $conf->{path}{striker_config}\n";
	if ($do eq "enable")
	{
		$shell_call = "$conf->{path}{sed} -i 's/^tools::safe_anvil_start::enabled\\(\\s*\\)=\\(\\s*\\)0/tools::safe_anvil_start::enabled\\1=\\21/' $conf->{path}{striker_config}\n";
	}
	$shell_call .= "
if \$(grep -q '^tools::safe_anvil_start::enabled\\s*=\\s*1' /etc/striker/striker.conf);
then 
    echo enabled; 
else 
    echo disabled;
fi";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 3);
		if ($line =~ /enabled/)
		{
			# Did I want this?
			if ($do eq "enable")
			{
				# Good!
				logger($conf, $THIS_FILE, __LINE__, "Enabled successfully.", 2);
			}
			else
			{
				# Woops...
				logger($conf, $THIS_FILE, __LINE__, "Failed to enable!", 0);
				$return_code = 1;
			}
		}
		elsif ($line =~ /disabled/)
		{
			# Did I want this?
			if ($do eq "disable")
			{
				# Good!
				logger($conf, $THIS_FILE, __LINE__, "Disabled successfully.", 2);
			}
			else
			{
				# Woops...
				logger($conf, $THIS_FILE, __LINE__, "Failed to disable!", 0);
				$return_code = 1;
			}
		}
	}
	close $file_handle;
	
	return($return_code);
}

# This uses the information from cluster.conf to determine how to check the
# peer's power state and power it on if needed.
sub power_on_peer
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "power_on_peer();", 3);
	
	my $fence_path = $conf->{path}{fence_path};
	logger($conf, $THIS_FILE, __LINE__, "nodes::peer::fence: [$conf->{nodes}{peer}{fence}], fence_path: [$fence_path]", 2);
	$conf->{nodes}{peer}{fence} =~ s/^fence/$fence_path\/fence/;
	logger($conf, $THIS_FILE, __LINE__, "nodes::peer::fence: [$conf->{nodes}{peer}{fence}]", 2);
	my $boot_peer   = 0;
	my $file_handle = IO::Handle->new();
	my $shell_call  = "$conf->{nodes}{peer}{fence} -o status; echo rc:\$?";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 3);
		if ($line =~ /rc:(\d+)/)
		{
			my $rc = $1;
			if ($rc eq "0")
			{
				# Already running.
				logger($conf, $THIS_FILE, __LINE__, "- The peer node is already running, no need to boot it.", 3);
			}
			elsif ($rc eq "1")
			{
				# Failed to reach the peer.
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Failed to reach the peer's IPMI interface, unable to determine it's power state.", 1);
				$conf->{sys}{bad_fence} = 1;
			}
			elsif ($rc eq "2")
			{
				# This should return '2'
				logger($conf, $THIS_FILE, __LINE__, "- The peer node is off, it will be booted.", 1);
				$boot_peer = 1;
			}
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "boot_peer: [$boot_peer]", 3);
	if ($boot_peer)
	{
		my $shell_call  = "$conf->{nodes}{peer}{fence} -o on; echo rc:\$?";
		logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
			if ($line =~ /rc:(\d+)/)
			{
				my $rc = $1;
				if ($rc eq "0")
				{
					# Running.
					logger($conf, $THIS_FILE, __LINE__, "- The peer node was booted successfully.", 1);
					$conf->{sys}{peer_booted} = 1;
				}
			}
		}
		close $file_handle;
	}
	
	return(0);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message, $level) = @_;
	$level = 0 if not $level;
	
	# Return if the log level is too low, unless debug is in use.
	if (not $conf->{sys}{debug})
	{
		return(0) if $level > $conf->{sys}{log_level};
	}
	
	# Print the message to the screen.
	# If the level is 0 or 1, don't print the file and line numnber
	if ($level < 2)
	{
		$message =~ s/^; //;
		print "$message\n";
	}
	else
	{
		print "$file $line_number; [ Debug ] - $message\n";
	}
	
	# We split on new-lines so that multi-line message render better in
	# syslog.
	my $is_debug = $message =~ /\[ Debug \]/ ? 1 : 0;
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		if (($is_debug) && ($line !~ /\[ Debug \]/))
		{
			$line = "[ Debug ]   $line";
		}
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "logger", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $THIS_FILE $line]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

# This gets the list of physical volume(s) backing each logical volume. This is
# needed to check the DRBD connection and disk state when deciding later which
# node to start the server on.
sub get_pvs_under_lv
{
	my ($conf) = @_;
	
	my @pvs;
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{lvs} --separator ' ' -o lv_name,vg_name,lv_path,devices";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ / (.*?) (.*?) (\/dev\/.*?) (\/dev\/.*)/)
		{
			my $lv_name = $1;
			my $vg_name = $2;
			my $lv_path = $3;
			my $pvs     = $4;
			# PVs are listed with their starting extend in brackets
			# which we don't care about.
			$pvs =~ s/\(.*?\)//g;
			# If the LV spans PVs, they will be comma-separated.
			$conf->{lvs}{$lv_path}{pvs} = $pvs;
			logger($conf, $THIS_FILE, __LINE__, "lvs::${lv_path}::pvs: [$conf->{lvs}{$lv_path}{pvs}]", 2);
		}
	}
	close $file_handle;
	
	return(0)
}

# This translates a DRBD resource name to it's block device path.
sub translate_drbd_resource_to_device_path
{
	my ($conf, $resource) = @_;
	logger($conf, $THIS_FILE, __LINE__, "translate_drbd_resource_to_device_path(); resource: [$resource]", 3);
	
	# This 'drbdadm' switch is in 'drbdadm hidden-commands'.
	my $device_path = "";
	my $file_handle = IO::Handle->new();
	my $shell_call  = "$conf->{path}{drbdadm} sh-dev $resource";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ /^(\/dev\/.*)/)
		{
			$device_path = $1;
			logger($conf, $THIS_FILE, __LINE__, "device_path: [$device_path]", 2);
		}
	}
	close $file_handle;
	
	return($device_path);
}

# This reads the current state of DRBD resource. This is used later to help
# decide which node to start a server on.
sub read_drbd_state
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "read_drbd_state()", 3);
	
	my $device_path = "";
	my $file_handle = IO::Handle->new();
	#my $shell_call  = "/etc/init.d/drbd status";
	my $shell_call  = "cat /proc/drbd";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		my $line = $_;
		next if not $line;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ /(\d+): cs:(.*?) ro:(.*?)\/(.*?) ds:(.*?)\/(.*?) /)
		{
			my $minor_number     = $1;
			my $connection_state = $2;
			my $me_role          = $3;
			my $peer_role        = $4;
			my $me_disk_state    = $5;
			my $peer_disk_state  = $6;
			my $resource_name    = "r".$minor_number;
			logger($conf, $THIS_FILE, __LINE__, "minor_number: [$minor_number], resource_name: [$resource_name], connection_state: [$connection_state], me_role: [$me_role], peer_role: [$peer_role], me_disk_state: [$me_disk_state], peer_disk_state: [$peer_disk_state]", 2);
			   ($device_path)    = translate_drbd_resource_to_device_path($conf, $resource_name);
			logger($conf, $THIS_FILE, __LINE__, "device_path: [$device_path]", 2);
			$conf->{drbd}{$device_path}{minor_number}     = $minor_number;
			$conf->{drbd}{$device_path}{resource_name}    = $resource_name;
			$conf->{drbd}{$device_path}{connection_state} = $connection_state;
			$conf->{drbd}{$device_path}{me}{role}         = $me_role;
			$conf->{drbd}{$device_path}{me}{disk_state}   = $me_disk_state;
			$conf->{drbd}{$device_path}{peer}{role}       = $peer_role;
			$conf->{drbd}{$device_path}{peer}{disk_state} = $peer_disk_state;
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::minor_number:     [$conf->{drbd}{$device_path}{minor_number}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::resource_name:    [$conf->{drbd}{$device_path}{resource_name}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::connection_state: [$conf->{drbd}{$device_path}{connection_state}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::me::role:         [$conf->{drbd}{$device_path}{me}{role}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::me::disk_state:   [$conf->{drbd}{$device_path}{me}{disk_state}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::peer::role:       [$conf->{drbd}{$device_path}{peer}{role}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::peer::disk_state: [$conf->{drbd}{$device_path}{peer}{disk_state}]", 2);
		}
		if ($line =~ /finish: (\d+):(\d+):(\d+) speed/)
		{
			my $hours     = $1;
			my $minutes   = $2;
			my $seconds   = $3;
			my $sync_time = ($hours * 3600) + ($minutes * 60) + $seconds;
			logger($conf, $THIS_FILE, __LINE__, "hours: [$hours], minutes: [$minutes], seconds: [$seconds], sync_time: [$sync_time]", 2);
			if (not $device_path)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - device_path not set!", 0);
			}
			else
			{
				$conf->{drbd}{$device_path}{sync_time} = $sync_time;
				logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::sync_time: [$conf->{drbd}{$device_path}{sync_time}]", 2);
			}
		}
	}
	close $file_handle;
	
	return(0);
}

# This starts by calling 'drbdadm adjust all' on both noes, then waiting up to
# the 'wait_for_drbd_sync' seconds for both to go UpToDate.
sub wait_for_drbd_sync
{
	my ($conf) = @_;
	
	# Call 'drbdadm adjust all';
	foreach my $node ("me", "peer")
	{
		next if (($node eq "peer") && ($conf->{nodes}{peer}{healthy} == 2));
		logger($conf, $THIS_FILE, __LINE__, "node: [$node]", 2);
		my $file_handle = IO::Handle->new();
		my $shell_call  = "$conf->{path}{drbdadm} adjust all";
		if ($node eq "peer")
		{
			$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{drbdadm} adjust all\"";
		}
		logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		}
		close $file_handle;
	}
	
	# Now loop for up to 'wait_for_drbd_sync' seconds
	my $all_uptodate = 0;
	logger($conf, $THIS_FILE, __LINE__, "all_uptodate: [$all_uptodate], timeouts::wait_for_drbd_sync: [$conf->{timeouts}{wait_for_drbd_sync}]", 3);
	logger($conf, $THIS_FILE, __LINE__, "- Waiting up to: [$conf->{timeouts}{wait_for_drbd_sync}] seconds for DRBD to become 'UpToDate' on both nodes.", 1);
	for (0..$conf->{timeouts}{wait_for_drbd_sync})
	{
		read_drbd_state($conf);
		
		$all_uptodate = 1;
		foreach my $device_path (sort {$a cmp $b} keys %{$conf->{drbd}})
		{
			logger($conf, $THIS_FILE, __LINE__, "device_path: [$device_path]", 2);
			my $me_role         = $conf->{drbd}{$device_path}{me}{role};
			my $me_disk_state   = $conf->{drbd}{$device_path}{me}{disk_state};
			my $peer_role       = $conf->{drbd}{$device_path}{peer}{role};
			my $peer_disk_state = $conf->{drbd}{$device_path}{peer}{disk_state};
			logger($conf, $THIS_FILE, __LINE__, "me_role: [$me_role], me_disk_state: [$me_disk_state], peer_role: [$peer_role], peer_disk_state: [$peer_disk_state]", 2);
			if (lc($me_role) ne "primary")
			{
				$all_uptodate = 0;
				logger($conf, $THIS_FILE, __LINE__, "Local DRBD device: [$device_path]'s role is: [$me_role], will wait for it to become 'Primary'", 2);
			}
			if (lc($peer_role) ne "primary")
			{
				$all_uptodate = 0;
				logger($conf, $THIS_FILE, __LINE__, "Peer's DRBD device: [$device_path]'s role is: [$peer_role], will wait for it to become 'Primary'", 2);
			}
			next if ($conf->{nodes}{peer}{healthy} == 2);
			if (lc($me_disk_state) ne "uptodate")
			{
				# If the resync time is longer than the max
				# wait time, proceed with startup.
				if (($conf->{drbd}{$device_path}{sync_time}) && ($conf->{drbd}{$device_path}{sync_time} > $conf->{timeouts}{wait_for_drbd_sync}))
				{
					logger($conf, $THIS_FILE, __LINE__, "Local DRBD device: [$device_path]'s disk state is: [$me_disk_state].", 2);
					logger($conf, $THIS_FILE, __LINE__, "It will take an estimated: [$conf->{drbd}{$device_path}{sync_time}] seconds to become 'UpToDate', which is longer than the maximum wait time of: [$conf->{timeouts}{wait_for_drbd_sync}].", 2);
					logger($conf, $THIS_FILE, __LINE__, "As such, there is no point waiting.", 2);
				}
				else
				{
					$all_uptodate = 0;
					logger($conf, $THIS_FILE, __LINE__, "Local DRBD device: [$device_path]'s disk state is: [$me_disk_state], will wait for it to become 'UpToDate'.", 2);
				}
			}
			if (lc($peer_disk_state) ne "uptodate")
			{
				logger($conf, $THIS_FILE, __LINE__, "drbd::${device_path}::sync_time: [$conf->{drbd}{$device_path}{sync_time}], timeouts::wait_for_drbd_sync: [$conf->{timeouts}{wait_for_drbd_sync}].", 2);
				if (($conf->{drbd}{$device_path}{sync_time}) && ($conf->{drbd}{$device_path}{sync_time} > $conf->{timeouts}{wait_for_drbd_sync}))
				{
					logger($conf, $THIS_FILE, __LINE__, "Peer's DRBD device: [$device_path]'s disk state is: [$me_disk_state].", 2);
					logger($conf, $THIS_FILE, __LINE__, "It will take an estimated: [$conf->{drbd}{$device_path}{sync_time}] seconds to become 'UpToDate', which is longer than the maximum wait time of: [$conf->{timeouts}{wait_for_drbd_sync}].", 2);
					logger($conf, $THIS_FILE, __LINE__, "As such, there is no point waiting.", 2);
				}
				else
				{
					$all_uptodate = 0;
					logger($conf, $THIS_FILE, __LINE__, "Peer's DRBD device: [$device_path]'s disk state is: [$peer_disk_state], will wait for it to become 'UpToDate'.", 2);
				}
			}
		}
		logger($conf, $THIS_FILE, __LINE__, "all_uptodate: [$all_uptodate]", 2);
		if ($all_uptodate)
		{
			logger($conf, $THIS_FILE, __LINE__, "- Ready!", 1);
			last;
		}
		sleep 1;
	}
	logger($conf, $THIS_FILE, __LINE__, "all_uptodate: [$all_uptodate].", 2);
	if ($all_uptodate)
	{
		if ($conf->{nodes}{peer}{healthy} == 2)
		{
			logger($conf, $THIS_FILE, __LINE__, "- All of my resource are Primary and UpToDate.", 1);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- All of DRBD resource on both nodes are Primary and UpToDate.", 1);
		}
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "- Timeout expired.", 1);
		if ($conf->{nodes}{peer}{healthy} == 2)
		{
			logger($conf, $THIS_FILE, __LINE__, "- At least one of my DRBD resources is not Primary or UpToDate, peer is unhealthy.", 1);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- All of my resource are UpToDate, but at least one of my peer's resources is not yet Primary or UpToDate.", 1);
		}
	}
	
	return(0);
}

# This reads the XML definition file for a VM. Specifically, we're looki
sub read_vm_definition
{
	my ($conf, $name, $definition) = @_;
	logger($conf, $THIS_FILE, __LINE__, "- read_vm_definition(); server name: [$name], definition: [$definition]", 3);
	
	my $read_ok = 1;
	if (not -e $definition)
	{
		$read_ok = 0;
		logger($conf, $THIS_FILE, __LINE__, "server name: [$name]'s definition: [$definition] file doesn't exist!", 2);
	}
	elsif (not -r $definition)
	{
		$read_ok = 0;
		logger($conf, $THIS_FILE, __LINE__, "server name: [$name]'s definition: [$definition] file exists but isn't readable!", 2);
	}
	if ($read_ok)
	{
		my $in_disk = 0;
		my $file_handle = IO::Handle->new();
		my $shell_call = "$definition";
		logger($conf, $THIS_FILE, __LINE__, "File read: [$shell_call]", 2);
		open ($file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			# I don't care about this output
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 3);
			
			if ($line =~ /<disk .*?device='disk'/)
			{
				# TODO: Make this check that the "inserted" ISO
				# actually exists, and if not, remove the ISO
				# from the definition file as not existing will
				# block boot.
				next if $line =~ /device='cdrom'/;
				$in_disk = 1;
				logger($conf, $THIS_FILE, __LINE__, "Going in_disk: [$in_disk]", 3);
				next;
			}
			if ($in_disk)
			{
				if ($line =~ /<\/disk>/)
				{
					$in_disk = 0;
					logger($conf, $THIS_FILE, __LINE__, "Exiting in_disk: [$in_disk]", 3);
					next;
				}
				if ($line =~ /<source dev='(.*?)'/)
				{
					my $lv_path = $1;
					push @{$conf->{vms}{$name}{lv_path}}, $lv_path;
					logger($conf, $THIS_FILE, __LINE__, "Adding lv_path: [$lv_path] to array vms::${name}::lv_path. Array contains: [".@{$conf->{vms}{$name}{lv_path}}."] disk(s).", 2);
				}
			}
		}
		close $file_handle;
	}
	
	return($read_ok)
}

# This checks the health of the storage behind each server and decides where to
# boot each server.
sub start_servers
{
	my ($conf) = @_;
	
	# Get a list of PV(s) under each LV.
	get_pvs_under_lv($conf);
	
	# Read/set the boot order.
	foreach my $server (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		# If it is defined, we'll use the set value. Otherwise we'll add it to set 1 with no delay.
		my $set   = 1;
		my $delay = 0;
		if ($conf->{server}{boot_order}{$server})
		{
			# Set, parse.
			if ($conf->{server}{boot_order}{$server} =~ /^(\d+):(\d+)$/)
			{
				$set   = $1;
				$delay = $2;
			}
			else
			{
				# Bad formatting, throw an error.
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - The server: [$server] appears to have a boot order set: [$conf->{server}{boot_order}{$server}], but it appears to be invalid. The boot order must be integers only and set as: 'server::boot_order::$server = (order):(delay)'. For example; '... = 2:30' or '... = 3:0'.", 0);
			}
		}
		
	}
	
	# Now decide where to start each server.
	foreach my $name (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		logger($conf, $THIS_FILE, __LINE__, "Reading server: [$name]'s definition file: [$conf->{vm}{$name}{definition}].", 2);
		logger($conf, $THIS_FILE, __LINE__, "- Starting server: [$name] (current state: [$conf->{vm}{$name}{'state'}], current host: [$conf->{vm}{$name}{host}]).", 1);
		if (lc($conf->{vm}{$name}{'state'}) eq "started")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Already running on: [$conf->{vm}{$name}{host}].", 1);
			next;
		}
		read_vm_definition($conf, $name, $conf->{vm}{$name}{definition});
		
		my $preferred_node = "";
		my $in_domain      = $conf->{vm}{$name}{domain};
		logger($conf, $THIS_FILE, __LINE__, "in_domain: [$in_domain].", 2);
		foreach my $priority (sort {$a cmp $b} keys %{$conf->{failoverdomain}{$in_domain}{priority}})
		{
			logger($conf, $THIS_FILE, __LINE__, "failoverdomain::${in_domain}::priority::${priority}::node: [$conf->{failoverdomain}{$in_domain}{priority}{$priority}{node}].", 2);
			$preferred_node = $conf->{failoverdomain}{$in_domain}{priority}{$priority}{node};
			logger($conf, $THIS_FILE, __LINE__, "preferred_node: [$preferred_node].", 2);
			last;
		}
		logger($conf, $THIS_FILE, __LINE__, "- Preferred node is: [$preferred_node].", 1);
		
		my $preferred_node_is = "me";
		my $backup_node_is    = "peer";
		logger($conf, $THIS_FILE, __LINE__, "preferred_node: [$preferred_node], nodes::peer::hostname: [$conf->{nodes}{peer}{hostname}].", 2);
		if ($preferred_node eq $conf->{nodes}{peer}{hostname})
		{
			$preferred_node_is = "peer";
			$backup_node_is    = "me";
		}
		logger($conf, $THIS_FILE, __LINE__, "preferred_node_is: [$preferred_node_is], backup_node_is: [$backup_node_is].", 2);
		
		# Make sure I can boot the server on the preferred host.
		my $can_boot_on_preferred = 1;
		my $can_boot_on_backup    = 1;
		logger($conf, $THIS_FILE, __LINE__, "nodes::${preferred_node_is}::healthy: [$conf->{nodes}{$preferred_node_is}{healthy}].", 2);
		if ($conf->{nodes}{$preferred_node_is}{healthy} == 1)
		{
			# Loop through each LV attached to this server, determine which
			# PVs are under it and make sure it/they are UpToDate.
			logger($conf, $THIS_FILE, __LINE__, "Checking storage health of preferred node: [$preferred_node_is ($conf->{nodes}{$preferred_node_is}{hostname})].", 2);
			foreach my $lv_path (sort {$a cmp $b} @{$conf->{vms}{$name}{lv_path}})
			{
				my $pvs = $conf->{lvs}{$lv_path}{pvs};
				logger($conf, $THIS_FILE, __LINE__, "lv_path: [$lv_path], pvs: [$pvs]", 2);
				foreach my $device_path (split/,/, $pvs)
				{
					logger($conf, $THIS_FILE, __LINE__, "device_path: [$device_path]", 2);
					my $role       = $conf->{drbd}{$device_path}{$preferred_node_is}{role};
					my $disk_state = $conf->{drbd}{$device_path}{$preferred_node_is}{disk_state};
					logger($conf, $THIS_FILE, __LINE__, "preferred_node_is: [$preferred_node_is], role: [$role], disk_state: [$disk_state]", 2);
					if ((lc($role) ne "primary") or (lc($disk_state) ne "uptodate"))
					{
						logger($conf, $THIS_FILE, __LINE__, "Can't boot on preferred node.", 2);
						logger($conf, $THIS_FILE, __LINE__, "- I can not boot this server on the preferred node, storage isn't ready.", 1);
						$can_boot_on_preferred = 0;
					}
				}
			}
		}
		if (($conf->{nodes}{$backup_node_is}{healthy} == 1) && (not $can_boot_on_preferred))
		{
			# Peer isn't healthy, make sure I am  
			logger($conf, $THIS_FILE, __LINE__, "Checking storage health of backup node: [$backup_node_is] ($conf->{nodes}{$backup_node_is}{hostname})].", 2);
			foreach my $lv_path (sort {$a cmp $b} @{$conf->{vms}{$name}{lv_path}})
			{
				my $pvs = $conf->{lvs}{$lv_path}{pvs};
				logger($conf, $THIS_FILE, __LINE__, "lv_path: [$lv_path], pvs: [$pvs]", 2);
				foreach my $device_path (split/,/, $pvs)
				{
					logger($conf, $THIS_FILE, __LINE__, "device_path: [$device_path]", 2);
					my $role       = $conf->{drbd}{$device_path}{$backup_node_is}{role};
					my $disk_state = $conf->{drbd}{$device_path}{$backup_node_is}{disk_state};
					logger($conf, $THIS_FILE, __LINE__, "backup_node_is: [$backup_node_is], role: [$role], disk_state: [$disk_state]", 2);
					if ((lc($role) ne "primary") or (lc($disk_state) ne "uptodate"))
					{
						logger($conf, $THIS_FILE, __LINE__, "- I can not boot this server on the backup node, storage isn't ready.", 1);
						$can_boot_on_backup = 0;
					}
				}
			}
		}
		
		# Ok, start!
		if ((not $can_boot_on_preferred) && (not $can_boot_on_backup))
		{
			logger($conf, $THIS_FILE, __LINE__, "- Unable to boot this server, skipping it.", 1);
		}
		else
		{
			my $file_handle = IO::Handle->new();
			my $shell_call  = "$conf->{path}{clusvcadm} -e vm:$name -m $preferred_node";
			if ($can_boot_on_preferred)
			{
				my $preferred_node = $conf->{nodes}{$preferred_node_is}{hostname};
				logger($conf, $THIS_FILE, __LINE__, "Starting server: [$name] on the preferred node: [$preferred_node].", 2);
				logger($conf, $THIS_FILE, __LINE__, "- Ready to start!", 1);
			}
			elsif ($can_boot_on_backup)
			{
				my $backup_node = $conf->{nodes}{$backup_node_is}{hostname};
				logger($conf, $THIS_FILE, __LINE__, "Starting server: [$name] on the backup node: [$backup_node].", 2);
				$shell_call = "$conf->{path}{clusvcadm} -e vm:$name -m $backup_node";
				logger($conf, $THIS_FILE, __LINE__, "- Starting server on backup node.", 1);
			}
			logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
			}
			close $file_handle;
			logger($conf, $THIS_FILE, __LINE__, "- Started!", 1);
		}
	}
	
	return(0);
}

# This checks to see if a file is a symlink or not. If so, it returns the
# target.
sub check_if_symlink
{
	my ($conf, $file, $node) = @_;
	logger($conf, $THIS_FILE, __LINE__, "check_if_symlink(); file: [$file], node: [$node]", 3);
	my $target = "";
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{ls} -l $file";
	if ($node eq "peer")
	{
		$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{ls} -l $file\"";
	}
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ /$file\s->\s(.*)/)
		{
			$target = $1;
			logger($conf, $THIS_FILE, __LINE__, "target: [$target]", 2);
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "target: [$target]", 4);
	if ($target =~ /^\.\.\//)
	{
		my $path = dirname $file;
		logger($conf, $THIS_FILE, __LINE__, "file: [$file], path: [$path], target: [$target]", 2);
		while ($target =~ /^\.\.\//)
		{
			$path   =  dirname $path;
			$target =~ s/^\.\.\///;
			logger($conf, $THIS_FILE, __LINE__, "target: [$target], path: [$path]", 2);
		}
		$target =  $path."/".$target;
		$target =~ s/\/\//\//g;
	}
	
	logger($conf, $THIS_FILE, __LINE__, "target: [$target]", 2);
	return ($target);
}

# This calls 'clustat' and checks to make sure no services are in a 'failed'
# state.
sub check_clustat
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "check_clustat()", 4);
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{clustat}";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		if ($line =~ /service:(.*?)\s(.*?)\s(.*)/)
		{
			my $service = $1;
			my $host    = $2;
			my $state   = $3;
			logger($conf, $THIS_FILE, __LINE__, "service: [$service], host: [$host], state: [$state]", 2);
			$conf->{services}{$service}{host}    = $host;
			$conf->{services}{$service}{'state'} = $state;
			logger($conf, $THIS_FILE, __LINE__, "service::${service}::host: [$conf->{services}{$service}{host}], service::${service}::state: [$conf->{services}{$service}{state}]", 2);
		}
		if ($line =~ /vm:(.*?)\s(.*?)\s(.*)/)
		{
			my $name  = $1;
			my $host  = $2;
			my $state = $3;
			logger($conf, $THIS_FILE, __LINE__, "name: [$name], host: [$host], state: [$state]", 2);
			
			$conf->{vm}{$name}{host}    = $host;
			$conf->{vm}{$name}{'state'} = $state;
			logger($conf, $THIS_FILE, __LINE__, "vm::${name}::host: [$conf->{vm}{$name}{host}], vm::${name}::state: [$conf->{vm}{$name}{'state'}]", 2);
		}
	}
	close $file_handle;
	
	return(0);
}

# This calls 'df -P' and parses the output.
sub read_df
{
	my ($conf, $node) = @_;
	logger($conf, $THIS_FILE, __LINE__, "read_df(); node: [$node]", 3);
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{df} -P";
	if ($node eq "peer")
	{
		$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{df} -P\"";
	}
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 3);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		next if ($line !~ /^\//);
		if ($line =~ /^(\/.*?)\s.*?(\/.*)/)
		{
			my $device     = $1;
			my $mountpoint = $2;
			logger($conf, $THIS_FILE, __LINE__, "device: [$device], mountpoint: [$mountpoint]", 2);
			$conf->{nodes}{$node}{mounts}{$device} = $mountpoint;
			logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::mounts::${device}: [$conf->{nodes}{$node}{mounts}{$device}]", 2);
		}
	}
	close $file_handle;
	
	# I need to get the device-mapper name for the mounts, if there is one,
	# as the LVs behind the gfs2 partitions often display in 'df' 
	# differently that is listed in cluster.conf'.
	foreach my $device (sort {$a cmp $b} keys %{$conf->{nodes}{$node}{mounts}})
	{
		my $mountpoint = $conf->{nodes}{$node}{mounts}{$device};
		logger($conf, $THIS_FILE, __LINE__, "Checking if: [$device], mounted at: [$mountpoint] is a symlink", 2);
		my ($target) = check_if_symlink($conf, $device, $node);
		if ($target)
		{
			$conf->{nodes}{$node}{mounts}{$target} = $mountpoint;
			logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::mounts::${target}: [$conf->{nodes}{$node}{mounts}{$target}]", 2);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::mounts::${device}, mounted at: [$conf->{nodes}{$node}{mounts}{$device}], is *not* a symlink", 2);
		}
	}
	
	return(0);
}

# This will wait for a period of time waiting for daemons and the gfs2 
# partition started by rgmanager services to come online. If a daemon is not
# up after the timeout, or goes into a failed state, the node will not be a 
# host candidate for servers.
sub check_node_health
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "check_node_health()", 3);
	
	logger($conf, $THIS_FILE, __LINE__, "- Waiting up to: [$conf->{timeouts}{wait_for_node_health}] seconds for the nodes to become healthy.", 1);
	for (0..$conf->{timeouts}{wait_for_node_health})
	{
		check_daemons($conf);
		read_df($conf, "me");
		read_df($conf, "peer");
		check_clustat($conf);
		
		$conf->{nodes}{me}{healthy}   = 1;
		$conf->{nodes}{peer}{healthy} = 1;
		foreach my $daemon (sort {$a cmp $b} keys %{$conf->{daemons}})
		{
			logger($conf, $THIS_FILE, __LINE__, "daemon: [$daemon]", 2);
			foreach my $node ("me", "peer")
			{
				logger($conf, $THIS_FILE, __LINE__, "node: [$node], ${node}::daemon::${daemon}::rc: [$conf->{$node}{daemon}{$daemon}{rc}]", 2);
				if ($conf->{$node}{daemon}{$daemon}{rc} ne "0")
				{
					$conf->{nodes}{$node}{healthy} = 0;
					logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::healthy: [$conf->{nodes}{$node}{healthy}]", 2);
				}
			}
		}
		
		### TODO: Check that DRBD resources are all 'Primary'.
		foreach my $clusterfs (sort {$a cmp $b} keys %{$conf->{cluster}{gfs2}})
		{
			logger($conf, $THIS_FILE, __LINE__, "clusterfs: [$clusterfs]", 2);
			foreach my $node ("me", "peer")
			{
				logger($conf, $THIS_FILE, __LINE__, "node: [$node], cluster::gfs2::${clusterfs}::device: [$conf->{cluster}{gfs2}{$clusterfs}{device}], cluster::gfs2::${clusterfs}::mountpoint: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
				my $device     = $conf->{cluster}{gfs2}{$clusterfs}{device};
				my $mountpoint = $conf->{cluster}{gfs2}{$clusterfs}{mountpoint};
				logger($conf, $THIS_FILE, __LINE__, "device: [$device], mountpoint: [$mountpoint]", 2);
				my ($target) = check_if_symlink($conf, $device, $node);
				if ($target)
				{
					my $old_device = $device;
					$device        = $target;
					$conf->{cluster}{gfs2}{$clusterfs}{device} = $target;
					logger($conf, $THIS_FILE, __LINE__, "Adapting device to symlink target; cluster::gfs2::${clusterfs}::device: [$conf->{cluster}{gfs2}{$clusterfs}{device}], was: [$old_device]", 2);
				}
				
				logger($conf, $THIS_FILE, __LINE__, "node: [$node], device: [$device]", 2);
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::mounts::${device}: [$conf->{nodes}{$node}{mounts}{$device}], cluster::gfs2::${clusterfs}::mountpoint: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 3);
				if (not exists $conf->{nodes}{$node}{mounts}{$device})
				{
					logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::mounts::${device} not mounted", 2);
					$conf->{nodes}{$node}{healthy} = 0;
				}
				elsif ($conf->{nodes}{$node}{mounts}{$device} eq $conf->{cluster}{gfs2}{$clusterfs}{mountpoint})
				{
					logger($conf, $THIS_FILE, __LINE__, "clusterfs: [$clusterfs] mounted properly: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "Unexpected mount point! nodes::${node}::mounts::${device}: [$conf->{nodes}{$node}{mounts}{$device}], expected: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
					$conf->{nodes}{$node}{healthy} = 2;
				}
			}
		}
		foreach my $service (sort {$a cmp $b} keys %{$conf->{services}})
		{
			logger($conf, $THIS_FILE, __LINE__, "services::${service}::state: [$conf->{services}{$service}{'state'}], host: [$conf->{services}{$service}{host}], my host name: [$conf->{nodes}{me}{hostname}], peer's host name: [$conf->{nodes}{peer}{hostname}]", 2);
			my $node = $conf->{services}{$service}{host} eq $conf->{nodes}{me}{hostname} ? "me" : "peer";
			if ($conf->{services}{$service}{'state'} eq "failed")
			{
				# TODO: Try to recover the service
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Service: [$service] on host: [$conf->{services}{$service}{'state'}] is 'failed'. Marking node: [$conf->{nodes}{$node}{hostname} ($node)] as unhealthy.", 0);
				$conf->{nodes}{$node}{healthy} = 2;
			}
			elsif ($conf->{services}{$service}{'state'} eq "started")
			{
				logger($conf, $THIS_FILE, __LINE__, "Service: [$service] started on host: [$conf->{services}{$service}{host}]", 2);
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "Service: [$service] is in state: [$conf->{services}{$service}{'state'}]", 2);
				$conf->{nodes}{$node}{healthy} = 0;
			}
		}
		
		# TODO: Make sure all LVs are 'ACTIVE' and, if not, try to
		#       activate them.
		logger($conf, $THIS_FILE, __LINE__, "Node health; nodes::me::healthy: [$conf->{nodes}{me}{healthy}], nodes::peer::healthy: [$conf->{nodes}{peer}{healthy}]", 2);
		if (($conf->{nodes}{me}{healthy} == 1) && ($conf->{nodes}{peer}{healthy} == 1))
		{
			logger($conf, $THIS_FILE, __LINE__, "- Both nodes are now healthy", 1);
			last;
		}
		elsif (($conf->{nodes}{me}{healthy} == 1) && ($conf->{nodes}{peer}{healthy} == 2))
		{
			logger($conf, $THIS_FILE, __LINE__, "- I am healthy, but my peer is not", 1);
			last;
		}
		elsif (($conf->{nodes}{me}{healthy} == 2) && ($conf->{nodes}{peer}{healthy} == 1))
		{
			logger($conf, $THIS_FILE, __LINE__, "- My peer is healthy, but I am not. Exiting", 1);
			exit(3);
		}
		elsif (($conf->{nodes}{me}{healthy} == 2) && ($conf->{nodes}{peer}{healthy} == 2))
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Both nodes have critical issues and can not proceed", 0);
			exit(4);
		}
		sleep 1;
	}
	if ($conf->{nodes}{me}{healthy} != 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Timed out waiting for this node to become healthy, exiting", 0);
		exit(5);
	}
	elsif ($conf->{nodes}{peer}{healthy} != 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Timed out waiting for my peer to become healthy, proceeding.", 0);
	}

	return(0);
}

# This will fork in order to start the requested daemon on both nodes at the
# same time.
sub start_daemon_simultaneously
{
	my ($conf, $daemon) = @_;
	logger($conf, $THIS_FILE, __LINE__, "start_daemon_simultaneously(); daemon: [$daemon]", 3);
	
	logger($conf, $THIS_FILE, __LINE__, "- Starting: [$daemon]", 1);
	
	# I need to fork here because the calls won't return until cman
	# either talks to it's peer or fences it.
	my $parent_pid = $$;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Parent PID: [$parent_pid]", 2);
	
	my %pids;
	defined(my $pid = fork) or die "Can't fork(), error was: $!\n";
	if ($pid)
	{
		# Parent
		$pids{$pid} = 1;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - Spawned child with PID: [$pid] to start: [$daemon] on: [$conf->{nodes}{me}{hostname}]", 2);
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - me::daemon::${daemon}::rc: [$conf->{me}{daemon}{$daemon}{rc}]", 2);
		if ($conf->{me}{daemon}{$daemon}{rc} eq "3")
		{
			# Start the daemon locally.
			my $file_handle = IO::Handle->new();
			my $shell_call = "$conf->{daemons}{$daemon} start 2>&1; echo $daemon:\$?";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - shell call: [$shell_call]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- Starting locally", 1);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				   $line =~ s/\r//;
				   $line =~ s/\n//;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - line: [$line]", 2);
			}
			close $file_handle;
		}
		elsif ($conf->{me}{daemon}{$daemon}{rc} eq "0")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Daemon: [$daemon] already running locally, no need to start it.", 1);
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - Parent process: [$pid ($$)] exiting.", 2);
	}
	else
	{
		# Child
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - Child process continuing.", 2);
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - peer::daemon::${daemon}::rc: [$conf->{peer}{daemon}{$daemon}{rc}].", 2);
		if ($conf->{peer}{daemon}{$daemon}{rc} eq "3")
		{
			# Start needed on the peer.
			my $file_handle = IO::Handle->new();
			my $shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{daemons}{$daemon} start 2>&1; echo $daemon:\\\$?\"";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - shell call: [$shell_call].", 3);
			logger($conf, $THIS_FILE, __LINE__, "- Starting on peer.", 1);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				   $line =~ s/\r//;
				   $line =~ s/\n//;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - line: [$line].", 2);
			}
			close $file_handle;
		}
		elsif ($conf->{peer}{daemon}{$daemon}{rc} eq "0")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Daemon: [$daemon] is already running on the peer, no need to start.", 1);
		}
		# NOTE: This probably isn't needed.
		sleep 1;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - Child process exiting.", 2);
		exit;
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Done fork()ing.", 2);
	
	# Now loop until both child processes are dead.
	# This helps to catch hung children.
	my $saw_reaped = 0;
	
	# If I am here, then I am the parent process and all the child process have
	# been spawned. I will not enter a while() loop that will exist for however
	# long the %pids hash has data.
	while (%pids)
	{
		# This is a bit of an odd loop that put's the while()
		# at the end. It will cycle once per child-exit event.
		my $pid;
		do
		{
			# 'wait' returns the PID of each child as they
			# exit. Once all children are gone it returns 
			# '-1'.
			$pid = wait;
			if ($pid < 1)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Parent process thinks all children are gone now as wait returned: [$pid]. Exiting loop.", 2);
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Parent process told that child with PID: [$pid] has exited.", 2);
			}
			
			# This deletes the just-exited child process' PID from the
			# %pids hash.
			delete $pids{$pid};
			
			# This counter is a safety mechanism. If I see more PIDs exit
			# than I spawned, something went oddly and I need to bail.
			$saw_reaped++;
			if ($saw_reaped > 2)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - All children should be gone now but it seems the program went into an infinit loop.", 0);
				exit(3);
			}
		}
		while $pid > 0;	# This re-enters the do() loop for as
				# long as the PID returned by wait()
				# was >0.
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Done watching child processes.", 2);
	logger($conf, $THIS_FILE, __LINE__, "- done!", 1);
	
	if ($daemon eq "rgmanager")
	{
		logger($conf, $THIS_FILE, __LINE__, "- 'rgmanager' started, Waiting up to one minute for services to come online.", 1);
		my $ok = 0;
		for (0..60)
		{
			   $ok          = 0;
			my $file_handle = IO::Handle->new();
			my $shell_call  = "$conf->{path}{clustat}";
			logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
				if ($line =~ /Service Name/)
				{
					# rgmanager is running
					$ok = 1;
				}
				if ($line =~ /service:(.*?)\s(.*?)\s(.*)/)
				{
					my $service = $1;
					my $host    = $2;
					my $state   = $3;
					logger($conf, $THIS_FILE, __LINE__, "service: [$service], host: [$host], state: [$state]", 2);
					if ($state ne "started")
					{
						$ok = 0;
					}
				}
			}
			close $file_handle;
			
			if ($ok)
			{
				logger($conf, $THIS_FILE, __LINE__, "- All services started!", 1);
				last;
			}
			sleep 1;
		}
		if (not $ok)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Not all services started in timeout period!", 1);
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   Will proceed, might be able to recover.", 1);
		}
	}
	
	return(0);
}

# This calls 'status' against the daemons found in cluster.conf (plus 'cman' 
# and 'rgmanager') and records their return code for the given node.
sub get_daemon_state
{
	my ($conf, $daemon, $node) = @_;
	logger($conf, $THIS_FILE, __LINE__, "get_daemon_state(); daemon: [$daemon], node: [$node]", 2);

	# Return code:
	# 0   == Started
	# 1   == Bad call
	# 3   == Stopped
	# 127 == File not found
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{daemons}{$daemon} status 2>&1 > /dev/null; echo $daemon:\$?";
	if ($node eq "peer")
	{
		$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{daemons}{$daemon} status 2>&1 > /dev/null; echo $daemon:\\\$?\"";
	}
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 4);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /$daemon:(\d+)/)
		{
			$conf->{$node}{daemon}{$daemon}{rc} = $1;
			logger($conf, $THIS_FILE, __LINE__, "${node}::daemon::${daemon}::rc: [$conf->{$node}{daemon}{$daemon}{rc}] (0 = Running, 3 = Stopped)", 2);
		}
		elsif ($line =~ /No such file or directory/)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Unable to find daemon script: [$conf->{daemon}{$daemon}] on: [$conf->{nodes}{$node}{hostname}]", 0);
			exit(7);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		}
	}
	close $file_handle;
	
	if (($conf->{$node}{daemon}{$daemon}{rc} ne "0") && ($conf->{$node}{daemon}{$daemon}{rc} ne "3"))
	{
		if ($node eq "me")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Daemon: [$daemon] is in an unknown state on this node.", 0);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Daemon: [$daemon] is in an unknown state on: [$conf->{nodes}{peer}{hostname}].", 0);
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Status return code was: [$conf->{$node}{daemon}{$daemon}{rc}].", 0);
		logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Only '0' (started) and '3' (stopped) are handled.", 0);
		exit(2);
	}
	
	return($conf->{$node}{daemon}{$daemon}{rc});
}

# This is a simple wrapper to call get_daemon_state() against both nodes.
sub check_daemons
{
	my ($conf) = @_;
	
	foreach my $daemon (sort {$a cmp $b} keys %{$conf->{daemons}})
	{
		logger($conf, $THIS_FILE, __LINE__, "Checking daemon: [$daemon] using: [$conf->{daemons}{$daemon}]", 4);
		get_daemon_state($conf, $daemon, "me");
		get_daemon_state($conf, $daemon, "peer");
	}
	
	return(0);
}

# This simply checks for an ssh-able connectiong to the peer.
sub check_peer_connection
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "check_peer_connection()", 3);
	
	if (not $conf->{nodes}{peer}{hostname})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Can't connect to peer, peer host name unknown.", 0);
		exit(1);
	}
	
	# Check to see if the node is powered on and, if not, power it on. If a
	# a previous attempt to check failed though, skip this.
	power_on_peer($conf) if ((not $conf->{sys}{bad_fence}) && (not $conf->{sys}{peer_booted}));
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{echo} 1\"";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		my $line = $_;
		if ($line eq "1")
		{
			$conf->{nodes}{peer}{reachable} = 1; 
			logger($conf, $THIS_FILE, __LINE__, "nodes::peer_reachable: [$conf->{nodes}{peer}{reachable}]", 2);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
		}
	}
	close $file_handle;
	
	return($conf->{nodes}{peer}{reachable});
}

# Read the cluster configuration file. This forms the backbone of all that
# we'll do next.
sub read_cluster_config
{
	my ($conf) = @_;
	
	my $in_fencedevices = 0;
	my $in_node         = "";
	my $in_domain       = "";
	my $file_handle     = IO::Handle->new();
	my $shell_call      = "$conf->{path}{cluster_config}";
	logger($conf, $THIS_FILE, __LINE__, "- Reading the cluster configuration.", 1);
	logger($conf, $THIS_FILE, __LINE__, "File read: [$shell_call]", 3);
	open ($file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 3);
		
		# Pull out the cluster name. This has no use yet, beyond
		# telling the user.
		if ($line =~ /<cluster .*?name="(.*?)"/)
		{
			$conf->{cluster}{name} = $1;
			logger($conf, $THIS_FILE, __LINE__, "cluster::name: [$conf->{cluster}{name}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- This cluster is called: [$conf->{cluster}{name}].", 1);
			next;
		}
		
		# One of these has to match the hostname and the other must be
		# usable to log into the peer.
		if ($line =~ /<clusternode .*?name="(.*?)"/)
		{
			my $node    = $1;
			   $in_node = $node;
			logger($conf, $THIS_FILE, __LINE__, "node: [$node].", 4);
			if ($node eq $conf->{nodes}{me}{hostname})
			{
				logger($conf, $THIS_FILE, __LINE__, "Me;   node: [$node]", 3);
			}
			else
			{
				# Shorten the names and see if they match.
				logger($conf, $THIS_FILE, __LINE__, "Peer; node: [$node]", 3);
				my ($short_hostname) = ($conf->{nodes}{me}{hostname} =~ /^(.*?)\./);
				my ($short_nodename) = ($node                        =~ /^(.*?)\./);
				logger($conf, $THIS_FILE, __LINE__, "short_hostname: [$short_hostname], short_nodename: [$short_nodename]", 3);
				if ($short_hostname eq $short_nodename)
				{
					logger($conf, $THIS_FILE, __LINE__, "Me; node: [$node]", 3);
				}
				else
				{
					$conf->{nodes}{peer}{hostname}   = $node;
					$conf->{nodes}{peer}{short_name} = $short_nodename;
					$conf->{nodes}{me}{short_name}   = $short_hostname;
					logger($conf, $THIS_FILE, __LINE__, "nodes::me::hostname:   [$conf->{nodes}{me}{hostname}], nodes::me::short_name:   [$conf->{nodes}{me}{short_name}]", 2);
					logger($conf, $THIS_FILE, __LINE__, "nodes::peer::hostname: [$conf->{nodes}{peer}{hostname}], nodes::peer::short_name: [$conf->{nodes}{peer}{short_name}]", 2);
					logger($conf, $THIS_FILE, __LINE__, "- This peer's host name is: [$conf->{nodes}{peer}{hostname}].", 1);
				}
			}
			next;
		}
		if (($in_node) && ($line =~ /<\/clusternode>/))
		{
			# Not in a node anymore.
			$in_node = "";
		}
		if ($line =~ /<fencedevices>/)
		{
			$in_fencedevices = 1;
		}
		if (($in_fencedevices) && ($line =~ /<\/fencedevices>/))
		{
			$in_fencedevices = 0;
		}
		
		# Gather IPMI of virsh fence device info.
		if (($in_fencedevices) && ($line =~ /<fencedevice/))
		{
			my $name = "";;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 3);
			if ($line =~ /name="(.*?)"/)
			{
				$name = $1;
				logger($conf, $THIS_FILE, __LINE__, "name: [$name]", 2);
			}
			if (($name) && ($line =~ /ipaddr="(.*?)"/))
			{
				$conf->{fence_device}{$name}{ipaddr} = "-a ".$1;
				logger($conf, $THIS_FILE, __LINE__, "fence_device::${name}::ipaddr: [$conf->{fence_device}{$name}{ipaddr}]", 2);
			}
			if ($line =~ /agent="(.*?)"/)
			{
				$conf->{fence_device}{$name}{agent} = $1;
				logger($conf, $THIS_FILE, __LINE__, "fence_device::${name}::agent: [$conf->{fence_device}{$name}{agent}]", 2);
			}
			if (($name) && ($line =~ /login="(.*?)"/))
			{
				$conf->{fence_device}{$name}{login} = "-l ".$1;
				logger($conf, $THIS_FILE, __LINE__, "fence_device::${name}::login: [$conf->{fence_device}{$name}{login}]", 2);
			}
			if ($line =~ /passwd="(.*?)"/)
			{
				$conf->{fence_device}{$name}{passwd} = "-p ".$1;
				logger($conf, $THIS_FILE, __LINE__, "fence_device::${name}::passwd: [$conf->{fence_device}{$name}{passwd}]", 2);
			}
			if ($line =~ /passwd_script="(.*?)"/)
			{
				$conf->{fence_device}{$name}{passwd_script} = "-S ".$1;
				logger($conf, $THIS_FILE, __LINE__, "fence_device::${name}::passwd_script: [$conf->{fence_device}{$name}{passwd_script}]", 2);
			}
		}
		
		# Gather my IPMI fencing info.
		if (($in_node) && ($line =~ /ipmi/))
		{
			#print "in_node; line: [$line]\n";
			next if $line =~ /<method/;
			my $node;
			if (($in_node eq $conf->{nodes}{me}{hostname}))
			{
				$node = "me";
			}
			elsif (($in_node eq $conf->{nodes}{peer}{hostname}))
			{
				$node = "peer";
			}
			if ($line =~ /ipaddr="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{ipaddr} = "-a ".$1;
			}
			if ($line =~ /login="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{login} = "-l ".$1;
			}
			if ($line =~ /name="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{name} = $1;
			}
			if ($line =~ /passwd="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{passwd} = "-p ".$1;
			}
			if ($line =~ /passwd_script="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{passwd_script} = "-S ".$1;
			}
		}
		
		# Gather fence_virsh data, in case this is a test VM cluster
		if (($in_node) && ($line =~ /kvm/))
		{
			next if $line =~ /<method/;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 3);
			my $node;
			if (($in_node eq $conf->{nodes}{me}{hostname}))
			{
				$node = "me";
				logger($conf, $THIS_FILE, __LINE__, "node: [$node]", 2);
			}
			elsif (($in_node eq $conf->{nodes}{peer}{hostname}))
			{
				$node = "peer";
				logger($conf, $THIS_FILE, __LINE__, "node: [$node]", 2);
			}
			if ($line =~ /port="(.*?)"/)
			{
				$conf->{nodes}{$node}{virsh}{port} = "-n ".$1;
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::virsh::port: [$conf->{nodes}{$node}{virsh}{port}]", 2);
			}
			if ($line =~ /ipaddr="(.*?)"/)
			{
				$conf->{nodes}{$node}{virsh}{ipaddr} = "-a ".$1;
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::virsh::ipaddr: [$conf->{nodes}{$node}{virsh}{ipaddr}]", 2);
			}
			if ($line =~ /login="(.*?)"/)
			{
				$conf->{nodes}{$node}{virsh}{login} = "-l ".$1;
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::virsh::login: [$conf->{nodes}{$node}{virsh}{login}]", 2);
			}
			if ($line =~ /name="(.*?)"/)
			{
				$conf->{nodes}{$node}{virsh}{name} = $1;
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::virsh::name: [$conf->{nodes}{$node}{virsh}{name}]", 2);
			}
			if ($line =~ /passwd="(.*?)"/)
			{
				$conf->{nodes}{$node}{virsh}{passwd} = "-p ".$1;
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::virsh::passwd: [$conf->{nodes}{$node}{virsh}{passwd}]", 2);
			}
			if ($line =~ /passwd_script="(.*?)"/)
			{
				$conf->{nodes}{$node}{virsh}{passwd_script} = "-S ".$1;
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::virsh::passwd_script: [$conf->{nodes}{$node}{virsh}{passwd_script}]", 2);
			}
		}
		
		# The scripts I find here will be the daemons whose status I will check later to determine 
		# health.
		if ($line =~ /<script file="(.*?)"/)
		{
			my $script_path = $1;
			my $script_name = ($script_path =~ /.*?\/([\w-]+)$/)[0];
			logger($conf, $THIS_FILE, __LINE__, "script_path: [$script_path], script_name: [$script_name]", 3);
			$conf->{daemons}{$script_name} = $script_path;
			logger($conf, $THIS_FILE, __LINE__, "daemons::$script_name: [$conf->{daemons}{$script_name}]", 3);
			logger($conf, $THIS_FILE, __LINE__, "- Found a managed script service called: [$script_name].", 1);
			next;
		}
		
		# Any clusterfs will be checked to make sure they mounted
		# properly. If the 'device' is a symlink to a device mapper
		# device, it will resolve fine as the devices found by 'df'
		# will also be checked for symlinks and resolve to their
		# device mapper device as well.
		if (($line =~ /<clusterfs /) && ($line =~ /device=/))
		{
			my ($device)     = ($line =~ /device="(.*?)"/);
			my ($mountpoint) = ($line =~ /mountpoint="(.*?)"/);
			my ($clusterfs)  = ($line =~ /name="(.*?)"/);
			$conf->{cluster}{gfs2}{$clusterfs}{device}     = $device;
			$conf->{cluster}{gfs2}{$clusterfs}{mountpoint} = $mountpoint,
			logger($conf, $THIS_FILE, __LINE__, "cluster::gfs2::${clusterfs}::device: [$conf->{cluster}{gfs2}{$clusterfs}{device}], cluster::gfs2::${clusterfs}::mountpoint: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 3);
			logger($conf, $THIS_FILE, __LINE__, "- Found a clustered file system called: [$clusterfs] which mounts at: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}].", 1);
			next;
		}
		
		# Read the server details. The listed failover domain will be
		# compared against the preferred nodes in the domain to find
		# the preferred host.
		if ($line =~ /<vm /)
		{
			#<vm domain="primary_n01" name="vm07-rhel6"
			my ($name)       =  ($line =~ / name="(.*?)"/);
			my ($domain)     =  ($line =~ / domain="(.*?)"/);
			my ($definition) =  ($line =~ / path="(.*?)"/);
			$definition      .= "/${name}.xml";
			$definition      =~ s/\/\//\//g;
			$conf->{vm}{$name}{domain}     = $domain;
			$conf->{vm}{$name}{definition} = $definition;
			logger($conf, $THIS_FILE, __LINE__, "vm::${name}::domain: [$conf->{vm}{$name}{domain}], vm::${name}::definition: [$conf->{vm}{$name}{definition}]", 3);
			logger($conf, $THIS_FILE, __LINE__, "- Found a server named: [$name] in the failover domain: [$conf->{vm}{$name}{domain}].", 1);
			next;
		}
		
		# This parses the failover domains in a manner that retains
		# their set priority ordering.
		if ($line =~ /<failoverdomain .*?name="(.*?)"/)
		{
			$in_domain = $1;
			logger($conf, $THIS_FILE, __LINE__, "in_domain: [$in_domain]", 3);
			logger($conf, $THIS_FILE, __LINE__, "- Found the failover domain named: [$in_domain].", 1);
			next;
		}
		if ($in_domain)
		{
			if ($line =~ /<\/failoverdomain>/)
			{
				$in_domain = "";
				logger($conf, $THIS_FILE, __LINE__, "Exiting domain; in_domain: [$in_domain]", 3);
				next;
			}
			else
			{
				if ($line =~ /<failoverdomainnode /)
				{
					my ($node)     = ($line =~ / name="(.*?)"/);
					my ($priority) = ($line =~ / priority="(.*?)"/);
					   $priority   = 1 if not $priority;
					$conf->{failoverdomain}{$in_domain}{priority}{$priority}{node} = $node;
					logger($conf, $THIS_FILE, __LINE__, "failoverdomain::${in_domain}::priority::${priority}::node: [$conf->{failoverdomain}{$in_domain}{priority}{$priority}{node}]", 4);
					logger($conf, $THIS_FILE, __LINE__, "- Node named: [$node] has priority: [$priority].", 1);
					next;
				}
			}
		}
		
	}
	close $file_handle;
	
	foreach my $node (sort {$a cmp $b} keys %{$conf->{nodes}})
	{
		logger($conf, $THIS_FILE, __LINE__, "node: [$node]", 2);
		my $fence = "fence_ipmilan";
		my $type  = "ipmi";
		if (not $conf->{nodes}{$node}{ipmi})
		{
			$type = "virsh";
		}
		logger($conf, $THIS_FILE, __LINE__, "type: [$type]", 2);
		foreach my $key (sort {$a cmp $b} keys %{$conf->{nodes}{$node}{$type}})
		{
			logger($conf, $THIS_FILE, __LINE__, "key: [$key]", 3);
			if ($key eq "name")
			{
				my $name = $conf->{nodes}{$node}{$type}{$key};
				logger($conf, $THIS_FILE, __LINE__, "name: [$name]", 2);
				foreach my $key (sort {$a cmp $b} keys %{$conf->{fence_device}{$name}})
				{
					logger($conf, $THIS_FILE, __LINE__, "key: [$key], fence_device::${name}::${key}: [$conf->{fence_device}{$name}{$key}]", 2);
					if ($key eq "agent")
					{
						logger($conf, $THIS_FILE, __LINE__, "fence_device::${name}::${key}: [$conf->{fence_device}{$name}{$key}]", 2);
						if ($conf->{fence_device}{$name}{$key} ne "fence_ipmilan")
						{
							logger($conf, $THIS_FILE, __LINE__, ">> fence: [$fence]", 3);
							$fence =~ s/^fence_ipmilan/$conf->{fence_device}{$name}{$key}/;
							logger($conf, $THIS_FILE, __LINE__, "<< fence: [$fence]", 3);
						}
					}
					else
					{
						logger($conf, $THIS_FILE, __LINE__, ">> fence: [$fence]", 3);
						$fence .= " $conf->{fence_device}{$name}{$key}";
						logger($conf, $THIS_FILE, __LINE__, "<< fence: [$fence]", 3);
					}
				}
			}
			elsif ($key eq "agent")
			{
				logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::${type}::${key}: [$conf->{nodes}{$node}{$type}{$key}]", 2);
				if ($conf->{nodes}{$node}{$type}{$key} ne "fence_ipmilan")
				{
					$fence =~ s/^fence_ipmilan /$conf->{nodes}{$node}{$type}{$key} /;
					logger($conf, $THIS_FILE, __LINE__, "fence: [$fence]", 2);
				}
			}
			else
			{
				$fence .= " $conf->{nodes}{$node}{$type}{$key}";
				logger($conf, $THIS_FILE, __LINE__, "fence: [$fence]", 2);
			}
		}
		$conf->{nodes}{$node}{fence} = $fence;
		logger($conf, $THIS_FILE, __LINE__, "nodes::${node}::fence: [$conf->{nodes}{$node}{fence}]", 2);
	}
	
	return(0);
}

# Read the hostname. This is used shortly to tell which cluster node I am and
# which my peer is.
sub read_hostname
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "read_hostname()", 3);
	
	my $file_handle = IO::Handle->new();
	my $shell_call  = "$conf->{path}{hostname}";
	logger($conf, $THIS_FILE, __LINE__, "shell_call: [$shell_call]", 3);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		$conf->{nodes}{me}{hostname} = $_;
		logger($conf, $THIS_FILE, __LINE__, "- My hostname is: [$conf->{nodes}{me}{hostname}]", 1);
	}
	close $file_handle;
	
	# If I am node 02, sleep for 1 minutes to help avoid conflicting with
	# the startup being performed by node 1.
	if (($conf->{nodes}{me}{hostname} =~ /n02/)    || 
	    ($conf->{nodes}{me}{hostname} =~ /n2/)     || 
	    ($conf->{nodes}{me}{hostname} =~ /node02/) || 
	    ($conf->{nodes}{me}{hostname} =~ /node2/))
	{
		if ($conf->{switches}{'no-sleep'})
		{
			logger($conf, $THIS_FILE, __LINE__, "- I am not node 2, but the delay has been bypassed, so I will proceed immediately.", 1);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- I am not node 1, so I will sleep for: [$conf->{sys}{node2_sleep}] seconds to help avoid race conditions.", 1);
			sleep $conf->{sys}{node2_sleep};
		}
	}
	
	return($conf->{nodes}{me}{hostname});
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			elsif (($argument eq "start") or ($argument eq "stop") or ($argument eq "status"))
			{
				$conf->{switches}{$argument} = 1;
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	if ($conf->{sys}{debug})
	{
		foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}})
		{
			print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n";
		}
	}
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	my $fh = IO::Handle->new();
	my $sc = "$conf->{path}{striker_config}";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		next if $line !~ /=/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		_make_hash_reference($conf, $var, $val);
	}
	$fh->close();
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Safe Anvil! Start

DESCRIPTION

This program starts the Anvil! high-availability stack and hosted servers 
automatically when the system boots, *if* to connection to the peer is
determined to be safe. It checks several things before starting the servers
and will abort if any problems are found, avoiding the risk of a fence 
loop[1].

It works by temporarily enabling the program on boot when enabled. This way,
on boot, striker.conf is edited to enable the program. The next time cron
runs the program, it will start the stack and then it disables itself when
done. This prevents a problem with the startup from blocking the OS boot
process.

1. https://alteeve.ca/w/Fence_Loop


SWITCHES

 --abort

	This kills any running instance of $THIS_FILE.
	It also prevents it from running again for this session. 
	
	NOTE: It does NOT disable $THIS_FILE!
	      If it was enabled, it will run on the next time the node boots.

 --debug

	This prints all log messages.

 --disable

	This deletes the run-level 3 symlink. Without this, the software stack
	will not run on boot.

 --enable

	Enables the program by creating a run-level 3 symlink. When the OS
	boots, it calls all (linked) scripts and passes 'start' to them. This
	program reacts to being passed 'start' by setting:
	
	tools::safe_anvil_start::enabled = 1
	
	In $conf->{path}{striker_config} and then exits. This allows the OS
	boot process to complete without delay. In the root user's cron table,
	this program is set to run every five minutes. Being now enabled, it
	will run and start the software stack and servers and, as the last 
	step, change 'tools::safe_anvil_start::enabled' back to '0' to prevent
	it running again (until the next boot).

 --force

	This will cause the program to run, even if it is disabled in
	$conf->{path}{striker_config}.

 -h, -?, --help

	Show this dialoge and exit.

 --no-sleep

	Normally, if the node this runs on is determined to be node 2, it will 
	sleep for $conf->{sys}{node2_sleep} seconds before proceeding. This is
	to give the peer node time to get the software stack started without
	getting into a race condition. This switch disabled that delay.

  start

	This enables safe_anvil_start in $conf->{path}{striker_config}. Please
	see '--enable' above for details.

                  
SUPPORT

https://alteeve.ca/w/Support

                                                              Alteeve's Niche!
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}
