#!/usr/bin/perl
#
# This will automatically start the Anvil!'s cluster stack on boot.
# 
# If you don't know what an Anvil! is, see:
# - https://alteeve.ca/w/AN!Cluster_Tutorial_2
#
# Exit Codes:
# 0  - OK
# 1  - Couldn't find peer's host name.
# 2  - Daemon status returned unhandled return code.
# 3  - This node is not healthy, but the peer node is healthy. Exiting to let
#      the peer's 'safe_anvil_start' boot the servers.
# 4  - Both nodes have either failed services, badly mounted cluster
#      filesystems or a combination of the two.
# 5  - Local node is not in a failed state, but it timed out waiting to become
#      healthy.
# 6  - Failed to connect to my peer within the timeout. To proceed would risk a
#      fence loop.
# 7  - Failed to find a daemon's init.d script
# 
# Bugs:
# - It would seem that, in some case (which I don't yet have a reproducer for),
#   there is a timing-based conflict starting cman/rgmanager. When this
#   happens, cman or drbd (via rgmanager failing to start) will lead to a fence
#   of the effected peer.
# - If /shared's dm device differs on the two nodes, VMs won't start is both
#   nodes will think the other is not healthy.
#
# TODO:
# - Check the health status file and do not initiate start up until the health
#   is "OK" on at least one node. When deciding which node to power a server
#   on, check if one node is "warning" and do not use it if so.
#

use strict;
use warnings;
use IO::Handle;
use File::Basename;

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;
$| = 1;

my $conf =  {
	cluster		=>	{
		name		=>	"",
	},
	daemons		=>	{
		cman		=>	"/etc/init.d/cman",
		rgmanager	=>	"/etc/init.d/rgmanager",
	},
	drbd		=>	{},
	failoverdomain	=>	{},
	lvs		=>	{},
	nodes		=>	{
		me		=>	{
			clusterfs	=>	{},
			daemon		=>	{},
			healthy		=>	0,	# 0 == not ready, 1 == healthy, 2 == fatal error, won't run Servers.
			hostname	=>	"",
			mounts		=>	{},
			short_name	=>	"",
		},
		peer		=>	{
			clusterfs	=>	{},
			daemon		=>	{},
			healthy		=>	0,
			hostname	=>	"",
			is_up		=>	0,
			mounts		=>	{},
			short_name	=>	"",
		}
	},
	path		=>	{
		clustat		=>	"/usr/sbin/clustat",
		cluster_conf	=>	"/etc/cluster/cluster.conf",
		clusvcadm	=>	"/usr/sbin/clusvcadm",
		df		=>	"/bin/df",
		drbdadm		=>	"/sbin/drbdadm",
		echo		=>	"/bin/echo",
		hostname	=>	"/bin/hostname",
		ls		=>	"/bin/ls",
		lvs		=>	"/sbin/lvs",
		ssh		=>	"/usr/bin/ssh",
	},
	services	=>	{},
	sys		=>	{
		debug		=>	1,
		node2_sleep	=>	120,
		bad_ipmi	=>	0,
	},
	timeouts	=>	{
		wait_for_drbd_sync	=>	300,	# Roughly 5 minutes.
		wait_for_node_health	=>	300,	# Roughly 5 minutes.
		wait_for_peer		=>	600,	# Roughly 10 minutes.
	},
	vms		=>	{},
};

logger($conf, $THIS_FILE, __LINE__, "\n-=] Safe Anvil! Start is now running.", 0);
read_hostname($conf);
read_cluster_conf($conf);

logger($conf, $THIS_FILE, __LINE__, "- Wait up to: [$conf->{timeouts}{wait_for_peer}] seconds to connect to my peer.", 1);
for (0..$conf->{timeouts}{wait_for_peer})
{
	$conf->{nodes}{peer}{is_up} = check_peer_connection($conf);
	if ($conf->{nodes}{peer}{is_up})
	{
		# Peer is up.
		logger($conf, $THIS_FILE, __LINE__, "- Peer is up!", 1);
		last;
	}
	sleep 1;
};

# If the peer wasn't reachable, then the only safe option is to exit.
if (not $conf->{nodes}{peer}{is_up})
{
	logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to peer within timeout.", 0);
	logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Proceeding would risk a fence loop. Exiting.", 0);
	exit(6);
}

# Check the state of the daemons.
check_daemons($conf);

# Now the fun starts!
start_daemon_simultaneously($conf, "cman");
sleep 2;	# This may not be needed, but is here just in case a race
		# condition is possible.
start_daemon_simultaneously($conf, "rgmanager");

# Check the health of each node's daemons, clusterfs mounts and services.
check_node_health($conf);

# Watches DRBD to see if both nodes go UpToDate within a reasonable amount of
# time.
wait_for_drbd_sync($conf);

# If I am still alive, I am healthy. Time to start the servers!
start_servers($conf);

# All done.
logger($conf, $THIS_FILE, __LINE__, "- Finished, exiting.\n", 1);
exit(0);

###############################################################################
# Here be Functions!                                                          #
###############################################################################

# This uses the information from cluster.conf to determine how to check the
# peer's power state and power it on if needed.
sub power_on_peer
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - power_on_peer();", 3);
	
	#print "nodes::me::fence:   [$conf->{nodes}{me}{fence}]\n";
	#print "nodes::peer::fence: [$conf->{nodes}{peer}{fence}]\n";
	my $boot_peer   = 0;
	my $file_handle = IO::Handle->new();
	my $shell_call  = "$conf->{nodes}{peer}{fence} -o status; echo rc:\$?";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 3);
		if ($line =~ /rc:(\d+)/)
		{
			my $rc = $1;
			if ($rc eq "0")
			{
				# Already running.
				logger($conf, $THIS_FILE, __LINE__, "- The peer node is already running, no need to boot it.", 3);
			}
			elsif ($rc eq "1")
			{
				# Failed to reach the peer.
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Failed to reach the peer's IPMI interface, unable to determine it's power state.", 1);
				$conf->{sys}{bad_ipmi} = 1;
			}
			elsif ($rc eq "2")
			{
				# This should return '2'
				logger($conf, $THIS_FILE, __LINE__, "- The peer node is off, it will be booted.", 1);
				$boot_peer = 1;
			}
		}
	}
	close $file_handle;
	
	if ($boot_peer)
	{
		my $shell_call  = "$conf->{nodes}{peer}{fence} -o on; echo rc:\$?";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 3);
			if ($line =~ /rc:(\d+)/)
			{
				my $rc = $1;
				if ($rc eq "0")
				{
					# Already running.
					logger($conf, $THIS_FILE, __LINE__, "- The peer node was booted successfully.", 1);
				}
			}
		}
		close $file_handle;
	}
	
	return(0);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message, $level) = @_;
	$level = 0 if not $level;
	
	# Return if the log level is too low.
	return(0) if $level > $conf->{sys}{debug};
	
	# Print the message to the screen.
	# If the level is 0 or 1, don't print the file and line numnber
	if ($level < 2)
	{
		$message =~ s/^; //;
		print "$message\n";
	}
	else
	{
		print "$file $line_number; $message\n";
	}
	
	# We split on new-lines so that multi-line message render better in
	# syslog.
	my $is_debug = $message =~ /\[ Debug \]/ ? 1 : 0;
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		if (($is_debug) && ($line !~ /\[ Debug \]/))
		{
			$line = "[ Debug ]   $line";
		}
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "logger", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $THIS_FILE $line]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

# This gets the list of physical volume(s) backing each logical volume. This is
# needed to check the DRBD connection and disk state when deciding later which
# node to start the server on.
sub get_pvs_under_lv
{
	my ($conf) = @_;
	
	my @pvs;
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{lvs} --separator ' ' -o lv_name,vg_name,lv_path,devices";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		if ($line =~ / (.*?) (.*?) (\/dev\/.*?) (\/dev\/.*)/)
		{
			my $lv_name = $1;
			my $vg_name = $2;
			my $lv_path = $3;
			my $pvs     = $4;
			# PVs are listed with their starting extend in brackets
			# which we don't care about.
			$pvs =~ s/\(.*?\)//g;
			# If the LV spans PVs, they will be comma-separated.
			$conf->{lvs}{$lv_path}{pvs} = $pvs;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - lvs::${lv_path}::pvs: [$conf->{lvs}{$lv_path}{pvs}]", 2);
		}
	}
	close $file_handle;
	
	return(0)
}

# This translates a DRBD resource name to it's block device path.
sub translate_drbd_resource_to_device_path
{
	my ($conf, $resource) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - translate_drbd_resource_to_device_path(); resource: [$resource]", 3);
	
	# This 'drbdadm' switch is in 'drbdadm hidden-commands'.
	my $device_path = "";
	my $file_handle = IO::Handle->new();
	my $shell_call  = "$conf->{path}{drbdadm} sh-dev $resource";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		if ($line =~ /^(\/dev\/.*)/)
		{
			$device_path = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device_path: [$device_path]", 2);
		}
	}
	close $file_handle;
	
	return($device_path);
}

# This reads the current state of DRBD resource. This is used later to help
# decide which node to start a server on.
sub read_drbd_state
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_drbd_state()", 3);
	
	my $device_path = "";
	my $file_handle = IO::Handle->new();
	#my $shell_call  = "/etc/init.d/drbd status";
	my $shell_call  = "cat /proc/drbd";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		my $line = $_;
		next if not $line;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		if ($line =~ /(\d+): cs:(.*?) ro:(.*?)\/(.*?) ds:(.*?)\/(.*?) /)
		{
			my $minor_number     = $1;
			my $connection_state = $2;
			my $me_role          = $3;
			my $peer_role        = $4;
			my $me_disk_state    = $5;
			my $peer_disk_state  = $6;
			my $resource_name    = "r".$minor_number;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - minor_number: [$minor_number], resource_name: [$resource_name], connection_state: [$connection_state], me_role: [$me_role], peer_role: [$peer_role], me_disk_state: [$me_disk_state], peer_disk_state: [$peer_disk_state]", 2);
			   ($device_path)    = translate_drbd_resource_to_device_path($conf, $resource_name);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device_path: [$device_path]", 2);
			$conf->{drbd}{$device_path}{minor_number}     = $minor_number;
			$conf->{drbd}{$device_path}{resource_name}    = $resource_name;
			$conf->{drbd}{$device_path}{connection_state} = $connection_state;
			$conf->{drbd}{$device_path}{me}{role}         = $me_role;
			$conf->{drbd}{$device_path}{me}{disk_state}   = $me_disk_state;
			$conf->{drbd}{$device_path}{peer}{role}       = $peer_role;
			$conf->{drbd}{$device_path}{peer}{disk_state} = $peer_disk_state;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::minor_number:     [$conf->{drbd}{$device_path}{minor_number}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::resource_name:    [$conf->{drbd}{$device_path}{resource_name}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::connection_state: [$conf->{drbd}{$device_path}{connection_state}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::me::role:         [$conf->{drbd}{$device_path}{me}{role}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::me::disk_state:   [$conf->{drbd}{$device_path}{me}{disk_state}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::peer::role:       [$conf->{drbd}{$device_path}{peer}{role}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::peer::disk_state: [$conf->{drbd}{$device_path}{peer}{disk_state}]", 2);
		}
		if ($line =~ /finish: (\d+):(\d+):(\d+) speed/)
		{
			my $hours     = $1;
			my $minutes   = $2;
			my $seconds   = $3;
			my $sync_time = ($hours * 3600) + ($minutes * 60) + $seconds;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - hours: [$hours], minutes: [$minutes], seconds: [$seconds], sync_time: [$sync_time]", 2);
			if (not $device_path)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - device_path not set!", 0);
			}
			else
			{
				$conf->{drbd}{$device_path}{sync_time} = $sync_time;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::sync_time: [$conf->{drbd}{$device_path}{sync_time}]", 2);
			}
		}
	}
	close $file_handle;
	
	return(0);
}

# This starts by calling 'drbdadm adjust all' on both noes, then waiting up to
# the 'wait_for_drbd_sync' seconds for both to go UpToDate.
sub wait_for_drbd_sync
{
	my ($conf) = @_;
	
	# Call 'drbdadm adjust all';
	foreach my $node ("me", "peer")
	{
		next if (($node eq "peer") && ($conf->{nodes}{peer}{healthy} == 2));
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - node: [$node]", 2);
		my $file_handle = IO::Handle->new();
		my $shell_call  = "$conf->{path}{drbdadm} adjust all";
		if ($node eq "peer")
		{
			$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{drbdadm} adjust all\"";
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		}
		close $file_handle;
	}
	
	# Now loop for up to 'wait_for_drbd_sync' seconds
	my $all_uptodate = 0;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - all_uptodate: [$all_uptodate], timeouts::wait_for_drbd_sync: [$conf->{timeouts}{wait_for_drbd_sync}]", 3);
	logger($conf, $THIS_FILE, __LINE__, "- Waiting up to: [$conf->{timeouts}{wait_for_drbd_sync}] seconds for DRBD to become 'UpToDate' on both nodes.", 1);
	for (0..$conf->{timeouts}{wait_for_drbd_sync})
	{
		read_drbd_state($conf);
		
		$all_uptodate = 1;
		foreach my $device_path (sort {$a cmp $b} keys %{$conf->{drbd}})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device_path: [$device_path]", 2);
			my $me_role         = $conf->{drbd}{$device_path}{me}{role};
			my $me_disk_state   = $conf->{drbd}{$device_path}{me}{disk_state};
			my $peer_role       = $conf->{drbd}{$device_path}{peer}{role};
			my $peer_disk_state = $conf->{drbd}{$device_path}{peer}{disk_state};
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - me_role: [$me_role], me_disk_state: [$me_disk_state], peer_role: [$peer_role], peer_disk_state: [$peer_disk_state]", 2);
			if (lc($me_role) ne "primary")
			{
				$all_uptodate = 0;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Local DRBD device: [$device_path]'s role is: [$me_role], will wait for it to become 'Primary'", 2);
			}
			if (lc($peer_role) ne "primary")
			{
				$all_uptodate = 0;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Peer's DRBD device: [$device_path]'s role is: [$peer_role], will wait for it to become 'Primary'", 2);
			}
			next if ($conf->{nodes}{peer}{healthy} == 2);
			if (lc($me_disk_state) ne "uptodate")
			{
				# If the resync time is longer than the max
				# wait time, proceed with startup.
				if (($conf->{drbd}{$device_path}{sync_time}) && ($conf->{drbd}{$device_path}{sync_time} > $conf->{timeouts}{wait_for_drbd_sync}))
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Local DRBD device: [$device_path]'s disk state is: [$me_disk_state].", 2);
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - It will take an estimated: [$conf->{drbd}{$device_path}{sync_time}] seconds to become 'UpToDate', which is longer than the maximum wait time of: [$conf->{timeouts}{wait_for_drbd_sync}].", 2);
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - As such, there is no point waiting.", 2);
				}
				else
				{
					$all_uptodate = 0;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Local DRBD device: [$device_path]'s disk state is: [$me_disk_state], will wait for it to become 'UpToDate'.", 2);
				}
			}
			if (lc($peer_disk_state) ne "uptodate")
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - drbd::${device_path}::sync_time: [$conf->{drbd}{$device_path}{sync_time}], timeouts::wait_for_drbd_sync: [$conf->{timeouts}{wait_for_drbd_sync}].", 2);
				if (($conf->{drbd}{$device_path}{sync_time}) && ($conf->{drbd}{$device_path}{sync_time} > $conf->{timeouts}{wait_for_drbd_sync}))
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Peer's DRBD device: [$device_path]'s disk state is: [$me_disk_state].", 2);
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - It will take an estimated: [$conf->{drbd}{$device_path}{sync_time}] seconds to become 'UpToDate', which is longer than the maximum wait time of: [$conf->{timeouts}{wait_for_drbd_sync}].", 2);
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - As such, there is no point waiting.", 2);
				}
				else
				{
					$all_uptodate = 0;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Peer's DRBD device: [$device_path]'s disk state is: [$peer_disk_state], will wait for it to become 'UpToDate'.", 2);
				}
			}
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - all_uptodate: [$all_uptodate]", 2);
		if ($all_uptodate)
		{
			logger($conf, $THIS_FILE, __LINE__, "- Ready!", 1);
			last;
		}
		sleep 1;
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - all_uptodate: [$all_uptodate].", 1);
	if ($all_uptodate)
	{
		if ($conf->{nodes}{peer}{healthy} == 2)
		{
			logger($conf, $THIS_FILE, __LINE__, "- All of my resource are Primary and UpToDate.", 1);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- All of DRBD resource on both nodes are Primary and UpToDate.", 1);
		}
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "- Timeout expired.", 1);
		if ($conf->{nodes}{peer}{healthy} == 2)
		{
			logger($conf, $THIS_FILE, __LINE__, "- At least one of my DRBD resources is not Primary or UpToDate, peer is unhealthy.", 1);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- All of my resource are UpToDate, but at least one of my peer's resources is not yet Primary or UpToDate.", 1);
		}
	}
	
	return(0);
}

# This reads the XML definition file for a VM. Specifically, we're looki
sub read_vm_definition
{
	my ($conf, $name, $definition) = @_;
	logger($conf, $THIS_FILE, __LINE__, "- read_vm_definition(); server name: [$name], definition: [$definition]", 3);
	
	my $read_ok = 1;
	if (not -e $definition)
	{
		$read_ok = 0;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - server name: [$name]'s definition: [$definition] file doesn't exist!", 2);
	}
	elsif (not -r $definition)
	{
		$read_ok = 0;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - server name: [$name]'s definition: [$definition] file exists but isn't readable!", 2);
	}
	if ($read_ok)
	{
		my $in_disk = 0;
		my $file_handle = IO::Handle->new();
		my $shell_call = "$definition";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - File read: [$shell_call]", 2);
		open ($file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			# I don't care about this output
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 3);
			
			if ($line =~ /<disk .*?device='disk'/)
			{
				# TODO: Make this check that the "inserted" ISO
				# actually exists, and if not, remove the ISO
				# from the definition file as not existing will
				# block boot.
				next if $line =~ /device='cdrom'/;
				$in_disk = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Going in_disk: [$in_disk]", 3);
				next;
			}
			if ($in_disk)
			{
				if ($line =~ /<\/disk>/)
				{
					$in_disk = 0;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Exiting in_disk: [$in_disk]", 3);
					next;
				}
				if ($line =~ /<source dev='(.*?)'/)
				{
					my $lv_path = $1;
					push @{$conf->{vms}{$name}{lv_path}}, $lv_path;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Adding lv_path: [$lv_path] to array vms::${name}::lv_path. Array contains: [".@{$conf->{vms}{$name}{lv_path}}."] disk(s).", 2);
				}
			}
		}
		close $file_handle;
	}
	
	return($read_ok)
}

# This checks the health of the storage behind each server and decides where to
# boot each server.
sub start_servers
{
	my ($conf) = @_;
	
	# Get a list of PV(s) under each LV.
	get_pvs_under_lv($conf);
	
	# Now decide where to start each server.
	foreach my $name (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Reading server: [$name]'s definition file: [$conf->{vm}{$name}{definition}].", 2);
		logger($conf, $THIS_FILE, __LINE__, "- Starting server: [$name] (current state: [$conf->{vm}{$name}{'state'}], current host: [$conf->{vm}{$name}{host}]).", 1);
		if (lc($conf->{vm}{$name}{'state'}) eq "started")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Already running on: [$conf->{vm}{$name}{host}].", 1);
			next;
		}
		read_vm_definition($conf, $name, $conf->{vm}{$name}{definition});
		
		my $preferred_node = "";
		my $in_domain      = $conf->{vm}{$name}{domain};
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - in_domain: [$in_domain].", 2);
		foreach my $priority (sort {$a cmp $b} keys %{$conf->{failoverdomain}{$in_domain}{priority}})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - failoverdomain::${in_domain}::priority::${priority}::node: [$conf->{failoverdomain}{$in_domain}{priority}{$priority}{node}].", 2);
			$preferred_node = $conf->{failoverdomain}{$in_domain}{priority}{$priority}{node};
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - preferred_node: [$preferred_node].", 2);
			last;
		}
		logger($conf, $THIS_FILE, __LINE__, "- Preferred node is: [$preferred_node].", 1);
		
		my $preferred_node_is = "me";
		my $backup_node_is    = "peer";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - preferred_node: [$preferred_node], nodes::peer::hostname: [$conf->{nodes}{peer}{hostname}].", 2);
		if ($preferred_node eq $conf->{nodes}{peer}{hostname})
		{
			$preferred_node_is = "peer";
			$backup_node_is    = "me";
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - preferred_node_is: [$preferred_node_is], backup_node_is: [$backup_node_is].", 2);
		
		# Make sure I can boot the server on the preferred host.
		my $can_boot_on_preferred = 1;
		my $can_boot_on_backup    = 1;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${preferred_node_is}::healthy: [$conf->{nodes}{$preferred_node_is}{healthy}].", 2);
		if ($conf->{nodes}{$preferred_node_is}{healthy} == 1)
		{
			# Loop through each LV attached to this server, determine which
			# PVs are under it and make sure it/they are UpToDate.
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Checking storage health of preferred node: [$preferred_node_is ($conf->{nodes}{$preferred_node_is}{hostname})].", 2);
			foreach my $lv_path (sort {$a cmp $b} @{$conf->{vms}{$name}{lv_path}})
			{
				my $pvs = $conf->{lvs}{$lv_path}{pvs};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - lv_path: [$lv_path], pvs: [$pvs]", 2);
				foreach my $device_path (split/,/, $pvs)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device_path: [$device_path]", 2);
					my $role       = $conf->{drbd}{$device_path}{$preferred_node_is}{role};
					my $disk_state = $conf->{drbd}{$device_path}{$preferred_node_is}{disk_state};
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - preferred_node_is: [$preferred_node_is], role: [$role], disk_state: [$disk_state]", 2);
					if ((lc($role) ne "primary") or (lc($disk_state) ne "uptodate"))
					{
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Can't boot on preferred node.", 2);
						logger($conf, $THIS_FILE, __LINE__, "- I can not boot this server on the preferred node, storage isn't ready.", 1);
						$can_boot_on_preferred = 0;
					}
				}
			}
		}
		if (($conf->{nodes}{$backup_node_is}{healthy} == 1) && (not $can_boot_on_preferred))
		{
			# Peer isn't healthy, make sure I am  
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Checking storage health of backup node: [$backup_node_is] ($conf->{nodes}{$backup_node_is}{hostname})].", 2);
			foreach my $lv_path (sort {$a cmp $b} @{$conf->{vms}{$name}{lv_path}})
			{
				my $pvs = $conf->{lvs}{$lv_path}{pvs};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - lv_path: [$lv_path], pvs: [$pvs]", 2);
				foreach my $device_path (split/,/, $pvs)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device_path: [$device_path]", 2);
					my $role       = $conf->{drbd}{$device_path}{$backup_node_is}{role};
					my $disk_state = $conf->{drbd}{$device_path}{$backup_node_is}{disk_state};
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - backup_node_is: [$backup_node_is], role: [$role], disk_state: [$disk_state]", 2);
					if ((lc($role) ne "primary") or (lc($disk_state) ne "uptodate"))
					{
						logger($conf, $THIS_FILE, __LINE__, "- I can not boot this server on the backup node, storage isn't ready.", 1);
						$can_boot_on_backup = 0;
					}
				}
			}
		}
		
		# Ok, start!
		if ((not $can_boot_on_preferred) && (not $can_boot_on_backup))
		{
			logger($conf, $THIS_FILE, __LINE__, "- Unable to boot this server, skipping it.", 1);
		}
		else
		{
			my $file_handle = IO::Handle->new();
			my $shell_call  = "$conf->{path}{clusvcadm} -e vm:$name -m $preferred_node";
			if ($can_boot_on_preferred)
			{
				my $preferred_node = $conf->{nodes}{$preferred_node_is}{hostname};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Starting server: [$name] on the preferred node: [$preferred_node].", 2);
				logger($conf, $THIS_FILE, __LINE__, "- Ready to start!", 1);
			}
			elsif ($can_boot_on_backup)
			{
				my $backup_node = $conf->{nodes}{$backup_node_is}{hostname};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Starting server: [$name] on the backup node: [$backup_node].", 2);
				$shell_call = "$conf->{path}{clusvcadm} -e vm:$name -m $backup_node";
				logger($conf, $THIS_FILE, __LINE__, "- Starting server on backup node.", 1);
			}
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
			}
			close $file_handle;
			logger($conf, $THIS_FILE, __LINE__, "- Started!", 1);
		}
	}
	
	return(0);
}

# This checks to see if a file is a symlink or not. If so, it returns the
# target.
sub check_if_symlink
{
	my ($conf, $file, $node) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check_if_symlink(); file: [$file], node: [$node]", 3);
	my $target = "";
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{ls} -l $file";
	if ($node eq "peer")
	{
		$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{ls} -l $file\"";
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		if ($line =~ /$file\s->\s(.*)/)
		{
			$target = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - target: [$target]", 2);
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - target: [$target]", 4);
	if ($target =~ /^\.\.\//)
	{
		my $path = dirname $file;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - file: [$file], path: [$path], target: [$target]", 2);
		while ($target =~ /^\.\.\//)
		{
			$path   =  dirname $path;
			$target =~ s/^\.\.\///;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - target: [$target], path: [$path]", 2);
		}
		$target =  $path."/".$target;
		$target =~ s/\/\//\//g;
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - target: [$target]", 2);
	return ($target);
}

# This calls 'clustat' and checks to make sure no services are in a 'failed'
# state.
sub check_clustat
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check_clustat()", 4);
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{clustat}";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		if ($line =~ /service:(.*?)\s(.*?)\s(.*)/)
		{
			my $service = $1;
			my $host    = $2;
			my $state   = $3;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - service: [$service], host: [$host], state: [$state]", 2);
			$conf->{services}{$service}{host}    = $host;
			$conf->{services}{$service}{'state'} = $state;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - service::${service}::host: [$conf->{services}{$service}{host}], service::${service}::state: [$conf->{services}{$service}{state}]", 2);
		}
		if ($line =~ /vm:(.*?)\s(.*?)\s(.*)/)
		{
			my $name  = $1;
			my $host  = $2;
			my $state = $3;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - name: [$name], host: [$host], state: [$state]", 2);
			
			$conf->{vm}{$name}{host}    = $host;
			$conf->{vm}{$name}{'state'} = $state;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - vm::${name}::host: [$conf->{vm}{$name}{host}], vm::${name}::state: [$conf->{vm}{$name}{'state'}]", 2);
		}
	}
	close $file_handle;
	
	return(0);
}

# This calls 'df -P' and parses the output.
sub read_df
{
	my ($conf, $node) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_df(); node: [$node]", 3);
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{df} -P";
	if ($node eq "peer")
	{
		$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{df} -P\"";
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 3);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		next if ($line !~ /^\//);
		if ($line =~ /^(\/.*?)\s.*?(\/.*)/)
		{
			my $device     = $1;
			my $mountpoint = $2;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device], mountpoint: [$mountpoint]", 2);
			$conf->{nodes}{$node}{mounts}{$device} = $mountpoint;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${node}::mounts::${device}: [$conf->{nodes}{$node}{mounts}{$device}]", 2);
		}
	}
	close $file_handle;
	
	# I need to get the device-mapper name for the mounts, if there is one,
	# as the LVs behind the gfs2 partitions often display in 'df' 
	# differently that is listed in cluster.conf'.
	foreach my $device (sort {$a cmp $b} keys %{$conf->{nodes}{$node}{mounts}})
	{
		my $mountpoint = $conf->{nodes}{$node}{mounts}{$device};
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Checking if: [$device], mounted at: [$mountpoint] is a symlink", 2);
		my ($target) = check_if_symlink($conf, $device, $node);
		if ($target)
		{
			$conf->{nodes}{$node}{mounts}{$target} = $mountpoint;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${node}::mounts::${target}: [$conf->{nodes}{$node}{mounts}{$target}]", 2);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${node}::mounts::${device}, mounted at: [$conf->{nodes}{$node}{mounts}{$device}], is *not* a symlink", 2);
		}
	}
	
	return(0);
}

# This will wait for a period of time waiting for daemons and the gfs2 
# partition started by rgmanager services to come online. If a daemon is not
# up after the timeout, or goes into a failed state, the node will not be a 
# host candidate for servers.
sub check_node_health
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check_node_health()", 3);
	
	logger($conf, $THIS_FILE, __LINE__, "- Waiting up to: [$conf->{timeouts}{wait_for_node_health}] seconds for the nodes to become healthy.", 1);
	for (0..$conf->{timeouts}{wait_for_node_health})
	{
		check_daemons($conf);
		read_df($conf, "me");
		read_df($conf, "peer");
		check_clustat($conf);
		
		$conf->{nodes}{me}{healthy}   = 1;
		$conf->{nodes}{peer}{healthy} = 1;
		foreach my $daemon (sort {$a cmp $b} keys %{$conf->{daemons}})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - daemon: [$daemon]", 2);
			foreach my $node ("me", "peer")
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - node: [$node], ${node}::daemon::${daemon}::rc: [$conf->{$node}{daemon}{$daemon}{rc}]", 2);
				if ($conf->{$node}{daemon}{$daemon}{rc} ne "0")
				{
					$conf->{nodes}{$node}{healthy} = 0;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${node}::healthy: [$conf->{nodes}{$node}{healthy}]", 2);
				}
			}
		}
		
		foreach my $clusterfs (sort {$a cmp $b} keys %{$conf->{cluster}{gfs2}})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - clusterfs: [$clusterfs]", 2);
			foreach my $node ("me", "peer")
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - node: [$node], cluster::gfs2::${clusterfs}::device: [$conf->{cluster}{gfs2}{$clusterfs}{device}], cluster::gfs2::${clusterfs}::mountpoint: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
				my $device     = $conf->{cluster}{gfs2}{$clusterfs}{device};
				my $mountpoint = $conf->{cluster}{gfs2}{$clusterfs}{mountpoint};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device], mountpoint: [$mountpoint]", 2);
				my ($target) = check_if_symlink($conf, $device, $node);
				if ($target)
				{
					my $old_device = $device;
					$device        = $target;
					$conf->{cluster}{gfs2}{$clusterfs}{device} = $target;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Adapting device to symlink target; cluster::gfs2::${clusterfs}::device: [$conf->{cluster}{gfs2}{$clusterfs}{device}], was: [$old_device]", 2);
				}
				
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - node: [$node], device: [$device]", 2);
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${node}::mounts::${device}: [$conf->{nodes}{$node}{mounts}{$device}], cluster::gfs2::${clusterfs}::mountpoint: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 3);
				if (not exists $conf->{nodes}{$node}{mounts}{$device})
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::${node}::mounts::${device} not mounted", 2);
					$conf->{nodes}{$node}{healthy} = 0;
				}
				elsif ($conf->{nodes}{$node}{mounts}{$device} eq $conf->{cluster}{gfs2}{$clusterfs}{mountpoint})
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - clusterfs: [$clusterfs] mounted properly: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Unexpected mount point! nodes::${node}::mounts::${device}: [$conf->{nodes}{$node}{mounts}{$device}], expected: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
					$conf->{nodes}{$node}{healthy} = 2;
				}
			}
		}
		foreach my $service (sort {$a cmp $b} keys %{$conf->{services}})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - services::${service}::state: [$conf->{services}{$service}{'state'}], host: [$conf->{services}{$service}{host}], my host name: [$conf->{nodes}{me}{hostname}], peer's host name: [$conf->{nodes}{peer}{hostname}]", 2);
			my $node = $conf->{services}{$service}{host} eq $conf->{nodes}{me}{hostname} ? "me" : "peer";
			if ($conf->{services}{$service}{'state'} eq "failed")
			{
				# TODO: Try to recover the service
				logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Service: [$service] on host: [$conf->{services}{$service}{'state'}] is 'failed'. Marking node: [$conf->{nodes}{$node}{hostname} ($node)] as unhealthy.", 0);
				$conf->{nodes}{$node}{healthy} = 2;
			}
			elsif ($conf->{services}{$service}{'state'} eq "started")
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Service: [$service] started on host: [$conf->{services}{$service}{host}]", 2);
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Service: [$service] is in state: [$conf->{services}{$service}{'state'}]", 2);
				$conf->{nodes}{$node}{healthy} = 0;
			}
		}
		
		# TODO: Make sure all LVs are 'ACTIVE' and, if not, try to
		#       activate them.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Node health; nodes::me::healthy: [$conf->{nodes}{me}{healthy}], nodes::peer::healthy: [$conf->{nodes}{peer}{healthy}]", 2);
		if (($conf->{nodes}{me}{healthy} == 1) && ($conf->{nodes}{peer}{healthy} == 1))
		{
			logger($conf, $THIS_FILE, __LINE__, "- Both nodes are now healthy", 1);
			last;
		}
		elsif (($conf->{nodes}{me}{healthy} == 1) && ($conf->{nodes}{peer}{healthy} == 2))
		{
			logger($conf, $THIS_FILE, __LINE__, "- I am healthy, but my peer is not", 1);
			last;
		}
		elsif (($conf->{nodes}{me}{healthy} == 2) && ($conf->{nodes}{peer}{healthy} == 1))
		{
			logger($conf, $THIS_FILE, __LINE__, "- My peer is healthy, but I am not. Exiting", 1);
			exit(3);
		}
		elsif (($conf->{nodes}{me}{healthy} == 2) && ($conf->{nodes}{peer}{healthy} == 2))
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Both nodes have critical issues and can not proceed", 0);
			exit(4);
		}
		sleep 1;
	}
	if ($conf->{nodes}{me}{healthy} != 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Timed out waiting for this node to become healthy, exiting", 0);
		exit(5);
	}
	elsif ($conf->{nodes}{peer}{healthy} != 1)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Timed out waiting for my peer to become healthy, proceeding.", 0);
	}

	return(0);
}

# This will fork in order to start the requested daemon on both nodes at the
# same time.
sub start_daemon_simultaneously
{
	my ($conf, $daemon) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - start_daemon_simultaneously(); daemon: [$daemon]", 3);
	
	logger($conf, $THIS_FILE, __LINE__, "- Starting: [$daemon]", 1);
	
	# I need to fork here because the calls won't return until cman
	# either talks to it's peer or fences it.
	my $parent_pid = $$;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Parent PID: [$parent_pid]", 2);
	
	my %pids;
	defined(my $pid = fork) or die "Can't fork(), error was: $!\n";
	if ($pid)
	{
		# Parent
		$pids{$pid} = 1;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - Spawned child with PID: [$pid] to start: [$daemon] on: [$conf->{nodes}{me}{hostname}]", 2);
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - me::daemon::${daemon}::rc: [$conf->{me}{daemon}{$daemon}{rc}]", 2);
		if ($conf->{me}{daemon}{$daemon}{rc} eq "3")
		{
			# Start the daemon locally.
			my $file_handle = IO::Handle->new();
			my $shell_call = "$conf->{daemons}{$daemon} start 2>&1; echo $daemon:\$?";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - shell call: [$shell_call]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- Starting locally", 1);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				   $line =~ s/\r//;
				   $line =~ s/\n//;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - line: [$line]", 2);
			}
			close $file_handle;
		}
		elsif ($conf->{me}{daemon}{$daemon}{rc} eq "0")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Daemon: [$daemon] already running locally, no need to start it.", 1);
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Parent ] - Parent process: [$pid ($$)] exiting.", 2);
	}
	else
	{
		# Child
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - Child process continuing.", 2);
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - peer::daemon::${daemon}::rc: [$conf->{peer}{daemon}{$daemon}{rc}].", 2);
		if ($conf->{peer}{daemon}{$daemon}{rc} eq "3")
		{
			# Start needed on the peer.
			my $file_handle = IO::Handle->new();
			my $shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{daemons}{$daemon} start 2>&1; echo $daemon:\\\$?\"";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - shell call: [$shell_call].", 3);
			logger($conf, $THIS_FILE, __LINE__, "- Starting on peer.", 1);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				   $line =~ s/\r//;
				   $line =~ s/\n//;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - line: [$line].", 2);
			}
			close $file_handle;
		}
		elsif ($conf->{peer}{daemon}{$daemon}{rc} eq "0")
		{
			logger($conf, $THIS_FILE, __LINE__, "- Daemon: [$daemon] is already running on the peer, no need to start.", 1);
		}
		# NOTE: This probably isn't needed.
		sleep 1;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) - Child ] - Child process exiting.", 2);
		exit;
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Done fork()ing.", 2);
	
	# Now loop until both child processes are dead.
	# This helps to catch hung children.
	my $saw_reaped = 0;
	
	# If I am here, then I am the parent process and all the child process have
	# been spawned. I will not enter a while() loop that will exist for however
	# long the %pids hash has data.
	while (%pids)
	{
		# This is a bit of an odd loop that put's the while()
		# at the end. It will cycle once per child-exit event.
		my $pid;
		do
		{
			# 'wait' returns the PID of each child as they
			# exit. Once all children are gone it returns 
			# '-1'.
			$pid = wait;
			if ($pid < 1)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Parent process thinks all children are gone now as wait returned: [$pid]. Exiting loop.", 2);
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Parent process told that child with PID: [$pid] has exited.", 2);
			}
			
			# This deletes the just-exited child process' PID from the
			# %pids hash.
			delete $pids{$pid};
			
			# This counter is a safety mechanism. If I see more PIDs exit
			# than I spawned, something went oddly and I need to bail.
			$saw_reaped++;
			if ($saw_reaped > 2)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - All children should be gone now but it seems the program went into an infinit loop.", 0);
				exit(3);
			}
		}
		while $pid > 0;	# This re-enters the do() loop for as
				# long as the PID returned by wait()
				# was >0.
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ($$) ] - Done watching child processes.", 2);
	logger($conf, $THIS_FILE, __LINE__, "- done!", 1);
	
	if ($daemon eq "rgmanager")
	{
		logger($conf, $THIS_FILE, __LINE__, "- 'rgmanager' started, Waiting up to one minute for services to come online.", 1);
		my $ok = 0;
		for (0..60)
		{
			   $ok          = 0;
			my $file_handle = IO::Handle->new();
			my $shell_call  = "$conf->{path}{clustat}";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
				if ($line =~ /Service Name/)
				{
					# rgmanager is running
					$ok = 1;
				}
				if ($line =~ /service:(.*?)\s(.*?)\s(.*)/)
				{
					my $service = $1;
					my $host    = $2;
					my $state   = $3;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - service: [$service], host: [$host], state: [$state]", 2);
					if ($state ne "started")
					{
						$ok = 0;
					}
				}
			}
			close $file_handle;
			
			if ($ok)
			{
				logger($conf, $THIS_FILE, __LINE__, "- All services started!", 1);
				last;
			}
			sleep 1;
		}
		if (not $ok)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Not all services started in timeout period!", 1);
			logger($conf, $THIS_FILE, __LINE__, "[ Warning ]   Will proceed, might be able to recover.", 1);
		}
	}
	
	return(0);
}

# This calls 'status' against the daemons found in cluster.conf (plus 'cman' 
# and 'rgmanager') and records their return code for the given node.
sub get_daemon_state
{
	my ($conf, $daemon, $node) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - get_daemon_state(); daemon: [$daemon], node: [$node]", 2);

	# Return code:
	# 0   == Started
	# 1   == Bad call
	# 3   == Stopped
	# 127 == File not found
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{daemons}{$daemon} status 2>&1 > /dev/null; echo $daemon:\$?";
	if ($node eq "peer")
	{
		$shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{daemons}{$daemon} status 2>&1 > /dev/null; echo $daemon:\\\$?\"";
	}
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 4);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /$daemon:(\d+)/)
		{
			$conf->{$node}{daemon}{$daemon}{rc} = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ${node}::daemon::${daemon}::rc: [$conf->{$node}{daemon}{$daemon}{rc}] (0 = Running, 3 = Stopped)", 2);
		}
		elsif ($line =~ /No such file or directory/)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Unable to find daemon script: [$conf->{daemon}{$daemon}] on: [$conf->{nodes}{$node}{hostname}]", 0);
			exit(7);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		}
	}
	close $file_handle;
	
	if (($conf->{$node}{daemon}{$daemon}{rc} ne "0") && ($conf->{$node}{daemon}{$daemon}{rc} ne "3"))
	{
		if ($node eq "me")
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Daemon: [$daemon] is in an unknown state on this node.", 0);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Daemon: [$daemon] is in an unknown state on: [$conf->{nodes}{peer}{hostname}].", 0);
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Status return code was: [$conf->{$node}{daemon}{$daemon}{rc}].", 0);
		logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Only '0' (started) and '3' (stopped) are handled.", 0);
		exit(2);
	}
	
	return($conf->{$node}{daemon}{$daemon}{rc});
}

# This is a simple wrapper to call get_daemon_state() against both nodes.
sub check_daemons
{
	my ($conf) = @_;
	
	foreach my $daemon (sort {$a cmp $b} keys %{$conf->{daemons}})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Checking daemon: [$daemon] using: [$conf->{daemons}{$daemon}]", 4);
		get_daemon_state($conf, $daemon, "me");
		get_daemon_state($conf, $daemon, "peer");
	}
	
	return(0);
}

# This simply checks for an ssh-able connectiong to the peer.
sub check_peer_connection
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check_peer_connection()", 3);
	
	if (not $conf->{nodes}{peer}{hostname})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Can't connect to peer, peer host name unknown.", 0);
		exit(1);
	}
	
	# Check to see if the node is powered on and, if not, power it on. If a
	# a previous attempt to check failed though, skip this.
	power_on_peer($conf) if not $conf->{sys}{bad_ipmi};
	
	my $file_handle = IO::Handle->new();
	my $shell_call = "$conf->{path}{ssh} root\@$conf->{nodes}{peer}{hostname} \"$conf->{path}{echo} 1\"";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		my $line = $_;
		if ($line eq "1")
		{
			$conf->{nodes}{peer}{reachable} = 1; 
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::peer_reachable: [$conf->{nodes}{peer}{reachable}]", 2);
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 2);
		}
	}
	close $file_handle;
	
	return($conf->{nodes}{peer}{reachable});
}

# Read the cluster configuration file. This forms the backbone of all that
# we'll do next.
sub read_cluster_conf
{
	my ($conf) = @_;
	
	my $in_fencedevices = 0;
	my $in_node         = "";
	my $in_domain       = "";
	my $file_handle     = IO::Handle->new();
	my $shell_call      = "$conf->{path}{cluster_conf}";
	logger($conf, $THIS_FILE, __LINE__, "- Reading the cluster configuration.", 1);
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - File read: [$shell_call]", 2);
	open ($file_handle, "<$shell_call") or die "Failed to read: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]", 3);
		
		# Pull out the cluster name. This has no use yet, beyond
		# telling the user.
		if ($line =~ /<cluster .*?name="(.*?)"/)
		{
			$conf->{cluster}{name} = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cluster::name: [$conf->{cluster}{name}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- This cluster is called: [$conf->{cluster}{name}].", 1);
			next;
		}
		
		# One of these has to match the hostname and the other must be
		# usable to log into the peer.
		if ($line =~ /<clusternode .*?name="(.*?)"/)
		{
			my $node    = $1;
			   $in_node = $node;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - node: [$node].", 4);
			if ($node eq $conf->{nodes}{me}{hostname})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Me; node: [$node]", 2);
			}
			else
			{
				# Shorten the names and see if they match.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Peer; node: [$node]", 2);
				my ($short_hostname) = ($conf->{nodes}{me}{hostname} =~ /^(.*?)\./);
				my ($short_nodename) = ($node                        =~ /^(.*?)\./);
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - short_hostname: [$short_hostname], short_nodename: [$short_nodename]", 2);
				if ($short_hostname eq $short_nodename)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Me; node: [$node]", 2);
				}
				else
				{
					$conf->{nodes}{peer}{hostname}   = $node;
					$conf->{nodes}{peer}{short_name} = $short_nodename;
					$conf->{nodes}{me}{short_name}   = $short_hostname;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - nodes::peer::hostname: [$conf->{nodes}{peer}{hostname}], nodes::peer::short_name: [$conf->{nodes}{peer}{short_name}], nodes::me::short_name: [$conf->{nodes}{me}{short_name}]", 2);
					logger($conf, $THIS_FILE, __LINE__, "- This peer's host name is: [$conf->{nodes}{peer}{hostname}].", 1);
				}
			}
			next;
		}
		if (($in_node) && ($line =~ /<\/clusternode>/))
		{
			# Not in a node anymore.
			$in_node = "";
		}
		if ($line =~ /<fencedevices>/)
		{
			$in_fencedevices = 1;
		}
		if (($in_fencedevices) && ($line =~ /<\/fencedevices>/))
		{
			$in_fencedevices = 0;
		}
		
		# Gather IPMI fence device info.
		if (($in_fencedevices) && ($line =~ /<fencedevice/))
		{
			my $name;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line]", 2);
			if ($line =~ /name="(.*?)"/)
			{
				$name = $1;
				logger($conf, $THIS_FILE, __LINE__, "name: [$name]", 2);
			}
			if (($name) && ($line =~ /ipaddr="(.*?)"/))
			{
				$conf->{ipmi}{$name}{ipaddr} = "-a ".$1;
				logger($conf, $THIS_FILE, __LINE__, "ipmi::${name}::ipaddr: [$conf->{ipmi}{$name}{ipaddr}]", 2);
			}
			if ($line =~ /agent="(.*?)"/)
			{
				$conf->{ipmi}{$name}{agent} = $1;
				logger($conf, $THIS_FILE, __LINE__, "ipmi::${name}::agent: [$conf->{ipmi}{$name}{agent}]", 2);
			}
			if (($name) && ($line =~ /login="(.*?)"/))
			{
				$conf->{ipmi}{$name}{login} = "-l ".$1;
				logger($conf, $THIS_FILE, __LINE__, "ipmi::${name}::login: [$conf->{ipmi}{$name}{login}]", 2);
			}
			if ($line =~ /passwd="(.*?)"/)
			{
				$conf->{ipmi}{$name}{passwd} = "-p ".$1;
				logger($conf, $THIS_FILE, __LINE__, "ipmi::${name}::passwd: [$conf->{ipmi}{$name}{passwd}]", 2);
			}
			if ($line =~ /passwd_script="(.*?)"/)
			{
				$conf->{ipmi}{$name}{passwd_script} = "-S ".$1;
				logger($conf, $THIS_FILE, __LINE__, "ipmi::${name}::passwd_script: [$conf->{ipmi}{$name}{passwd_script}]", 2);
			}
		}
		
		# Gather my IPMI fencing info.
		if (($in_node) && ($line =~ /ipmi/))
		{
			#print "in_node; line: [$line]\n";
			next if $line =~ /<method/;
			my $node;
			if (($in_node eq $conf->{nodes}{me}{hostname}))
			{
				$node = "me";
			}
			elsif (($in_node eq $conf->{nodes}{peer}{hostname}))
			{
				$node = "peer";
			}
			if ($line =~ /ipaddr="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{ipaddr} = "-a ".$1;
			}
			if ($line =~ /login="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{login} = "-l ".$1;
			}
			if ($line =~ /name="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{name} = $1;
			}
			if ($line =~ /passwd="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{passwd} = "-p ".$1;
			}
			if ($line =~ /passwd_script="(.*?)"/)
			{
				$conf->{nodes}{$node}{ipmi}{passwd_script} = "-S ".$1;
			}
		}
		
		# The scripts I find here will be the daemons whose status I
		# will check later to determine health.
		if ($line =~ /<script file="(.*?)"/)
		{
			my $script_path = $1;
			my ($script_name) = ($script_path =~ /.*?\/(\w+)$/);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - script_path: [$script_path], script_name: [$script_name]", 3);
			$conf->{daemons}{$script_name} = $script_path;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - daemons::$script_name: [$conf->{daemons}{$script_name}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- Found a managed script service called: [$script_name].", 1);
			next;
		}
		
		# Any clusterfs will be checked to make sure they mounted
		# properly. If the 'device' is a symlink to a device mapper
		# device, it will resolve fine as the devices found by 'df'
		# will also be checked for symlinks and resolve to their
		# device mapper device as well.
		if (($line =~ /<clusterfs /) && ($line =~ /device=/))
		{
			my ($device)     = ($line =~ /device="(.*?)"/);
			my ($mountpoint) = ($line =~ /mountpoint="(.*?)"/);
			my ($clusterfs)  = ($line =~ /name="(.*?)"/);
			$conf->{cluster}{gfs2}{$clusterfs}{device}     = $device;
			$conf->{cluster}{gfs2}{$clusterfs}{mountpoint} = $mountpoint,
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cluster::gfs2::${clusterfs}::device: [$conf->{cluster}{gfs2}{$clusterfs}{device}], cluster::gfs2::${clusterfs}::mountpoint: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- Found a clustered file system called: [$clusterfs] which mounts at: [$conf->{cluster}{gfs2}{$clusterfs}{mountpoint}].", 1);
			next;
		}
		
		# Read the server details. The listed failover domain will be
		# compared against the preferred nodes in the domain to find
		# the preferred host.
		if ($line =~ /<vm /)
		{
			#<vm domain="primary_n01" name="vm07-rhel6"
			my ($name)       =  ($line =~ / name="(.*?)"/);
			my ($domain)     =  ($line =~ / domain="(.*?)"/);
			my ($definition) =  ($line =~ / path="(.*?)"/);
			$definition      .= "/${name}.xml";
			$definition      =~ s/\/\//\//g;
			$conf->{vm}{$name}{domain}     = $domain;
			$conf->{vm}{$name}{definition} = $definition;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - vm::${name}::domain: [$conf->{vm}{$name}{domain}], vm::${name}::definition: [$conf->{vm}{$name}{definition}]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- Found a server named: [$name] in the failover domain: [$conf->{vm}{$name}{domain}].", 1);
			next;
		}
		
		# This parses the failover domains in a manner that retains
		# their set priority ordering.
		if ($line =~ /<failoverdomain .*?name="(.*?)"/)
		{
			$in_domain = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - in_domain: [$in_domain]", 2);
			logger($conf, $THIS_FILE, __LINE__, "- Found the failover domain named: [$in_domain].", 1);
			next;
		}
		if ($in_domain)
		{
			if ($line =~ /<\/failoverdomain>/)
			{
				$in_domain = "";
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Exiting domain; in_domain: [$in_domain]", 3);
				next;
			}
			else
			{
				if ($line =~ /<failoverdomainnode /)
				{
					my ($node)     = ($line =~ / name="(.*?)"/);
					my ($priority) = ($line =~ / priority="(.*?)"/);
					   $priority   = 1 if not $priority;
					$conf->{failoverdomain}{$in_domain}{priority}{$priority}{node} = $node;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - failoverdomain::${in_domain}::priority::${priority}::node: [$conf->{failoverdomain}{$in_domain}{priority}{$priority}{node}]", 4);
					logger($conf, $THIS_FILE, __LINE__, "- Node named: [$node] has priority: [$priority].", 1);
					next;
				}
			}
		}
		
	}
	close $file_handle;
	
	foreach my $node (sort {$a cmp $b} keys %{$conf->{nodes}})
	{
		#print "Node: [$node] IPMI fence attributes:\n";
		my $fence = "fence_ipmilan";
		foreach my $key (sort {$a cmp $b} keys %{$conf->{nodes}{$node}{ipmi}})
		{
			#print "- $key: [$conf->{nodes}{$node}{ipmi}{$key}]\n";
			if ($key eq "name")
			{
				my $name = $conf->{nodes}{$node}{ipmi}{$key};
				foreach my $key (sort {$a cmp $b} keys %{$conf->{ipmi}{$name}})
				{
					#print "- $key: [$conf->{ipmi}{$name}{$key}]\n";
					if ($key eq "agent")
					{
						if ($conf->{ipmi}{$name}{$key} ne "fence_ipmilan")
						{
							$fence =~ s/^fence_ipmilan /$conf->{ipmi}{$name}{$key} /;
						}
					}
					else
					{
						$fence .= " $conf->{nodes}{$node}{ipmi}{$key}";
					}
				}
			}
			elsif ($key eq "agent")
			{
				if ($conf->{nodes}{$node}{ipmi}{$key} ne "fence_ipmilan")
				{
					$fence =~ s/^fence_ipmilan /$conf->{nodes}{$node}{ipmi}{$key} /;
				}
			}
			else
			{
				$fence .= " $conf->{nodes}{$node}{ipmi}{$key}";
			}
		}
		$conf->{nodes}{$node}{fence} = $fence;
		#print "nodes::${node}::fence: [$conf->{nodes}{$node}{fence}]\n";
	}
	
	return(0);
}

# Read the hostname. This is used shortly to tell which cluster node I am and
# which my peer is.
sub read_hostname
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_hostname()", 3);
	
	my $file_handle = IO::Handle->new();
	my $shell_call  = "$conf->{path}{hostname}";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell call: [$shell_call]", 2);
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		# I don't care about this output
		chomp;
		$conf->{nodes}{me}{hostname} = $_;
		logger($conf, $THIS_FILE, __LINE__, "- My hostname is: [$conf->{nodes}{me}{hostname}]", 1);
	}
	close $file_handle;
	
	# If I am node 02, sleep for 1 minutes to help avoid conflicting with
	# the startup being performed by node 1.
	if (($conf->{nodes}{me}{hostname} =~ /n02/)    || 
	    ($conf->{nodes}{me}{hostname} =~ /n2/)     || 
	    ($conf->{nodes}{me}{hostname} =~ /node02/) || 
	    ($conf->{nodes}{me}{hostname} =~ /node2/))
	{
		logger($conf, $THIS_FILE, __LINE__, "- I am not node 1, so I will sleep for a minute to help avoid race conditions.", 1);
		sleep $conf->{sys}{node2_sleep};
	}
	
	return($conf->{nodes}{me}{hostname});
}
