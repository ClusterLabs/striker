#!/usr/bin/perl
# 
# This tool does not do or change anything. It uses the information from 'anvil-report-state' and formats a 
# subset of it for display in a clean(ish) way on the command line.
# 
# Return Codes:
# 0  = OK
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Term::ANSIColor;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({
	data		=> {
		padding		=>	{
			anvil		=>	{
				name		=>	14,
				hostnames	=>	30,
			},
		},
		status		=>	{
			anvil		=>	{
				name		=>	"",
				my_hostname	=>	"",
				peer_hostname	=>	"",
			},
		},
		sys		=>	{
			log_level	=>	2,
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{'anvil-safe-start'}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Gather whatever we can find.
gather_data($an);
report_status($an);

$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This prints out the information we gathered
sub report_status
{
	my ($an) = @_;
	
	### Pad left
	# sprintf("%${padding}s", $1);;
	### Pad right
	# sprintf("%-${padding}s", $1);;
	my $coloured_anvil_name    = colored(sprintf("%-".$an->data->{padding}{anvil}{name}."s", $an->data->{status}{anvil}{name}), 'bold magenta');
	my $coloured_my_hostname   = colored(sprintf("%".$an->data->{padding}{anvil}{hostnames}."s", $an->data->{status}{anvil}{me_hostname}), 'bold blue');
	my $coloured_peer_hostname = colored(sprintf("%-".$an->data->{padding}{anvil}{hostnames}."s", $an->data->{status}{anvil}{peer_hostname}), 'bold blue');
	print $an->String->get({key => "acs_report_0001", variables => {
		anvil_name    => $coloured_anvil_name,
		my_hostname   => $coloured_my_hostname,
		peer_hostname => $coloured_peer_hostname,
	}})."\n";
	
	return(0);
}

# This calls 'anvil-report-state' to gather information about the node.
sub gather_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "gather_data" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{'anvil-report-state'}." --fast";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /anvil::name = \[(.*?)\]/)
		{
			$an->data->{status}{anvil}{name} = $1;
		}
		elsif ($line =~ /clustat::name::me = \[(.*?)\]/)
		{
			$an->data->{status}{anvil}{me_hostname} = $1;
		}
		elsif ($line =~ /clustat::name::peer = \[(.*?)\]/)
		{
			$an->data->{status}{anvil}{peer_hostname} = $1;
		}
	}
	close $file_handle;
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "acs_message_0001"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
