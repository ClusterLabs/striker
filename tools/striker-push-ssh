#!/usr/bin/perl
# 
# This pushes the local Striker's user's SSH RSA keys to the target Anvil!'s node's authorized_keys file. 
# This is needed to enable Virtual Machine Manager passwordless access to the hosted Servers.
# 
# This doesn't use 'ssh-copy-id' because 'expect' is a PITA.
# 
# Return codes:
# 0  = Normal exit.
# 1  = Disabled in striker.conf.
# 

use strict; 
use warnings;
use IO::Handle;
use AN::Tools;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

my $an = AN::Tools->new({data => {
		path		=>	{
			log_file	=>	"/var/log/striker.log",
			ssh_config	=>	"/etc/ssh/ssh_config",
			striker_config	=>	"/etc/striker/striker.conf",
			striker_strings	=>	"/sbin/striker/Data/strings.xml",
		},
		switches	=>	{},
		sys		=>	{
			key_size	=>	8191,
			language	=>	"en_CA",
			local_users	=>	[],
			log_language	=>	"en_CA",
			log_level	=>	2,
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Log our startup
$an->Log->entry({log_level => 3, message_key => "sps_log_0001", message_variables => { this_file => $THIS_FILE }, file => $THIS_FILE, line => __LINE__});

# Exit if we've been disabled in the config file.
if (not $an->data->{tools}{'striker-push-ssh'}{enabled})
{
	$an->Log->entry({log_level => 2, message_key => "sps_log_0013", file => $THIS_FILE, line => __LINE__});
	print $an->String->get({key => "sps_log_0013"})."\n";
	$an->nice_exit({exit_code => 1});
}

# Can I connect to a database?
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
	name1 => "connections", value1 => $connections, 
}, file => $THIS_FILE, line => __LINE__});
if (not $connections)
{
	# Nope, warn the user.
	print $an->String->get({key => "scv_warning_0003"})."\n";
	$an->Log->entry({log_level => 1, message_key => "scv_warning_0003", file => $THIS_FILE, line => __LINE__});
	$an->nice_exit({exit_code => 0});
}

# Now determine what local users exist.
$an->data->{sys}{local_users} = $an->Get->local_users();
my $local_user_count          = @{$an->data->{sys}{local_users}};
if (not $local_user_count)
{
	# No users found, nothing to do.
	$an->Log->entry({log_level => 2, message_key => "sps_log_0004", file => $THIS_FILE, line => __LINE__});
	$an->nice_exit({exit_code => 0});
}

# Find the login details
my $anvil_data = $an->ScanCore->parse_anvil_data();
foreach my $anvil_uuid (keys %{$an->data->{anvils}})
{
	$an->data->{anvil}{uuid}     = $anvil_uuid;
	$an->data->{anvil}{name}     = $an->data->{anvils}{$anvil_uuid}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "anvil::uuid", value1 => $an->data->{anvil}{uuid}, 
		name2 => "anvil::name", value2 => $an->data->{anvil}{name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "sps_log_0002", message_variables => { anvil => $an->data->{anvil}{name} }, file => $THIS_FILE, line => __LINE__});
	$an->Striker->load_anvil({anvil_uuid => $anvil_uuid});
	
	# Short-scan node 1 and 2
	$an->Striker->scan_node({
		uuid       => $an->data->{sys}{anvil}{node1}{uuid},
		short_scan => 1,
	});
	$an->Striker->scan_node({
		uuid       => $an->data->{sys}{anvil}{node2}{uuid},
		short_scan => 1,
	});
	
	# If I am still alive, loop through the list of users, get their local RSA key (generating it as needed) and
	# then add it to each target node.
	foreach my $user (sort {$a cmp $b} @{$an->data->{sys}{local_users}})
	{
		# Push the keys to whichever nodes are online.
		push_ssh_keys($an, $user);
	}
}

$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This reads in the given user's RSA public key, generating it if needed, and then copies it to each node in
# the Anvil!.
sub push_ssh_keys
{
	my ($an, $user) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "push_ssh_keys" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "user", value1 => $user, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# First up, read (and generate, if needed) the user's RSA public key.
	my ($owner, $key) = $an->Get->rsa_public_key({user => $user, key_size => $an->data->{sys}{key_size}});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "owner", value1 => $owner, 
		name2 => "key",   value2 => $key, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I read the key, push it to the nodes now.
	if ($key)
	{
		### TODO: Update this to use the new access methods.
		# OK, loop through the nodes.
		foreach my $node_key ("node1", "node2")
		{
			# First, is it up?
			my $node_name = $an->data->{sys}{anvil}{$node_key}{name};
			my $online    = $an->data->{sys}{anvil}{$node_key}{online};
			my $use_ip    = $an->data->{sys}{anvil}{$node_key}{use_ip};
			my $use_port  = $an->data->{sys}{anvil}{$node_key}{use_port};
			my $password  = $an->data->{sys}{anvil}{$node_key}{password};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "node_name", value1 => $node_name, 
				name2 => "online",    value2 => $online, 
				name3 => "use_ip",    value3 => $use_ip, 
				name4 => "use_port",  value4 => $use_port, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "password", value1 => $password, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (not $an->data->{sys}{anvil}{$node_key}{online})
			{
				# Failed to reach it.
				$an->Alert->warning({message_key => "sps_warning_0003", message_variables => { node => $node_name }, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			# Insert/update the use_ip and hostname into our local /etc/hosts file. This will 
			# allow us to store the fingerprint by the node's name.
			update_hosts($an, $node_name, $use_ip);
			
			# Make sure I've got the remote machine's RSA fingerprint recorded.
			$an->Remote->add_target_to_known_hosts({
				user   => $user, 
				target => $node_name,
			});
			
			# If I'm still here, I can reach the node so it's time to add they key.
			# 0 == Existed
			# 1 == Failed to add
			# 2 == Added successfully
			my $return = $an->Remote->add_rsa_key_to_target({
				user      => "root",
				target    => $node_name,
				port      => $use_port,
				password  => $password,
				key       => $key, 
				key_owner => $owner,
			});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "return", value1 => $return, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# Read in /etc/hosts and insert the host name (or update the existing entry if it's changed).
sub update_hosts
{
	my ($an, $node_name, $use_ip) = @_;
	
	my $insert     = 1;
	my $new_hosts  = "";
	my $shell_call = $an->data->{path}{etc_hosts};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^(\d+\.\d+\.\d+\.\d+)\s+(.*)?/)
		{
			my $ip    = $1;
			my $names = $2;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "ip",    value1 => $ip, 
				name2 => "names", value2 => $names, 
			}, file => $THIS_FILE, line => __LINE__});
			
			foreach my $name (split/ /, $names)
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "name", value1 => $name, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($name eq $node_name)
				{
					# Found it.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "ip",     value1 => $ip, 
						name2 => "use_ip", value2 => $use_ip, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($ip eq $use_ip)
					{
						# Match, no need to update
						$insert = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "insert", value1 => $insert, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					else
					{
						# IP has changed, so we'll remove out name from this line and
						# insert.
						$line =~ s/$node_name//;
						$line =~ s/  / /g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "line", value1 => $line, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
		}
		
		$new_hosts .= "$line\n";
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "insert", value1 => $insert, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($insert)
	{
		# (re)Add the name and IP.
		$new_hosts .= "$use_ip	$node_name\n";
		
		# Create a backup.
		my ($date)      = $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		my $destination = $an->data->{path}{striker_backups}."/hosts.$date";
		my $shell_call  = $an->data->{path}{cp}." -f ".$an->data->{path}{etc_hosts}." $destination";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Write it out.
		$shell_call = $an->data->{path}{etc_hosts};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		print $file_handle $new_hosts;
		close $file_handle;
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $help = $an->String->get({key => "sps_message_0001"})."\n";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
