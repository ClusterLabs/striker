#!/usr/bin/perl
# 
# This pushes the local Striker's user's SSH RSA keys to the target Anvil!'s node's authorized_keys file. 
# This is needed to enable Virtual Machine Manager passwordless access to the hosted Servers.
# 
# This doesn't use 'ssh-copy-id' because 'expect' is a PITA.
# 
# Return codes:
# 0  = Normal exit.
# 

use strict; 
use warnings;
use IO::Handle;
use AN::Tools;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	        $running_directory =~ s/^\./$ENV{PWD}/;
}

my $an = AN::Tools->new({data => {
		path		=>	{
			'chown'		=>	"/bin/chown",
			'chmod'		=>	"/bin/chmod",
			'echo'		=>	"/bin/echo",
			'grep'		=>	"/bin/grep",
			log_file	=>	"/var/log/striker.log",
			ls		=>	"/bin/ls",
			ssh_config	=>	"/etc/ssh/ssh_config",
			striker_config	=>	"/etc/striker/striker.conf",
			striker_strings	=>	"/sbin/striker/Data/strings.xml",
			gethostip	=>	"/usr/bin/gethostip",
			'ssh-keygen'	=>	"/usr/bin/ssh-keygen",
			'ssh-keyscan'	=>	"/usr/bin/ssh-keyscan",
			'ssh-copy-id'	=>	"/usr/bin/ssh-copy-id",
		},
		switches	=>	{},
		local_users	=>	[],
		sys		=>	{
			key_size	=>	8191,
			language	=>	"en_CA",
			log_language	=>	"en_CA",
			log_level	=>	2,
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->String->read_words  ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();

# Log our startup
$an->Log->entry({log_level => 3, message_key => "sps_log_0001", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});

# Exit if no Anvil! defined.
if (not $an->data->{switches}{anvil})
{
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "sps_error_0001", code => 1, file => "$THIS_FILE", line => __LINE__});
}

# Log that we're looking for the login credentials to the defined node.
$an->Log->entry({log_level => 2, message_key => "sps_log_0002", message_variables => {
	anvil	=>	$an->data->{switches}{server},
}, file => $THIS_FILE, line => __LINE__});

# Find the login details
foreach my $id (sort {$a cmp $b} keys %{$an->data->{cluster}})
{
	if ($an->data->{cluster}{$id}{name} eq $an->data->{switches}{anvil})
	{
		# Split out the node names.
		my ($node1, $node2) = (split/,/, $an->data->{cluster}{$id}{nodes});
		$node1 =~ s/^\s+//g;
		$node1 =~ s/\s+$//g;
		$node2 =~ s/^\s+//g;
		$node2 =~ s/\s+$//g;
		
		$an->data->{anvil}{id}       = $id;
		$an->data->{anvil}{node1}    = $node1;
		$an->data->{anvil}{node2}    = $node2;
		$an->data->{anvil}{password} = $an->data->{cluster}{$id}{root_pw} ? $an->data->{cluster}{$id}{root_pw} : $an->data->{cluster}{$id}{ricci_pw};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "anvil::id",       value1 => $an->data->{anvil}{id}, 
			name2 => "anvil::node1",    value2 => $an->data->{anvil}{node1}, 
			name3 => "anvil::node2",    value3 => $an->data->{anvil}{node2}, 
			name4 => "anvil::password", value4 => $an->data->{anvil}{password}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
}

# If I didn't find an Anvil!, exit.
if ($an->data->{anvil}{id})
{
	# Woot!
	$an->Log->entry({log_level => 2, message_key => "sps_log_0003", message_variables => {
		anvil	=>	$an->data->{switches}{anvil}, 
	}, file => $THIS_FILE, line => __LINE__});
}
else
{
	# Well foo. 
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "sps_error_0002", message_variables => {
		anvil	=>	$an->data->{switches}{anvil},
	}, code => 2, file => "$THIS_FILE", line => __LINE__});
}

# Now determine what local users exist.
if (not get_local_users($an))
{
	# No users found, nothing to do.
	$an->Log->entry({log_level => 2, message_key => "sps_log_0004", file => $THIS_FILE, line => __LINE__});
	exit(0);
}

# If I am still alive, loop through the list of users, get their local RSA key (generating it as needed) and
# then add it to each target node.
foreach my $user (sort {$a cmp $b} @{$an->data->{local_users}})
{
	push_ssh_keys($an, $user);
}

exit(0);

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This checks the root user's ~/.ssh/authorized_keys file for the given key. Returns '1' if it exists, '0' if
# it doesn't.
sub check_if_key_is_on_node
{
	my ($an, $node, $key) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_if_key_is_on_node" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "node", value1 => $node,
		name2 => "key",  value2 => $key,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $exists = 0;
	my $shell_call = "ssh root\@$node \"".$an->data->{path}{'grep'}." -q $key /root/.ssh/authorized_keys; ".$an->data->{path}{'echo'}." rc:\\\$?\"";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
		target		=>	$node,
		password	=>	$an->data->{anvil}{password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	$shell_call,
	});
	foreach my $line (@{$return})
	{
		### TODO: Handle a rebuilt machine where the fingerprint no longer matches.
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /rc:(\d+)/)
		{
			# If rc = 0, the key is there. Otherwise, add it.
			my $rc = $1;
			if ($rc)
			{
				# Add it
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "rc", value1 => $rc, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Exists.
				$exists = 1;
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "exists", value1 => $exists, 
	}, file => $THIS_FILE, line => __LINE__});
	return($exists);
}

# This does the work of adding the user's public RSA key to the target node's root user's authorized_keys
# file.
sub add_rsa_public_key_to_remote_node
{
	my ($an, $user, $node, $owner, $key) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "add_rsa_public_key_to_remote_node" }, message_key => "an_variables_0004", message_variables => { 
		name1 => "user",  value1 => $user,
		name2 => "node",  value2 => $node,
		name3 => "owner", value3 => $owner, 
		name4 => "key",   value4 => $key,
	}, file => $THIS_FILE, line => __LINE__});
	
	# I'll need to make sure I've seen the fingerprint before.
	my $known_hosts = "/home/$user/.ssh/known_hosts";
	if ($user eq "root")
	{
		$known_hosts = "/root/.ssh/known_hosts";
	}
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "known_hosts", value1 => $known_hosts, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Calling 'grep -q' will return;
	# 0 = Match found
	# 1 = Match not found
	# 2 = File didn't exist.
	# We don't care about 1 or 2 because '>>' will create the file if needed.
	### TODO: Too much duplication of code here...
	my $shell_call = "
# If known_hosts exists, grep for the target machine
if [ -e '$known_hosts' ]
then
    # Search
    ".$an->data->{path}{'grep'}." -q '$node ssh-rsa ' $known_hosts
    if [ \"\$?\" -eq '0' ];
    then
        # Already exists
        ".$an->data->{path}{'echo'}." exists
    else
        # Add
        ".$an->data->{path}{'echo'}." add
        ".$an->data->{path}{'ssh-keyscan'}." $node >> $known_hosts
        ".$an->data->{path}{'chown'}." $user:$user $known_hosts

        # Verify
        ".$an->data->{path}{'grep'}." -q '$node ssh-rsa ' $known_hosts
        if [ \"\$?\" -eq '0' ];
        then
            ".$an->data->{path}{'echo'}." ok
        else
            ".$an->data->{path}{'echo'}." failed
        fi
    fi
else
    # known_hosts doesn't exist, to create it
    ".$an->data->{path}{'echo'}." no known_hosts, add
    ".$an->data->{path}{'ssh-keyscan'}." $node >> $known_hosts
    ".$an->data->{path}{'chown'}." $user:$user $known_hosts

    # Verify
    ".$an->data->{path}{'grep'}." -q '$node ssh-rsa ' $known_hosts
    if [ \"\$?\" -eq '0' ];
    then
        ".$an->data->{path}{'echo'}." ok
    else
        ".$an->data->{path}{'echo'}." failed
    fi
fi
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		push @{$an->data->{local_users}}, $line;
		if ($line =~ /add/)
		{
			$an->Log->entry({log_level => 2, message_key => "sps_log_0008", message_variables => {
				node => $node, 
				user => $user, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /ok/)
		{
			# \o/
			$an->Log->entry({log_level => 2, message_key => "sps_log_0010", message_variables => {
				node => $node, 
				user => $user, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /exists/)
		{
			$an->Log->entry({log_level => 2, message_key => "sps_log_0009", message_variables => {
				node => $node, 
				user => $user, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /failed/)
		{
			$an->Alert->warning({message_key => "sps_warning_0004", message_variables => {
				node => $node, 
				user => $user, 
			}, file => $THIS_FILE, line => __LINE__});
			return(1);
		}
	}
	
	# This returns '1' if the key exists on the node
	if (check_if_key_is_on_node($an, $node, $key))
	{
		# Already there
		$an->Log->entry({log_level => 2, message_key => "sps_log_0011", message_variables => {
			node => $node, 
			user => $user, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Add the key.
		my $shell_call = "ssh root\@$node \"".$an->data->{path}{'echo'}." 'ssh-rsa $key ' >> /root/.ssh/authorized_keys; ".$an->data->{path}{'echo'}." rc:\\\$?\"";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$node,
			password	=>	$an->data->{anvil}{password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			### TODO: Handle a rebuilt machine where the fingerprint no longer matches.
			next if not $line;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /rc:(\d+)/)
			{
				# If rc = 0, the key is there. Otherwise, add it.
				my $rc = $1;
				if ($rc)
				{
					# Add it
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "rc", value1 => $rc, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		
		# Check that it was added...
		if (check_if_key_is_on_node($an, $node, $key))
		{
			# Success!
			$an->Log->entry({log_level => 2, message_key => "sps_log_0012", message_variables => {
				node => $node, 
				user => $user, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Boo :(
			$an->Alert->warning({message_key => "sps_warning_0005	", message_variables => {
				node => $node, 
				user => $user, 
			}, file => $THIS_FILE, line => __LINE__});
			return(1);
		}
	}
	
	return(0);
}

# This reads in the given user's RSA public key, generating it if needed, and then copies it to each node in
# the Anvil!.
sub push_ssh_keys
{
	my ($an, $user) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "push_ssh_keys" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "user", value1 => $user, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# First up, read (and generate, if needed) the user's RSA public key.
	my ($owner, $key) = get_rsa_public_key($an, $user);
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "owner", value1 => $owner, 
		name2 => "key",   value2 => $key, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I read the key, push it to the nodes now.
	if ($key)
	{
		# OK, loop through the nodes.
		foreach my $node ($an->data->{anvil}{node1}, $an->data->{anvil}{node2})
		{
			# First, is it up?
			if ($an->Check->ping({target => $node, count => 3}))
			{
				# Failed to reach it.
				$an->Alert->warning({message_key => "sps_warning_0003", message_variables => {
					node	=>	$node,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			# If I'm still here, I can reach the node. This returns '1' on failure, '0' on 
			# success.
			add_rsa_public_key_to_remote_node($an, $user, $node, $owner, $key);
		}
	}
	
	return(0);
}

# This generates an RSA key for the user.
sub generate_rsa_public_key
{
	my ($an, $user) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "generate_rsa_public_key" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "user", value1 => $user, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Determine and define the private RSA key file
	my $rsa_private_file = "/home/$user/.ssh/id_rsa";
	if ($user eq "root")
	{
		$rsa_private_file = "/root/.ssh/id_rsa";
	}
	my $rsa_public_file = "${rsa_private_file}.pub";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "rsa_private_file", value1 => $rsa_private_file, 
		name2 => "rsa_public_file",  value2 => $rsa_public_file,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Log that this can take time and then make the call.
	$an->Log->entry({log_level => 2, message_key => "sps_log_0005", file => $THIS_FILE, line => __LINE__});
	my $shell_call  = $an->data->{path}{'ssh-keygen'}." -t rsa -N \"\" -b ".$an->data->{sys}{key_size}." -f $rsa_private_file && ";
	   $shell_call .= $an->data->{path}{'chown'}." $user:$user $rsa_private_file && ";
	   $shell_call .= $an->data->{path}{'chown'}." $user:$user $rsa_public_file && ";
	   $shell_call .= $an->data->{path}{'chmod'}." 600 $rsa_private_file && ";
	   $shell_call .= $an->data->{path}{'chown'}." 644 $rsa_public_file";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "rsa_private_file", value1 => $rsa_private_file, 
		name2 => "rsa_public_file",  value2 => $rsa_public_file,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Did it work?
	my $ok = 0;
	if (-e $rsa_private_file)
	{
		# Yup!
		$ok = 1;
		$an->Log->entry({log_level => 2, message_key => "sps_log_0006", message_variables => {
			user => $user, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Failed, tell the user.
		$an->Alert->warning({message_key => "sps_warning_0001", message_variables => {
			user	=>	$user,
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "ok", value1 => $ok, 
	}, file => $THIS_FILE, line => __LINE__});
	return($ok);
}

# Get the local user's RSA public key.
sub get_rsa_public_key
{
	my ($an, $user) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_rsa_public_key" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "user", value1 => $user, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $rsa_file = "/home/$user/.ssh/id_rsa.pub";
	if ($user eq "root")
	{
		$rsa_file = "/root/.ssh/id_rsa.pub";
	}
	
	#If it doesn't exit, create it,
	if (not -e $rsa_file)
	{
		# Generate it.
		if (not generate_rsa_public_key($an, $user))
		{
			# Failed, return.
			return("", "");
		}
	}
	
	# Read it!
	my $key_owner  = "";
	my $key_string = "";
	my $shell_call = $rsa_file;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /^ssh-rsa (.*?) (.*?\@.*)$/)
		{
			$key_string = $1;
			$key_owner  = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "key_string", value1 => $key_string, 
				name2 => "key_owner",  value2 => $key_owner, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# If I failed to read the key, exit.
	if ((not $key_owner) or (not $key_string))
	{
		# Foo. Warn the user and skip.
		$an->Alert->warning({message_key => "sps_warning_0002", message_variables => {
			user	=>	$user,
			file	=>	$rsa_file,
		}, file => $THIS_FILE, line => __LINE__});
		return("", "");
	}
	else
	{
		# We're good!
		$an->Log->entry({log_level => 3, message_key => "sps_log_0007", message_variables => {
			owner	=>	$key_owner, 
			key	=>	$key_string, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	return($key_owner, $key_string);
}

# This calls 'ls /home' to get a list of local users. It returns the number of users found.
sub get_local_users
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_local_users" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{ls}." /home";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		push @{$an->data->{local_users}}, $line;
	}
	
	# record how many users we read into the array.
	$an->Log->entry({log_level => 2, message_key => "tools_log_0005", message_variables => {
		array	=>	"local_users",
		count	=>	@{$an->data->{local_users}},
	}, file => $THIS_FILE, line => __LINE__});
	return(@{$an->data->{local_users}});
}




=pod
# Log into the remote machine and add our keys.
sub add_rsa_to_remote
{
	my ($conf) = @_;
	
	# Make sure the remote machine's fingerprints are in our 
	# ~/.ssh/known_hosts.
	my $known_hosts = "/home/$an->data->{sys}{username}/.ssh/known_hosts";
	my $shell_call  = "if [ -e '$known_hosts' ] && \$(grep -q $an->data->{sys}{remote} $known_hosts); then echo exists; else echo add; ssh-keyscan $an->data->{sys}{remote} >> $known_hosts; fi; chown $an->data->{sys}{username}:$an->data->{sys}{username} $known_hosts";
	# Untaint
	if ($shell_call =~ /^(if .*)$/)
	{
		$shell_call = $1;
	}
	else
	{
		die "$THIS_FILE ".__LINE__."; Shell call tainted: [$shell_call]\n";
	}
	print "[ Debug ] ".__LINE__."; - shell_call: [$shell_call]\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /exists/)
		{
			print "- The remote machine's fingerprint is already registered.\n";
		}
		if ($line =~ /add/)
		{
			print "- Recording the remote machine's fingerprint.\n";
		}
		#print "[ Debug ] ".__LINE__."; - line: [$line]\n";
	}
	close $file_handle;
	
	# Read in the user's existing root user's authorized_keys file, if it
	# exists.
	if (check_authorized_keys($conf, "root"))
	{
		print "- The 'root' user doesn't have our RSA key, adding it.\n";
		if (add_key_to_remote($conf, "root"))
		{
			# Success!
			print "- Our RSA key was successfully added to root's authorized_keys.\n";
		}
		else
		{
			# Failed. :(
			print "[ Error ] - Failed to add our key to root's authorized_keys!\n";
			exit(15);
		}
	}
	else
	{
		print "- The 'root' user has our key already, skipping.\n";
	}
	
	# How get a list of all users on the remote system and add our key to
	# each.
	get_remote_user_list($conf);
	
	foreach my $user (sort {$a cmp $b} @{$an->data->{remote_users}})
	{
		next if not $user;
		print "- Adding our key to remote user: [$user]'s authorized_keys file.\n";
		if (check_authorized_keys($conf, $user))
		{
			print "- The '$user' user doesn't have our RSA key, adding it.\n";
			if (add_key_to_remote($conf, $user))
			{
				# Success!
				print "- Our RSA key was successfully added to ${user}'s authorized_keys.\n";
			}
			else
			{
				# Failed. :(
				print "[ Error ] - Failed to add our key to ${user}'s authorized_keys!\n";
				exit(15);
			}
		}
		else
		{
			print "- The '$user' user has our key already, skipping.\n";
		}
	}
	
	return(0);
}

# This simply does an 'ls /home' to get a list of remote users.
sub get_remote_user_list
{
	my ($conf) = @_;
	
	my $shell_call = "ls /home";
	#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$an->data->{sys}{remote},
		port		=>	22,
		user		=>	"root",
		password	=>	$an->data->{sys}{password},
		ssh_fh		=>	$an->data->{sys}{ssh_fh} ? $an->data->{sys}{ssh_fh} : "",
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	#print "[ Debug ] ".__LINE__."; - error: [$error], ssh_fh: [$ssh_fh], return: [$return (".@{$return}." lines)]\n";
	foreach my $line (@{$return})
	{
		#print "[ Debug ] ".__LINE__."; - line: [$line]\n";
		next if $line eq "lost+found";
		push @{$an->data->{remote_users}}, $line;
	}
	
	return(0);
}

# This does the actual addition of our key to the remote machine's named user.
# After adding, the key is read back to make sure it was indeed added.
sub add_key_to_remote
{
	my ($conf, $user) = @_;
	
	my $ok = 0;
	my $authorized_keys = "/home/$user/.ssh/authorized_keys";
	if ($user eq "root")
	{
		$authorized_keys = "/root/.ssh/authorized_keys";
	}
	my $shell_call = "echo '$an->data->{sys}{rsa_key}' >> $authorized_keys && sync && cat $authorized_keys";
	#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$an->data->{sys}{remote},
		port		=>	22,
		user		=>	"root",
		password	=>	$an->data->{sys}{password},
		ssh_fh		=>	$an->data->{sys}{ssh_fh} ? $an->data->{sys}{ssh_fh} : "",
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	#print "[ Debug ] ".__LINE__."; - error: [$error], ssh_fh: [$ssh_fh], return: [$return (".@{$return}." lines)]\n";
	foreach my $line (@{$return})
	{
		if ($line eq "$an->data->{sys}{rsa_key}")
		{
			#print "[ Debug ] ".__LINE__."; - Found our key.\n";
			$ok = 1;
		}
	}
	
	return($ok);
}

# This takes a user name and reads it's authorized_keys file, if it exists. If
# it doesn't, it checks to see if ~/.ssh exists and creates it, if it. If the
# authorized_keys file does exist, it looks to see if our key is in the file
# and returns '1' if not, '0' if found.
sub check_authorized_keys
{
	my ($conf, $user) = @_;
	
	my $add_key = 1;
	my $authorized_keys = "/home/$user/.ssh/authorized_keys";
	my $ssh_directory   = "/home/$user/.ssh";
	if ($user eq "root")
	{
		$authorized_keys = "/root/.ssh/authorized_keys";
		$ssh_directory   = "/root/.ssh";
	}
	print "- Reading '$authorized_keys' on: [$an->data->{sys}{remote}]\n";
	my $shell_call = "if [ -e '$authorized_keys' ]
			then
				cat $authorized_keys
			else
				echo 'not found'
				if [ ! -e '$ssh_directory' ]
				then
					mkdir $ssh_directory
					chown $user:$user $ssh_directory
					chmod 700 $ssh_directory
					echo '$ssh_directory directory created.'
				fi
			fi";
	#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$an->data->{sys}{remote},
		port		=>	22,
		user		=>	"root",
		password	=>	$an->data->{sys}{password},
		ssh_fh		=>	$an->data->{sys}{ssh_fh} ? $an->data->{sys}{ssh_fh} : "",
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	#print "[ Debug ] ".__LINE__."; - error: [$error], ssh_fh: [$ssh_fh], return: [$return (".@{$return}." lines)]\n";
	foreach my $line (@{$return})
	{
		if ($line =~ /not found/i)
		{
			print "- 'authorized_keys' doesn't exist on the peer yet.\n";
		}
		elsif ($line =~ /directory created/i)
		{
			print "- '.ssh' directory create for the 'root' user.\n";
		}
		else
		{
			#print "[ Debug ] ".__LINE__."; - Read: [$line]\n";
			if ($line eq $an->data->{sys}{rsa_key})
			{
				print "- Our SSH key is already added.\n";
				$add_key = 0;
			}
		}
	}
	
	return($add_key);
}

# This calls the target machine and runs a command.
sub remote_call
{
	my ($conf, $parameters) = @_;
	
	#print "[ Debug ] ".__LINE__."; parameters->{password}: [$parameters->{password}], sys::root_password: [$an->data->{sys}{root_password}]\n";
	my $remote     = $parameters->{remote}           ? $parameters->{remote}   : $an->data->{sys}{remote};
	my $port       = $parameters->{port}             ? $parameters->{port}     : $an->data->{sys}{ssh_port};
	my $user       = $parameters->{user}             ? $parameters->{user}     : "root";
	my $password   = $parameters->{password}         ? $parameters->{password} : $an->data->{sys}{password};
	my $ssh_fh     = $parameters->{ssh_fh}           ? $parameters->{ssh_fh}   : "";
	my $close      = defined $parameters->{'close'}  ? $parameters->{'close'}  : 1;
	my $shell_call = $parameters->{shell_call};
	#print "[ Debug ] ".__LINE__."; remote: [$remote], port: [$port], user: [$user], password: [$password], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]\n";
	#print "[ Debug ] ".__LINE__."; remote: [$remote], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]\n";
	
	# Break out the port, if needed.
	my $state;
	my $error;
	#print "[ Debug ] ".__LINE__."; remote: [$remote]\n";
	if ($remote =~ /^(.*):(\d+)$/)
	{
		#print "[ Debug ] ".__LINE__."; >> remote: [$remote], port: [$port]\n";
		$remote = $1;
		$port   = $2;
		#print "[ Debug ] ".__LINE__."; << remote: [$remote], port: [$port]\n";
		if (($port < 0) || ($port > 65536))
		{
			# Variables for 'message_0373'.
			print "[ Error ] ".__LINE__."; - The TCP port: [$port] is out of range. It must be between 1 and 65536. The default is '22'.\n";
			print "[ Error ] ".__LINE__.";   The error was hit calling: [$shell_call]\n";
			exit(8);
		}
	}
	
	# These will be merged into a single 'output' array before returning.
	my $stdout_output = [];
	my $stderr_output = [];
	#print "[ Debug ] ".__LINE__."; ssh_fh: [$ssh_fh]\n";
	if ($ssh_fh !~ /^Net::SSH2/)
	{
		#print "[ Debug ] ".__LINE__."; Opening an SSH connection to: [$user\@$remote:$port].\n";
		$ssh_fh = Net::SSH2->new();
		# Untaint.
		if ($remote =~ /^(.*)$/)  { $remote = $1; }
		if ($port   =~ /^(\d+)$/) { $port   = $1; }
		if (not $ssh_fh->connect($remote, $port, Timeout => 10))
		{
			print "[ Debug ] ".__LINE__."; error: [$@]\n";
			if ($@ =~ /Bad hostname/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(9);
			}
			elsif ($@ =~ /Connection refused/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(10);
			}
			elsif ($@ =~ /No route to host/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(11);
			}
			elsif ($@ =~ /timeout/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(12);
			}
			else
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(13);
			}
		}
		#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh]\n";
		if (not $error)
		{
			#print "[ Debug ] ".__LINE__."; user: [$user], password: [$password]\n";
			$ssh_fh->auth_password($user, $password);
			my $ok = $ssh_fh->auth_ok();
			print "[ Debug ] ".__LINE__."; ok: [$ok]\n";
                        if (not $ok)                                      
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Please check that the password provides is the correct password for 'root' on the target machine.\n";
				exit(14);
			}
			else
			{
				#print "[ Debug ] ".__LINE__."; SSH session opened to: [$remote].\n";
			}
		}
	}
	
	### Special thanks to Rafael Kitover (rkitover@gmail.com), maintainer
	### of Net::SSH2, for helping me sort out the polling and data
	### collection in this section.
	#
	# Open a channel and make the call.
	#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh]\n";
	if (($ssh_fh =~ /^Net::SSH2/) && (not $error))
	{
		# We need to open a channel every time for 'exec' calls. We
		# want to keep blocking off, but we need to enable it for the
		# channel() call.
		$ssh_fh->blocking(1);
		my $channel = $ssh_fh->channel();
		$ssh_fh->blocking(0);
		
		# Make the shell call
		if (not $channel)
		{
			$error  = "Failed to establish channel to remote: [$remote] for shell call: [$shell_call]\n";
			$ssh_fh = "";
		}
		else
		{
			#print "[ Debug ] ".__LINE__."; channel: [$channel], shell_call: [$shell_call]\n";
			$channel->exec("$shell_call");
			# "/etc/ssh/ssh_config",
			# This keeps the connection open when the remote side is slow
			# to return data, like in '/etc/init.d/rgmanager stop'.
			my @poll = {
				handle => $channel,
				events => [qw/in err/],
			};
			
			# We'll store the STDOUT and STDERR data here.
			my $stdout = "";
			my $stderr = "";
			
			# Not collect the data.
			while(1)
			{
				$ssh_fh->poll(250, \@poll);
				
				# Read in anything from STDOUT
				while($channel->read(my $chunk, 80))
				{
					$stdout .= $chunk;
				}
				while ($stdout =~ s/^(.*)\n//)
				{
					my $line = $1;
					#print "[ Debug ] ".__LINE__."; STDOUT: [$line].\n";
					push @{$stdout_output}, $line;
				}
				
				# Read in anything from STDERR
				while($channel->read(my $chunk, 80, 1))
				{
					$stderr .= $chunk;
				}
				while ($stderr =~ s/^(.*)\n//)
				{
					my $line = $1;
					#print "[ Debug ] ".__LINE__."; STDERR: [$line].\n";
					push @{$stderr_output}, $line;
				}
				
				# Exit when we get the end-of-file.
				last if $channel->eof;
			}
			if ($stdout)
			{
				#print "[ Debug ] ".__LINE__."; stdout: [$stdout].\n";
				push @{$stdout_output}, $stdout;
			}
			if ($stderr)
			{
				#print "[ Debug ] ".__LINE__."; stderr: [$stderr].\n";
				push @{$stderr_output}, $stderr;
			}
		}
	}
	
	# Merge the STDOUT and STDERR
	my $output = [];
	
	foreach my $line (@{$stderr_output}, @{$stdout_output})
	{
		#print "[ Debug ] ".__LINE__."; Merge; line: [$line]\n";
		push @{$output}, $line;
	}
	
	# Close the connection if requested.
	if ($close)
	{
		#print "[ Debug ] ".__LINE__."; Disconnecting from: [$remote]\n";
		$ssh_fh->disconnect();
		
		# For good measure, blank both variables.
		$an->data->{remote}{$remote}{ssh_fh} = "";
		$ssh_fh                      = "";
	}
	
	$error = "" if not defined $error;
	#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n";
	return($error, $ssh_fh, $output);
}

# Get (and create if needed) the local user's RSA key.
sub get_local_rsa
{
	my ($conf) = @_;
	
	my $rsa_file = "/home/$an->data->{sys}{username}/.ssh/id_rsa.pub";
	if ($an->data->{sys}{username} eq "root")
	{
		$rsa_file = "/root/.ssh/id_rsa.pub";
	}
	print "- Reading: [$rsa_file]\n";
	if (not -e "$rsa_file")
	{
		# Generate.
		print "- Generating: [$an->data->{sys}{username}]'s RSA keys.\n";
		print "- Please be patient! It can take a few minutes to gather entropy.\n";
		my $ssh_directory = "/home/$an->data->{sys}{username}/.ssh";
		my $shell_call    = "
if [ ! -e '$ssh_directory' ];
then
	mkdir $ssh_directory
	chown $an->data->{sys}{username}:$an->data->{sys}{username} $ssh_directory
	chmod 700 $ssh_directory
fi
$an->data->{executable}{'ssh-keygen'} -t rsa -N \"\" -b 8191 -f /home/$an->data->{sys}{username}/.ssh/id_rsa
chown $an->data->{sys}{username}:$an->data->{sys}{username} /home/$an->data->{sys}{username}/.ssh/id_rsa
chown $an->data->{sys}{username}:$an->data->{sys}{username} /home/$an->data->{sys}{username}/.ssh/id_rsa.pub
chmod 600 /home/$an->data->{sys}{username}/.ssh/id_rsa
chown 644 /home/$an->data->{sys}{username}/.ssh/id_rsa.pub";
		open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		print "/------------------\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /already exists/)
			{
				print "- The RSA key already exists, but I didn't see it.\n";
				exit(5);
			}
			print "| $line\n";
		}
		close $file_handle;
		print "\\------------------\n";
	}
	if (not -e "$rsa_file")
	{
		# Something went wrong...
		print "[ Error ] - It looks like something went wrong.\n";
		print "[ Error ]   The RSA key doesn't exist, but it should have been created.\n";
		exit(2);
	}
	if (not -r "$rsa_file")
	{
		# Unreadable...
		print "[ Error ] - I was unable to read: [$rsa_file].\n";
		print "[ Error ]   Please check the permissions and ownership.\n";
		exit(3);
	}
	
	# Read it!
	my $shell_call = "$rsa_file";
	open (my $file_handle, "<", "$rsa_file") or die "$THIS_FILE ".__LINE__."; Failed to read: [$rsa_file], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^ssh-rsa .* (.*?\@.*)$/)
		{
			$an->data->{sys}{user_host} = $1;
			$an->data->{sys}{rsa_key}   = $line;
			last;
		}
	}
	close $file_handle;
	#print "[ Debug ] ".__LINE__." - User and host: [$an->data->{sys}{user_host}], RSA key: [$an->data->{sys}{rsa_key}]\n";
	
	return(0);
}

# This validates a string as being an IPv4 address in dotted-decimal notation.
sub validate_ip_address
{
	my ($conf, $ip) = @_;

	if ($ip =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/)
	{
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		# First octal has to be >= 1. The rest can be 0.
		if (($first_octal < 1)  || ($first_octal > 255)  ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal < 0)  || ($third_octal > 255)  ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			$ip = "#!INVALID!#";
		}
	}
	else
	{
		# Not even formatted properl.
		$ip = "#!INVALID!#";
	}

	return($ip);
}

# This breaks out the command-line switches and varifies that their values are
# (more or less) sane
sub sanity_check_switches
{
	my ($conf) = @_;
	
	# Something has been set for all values, sanity check them.
	# This will fail out if set to '1' once all sanity checking is done.
	my $bad_value = 0;

	# The network is a little tricker
	if (($an->data->{switches}{h}) or ($an->data->{switches}{help}) or ($an->data->{switches}{'?'}))
	{
		print_usage($conf);
		exit(0);
	}
	if (not $an->data->{switches}{r})
	{
		print "[ Error ] - The remote machine machine must be specified with: '-r <ip_or_hostname>'.\n";
		$bad_value = 1;
	}
	else
	{
		# Check the remote machine.
		if (validate_ip_address($conf, $an->data->{switches}{r}) eq "#!INVALID!#")
		{
			# It's not an IP, try to resolve it.
			print "- Resolving hostname: [$an->data->{switches}{r}] to IP address.\n";
			my $shell_call = "$an->data->{executable}{gethostip} -d $an->data->{switches}{r}";
			# Untaint the call so that it works when called via
			# setuid.
			if ($shell_call =~ /^(\/.*? -d .*)$/)
			{
				$shell_call = $1;
			}
			else
			{
				die "$THIS_FILE ".__LINE__."; shell_call appears to be tainted: [$shell_call]\n";
			}
			open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] ".__LINE__." - line: [$line]\n";
				if (($line =~ /lookup failure/i) || ($line =~ /unknown host/i))
				{
					print "[ Error ] - Unable to resolve hostname: [$an->data->{switches}{r}] to an IP address.\n";
					$bad_value = 1;
				}
			}
			close $file_handle;
		}
		else
		{
			# It's an IP address, we're good.
		}
		$an->data->{sys}{remote} = $an->data->{switches}{r};
	}
	
	# Make sure we have a password.
	if ((not $an->data->{switches}{p}) && (not $an->data->{switches}{P}))
	{
		print "[ Error ] - No password or password script passed.\n";
		$bad_value = 1;
	}
	
	# We have a password, but which type?
	if ($an->data->{switches}{p})
	{
		# Directly passed. Copy the password into the 'sys' hash.
		$an->data->{sys}{password} = $an->data->{switches}{p};
	}
	
	# Script, run it.
	if ($an->data->{switches}{P})
	{
		# Script!
		print "- Running: [$an->data->{switches}{P}] to get the remote machine's 'root' password\n";
		if (not -e $an->data->{switches}{P})
		{
			print "[ Error ] - Password script: [$an->data->{switches}{P}] not found!\n";
			$bad_value = 1;
		}
		elsif (not -x $an->data->{switches}{P})
		{
			print "[ Error ] - Password script: [$an->data->{switches}{P}] is not executable! Try running:\n";
			print "[ Error ]   chmod 755 $an->data->{switches}{P}\n";
			$bad_value = 1;
		}
		my $shell_call = "$an->data->{switches}{P}";
		open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->data->{sys}{password} = $line;
			last;
		}
		close $file_handle;
		
		if (not $an->data->{sys}{password})
		{
			print "[ Error ] - Password script didn't appear to print the password.\n";
			print "[ Error ]   Make sure the script prints the password on the first line and then exits.\n";
		}
	}
	
	return($bad_value);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$an->data->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$an->data->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$an->data->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$an->data->{switches}{$last_argument} = $value;
				}
				else
				{
					$an->data->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$an->data->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$an->data->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($an->data->{switches}{raw})
	{
		$an->data->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$an->data->{switches}}) { print "Variable: [$variable]\t-> value: [$an->data->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = q|
 -=] Populate Remote ~/.ssh/authorized_keys

DESCRIPTION

This program will read the user's RSA keys, creating the keys if needed, and
then add them to the target machine's ~/.ssh/authorized_keys file for the
'root' user and any user found in /home/.


SWITCHES

 -h, -?, --help

	Show this dialoge and exit.

 -p <password>

	This is the remote machine's 'root' user password.

 -P </path/to/password.script>

	If you do not want to pass the password on the command line, you can
	use this option to specify a script which prints the root user's
	password. To create this, create a text file that has:
		echo '<password>'
	Save it, and set it to be executable:
		chmod 755 /path/to/password.script

 -r <ip_or_hostname>
	
	This is the IP address (or resolvable host name) of the remote machine.


EXAMPLE

Use an IP address and password:

 ./populate_remote_authorized_keys -r 10.255.5.1 -p secret
 
Use a hostname and password script:

 ./populate_remote_authorized_keys -r my.server -P /root/my.server.pw

                  
SUPPORT

https://alteeve.ca/w/Support

							      Alteeve's Niche!
|;
	open (my $file_handle, ">", "/tmp/populate_remote_authorized_keys") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/populate_remote_authorized_keys");

	return(0);
}
=cut
