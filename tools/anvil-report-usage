#!/usr/bin/perl
# 
# This is a simple tool that shows how much system resources are available and how much is used by servers.
# 
# Exit Codes;
# 0  = OK
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Data::Dumper;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		'anvil-report-usage' =>	{
			log_db_transactions	=>	0,
		},
		path		=>	{
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		switches	=>	{
		},
		sys		=>	{
			language		=>	"en_CA",
			log_language		=>	"en_CA",
			log_level		=>	2,
			program_name		=>	$program_name,
		},
}});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{'anvil-rehome-server'}{log_db_transactions};
$an->Readable->base2(1);

gather_data($an);

report($an);

$an->nice_exit({exit_code => 0});

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# Format and print.
sub report
{
	my ($an) = @_;
	
	if ($an->data->{switches}{pretty})
	{
		pretty_report($an);
	}
	else
	{
		parsable_report($an);
	}
	
	return(0);
}

# Show the results for a human to read.
sub pretty_report
{
	my ($an) = @_;
	
	
	my $name_length = 0;
	my $source_length = 0;
	my $cpu_length = 0;
	
	my $say_cpu         = $an->String->get({key => "row_0006"});
	my $say_storage     = $an->String->get({key => "title_0077"});
	my $say_network     = $an->String->get({key => "title_0089"});
	my $say_server_name = $an->String->get({key => "row_0114"});
	my $say_ram         = $an->String->get({key => "title_0076"});
	my $say_cores       = $an->String->get({key => "title_0078"});
	my $say_type        = $an->String->get({key => "row_0004"});
	my $say_bus         = $an->String->get({key => "row_0007"});
	my $say_target      = $an->String->get({key => "row_0308"});
	my $say_size        = $an->String->get({key => "row_0060"});
	my $say_source      = $an->String->get({key => "row_0008"});
	my $say_mac         = $an->String->get({key => "row_0009"});
	my $say_model       = $an->String->get({key => "row_0046"});
	my $say_bridge      = $an->String->get({key => "row_0010"});
	
	my $length_server_name    = length($say_server_name);
	my $length_ram            = length($say_ram);
	my $length_cpu_cores      = length($say_cores);
	my $length_cpu_type       = length($say_type);
	my $length_storage_type   = length($say_type);
	my $length_storage_bus    = length($say_bus);
	my $length_storage_target = length($say_target);
	my $length_storage_size   = length($say_size);
	my $length_storage_source = length($say_source);
	my $length_network_mac    = length($say_mac);
	my $length_network_model  = length($say_model);
	my $length_network_bridge = length($say_bridge);
	
	# The first pass figures out maximum lengths and prepares the arrays.
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{server}})
	{
		
		my $ram   = $an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{$name}{ram}});
		my $cores = $an->data->{server}{$name}{cpu}{cores};
		my $type  = $an->data->{server}{$name}{cpu}{mode};
		
		if (length($name)  > $length_server_name) { $length_server_name = length($name);  }
		if (length($ram)   > $length_ram)         { $length_ram         = length($ram);   }
		if (length($cores) > $length_cpu_cores)   { $length_cpu_cores  = length($cores); }
		if (length($type)  > $length_cpu_type)    { $length_cpu_type   = length($type);  }
		
		$an->data->{server}{$name}{disk_array} = [];
		$an->data->{server}{$name}{nic_array}  = [];
		foreach my $device_type (sort {$b cmp $a} keys %{$an->data->{server}{$name}{block}})
		{
			foreach my $guest_device (sort {$a cmp $b} keys %{$an->data->{server}{$name}{block}{$device_type}})
			{
				my $bus    = $an->data->{server}{$name}{block}{$device_type}{$guest_device}{bus};
				my $size   = $an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{$name}{block}{$device_type}{$guest_device}{size}});
				my $source = $an->data->{server}{$name}{block}{$device_type}{$guest_device}{source};
				if (length($device_type)  > $length_storage_type)   { $length_storage_type   = length($device_type);  }
				if (length($bus)          > $length_storage_bus)    { $length_storage_bus    = length($bus);          }
				if (length($guest_device) > $length_storage_target) { $length_storage_target = length($guest_device); }
				if (length($size)         > $length_storage_size)   { $length_storage_size   = length($size);         }
				if (length($source)       > $length_storage_source) { $length_storage_source = length($source);       }
				#print "server: [$name], type: [$device_type ($length_storage_type)], guest device: [$guest_device ($length_storage_target)], bus: [$bus ($length_storage_bus)], size: [$size ($length_storage_size)], source: [$source ($length_storage_source)]\n";
				
				# Store the MAC, the store the hash reference.
				$an->data->{server}{$name}{block}{$device_type}{$guest_device}{size}         = $size;
				$an->data->{server}{$name}{block}{$device_type}{$guest_device}{device_type}  = $device_type;
				$an->data->{server}{$name}{block}{$device_type}{$guest_device}{guest_device} = $guest_device;
				push @{$an->data->{server}{$name}{disk_array}}, $an->data->{server}{$name}{block}{$device_type}{$guest_device};
			}
		}
		foreach my $mac (sort {$a cmp $b} keys %{$an->data->{server}{$name}{network}})
		{
			my $model  = $an->data->{server}{$name}{network}{$mac}{model};
			my $bridge = $an->data->{server}{$name}{network}{$mac}{bridge};
			if (length($mac)    > $length_network_mac)    { $length_network_mac    = length($mac);    }
			if (length($model)  > $length_network_model)  { $length_network_model  = length($model);  }
			if (length($bridge) > $length_network_bridge) { $length_network_bridge = length($bridge); }
			
			# Store the MAC, the store the hash reference.
			$an->data->{server}{$name}{network}{$mac}{mac} = $mac;
			push @{$an->data->{server}{$name}{nic_array}}, $an->data->{server}{$name}{network}{$mac};
		}
	}
	
	# Now display;
	my $total_length = 2 + $length_server_name + 3 + $length_ram + 3 + $length_cpu_cores + 3 + $length_cpu_type + 3 + $length_storage_type + 3 + $length_storage_bus + 3 + $length_storage_target + 3 + $length_storage_size + 3 + $length_storage_source + 3 + $length_network_mac + 3 + $length_network_model + 3 + $length_network_bridge + 2;
	print " "; for (0..($total_length - 3)) { print "_"; } print " \n";
	
	print "| ".sprintf("%-${length_server_name}s", "")."   ".sprintf("%-${length_ram}s", "")." | -=] ".sprintf("%-".($length_cpu_cores + $length_cpu_type - 1)."s", $say_cpu)." | -=] ".sprintf("%-".($length_storage_type + $length_storage_bus + $length_storage_target + $length_storage_size + $length_storage_source + 8)."s", $say_storage)." | -=] ".sprintf("%-".($length_network_mac + $length_network_model + $length_network_bridge + 2)."s", $say_network)." |\n";
	
	print "| ".sprintf("%-${length_server_name}s", $say_server_name)." | ".sprintf("%-${length_ram}s", $say_ram)." | ".sprintf("%-${length_cpu_cores}s", $say_cores)." | ".sprintf("%-${length_cpu_type}s", $say_type)." | ".sprintf("%-${length_storage_type}s", $say_type)." | ".sprintf("%-${length_storage_bus}s", $say_bus)." | ".sprintf("%-${length_storage_target}s", $say_target)." | ".sprintf("%-${length_storage_size}s", $say_size)." | ".sprintf("%-${length_storage_source}s", $say_source)." | ".sprintf("%-${length_network_mac}s", $say_mac)." | ".sprintf("%-${length_network_model}s", $say_model)." | ".sprintf("%-${length_network_bridge}s", $say_bridge)." |\n";
	
	my $break_line = "+-".sprintf("%0${length_server_name}d", 0)."-+-".sprintf("%0${length_ram}d", 0)."-+-".sprintf("%0${length_cpu_cores}d", 0)."-+-".sprintf("%0${length_cpu_type}d", 0)."-+-".sprintf("%0${length_storage_type}d", 0)."-+-".sprintf("%0${length_storage_bus}d", 0)."-+-".sprintf("%0${length_storage_target}d", 0)."-+-".sprintf("%0${length_storage_size}d", 0)."-+-".sprintf("%0${length_storage_source}d", 0)."-+-".sprintf("%0${length_network_mac}d", 0)."-+-".sprintf("%0${length_network_model}d", 0)."-+-".sprintf("%0${length_network_bridge}d", 0)."-+";
	   $break_line =~ s/0/-/g;
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{server}})
	{
		print $break_line."\n";
		my $ram   = $an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{$name}{ram}});
		my $cores = $an->data->{server}{$name}{cpu}{cores};
		my $type  = $an->data->{server}{$name}{cpu}{mode};
		
		# How many lines?
		my $disk_lines = @{$an->data->{server}{$name}{disk_array}};
		my $nic_lines  = @{$an->data->{server}{$name}{nic_array}};
		my $lines      = $disk_lines > $nic_lines ? $disk_lines : $nic_lines;
		
		my $disk_hash = $an->data->{server}{$name}{disk_array}->[0];
		my $nic_hash  = $an->data->{server}{$name}{nic_array}->[0];
		
		print "| ".sprintf("%-${length_server_name}s", $name)." | ".sprintf("%-${length_ram}s", $ram)." | ".sprintf("%-${length_cpu_cores}s", $cores)." | ".sprintf("%-${length_cpu_type}s", $type)." | ".sprintf("%-${length_storage_type}s", $disk_hash->{device_type})." | ".sprintf("%-${length_storage_bus}s", $disk_hash->{bus})." | ".sprintf("%-${length_storage_target}s", $disk_hash->{guest_device})." | ".sprintf("%-${length_storage_size}s", $disk_hash->{size})." | ".sprintf("%-${length_storage_source}s", $disk_hash->{source})." | ".sprintf("%-${length_network_mac}s", $nic_hash->{mac})." | ".sprintf("%-${length_network_model}s", $nic_hash->{model})." | ".sprintf("%-${length_network_bridge}s", $nic_hash->{bridge})." |\n";
		for (my $i = 1; $i < $lines; $i++)
		{
			$disk_hash = defined $an->data->{server}{$name}{disk_array}->[$i] ? $an->data->{server}{$name}{disk_array}->[$i] : {};
			$nic_hash  = defined $an->data->{server}{$name}{nic_array}->[$i]  ? $an->data->{server}{$name}{nic_array}->[$i]  : {};
			
			$disk_hash->{device_type}  = "" if not defined $disk_hash->{device_type};
			$disk_hash->{bus}          = "" if not defined $disk_hash->{bus};
			$disk_hash->{guest_device} = "" if not defined $disk_hash->{guest_device};
			$disk_hash->{size}         = "" if not defined $disk_hash->{size};
			$disk_hash->{source}       = "" if not defined $disk_hash->{source};
			$nic_hash->{mac}           = "" if not defined $nic_hash->{mac};
			$nic_hash->{model}         = "" if not defined $nic_hash->{model};
			$nic_hash->{bridge}        = "" if not defined $nic_hash->{bridge};
			print "| ".sprintf("%-${length_server_name}s", "")." | ".sprintf("%-${length_ram}s", "")." | ".sprintf("%-${length_cpu_cores}s", "")." | ".sprintf("%-${length_cpu_type}s", $type)." | ".sprintf("%-${length_storage_type}s", $disk_hash->{device_type})." | ".sprintf("%-${length_storage_bus}s", $disk_hash->{bus})." | ".sprintf("%-${length_storage_target}s", $disk_hash->{guest_device})." | ".sprintf("%-${length_storage_size}s", $disk_hash->{size})." | ".sprintf("%-${length_storage_source}s", $disk_hash->{source})." | ".sprintf("%-${length_network_mac}s", $nic_hash->{mac})." | ".sprintf("%-${length_network_model}s", $nic_hash->{model})." | ".sprintf("%-${length_network_bridge}s", $nic_hash->{bridge})." |\n";
		}
	}
	$break_line =~ s/^\+/ /;
	$break_line =~ s/\+$/ /;
	$break_line =~ s/\+/^/g;
	print $break_line."\n\n";
	
	my $bridges = "";
	foreach my $bridge_name (sort {$a cmp $b} keys %{$an->data->{bridge}})
	{
		$bridges .= $bridge_name.", ";
	}
	$bridges =~ s/, $//;
	
	my $volume_groups = "";
	foreach my $vg (sort {$a cmp $b} keys %{$an->data->{vg}})
	{
		$volume_groups .= $an->String->get({key => "message_0009", variables => {
			name => $vg, 
			size => $an->Readable->bytes_to_hr({'bytes' => $an->data->{vg}{$vg}{size}}),
			free => $an->Readable->bytes_to_hr({'bytes' => $an->data->{vg}{$vg}{free}}),
		}})."\n";
	}


	print $an->String->get({key => "message_0008", variables => {
		cores         => $an->data->{summary}{cpu}{cores}, 
		threads       => $an->data->{summary}{cpu}{threads}, 
		model         => $an->data->{summary}{cpu}{model}, 
		ram_size      => $an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{size}}), 
		ram_allocated => $an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{allocated}}), 
		ram_available => $an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{available}}), 
		swap_size     => $an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{swap}{size}}), 
		swap_used     => $an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{swap}{used}}), 
		swap_free     => $an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{swap}{free}}), 
		bridges       => $bridges,
		volume_groups => 
	}})."\n\n";
	
	return(0);
}

# Show the data in a machine-parsable way.
sub parsable_report
{
	my ($an) = @_;
	
	print "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<usage>
	<cpu>
		<model>".$an->data->{summary}{cpu}{model}."</model>
		<cores>".$an->data->{summary}{cpu}{cores}."</cores>
		<threads>".$an->data->{summary}{cpu}{threads}."</threads>
	</cpu>
	<ram>
		<size>".$an->data->{summary}{ram}{size}."</size>
		<free>".$an->data->{summary}{ram}{free}."</free>
		<available>".$an->data->{summary}{ram}{available}."</available>
		<allocated>".$an->data->{summary}{ram}{allocated}."</allocated>
	</ram>
	<swap>
		<size>".$an->data->{summary}{swap}{size}."</size>
		<free>".$an->data->{summary}{swap}{free}."</free>
		<used>".$an->data->{summary}{swap}{used}."</used>
	</swap>
	<bridges>
";
	foreach my $bridge_name (sort {$a cmp $b} keys %{$an->data->{bridge}})
	{
		print "\t\t<bridge><![CDATA[$bridge_name]]></bridge>\n";
	}
	print "\t</bridges>
	<volume_groups>\n";
	foreach my $vg (sort {$a cmp $b} keys %{$an->data->{vg}})
	{
		print "\t\t<volume_group>
			<name><![CDATA[".$vg."]]></name>
			<size>".$an->data->{vg}{$vg}{size}."</size>
			<pe_size>".$an->data->{vg}{$vg}{pe_size}."</pe_size>
			<free>".$an->data->{vg}{$vg}{free}."</free>
		</volume_group>
";
	}
	print "\t</volume_groups>
	<logical_volumes>\n";
	foreach my $lv (sort {$a cmp $b} keys %{$an->data->{lv}})
	{
		# This can exist if an LV is referenced in a definition file, but not exist yet locally. So 
		# we skip if there is no size.
		next if not exists $an->data->{lv}{$lv}{size};
		print "\t\t<logical_volume>
			<name>$lv</name>
			<on_vg>".$an->data->{lv}{$lv}{on_vg}."</on_vg>
			<size>".$an->data->{lv}{$lv}{size}."</size>
		</logical_volume>\n";
	}
	print "\t</logical_volumes>\n";
	
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{server}})
	{
		print "\t<server>
		<name><![CDATA[$name]]></name>
		<ram>".$an->data->{server}{$name}{ram}."</ram>
		<cpu>
			<cores>".$an->data->{server}{$name}{cpu}{cores}."</cores>
			<mode>".$an->data->{server}{$name}{cpu}{mode}."</mode>
		</cpu>
";

		# Pull out storage
		foreach my $device_type (sort {$a cmp $b} keys %{$an->data->{server}{$name}{block}})
		{
			foreach my $guest_device (sort {$a cmp $b} keys %{$an->data->{server}{$name}{block}{$device_type}})
			{
				print "\t\t<block>
			<device_type>$device_type</device_type>
			<guest_device>$guest_device</guest_device>
			<bus>".$an->data->{server}{$name}{block}{$device_type}{$guest_device}{bus}."</bus>
			<source>".$an->data->{server}{$name}{block}{$device_type}{$guest_device}{source}."</source>
			<size>".$an->data->{server}{$name}{block}{$device_type}{$guest_device}{size}."</size>
		</block>
";
			}
		}
		
		# Pull out network
		foreach my $mac (sort {$a cmp $b} keys %{$an->data->{server}{$name}{network}})
		{
				print "\t\t<interface>
			<mac>$mac</mac>
			<bridge>".$an->data->{server}{$name}{network}{$mac}{bridge}."</bridge>
			<model>".$an->data->{server}{$name}{network}{$mac}{model}."</model>
		</interface>
";
		}
	print "\t</server>
";
	}
	
	print "</usage>\n";
	
	return(0);
}

# Collect the data we want
sub gather_data
{
	my ($an) = @_;
	
	collect_cpu_data($an);
	collect_ram_data($an);
	collect_storage_data($an);
	collect_server_data($an);
	collect_bridges($an);
	
	return(0);
}

sub collect_bridges
{
	my ($an) = @_;
	
	my $shell_call = $an->data->{path}{brctl}." show";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		next if $line =~ /^bridge name/i;
		next if $line =~ /^\s/;
		if ($line =~ /^(\S.*?)\s/)
		{
			my $bridge_name = $1;
			$an->data->{bridge}{$bridge_name} = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bridge::${bridge_name}", value1 => $an->data->{bridge}{$bridge_name}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	return(0);
}

# This reads in the XML files for the servers to report what each server is using.
sub collect_server_data
{
	my ($an) = @_;
	
	$an->data->{summary}{ram}{allocated} = 0;
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::shared_definitions", value1 => $an->data->{path}{shared_definitions}, 
	}, file => $THIS_FILE, line => __LINE__});
	local(*DIRECTORY);
	opendir(DIRECTORY, $an->data->{path}{shared_definitions});
	while(my $file = readdir(DIRECTORY))
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "file", value1 => $file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		next if $file !~ /\.xml$/;
		my $full_file = $an->data->{path}{shared_definitions}."/".$file;
		next if not -f $full_file;
		
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "full_file", value1 => $full_file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $xml  = XML::Simple->new();
		my $data = $xml->XMLin($full_file, ForceArray => 1);
		
		#print Dumper $data;
		my $current_memory_number = $data->{currentMemory}->[0]->{content};
		my $current_memory_units  = $data->{currentMemory}->[0]->{unit};
		my $current_memory_bytes  = $an->Readable->hr_to_bytes({size => $current_memory_number, type => $current_memory_units});
		my $memory_number         = $data->{memory}->[0]->{content};
		my $memory_units          = $data->{memory}->[0]->{unit};
		my $memory_bytes          = $an->Readable->hr_to_bytes({size => $current_memory_number, type => $current_memory_units});
		my $ram                   = $current_memory_bytes > $memory_bytes ? $current_memory_bytes : $memory_bytes;
		my $cores                 = $data->{vcpu}->[0]->{content};
		my $cpu_mode              = $data->{cpu}->[0]->{mode} ? $data->{cpu}->[0]->{mode} : $an->String->get({key => "state_0041"});;
		my $name                  = $data->{name}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
			name1  => "current_memory_number", value1  => $an->Readable->comma($current_memory_number), 
			name2  => "current_memory_units",  value2  => $current_memory_units, 
			name3  => "current_memory_bytes",  value3  => $current_memory_bytes." (".$an->Readable->bytes_to_hr({'bytes' => $current_memory_bytes}).")", 
			name4  => "memory_number",         value4  => $an->Readable->comma($memory_number), 
			name5  => "memory_units",          value5  => $memory_units, 
			name6  => "memory_bytes",          value6  => $memory_bytes." (".$an->Readable->bytes_to_hr({'bytes' => $memory_bytes}).")", 
			name7  => "ram",                   value7  => $ram." (".$an->Readable->bytes_to_hr({'bytes' => $ram}).")", 
			name8  => "cores",                 value8  => $cores, 
			name9  => "cpu_mode",              value9  => $cpu_mode, 
			name10 => "name",                  value10 => $name, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{server}{$name}{cpu}{cores} =  $cores;
		$an->data->{server}{$name}{cpu}{mode}  =  $cpu_mode;
		$an->data->{server}{$name}{ram}        =  $ram;
		$an->data->{summary}{ram}{allocated}   += $ram;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "server::${name}::cpu::cores", value1 => $an->data->{server}{$name}{cpu}{cores}, 
			name2 => "server::${name}::cpu::mode",  value2 => $an->data->{server}{$name}{cpu}{mode}, 
			name3 => "server::${name}::ram",        value3 => $an->data->{server}{$name}{ram}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{$name}{ram}}).")", 
			name4 => "summary::ram::allocated",     value4 => $an->data->{summary}{ram}{allocated}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{allocated}}).")", 
		}, file => $THIS_FILE, line => __LINE__});
		
		#print Dumper $data->{devices}->[0]->{disk};
		foreach my $hash_ref (@{$data->{devices}->[0]->{disk}})
		{
			my $device_type  = $hash_ref->{device};
			my $source       = $hash_ref->{source}->[0]->{dev} ? $hash_ref->{source}->[0]->{dev} : "";
			my $guest_device = $hash_ref->{target}->[0]->{dev};
			my $bus          = $hash_ref->{target}->[0]->{bus};
			my $size         = 0;
			if ((not $source) && ($device_type eq "cdrom"))
			{
				$source = $an->String->get({key => "state_0023"});
			}
			elsif (($device_type eq "disk") && ($an->data->{lv}{$source}{size}))
			{
				$size = $an->data->{lv}{$source}{size};
			}
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "device_type",  value1 => $device_type, 
				name2 => "source",       value2 => $source, 
				name3 => "guest_device", value3 => $guest_device, 
				name4 => "bus",          value4 => $bus, 
				name5 => "size",         value5 => $size." (".$an->Readable->bytes_to_hr({'bytes' => $size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{server}{$name}{block}{$device_type}{$guest_device}{bus}    = $bus;
			$an->data->{server}{$name}{block}{$device_type}{$guest_device}{source} = $source;
			$an->data->{server}{$name}{block}{$device_type}{$guest_device}{size}   = $size;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "server::${name}::block::${device_type}::${guest_device}::bus",    value1 => $an->data->{server}{$name}{block}{$device_type}{$guest_device}{bus}, 
				name2 => "server::${name}::block::${device_type}::${guest_device}::source", value2 => $an->data->{server}{$name}{block}{$device_type}{$guest_device}{source}, 
				name3 => "server::${name}::block::${device_type}::${guest_device}::size",   value3 => $an->data->{server}{$name}{block}{$device_type}{$guest_device}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{$name}{block}{$device_type}{$guest_device}{size}}).")",  
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		#print Dumper $data->{devices}->[0]->{interface};
		foreach my $hash_ref (@{$data->{devices}->[0]->{interface}})
		{
			my $bridge = $hash_ref->{source}->[0]->{bridge};
			my $model  = $hash_ref->{model}->[0]->{type};
			my $mac    = $hash_ref->{mac}->[0]->{address};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "bridge", value1 => $bridge, 
				name2 => "model",  value2 => $model, 
				name3 => "mac",    value3 => $mac,  
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{server}{$name}{network}{$mac}{bridge} = $bridge;
			$an->data->{server}{$name}{network}{$mac}{model}  = $model;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "server::${name}::network::${mac}::bridge", value1 => $an->data->{server}{$name}{network}{$mac}{bridge}, 
				name2 => "server::${name}::network::${mac}::model",  value2 => $an->data->{server}{$name}{network}{$mac}{model}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	closedir(DIRECTORY);
	
	# Calculate the available RAM; We take a simple 4GiB off as our 'free' comes from dmi, not /proc/meminfo
	$an->data->{summary}{ram}{free}      = $an->data->{summary}{ram}{size} - $an->data->{summary}{ram}{allocated};
	$an->data->{summary}{ram}{available} = $an->data->{summary}{ram}{free} - (4 * (2 ** 30));
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "summary::ram::free",      value1 => $an->data->{summary}{ram}{free}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{free}}).")", 
		name2 => "summary::ram::available", value2 => $an->data->{summary}{ram}{available}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{available}}).")", 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This collects data on existing LVs and VGs.
sub collect_storage_data
{
	my ($an) = @_;
	
	# Collect the LVs
	my $lv_path    = "";
	my $lv_size    = 0;
	my $on_vg      = "";
	my $shell_call = $an->data->{path}{lvdisplay}." --units b";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /LV Path (\/dev\/.*)$/)
		{
			$lv_path = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "lv_path", value1 => $lv_path, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $lv_path;
		
		if ($line =~ /VG Name (.*)$/)
		{
			$on_vg = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "on_vg", value1 => $on_vg, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /LV Size (\d+) B/)
		{
			$lv_size = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "lv_size", value1 => $lv_size." (".$an->Readable->bytes_to_hr({'bytes' => $lv_size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (not $line)
		{
			if ($lv_size)
			{
				$an->data->{lv}{$lv_path}{on_vg} = $on_vg;
				$an->data->{lv}{$lv_path}{size}  = $lv_size;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "lv::${lv_path}::on_vg", value1 => $an->data->{lv}{$lv_path}{on_vg}, 
					name2 => "lv::${lv_path}::size",  value2 => $an->data->{lv}{$lv_path}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{lv}{$lv_path}{size}}).")", 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$lv_path = "";
			$lv_size = 0;
			$on_vg   = "";
		}
	}
	close $file_handle;
	
	# Get VG info
	my $in_vg      = "";
	   $shell_call = $an->data->{path}{vgdisplay}." --units b";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /VG Name (.*+)$/)
		{
			$in_vg = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_vg", value1 => $in_vg, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		next if not $in_vg;
		if (not $line)
		{
			$in_vg = "";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_vg", value1 => $in_vg, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		if ($line =~ /VG Size (\d+) B/)
		{
			$an->data->{vg}{$in_vg}{size} = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "vg::${in_vg}::size", value1 => $an->data->{vg}{$in_vg}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{vg}{$in_vg}{size}}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /PE Size (\d+) B/)
		{
			$an->data->{vg}{$in_vg}{pe_size} = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "vg::${in_vg}::pe_size", value1 => $an->data->{vg}{$in_vg}{pe_size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{vg}{$in_vg}{pe_size}}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /Free PE \/ Size \d+ \/ (\d+) B/)
		{
			$an->data->{vg}{$in_vg}{free} = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "vg::${in_vg}::free", value1 => $an->data->{vg}{$in_vg}{free}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{vg}{$in_vg}{free}}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	return(0);
}

# This reads in data about the RAM
sub collect_ram_data
{
	my ($an) = @_;
	
	my $total_size    = 0;
	my $size          = "";
	my $locator       = "";
	my $manufacturer  = "";
	my $part_number   = "";
	my $serial_number = "";
	my $shell_call = $an->data->{path}{dmidecode}." --type memory";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:\s+/: /;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	
		if ($line =~ /^Locator: (.*?)$/)
		{
			$locator = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "locator", value1 => $locator, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /^Size: (.*?)$/)
		{
			$size = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "size", value1 => $size, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If the "size" is "no module installed", we're done here.
			if ($size !~ /^\d/)
			{
				$locator = "";
				$size    = "";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "locator", value1 => $locator, 
					name2 => "size",    value2 => $size, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			# THis reports in 'MB' but it's really 'MiB'.
			$size = $an->Readable->hr_to_bytes({
				base2 => 1,
				size  => $size,
			});
			$total_size += $size;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "size",       value1 => $size, 
				name2 => "total_size", value2 => $total_size, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $locator;
		if (not $line)
		{
			if ($size)
			{
				$an->data->{ram}{dmi}{locator}{$locator}{size} = $size;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "ram::dmi::locator::${locator}::size", value1 => $an->Readable->comma($an->data->{ram}{dmi}{locator}{$locator}{size})." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{ram}{dmi}{locator}{$locator}{size}}).")", 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			$size    = "";
			$locator = "";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "size",    value1 => $size, 
				name2 => "locator", value2 => $locator, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	if (-r '/proc/meminfo')
	{
		my $shell_call = "/proc/meminfo";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "tools_title_0003", message_key => "error_message_0066", message_variables => { shell_call => $shell_call, error => $! }, code => 3, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+:\s+/: /;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($line =~ /^(.*?):\s+(\d+.*?)$/)
			{
				my $variable = $1;
				my $size     = $2;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "size",     value2 => $size, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# We care about a few variables only.
				my $say_variable = "";
				if ($variable eq "SwapTotal")
				{
					$say_variable = "swap_total";
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "say_variable", value1 => $say_variable, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				if ($variable eq "SwapFree")
				{
					$say_variable = "swap_free";
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "say_variable", value1 => $say_variable, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				next if not $say_variable;
				
				# This reports sizes as 'kB', but it's really base2.
				$size = $an->Readable->hr_to_bytes({
					base2 => 1,
					size  => $size,
				});
				
				$an->data->{summary}{ram}{proc}{$say_variable} = $size;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "summary::ram::proc::${say_variable}", value1 => $an->Readable->comma($an->data->{summary}{ram}{proc}{$say_variable})." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{proc}{$say_variable}}).")", 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
	}
	
	$an->data->{summary}{ram}{size}  = $total_size;
	$an->data->{summary}{swap}{size} = $an->data->{summary}{ram}{proc}{swap_total};
	$an->data->{summary}{swap}{free} = $an->data->{summary}{ram}{proc}{swap_free};
	$an->data->{summary}{swap}{used} = $an->data->{summary}{ram}{proc}{swap_total} - $an->data->{summary}{ram}{proc}{swap_free};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "summary::ram::size",  value1 => $an->Readable->comma($an->data->{summary}{ram}{size})." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{ram}{size}}).")", 
		name2 => "summary::swap::size", value2 => $an->Readable->comma($an->data->{summary}{swap}{size})." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{swap}{size}}).")", 
		name3 => "summary::swap::free", value3 => $an->Readable->comma($an->data->{summary}{swap}{free})." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{swap}{free}}).")", 
		name4 => "summary::swap::used", value4 => $an->Readable->comma($an->data->{summary}{swap}{used})." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{summary}{swap}{used}}).")", 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This reads in data about the CPU
sub collect_cpu_data
{
	my ($an) = @_;
	my $total_cores   = 0;
	my $total_threads = 0;
	my $cores         = 0;
	my $threads       = 0;
	my $in_cpu        = "";
	
	my $shell_call = $an->data->{path}{dmidecode}." --type processor";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Socket Designation: (.*+)$/)
		{
			$in_cpu = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_cpu", value1 => $in_cpu, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif (not $line)
		{
			# TODO: Process here?
			$in_cpu  = "";
			$cores   = 0;
			$threads = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "in_cpu",  value1 => $in_cpu, 
				name2 => "cores",   value2 => $cores, 
				name3 => "threads", value3 => $threads, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if $in_cpu eq "";
		
		if ($line =~ /Core Count: (\d+)$/)
		{
			$cores       =  $1;
			$total_cores += $cores; 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "cores",       value1 => $cores, 
				name2 => "total_cores", value2 => $total_cores, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /Thread Count: (\d+)$/)
		{
			$threads       =  $1;
			$total_threads += $threads; 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "threads",       value1 => $threads, 
				name2 => "total_threads", value2 => $total_threads, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# Read in /proc/cpuinfo.
	my $model = "";
	if (-r '/proc/cpuinfo')
	{
		my $shell_call = "/proc/cpuinfo";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "tools_title_0003", message_key => "error_message_0066", message_variables => { shell_call => $shell_call, error => $! }, code => 3, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+:\s+/: /;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($line =~ /^model name: (.*?)$/)
			{
				my $this_model = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "this_model", value1 => $this_model, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $model)
				{
					$model = $this_model;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "model", value1 => $model, 
					}, file => $THIS_FILE, line => __LINE__});
					last;
				}
			}
		}
		close $file_handle;
	}
	
	# Record what we found.
	$an->data->{summary}{cpu}{model}   = $model;
	$an->data->{summary}{cpu}{cores}   = $total_cores;
	$an->data->{summary}{cpu}{threads} = $total_threads;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "summary::cpu::model",   value1 => $an->data->{summary}{cpu}{model}, 
		name2 => "summary::cpu::cores",   value2 => $an->data->{summary}{cpu}{cores}, 
		name3 => "summary::cpu::threads", value3 => $an->data->{summary}{cpu}{threads}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}
