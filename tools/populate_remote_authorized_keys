#!/usr/bin/perl
# 
# This takes the ~/.ssh/id_rsa.pub file from the user account running this
# program and adds it to the ~/.ssh/authorized_keys of the target machine's
# root user and any users found under /home/. It will create the local user's
# RSA keys if not found.
# 
# TODO: Detect is selinux is running on remote and set context on created
#       directories and files.
# 
# Return codes:
# 0  = Normal exit.
# 1  = Unable to determine user this is running as.
# 2  = Failed to create the RSA key.
# 3  = Unable to read the RSA key.
# 4  = No switches passed.
# 5  = Failed to find the RSA key, but ssh-keygen complained that the key exists.
# 6  = No password or password script specified.
# 7  = One or more sanity check failed.
# 8  = Invalid TCP port specified in remote shell call.
# 9  = SSH reported bad hostname.
# 10 = SSH reported connection refused.
# 11 = SSH reported no route to host.
# 12 = SSH reported timeout trying to connect to host.
# 13 = SSH errored with an unknown error.
# 14 = SSH failed to connect, probably a bad password.
# 15 = Failed to add our key to the user's authorized_keys file.
# 

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

use strict; 
use warnings;
use IO::Handle;
use Net::SSH2;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID and EffectiveUID from throwing an error
$< = $>;

my $conf = {
	executable	=>	{
		gethostip	=>	"/usr/bin/gethostip",
		ping		=>	"/bin/ping",
		'ssh-keygen'	=>	"/usr/bin/ssh-keygen",
	},
	path		=>	{
		ssh_config	=>	"/etc/ssh/ssh_config",
	},
	switches	=>	{},
	remote_users	=>	[],
	sys		=>	{
		password	=>	"",
		user_host	=>	"",
		username	=>	"",
		remote		=>	"",
		rsa_key		=>	"",
		ssh_fh		=>	"",
		ssh_port	=>	22,
	},
};

# Make sure I was given the target machine's IP address and password.
get_switches($conf);
if (not $conf->{sys}{switch_count})
{
	print_usage($conf);
	exit(4);
}

# This sanity-checks the passed in command line switches and returns '1' if
# any problems were found.
$conf->{sys}{username} = $ENV{LOGNAME} || $ENV{USER} || getpwuid($<);
if ((not $conf->{sys}{username}) || ($conf->{sys}{username} eq "apache"))
{
        # taint!
        $conf->{sys}{username} = ($ENV{_} =~ /^\/home\/(.*?)\//)[0];
}
print "Starting: [$0] for: [$conf->{sys}{username}]...\n";
if (sanity_check_switches($conf))
{
	exit(7);
}
if (not $conf->{sys}{username})
{
	print "[ Error ] - Unable to determine which user I am running as.\n";
	exit(1);
}
print "- Adding local user: [$conf->{sys}{username}]'s RSA key to: [$conf->{sys}{remote}]\n";

# Get (and create if needed) the local user's RSA key.
get_local_rsa($conf);

# Now we do the adding.
add_rsa_to_remote($conf);

print "Done!\n\n";

exit(0);

# Log into the remote machine and add our keys.
sub add_rsa_to_remote
{
	my ($conf) = @_;
	
	# Make sure the remote machine's fingerprints are in our 
	# ~/.ssh/known_hosts.
	my $known_hosts = "/home/$conf->{sys}{username}/.ssh/known_hosts";
	my $shell_call  = "if [ -e '$known_hosts' ] && \$(grep -q $conf->{sys}{remote} $known_hosts); then echo exists; else echo add;  ssh-keyscan $conf->{sys}{remote} >> $known_hosts; fi";
	# Untaint
	if ($shell_call =~ /^(if .* fi)$/)
	{
		$shell_call = $1;
	}
	else
	{
		die "$THIS_FILE ".__LINE__."; Shell call tainted: [$shell_call]\n";
	}
	#print "[ Debug ] ".__LINE__."; - shell_call: [$shell_call]\n";
	open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /exists/)
		{
			print "- The remote machine's fingerprint is already registered.\n";
		}
		if ($line =~ /add/)
		{
			print "- Recording the remote machine's fingerprint.\n";
		}
		#print "[ Debug ] ".__LINE__."; - line: [$line]\n";
	}
	close $file_handle;
	
	# Read in the user's existing root user's authorized_keys file, if it
	# exists.
	if (check_authorized_keys($conf, "root"))
	{
		print "- The 'root' user doesn't have our RSA key, adding it.\n";
		if (add_key_to_remote($conf, "root"))
		{
			# Success!
			print "- Our RSA key was successfully added to root's authorized_keys.\n";
		}
		else
		{
			# Failed. :(
			print "[ Error ] - Failed to add our key to root's authorized_keys!\n";
			exit(15);
		}
	}
	else
	{
		print "- The 'root' user has our key already, skipping.\n";
	}
	
	# How get a list of all users on the remote system and add our key to
	# each.
	get_remote_user_list($conf);
	
	foreach my $user (sort {$a cmp $b} @{$conf->{remote_users}})
	{
		next if not $user;
		print "- Adding our key to remote user: [$user]'s authorized_keys file.\n";
		if (check_authorized_keys($conf, $user))
		{
			print "- The '$user' user doesn't have our RSA key, adding it.\n";
			if (add_key_to_remote($conf, $user))
			{
				# Success!
				print "- Our RSA key was successfully added to ${user}'s authorized_keys.\n";
			}
			else
			{
				# Failed. :(
				print "[ Error ] - Failed to add our key to ${user}'s authorized_keys!\n";
				exit(15);
			}
		}
		else
		{
			print "- The '$user' user has our key already, skipping.\n";
		}
	}
	
	return(0);
}

# This simply does an 'ls /home' to get a list of remote users.
sub get_remote_user_list
{
	my ($conf) = @_;
	
	my $shell_call = "ls /home";
	#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$conf->{sys}{remote},
		port		=>	22,
		user		=>	"root",
		password	=>	$conf->{sys}{password},
		ssh_fh		=>	$conf->{sys}{ssh_fh} ? $conf->{sys}{ssh_fh} : "",
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	#print "[ Debug ] ".__LINE__."; - error: [$error], ssh_fh: [$ssh_fh], return: [$return (".@{$return}." lines)]\n";
	foreach my $line (@{$return})
	{
		#print "[ Debug ] ".__LINE__."; - line: [$line]\n";
		next if $line eq "lost+found";
		push @{$conf->{remote_users}}, $line;
	}
	
	return(0);
}

# This does the actual addition of our key to the remote machine's named user.
# After adding, the key is read back to make sure it was indeed added.
sub add_key_to_remote
{
	my ($conf, $user) = @_;
	
	my $ok = 0;
	my $authorized_keys = "/home/$user/.ssh/authorized_keys";
	if ($user eq "root")
	{
		$authorized_keys = "/root/.ssh/authorized_keys";
	}
	my $shell_call = "echo '$conf->{sys}{rsa_key}' >> $authorized_keys && sync && cat $authorized_keys";
	#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$conf->{sys}{remote},
		port		=>	22,
		user		=>	"root",
		password	=>	$conf->{sys}{password},
		ssh_fh		=>	$conf->{sys}{ssh_fh} ? $conf->{sys}{ssh_fh} : "",
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	#print "[ Debug ] ".__LINE__."; - error: [$error], ssh_fh: [$ssh_fh], return: [$return (".@{$return}." lines)]\n";
	foreach my $line (@{$return})
	{
		if ($line eq "$conf->{sys}{rsa_key}")
		{
			#print "[ Debug ] ".__LINE__."; - Found our key.\n";
			$ok = 1;
		}
	}
	
	return($ok);
}

# This takes a user name and reads it's authorized_keys file, if it exists. If
# it doesn't, it checks to see if ~/.ssh exists and creates it, if it. If the
# authorized_keys file does exist, it looks to see if our key is in the file
# and returns '1' if not, '0' if found.
sub check_authorized_keys
{
	my ($conf, $user) = @_;
	
	my $add_key = 1;
	my $authorized_keys = "/home/$user/.ssh/authorized_keys";
	my $ssh_directory   = "/home/$user/.ssh";
	if ($user eq "root")
	{
		$authorized_keys = "/root/.ssh/authorized_keys";
		$ssh_directory   = "/root/.ssh";
	}
	print "- Reading '$authorized_keys' on: [$conf->{sys}{remote}]\n";
	my $shell_call = "if [ -e '$authorized_keys' ]
			then
				cat $authorized_keys
			else
				echo 'not found'
				if [ ! -e '$ssh_directory' ]
				then
					mkdir $ssh_directory
					chown root:root $ssh_directory
					chmod 700 $ssh_directory
					echo '$ssh_directory directory created.'
				fi
			fi";
	#print "[ Debug ] ".__LINE__." - shell_call: [$shell_call]\n";
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$conf->{sys}{remote},
		port		=>	22,
		user		=>	"root",
		password	=>	$conf->{sys}{password},
		ssh_fh		=>	$conf->{sys}{ssh_fh} ? $conf->{sys}{ssh_fh} : "",
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	#print "[ Debug ] ".__LINE__."; - error: [$error], ssh_fh: [$ssh_fh], return: [$return (".@{$return}." lines)]\n";
	foreach my $line (@{$return})
	{
		if ($line =~ /not found/i)
		{
			print "- 'authorized_keys' doesn't exist on the peer yet.\n";
		}
		elsif ($line =~ /directory created/i)
		{
			print "- '.ssh' directory create for the 'root' user.\n";
		}
		else
		{
			#print "[ Debug ] ".__LINE__."; - Read: [$line]\n";
			if ($line eq $conf->{sys}{rsa_key})
			{
				print "- Our SSH key is already added.\n";
				$add_key = 0;
			}
		}
	}
	
	return($add_key);
}

# This calls the target machine and runs a command.
sub remote_call
{
	my ($conf, $parameters) = @_;
	
	#print "[ Debug ] ".__LINE__."; parameters->{password}: [$parameters->{password}], sys::root_password: [$conf->{sys}{root_password}]\n";
	my $remote     = $parameters->{remote}           ? $parameters->{remote}   : $conf->{sys}{remote};
	my $port       = $parameters->{port}             ? $parameters->{port}     : $conf->{sys}{ssh_port};
	my $user       = $parameters->{user}             ? $parameters->{user}     : "root";
	my $password   = $parameters->{password}         ? $parameters->{password} : $conf->{sys}{password};
	my $ssh_fh     = $parameters->{ssh_fh}           ? $parameters->{ssh_fh}   : "";
	my $close      = defined $parameters->{'close'}  ? $parameters->{'close'}  : 1;
	my $shell_call = $parameters->{shell_call};
	#print "[ Debug ] ".__LINE__."; remote: [$remote], port: [$port], user: [$user], password: [$password], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]\n";
	#print "[ Debug ] ".__LINE__."; remote: [$remote], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]\n";
	
	# Break out the port, if needed.
	my $state;
	my $error;
	#print "[ Debug ] ".__LINE__."; remote: [$remote]\n";
	if ($remote =~ /^(.*):(\d+)$/)
	{
		#print "[ Debug ] ".__LINE__."; >> remote: [$remote], port: [$port]\n";
		$remote = $1;
		$port   = $2;
		#print "[ Debug ] ".__LINE__."; << remote: [$remote], port: [$port]\n";
		if (($port < 0) || ($port > 65536))
		{
			# Variables for 'message_0373'.
			print "[ Error ] ".__LINE__."; - The TCP port: [$port] is out of range. It must be between 1 and 65536. The default is '22'.\n";
			print "[ Error ] ".__LINE__.";   The error was hit calling: [$shell_call]\n";
			exit(8);
		}
	}
	
	# These will be merged into a single 'output' array before returning.
	my $stdout_output = [];
	my $stderr_output = [];
	#print "[ Debug ] ".__LINE__."; ssh_fh: [$ssh_fh]\n";
	if ($ssh_fh !~ /^Net::SSH2/)
	{
		#print "[ Debug ] ".__LINE__."; Opening an SSH connection to: [$user\@$remote:$port].\n";
		$ssh_fh = Net::SSH2->new();
		# Untaint.
		if ($remote =~ /^(.*)$/)  { $remote = $1; }
		if ($port   =~ /^(\d+)$/) { $port   = $1; }
		if (not $ssh_fh->connect($remote, $port, Timeout => 10))
		{
			print "[ Debug ] ".__LINE__."; error: [$@]\n";
			if ($@ =~ /Bad hostname/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(9);
			}
			elsif ($@ =~ /Connection refused/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(10);
			}
			elsif ($@ =~ /No route to host/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(11);
			}
			elsif ($@ =~ /timeout/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(12);
			}
			else
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(13);
			}
		}
		#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh]\n";
		if (not $error)
		{
			#print "[ Debug ] ".__LINE__."; user: [$user], password: [$password]\n";
			$ssh_fh->auth_password($user, $password);
			my $ok = $ssh_fh->auth_ok();
			print "[ Debug ] ".__LINE__."; ok: [$ok]\n";
                        if (not $ok)                                      
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Please check that the password provides is the correct password for 'root' on the target machine.\n";
				exit(14);
			}
			else
			{
				#print "[ Debug ] ".__LINE__."; SSH session opened to: [$remote].\n";
			}
		}
	}
	
	### Special thanks to Rafael Kitover (rkitover@gmail.com), maintainer
	### of Net::SSH2, for helping me sort out the polling and data
	### collection in this section.
	#
	# Open a channel and make the call.
	#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh]\n";
	if (($ssh_fh =~ /^Net::SSH2/) && (not $error))
	{
		# We need to open a channel every time for 'exec' calls. We
		# want to keep blocking off, but we need to enable it for the
		# channel() call.
		$ssh_fh->blocking(1);
		my $channel = $ssh_fh->channel();
		$ssh_fh->blocking(0);
		
		# Make the shell call
		if (not $channel)
		{
			$error  = "Failed to establish channel to remote: [$remote] for shell call: [$shell_call]\n";
			$ssh_fh = "";
		}
		else
		{
			#print "[ Debug ] ".__LINE__."; channel: [$channel], shell_call: [$shell_call]\n";
			$channel->exec("$shell_call");
			# "/etc/ssh/ssh_config",
			# This keeps the connection open when the remote side is slow
			# to return data, like in '/etc/init.d/rgmanager stop'.
			my @poll = {
				handle => $channel,
				events => [qw/in err/],
			};
			
			# We'll store the STDOUT and STDERR data here.
			my $stdout = "";
			my $stderr = "";
			
			# Not collect the data.
			while(1)
			{
				$ssh_fh->poll(250, \@poll);
				
				# Read in anything from STDOUT
				while($channel->read(my $chunk, 80))
				{
					$stdout .= $chunk;
				}
				while ($stdout =~ s/^(.*)\n//)
				{
					my $line = $1;
					#print "[ Debug ] ".__LINE__."; STDOUT: [$line].\n";
					push @{$stdout_output}, $line;
				}
				
				# Read in anything from STDERR
				while($channel->read(my $chunk, 80, 1))
				{
					$stderr .= $chunk;
				}
				while ($stderr =~ s/^(.*)\n//)
				{
					my $line = $1;
					#print "[ Debug ] ".__LINE__."; STDERR: [$line].\n";
					push @{$stderr_output}, $line;
				}
				
				# Exit when we get the end-of-file.
				last if $channel->eof;
			}
			if ($stdout)
			{
				#print "[ Debug ] ".__LINE__."; stdout: [$stdout].\n";
				push @{$stdout_output}, $stdout;
			}
			if ($stderr)
			{
				#print "[ Debug ] ".__LINE__."; stderr: [$stderr].\n";
				push @{$stderr_output}, $stderr;
			}
		}
	}
	
	# Merge the STDOUT and STDERR
	my $output = [];
	
	foreach my $line (@{$stderr_output}, @{$stdout_output})
	{
		#print "[ Debug ] ".__LINE__."; Merge; line: [$line]\n";
		push @{$output}, $line;
	}
	
	# Close the connection if requested.
	if ($close)
	{
		#print "[ Debug ] ".__LINE__."; Disconnecting from: [$remote]\n";
		$ssh_fh->disconnect();
		
		# For good measure, blank both variables.
		$conf->{remote}{$remote}{ssh_fh} = "";
		$ssh_fh                      = "";
	}
	
	$error = "" if not defined $error;
	#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n";
	return($error, $ssh_fh, $output);
}

# Get (and create if needed) the local user's RSA key.
sub get_local_rsa
{
	my ($conf) = @_;
	
	my $rsa_file = "/home/$conf->{sys}{username}/.ssh/id_rsa.pub";
	if ($conf->{sys}{username} eq "root")
	{
		$rsa_file = "/root/.ssh/id_rsa.pub";
	}
	print "- Reading: [$rsa_file]\n";
	if (not -e "$rsa_file")
	{
		# Generate.
		print "- Generating: [$conf->{sys}{username}]'s RSA keys.\n";
		print "- Please be patient! It can take a few minutes to gather entropy.\n";
		my $shell_call = "$conf->{executable}{'ssh-keygen'} -t rsa -N \"\" -b 8191 -f /home/$conf->{sys}{username}/.ssh/id_rsa";
		open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		print "/------------------\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /already exists/)
			{
				print "- The RSA key already exists, but I didn't see it.\n";
				exit(5);
			}
			print "| $line\n";
		}
		close $file_handle;
		print "\\------------------\n";
	}
	if (not -e "$rsa_file")
	{
		# Something went wrong...
		print "[ Error ] - It looks like something went wrong.\n";
		print "[ Error ]   The RSA key doesn't exist, but it should have been created.\n";
		exit(2);
	}
	if (not -r "$rsa_file")
	{
		# Unreadable...
		print "[ Error ] - I was unable to read: [$rsa_file].\n";
		print "[ Error ]   Please check the permissions and ownership.\n";
		exit(3);
	}
	
	# Read it!
	my $shell_call = "$rsa_file";
	open (my $file_handle, "<", "$rsa_file") or die "$THIS_FILE ".__LINE__."; Failed to read: [$rsa_file], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^ssh-rsa .* (.*?\@.*)$/)
		{
			$conf->{sys}{user_host} = $1;
			$conf->{sys}{rsa_key}   = $line;
			last;
		}
	}
	close $file_handle;
	#print "[ Debug ] ".__LINE__." - User and host: [$conf->{sys}{user_host}], RSA key: [$conf->{sys}{rsa_key}]\n";
	
	return(0);
}

# This validates a string as being an IPv4 address in dotted-decimal notation.
sub validate_ip_address
{
	my ($conf, $ip) = @_;

	if ($ip =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/)
	{
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		# First octal has to be >= 1. The rest can be 0.
		if (($first_octal < 1)  || ($first_octal > 255)  ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal < 0)  || ($third_octal > 255)  ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			$ip = "#!INVALID!#";
		}
	}
	else
	{
		# Not even formatted properl.
		$ip = "#!INVALID!#";
	}

	return($ip);
}

# This breaks out the command-line switches and varifies that their values are
# (more or less) sane
sub sanity_check_switches
{
	my ($conf) = @_;
	
	# Something has been set for all values, sanity check them.
	# This will fail out if set to '1' once all sanity checking is done.
	my $bad_value = 0;

	# The network is a little tricker
	if (($conf->{switches}{h}) or ($conf->{switches}{help}) or ($conf->{switches}{'?'}))
	{
		print_usage($conf);
		exit(0);
	}
	if (not $conf->{switches}{r})
	{
		print "[ Error ] - The remote machine machine must be specified with: '-r <ip_or_hostname>'.\n";
		$bad_value = 1;
	}
	else
	{
		# Check the remote machine.
		if (validate_ip_address($conf, $conf->{switches}{r}) eq "#!INVALID!#")
		{
			# It's not an IP, try to resolve it.
			print "- Resolving hostname: [$conf->{switches}{r}] to IP address.\n";
			my $shell_call = "$conf->{executable}{gethostip} -d $conf->{switches}{r}";
			# Untaint the call so that it works when called via
			# setuid.
			if ($shell_call =~ /^(\/.*? -d .*)$/)
			{
				$shell_call = $1;
			}
			else
			{
				die "$THIS_FILE ".__LINE__."; shell_call appears to be tainted: [$shell_call]\n";
			}
			open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				#print "[ Debug ] ".__LINE__." - line: [$line]\n";
				if (($line =~ /lookup failure/i) || ($line =~ /unknown host/i))
				{
					print "[ Error ] - Unable to resolve hostname: [$conf->{switches}{r}] to an IP address.\n";
					$bad_value = 1;
				}
			}
			close $file_handle;
		}
		else
		{
			# It's an IP address, we're good.
		}
		$conf->{sys}{remote} = $conf->{switches}{r};
	}
	
	# Make sure we have a password.
	if ((not $conf->{switches}{p}) && (not $conf->{switches}{P}))
	{
		print "[ Error ] - No password or password script passed.\n";
		$bad_value = 1;
	}
	
	# We have a password, but which type?
	if ($conf->{switches}{p})
	{
		# Directly passed. Copy the password into the 'sys' hash.
		$conf->{sys}{password} = $conf->{switches}{p};
	}
	
	# Script, run it.
	if ($conf->{switches}{P})
	{
		# Script!
		print "- Running: [$conf->{switches}{P}] to get the remote machine's 'root' password\n";
		if (not -e $conf->{switches}{P})
		{
			print "[ Error ] - Password script: [$conf->{switches}{P}] not found!\n";
			$bad_value = 1;
		}
		elsif (not -x $conf->{switches}{P})
		{
			print "[ Error ] - Password script: [$conf->{switches}{P}] is not executable! Try running:\n";
			print "[ Error ]   chmod 755 $conf->{switches}{P}\n";
			$bad_value = 1;
		}
		my $shell_call = "$conf->{switches}{P}";
		open (my $file_handle, "$shell_call 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$conf->{sys}{password} = $line;
			last;
		}
		close $file_handle;
		
		if (not $conf->{sys}{password})
		{
			print "[ Error ] - Password script didn't appear to print the password.\n";
			print "[ Error ]   Make sure the script prints the password on the first line and then exits.\n";
		}
	}
	
	return($bad_value);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}}) { print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = q|
 -=] Populate Remote ~/.ssh/authorized_keys

DESCRIPTION

This program will read the user's RSA keys, creating the keys if needed, and
then add them to the target machine's ~/.ssh/authorized_keys file for the
'root' user and any user found in /home/.


SWITCHES

 -h, -?, --help

	Show this dialoge and exit.

 -p <password>

	This is the remote machine's 'root' user password.

 -P </path/to/password.script>

	If you do not want to pass the password on the command line, you can
	use this option to specify a script which prints the root user's
	password. To create this, create a text file that has:
		echo '<password>'
	Save it, and set it to be executable:
		chmod 755 /path/to/password.script

 -r <ip_or_hostname>
	
	This is the IP address (or resolvable host name) of the remote machine.


EXAMPLE

Use an IP address and password:

 ./populate_remote_authorized_keys -r 10.255.5.1 -p secret
 
Use a hostname and password script:

 ./populate_remote_authorized_keys -r my.server -P /root/my.server.pw

                  
SUPPORT

https://alteeve.ca/w/Support

							      Alteeve's Niche!
|;
	open (my $file_handle, ">", "/tmp/populate_remote_authorized_keys") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/populate_remote_authorized_keys");

	return(0);
}
