#!/usr/bin/perl
# 
# This tool tries to safely start an Anvil! when a node boots. It will replace 'safe_anvil_start' once 
# finished.
# 
# Exit Codes;
# 0  = OK
# 1  = Another instance was running
# 2  = Called with invalid or missing switches.
#

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Data::Dumper;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		path		=>	{
			cluster_conf		=>	"/etc/cluster/cluster.conf", 
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		peer		=>	{
			short_name		=>	"",
			bcn_name		=>	"",
			sn_name			=>	"",
			ifn_name		=>	"",
		},
		daemon		=>	{
			cman			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
			rgmanager			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
		},
		drbd		=>	{
			resource		=>	{},
		},
		sys		=>	{
			i_am_node2		=>	0,
			language		=>	"en_CA",
			local_health		=>	"",
			local_node		=>	"",
			log_language		=>	"en_CA",
			log_level		=>	1,
			peer_health		=>	"",
			peer_node		=>	"",
			program_name		=>	$program_name,
			resync_max_wait_time	=>	600,
			shutdown_target		=>	"",
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	exit(0);
}

# Exit if another instance is running already.
avoid_duplicate_run($an);

# Log our startup
$an->Log->entry({log_level => 1, message_key => "assp_log_0001", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});

# Who am I and what Anvil! do I belong to?
find_myself($an);

# Do the deed
process_request($an);

# We're done.
$an->Log->entry({log_level => 1, message_key => "asst_log_0006", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});
exit(0);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This sheds load based on the following criteria:
# 
# 1. Can the peer be reached? If not, load shedding is aborted (as it is assumed
#    the peer is already offline, in this context).
# 
# 2. If one node is the 'SyncSource' for the other, then the Inconsistent peer
#    will be shut down.
#    
#    NOTE: if *both* nodes are SyncSource (on different storage pools), the load
#          shed will throw an error and exit with a non-0 exit code.
# 
# 3. If both nodes are UpToDate, and one node's health is not 'OK', then the sick
#    node will be shut down.
# 
# 4. If both nodes are UpToDate and healthy, the the sum of the RAM used by 
#    servers on each node is added. The node with the least amount of RAM used by
#    servers will shutdown.
#    
# 5. If the RAM in use by servers on both nodes is the same, node 2 will shut 
#    down.
sub shed_load
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "shed_load" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Can we reach the peer?
	my $peer_access = $an->Check->access({
		target		=>	$an->data->{sys}{peer_node},
		password	=>	$an->data->{sys}{anvil_password},
	});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "peer_access", value1 => $peer_access, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if (not $peer_access)
	{
		# We're done.
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "assp_error_0002", message_variables => { peer => $an->data->{sys}{peer_node} }, code => 3, file => "$THIS_FILE", line => __LINE__});
		exit(3);
	}
	
	# Wait if we're node 2
	if ($an->data->{sys}{i_am_node2})
	{
		$an->Remote->wait_on_peer({
			program  => $an->data->{sys}{program_name}, 
			target   => $an->data->{sys}{peer_node}, 
			password => $an->data->{sys}{anvil_password}, 
		});
	}
	
	# Get the DRBD info and see if a node is SyncTarget.
	my $i_am_synctarget    = 0;
	my $peer_is_synctarget = 0;
	my $drbd_data          = $an->Get->drbd_data();
	foreach my $resource (sort {$a cmp $b} keys %{$drbd_data->{resource}})
	{
		my $local_disk_state = $drbd_data->{resource}{$resource}{my_disk_state};
		my $peer_disk_state  = $drbd_data->{resource}{$resource}{peer_disk_state};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "local_disk_state", value1 => $local_disk_state, 
			name2 => "peer_disk_state",  value2 => $peer_disk_state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($local_disk_state =~ /SyncTarget/i)
		{
			$i_am_synctarget = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "i_am_synctarget", value1 => $i_am_synctarget, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($peer_disk_state =~ /SyncTarget/i)
		{
			$peer_is_synctarget = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "peer_is_synctarget", value1 => $peer_is_synctarget, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If both are SyncTarget (on different resources), abort.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "i_am_synctarget",    value1 => $i_am_synctarget, 
		name2 => "peer_is_synctarget", value2 => $peer_is_synctarget, 
	}, file => $THIS_FILE, line => __LINE__});
	if (($i_am_synctarget) && ($peer_is_synctarget))
	{
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "assp_error_0003", code => 4, file => "$THIS_FILE", line => __LINE__});
		exit(4);
	}
	
	# By default, we'll shutdown node 2, unless the peer is a sync target.
	if ($peer_is_synctarget)
	{
		$an->data->{sys}{shutdown_target} = "peer";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($i_am_synctarget)
	{
		$an->data->{sys}{shutdown_target} = "local";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# If I don't have a shutdown target yet, check the health of each node.
	if (not $an->data->{sys}{shutdown_target})
	{
		$an->data->{sys}{local_health} = $return->{health}{'local'};
		$an->data->{sys}{peer_health}  = $return->{health}{peer};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sys::local_health", value1 => $an->data->{sys}{local_health}, 
			name2 => "sys::peer_health",  value2 => $an->data->{sys}{peer_health}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (($an->data->{sys}{local_health} ne "ok") && ($an->data->{sys}{peer_health} ne "ok"))
		{
			# Neither node is healthy, so this isn't useful for selecting the shed target.
		}
		elsif ($an->data->{sys}{local_health} ne "ok")
		{
			$an->data->{sys}{shutdown_target} = "local";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{sys}{peer_health} ne "ok")
		{
			$an->data->{sys}{shutdown_target} = "peer";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I still don't have a shutdown target, sum the RAM used by servers on each node.
	
	return(0);
}

# This figures out what to do.
sub process_request
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_request" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Are we shutting down or shedding load?
	if ($an->data->{switches}{'shed-load'})
	{
		shed_load($an);
	}
	elsif ($an->data->{switches}{'local'})
	{
		shut_down($an);
	}
	else
	{
		# Bad request
		print_usage($an);
		print $an->String->get({key => "assp_error_0001"})."\n";
		exit(2);
	}
	
	return(0);
}

# This figures out who I am, what Anvil! I am in and who my peer is.
sub find_myself
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_myself" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $hostname_full  = $an->hostname();
	my $hostname_short = $an->short_hostname();
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "hostname_full",  value1 => $hostname_full, 
		name2 => "hostname_short", value2 => $hostname_short, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Collect information about this Anvil!
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cluster_conf},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I am node 2, make note so that we can delay and let node 1 run first.
	if (($an->data->{sys}{local_node} =~ /n02/) or ($an->data->{sys}{local_node} =~ /node02/) or ($an->data->{sys}{local_node} =~ /node2/))
	{
		$an->data->{sys}{i_am_node2} = 1;
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::i_am_node2", value1 => $an->data->{sys}{i_am_node2}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Figure out what my peer's BCN, SN and IFN names are
	$an->data->{peer}{short_name} =  $an->data->{sys}{peer_node};
	$an->data->{peer}{short_name} =~ s/\..*$//;
	$an->data->{peer}{bcn_name}   =  $an->data->{peer}{short_name}.".bcn";
	$an->data->{peer}{sn_name}    =  $an->data->{peer}{short_name}.".sn";
	$an->data->{peer}{ifn_name}   =  $an->data->{peer}{short_name}.".ifn";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "peer::short_name", value1 => $an->data->{peer}{short_name}, 
		name2 => "peer::bcn_name",   value2 => $an->data->{peer}{bcn_name}, 
		name3 => "peer::sn_name",    value3 => $an->data->{peer}{sn_name}, 
		name4 => "peer::ifn_name",   value4 => $an->data->{peer}{ifn_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This exits if any other instance of this program is running already.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $pids  = $an->Get->pids({program_name => $an->data->{sys}{program_name}});
	my $count = @{$pids};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		exit(1);
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "assp_message_0001"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
