#!/usr/bin/perl
# 
# This tool tries to safely stop an Anvil! node, migrating or stopping servers as needed and aborting if the
# peer would fail without us.
# 
# Exit Codes;
# 0  = OK
# 1  = Another instance was running
# 2  = Called with invalid or missing switches.
# 3  = Load shedding failed because we can't access the peer to determine its state.
# 4  = Both nodes are SyncSource or Diskless, so load shedding is not possible.
# 5  = We're SyncSource (or our peer is Diskless), so local shutdown is aborted.
#
# TODO:
# - Make this work without DB access
# - Check if the node has anvil-kick-apc-ups enabled and stop it unless overridden by a switch.
# - Add a '--script' option that prints parsable output about server migrations/shutdowns and so on so that
#   Striker's "Cold Stop" output can be cleaner.
#

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Data::Dumper;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		'anvil-safe-stop' =>	{
			log_db_transactions	=>	0,
		},
		path		=>	{
			cluster_conf		=>	"/etc/cluster/cluster.conf", 
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		peer		=>	{
			short_name		=>	"",
			bcn_name		=>	"",
			sn_name			=>	"",
			ifn_name		=>	"",
		},
		daemon		=>	{
			cman			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
			rgmanager			=>	{
				'local'			=>	0,
				peer			=>	0,
			},
		},
		drbd		=>	{
			resource		=>	{},
		},
		sys		=>	{
			i_am_node2		=>	0,
			language		=>	"en_CA",
			local_health		=>	"",
			local_node		=>	"",
			log_language		=>	"en_CA",
			log_level		=>	2,
			peer_health		=>	"",
			peer_node		=>	"",
			program_name		=>	$THIS_FILE,
			resync_max_wait_time	=>	600,
			shutdown_target		=>	"",
			stop_reason		=>	"host_poweroff",
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{'anvil-safe-stop'}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	exit(0);
}

# Exit if another instance is running already.
avoid_duplicate_run($an);

# Log our startup
$an->Log->entry({log_level => 1, message_key => "assp_log_0001", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});

# Can I connect to a database?
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
	name1 => "connections", value1 => $connections, 
}, file => $THIS_FILE, line => __LINE__});
if (not $connections)
{
	# We'll fall back to local data only.
	$an->Log->entry({log_level => 1, message_key => "assp_log_0002", file => $THIS_FILE, line => __LINE__});
}

# Who am I and what Anvil! do I belong to?
find_myself($an);

# Do the deed
process_request($an);

# We're done.
$an->Log->entry({log_level => 1, message_key => "asst_log_0006", message_variables => {
	this_file	=>	$THIS_FILE, 
}, file => $THIS_FILE, line => __LINE__});
exit(0);

### TODO: Make this work without access to a DB. Check '$an->data->{sys}{read_db_id}' as needed and use local
###       checks or reads to the peer as needed.

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This sheds load based on the following criteria:
# 
# 1. Can the peer be reached? If not, load shedding is aborted (as it is assumed
#    the peer is already offline, in this context).
#    
# 2. If one of the nodes is NOT in the cluster and the other is, the withdrawn 
#    one will be shut off.
# 
# 3. If one node is the 'SyncSource' for the other, then the Inconsistent peer
#    will be shut down.
#    
#    NOTE: if *both* nodes are SyncSource (on different storage pools), the load
#          shed will throw an error and exit with a non-0 exit code.
# 
# 4. If both nodes are UpToDate, and one node's health is not 'OK', then the sick
#    node will be shut down.
# 
# 5. If both nodes are UpToDate and healthy, the the sum of the RAM used by 
#    servers on each node is added. The node with the least amount of RAM used by
#    servers will shutdown.
#    
# 6. If the RAM in use by servers on both nodes is the same, node 2 will shut 
#    down.
sub shed_load
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "shed_load" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Can we reach the peer?
	my $peer_access = $an->Check->access({
		target		=>	$an->data->{sys}{peer_node},
		password	=>	$an->data->{sys}{anvil_password},
	});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "peer_access", value1 => $peer_access, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if (not $peer_access)
	{
		# We're done.
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "assp_error_0002", message_variables => { peer => $an->data->{sys}{peer_node} }, code => 3, file => "$THIS_FILE", line => __LINE__});
		exit(3);
	}
	
	# Wait if we're node 2
	if ($an->data->{sys}{i_am_node2})
	{
		$an->Remote->wait_on_peer({
			program  => $an->data->{sys}{program_name}, 
			target   => $an->data->{sys}{peer_node}, 
			password => $an->data->{sys}{anvil_password}, 
		});
	}
	
	# See if one of the nods is in the cluster and if the other is not.
	my $local_clustat_data = $an->Cman->get_clustat_data({
		target   => $an->data->{sys}{local_node}, 
		password => $an->data->{sys}{anvil_password}, 
	});
	my $peer_clustat_data = $an->Cman->get_clustat_data({
		target   => $an->data->{sys}{peer_node}, 
		password => $an->data->{sys}{anvil_password}, 
	});
	my $local_rgmanager_state = $local_clustat_data->{node}{'local'}{rgmanager} ? $local_clustat_data->{node}{'local'}{rgmanager} : "";
	my $peer_rgmanager_state  = $peer_clustat_data->{node}{'local'}{rgmanager}  ? $peer_clustat_data->{node}{'local'}{rgmanager}  : "";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "local_rgmanager_state", value1 => $local_rgmanager_state, 
		name2 => "peer_rgmanager_state",  value2 => $peer_rgmanager_state, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $local_rgmanager_state) && (not $peer_rgmanager_state))
	{
		# Neither node is in the cluster, so shut down node 2.
		if ($an->data->{sys}{i_am_node2})
		{
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{local_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Peer has more RAM in use by servers, so we'll shut down the local system.
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{peer_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif (not $local_rgmanager_state)
	{
		# I'm not in the cluster, so I will shut down.
		$an->data->{sys}{shutdown_target} = $an->data->{sys}{local_node};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif (not $peer_rgmanager_state)
	{
		# The peer is not in the cluster, so I will shut it down.
		$an->data->{sys}{shutdown_target} = $an->data->{sys}{peer_node};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Check DRBD if I don't have a shutdown target yet.
	if ($an->data->{sys}{shutdown_target})
	{
		# Get the DRBD info and see if a node is SyncTarget.
		my ($i_am_synctarget, $peer_is_synctarget) = check_drbd($an);
		
		# If both are SyncTarget (on different resources), abort.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "i_am_synctarget",    value1 => $i_am_synctarget, 
			name2 => "peer_is_synctarget", value2 => $peer_is_synctarget, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($i_am_synctarget) && ($peer_is_synctarget))
		{
			$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "assp_error_0003", code => 4, file => "$THIS_FILE", line => __LINE__});
			exit(4);
		}
		
		# By default, we'll shutdown node 2, unless the peer is a sync target.
		if ($peer_is_synctarget)
		{
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{peer_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($i_am_synctarget)
		{
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{local_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I don't have a shutdown target yet, check the health of each node.
	if (not $an->data->{sys}{shutdown_target})
	{
		if (($an->data->{sys}{local_health} ne "ok") && ($an->data->{sys}{peer_health} ne "ok"))
		{
			# Neither node is healthy, so this isn't useful for selecting the shed target.
			$an->Log->entry({log_level => 1, message_key => "assp_log_0003", file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{sys}{local_health} ne "ok")
		{
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{local_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{sys}{peer_health} ne "ok")
		{
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{peer_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I still don't have a shutdown target, sum the RAM used by servers on each node.
	my $local_server_ram = 0;
	my $peer_server_ram  = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not $an->data->{sys}{shutdown_target})
	{
		foreach my $server (sort {$a cmp $b} keys %{$an->data->{server}})
		{
			my $state = $an->data->{server}{$server}{'state'};
			my $host  = $an->data->{server}{$server}{host};
			my $ram   = $an->data->{server}{$server}{ram};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "server", value1 => $server, 
				name2 => "state",  value2 => $state, 
				name3 => "host",   value3 => $host, 
				name4 => "ram",    value4 => $ram, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($state !~ /start/)
			{
				# Ignore it
				next;
			}
			if (not $ram)
			{
				# What? Probably a program error...
				$an->Log->entry({log_level => 0, message_key => "assp_warning_0001", message_variables => {
					server  => $server, 
					'state' => $state, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			if ($host eq $an->data->{sys}{local_node})
			{
				$local_server_ram += $ram;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_server_ram", value1 => $local_server_ram, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				$peer_server_ram += $ram;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_server_ram", value1 => $peer_server_ram, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# 
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "local_server_ram", value1 => $local_server_ram, 
			name2 => "peer_server_ram",  value2 => $peer_server_ram, 
		}, file => $THIS_FILE, line => __LINE__});
		if ((not $local_server_ram) && (not $peer_server_ram))
		{
			# Neither node has any servers, so that's no help...
			$an->Log->entry({log_level => 0, message_key => "assp_log_0004", file => $THIS_FILE, line => __LINE__});
		}
		elsif ($local_server_ram eq $peer_server_ram)
		{
			# Both have the same total amount of allocated RAM.
			$an->Log->entry({log_level => 0, message_key => "assp_log_0005", file => $THIS_FILE, line => __LINE__});
		}
		elsif ($local_server_ram > $peer_server_ram)
		{
			# Local has more RAM in use by servers, so we'll shut down the peer.
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{local_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Peer has more RAM in use by servers, so we'll shut down the local system.
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{peer_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If we still haven't chosen a victim, choose node 2.
	if (not $an->data->{sys}{shutdown_target})
	{
		if ($an->data->{sys}{i_am_node2})
		{
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{local_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Peer has more RAM in use by servers, so we'll shut down the local system.
			$an->data->{sys}{shutdown_target} = $an->data->{sys}{peer_node};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::shutdown_target", value1 => $an->data->{sys}{shutdown_target}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Now we're ready! We're migrate all servers.
	shutdown_node($an, $an->data->{sys}{shutdown_target}, 1);
	
	return(0);
}

# This checks to see if any DRBD resource is syncsource.
sub check_drbd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "process_request" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If one node is Diskless, we're effectively sync source in that the diskless node relies on the 
	# peer, so we'll treat it the same.
	my $i_am_synctarget    = 0;
	my $peer_is_synctarget = 0;
	my $drbd_data          = $an->Get->drbd_data();
	foreach my $resource (sort {$a cmp $b} keys %{$drbd_data->{resource}})
	{
		my $local_disk_state = $drbd_data->{resource}{$resource}{my_disk_state};
		my $peer_disk_state  = $drbd_data->{resource}{$resource}{peer_disk_state};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "local_disk_state", value1 => $local_disk_state, 
			name2 => "peer_disk_state",  value2 => $peer_disk_state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (($local_disk_state =~ /SyncTarget/i) or ($peer_disk_state =~ /Diskless/i))
		{
			$i_am_synctarget = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "i_am_synctarget", value1 => $i_am_synctarget, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (($peer_disk_state =~ /SyncTarget/i) or ($local_disk_state =~ /Diskless/i))
		{
			$peer_is_synctarget = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "peer_is_synctarget", value1 => $peer_is_synctarget, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "i_am_synctarget",    value1 => $i_am_synctarget, 
		name2 => "peer_is_synctarget", value2 => $peer_is_synctarget, 
	}, file => $THIS_FILE, line => __LINE__});
	return($i_am_synctarget, $peer_is_synctarget);
}

# This shuts down the node, either stopping or migrating servers as the case may be. Shedding load should 
# always migrate and local stop with migrate if the peer was accessible and online, and will otherwise power
# off the servers.
sub shutdown_node
{
	my ($an, $node, $migrate) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "shutdown_node" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "node",    value1 => $node, 
		name2 => "migrate", value2 => $migrate,  
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, deal with any running servers.
	my $output  = "";
	my $proceed = 1;
	foreach my $server (sort {$a cmp $b} keys %{$an->data->{server}})
	{
		my $state = $an->data->{server}{$server}{'state'};
		my $host  = $an->data->{server}{$server}{host};
		my $ram   = $an->data->{server}{$server}{ram};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "server", value1 => $server, 
			name2 => "state",  value2 => $state, 
			name3 => "host",   value3 => $host, 
			name4 => "ram",    value4 => $ram, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($host eq $node)
		{
			# Migrate or Terminate?
			$an->Log->entry({log_level => 0, message_key => "an_variables_0001", message_variables => {
				name1 => "migrate", value1 => $migrate, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($migrate)
			{
				# Get off my lawn!
				my ($success, $migrate_output) = do_migration($an, $server);
				$output .= $migrate_output;
				
				# Shut it down if migration failed.
				$an->Log->entry({log_level => 0, message_key => "an_variables_0001", message_variables => {
					name1 => "success", value1 => $success, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $success)
				{
					$output .= $an->Cman->stop_server({
						server => $server, 
						reason => $an->data->{sys}{stop_reason},
					});
				}
			}
			else
			{
				if ($an->data->{switches}{reason})
				{
					if ($an->data->{switches}{reason} =~ /\W/)
					{
						$an->Log->entry({log_level => 0, message_key => "an_variables_0001", message_variables => {
							name1 => "reason", value1 => $an->data->{switches}{reason}, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->data->{switches}{reason} = "";
					}
					else
					{
						$an->data->{sys}{stop_reason} = $an->data->{switches}{reason};
					}
				}
				
				# Today is a good day to die.
				$output .= $an->Cman->stop_server({
					server => $server, 
					reason => $an->data->{sys}{stop_reason},
				});
			}
		}
	}
	
	# Proceed, if safe.
	if ($proceed)
	{
		# Stop rgmanager, then stop cman.
		my ($return_code, $withdraw_output) = $an->Cman->withdraw_node({
			target   => $node,
			password => $an->data->{sys}{anvil_password}, 
		});
		$output .= $withdraw_output;
		# 0 == success
		# 1 == failed, restart succeeded.
		# 2 == failed, restart also failed.
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "return_code", value1 => $return_code, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($return_code eq "0")
		{
			# We're done, power off.
			$output .= $an->System->poweroff({
				target   => $node,
				password => $an->data->{sys}{anvil_password}, 
			});
		}
		elsif ($return_code eq "2")
		{
			# TODO: self-fence?
		}
	}
	
	return($output);
}

# This will shut down this node. A decision needs to then be made of whether to migrate the servers or power
# them down. Migration is obviously ideal, so the decision to shut down instead is based on;
# 
# 1. Can I access my peer?
# 
# 2. If so, is rgmanager running on this machine and the peer?
# 
# 3. If so, are we sync source for a resource?
#    - If so, the shut down is aborted.
# 
# 4. If the peer is 'critical' health, don't migrate.
# 
# Before shutting down, a check is made to see if we're a migration target for any servers. If so, we will 
# send the shutdown command to those servers before withdrawing and powering off.
sub local_shut_down
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "process_request" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Can we reach the peer?
	my $peer_access = $an->Check->access({
		target		=>	$an->data->{sys}{peer_node},
		password	=>	$an->data->{sys}{anvil_password},
	});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "peer_access", value1 => $peer_access, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $migrate_servers = 1;
	if ($peer_access)
	{
		# Yes. Are we and the peer running rgmanager?
		my $local_clustat_data = $an->Cman->get_clustat_data({
			target   => $an->data->{sys}{local_node}, 
			password => $an->data->{sys}{anvil_password}, 
		});
		my $peer_clustat_data = $an->Cman->get_clustat_data({
			target   => $an->data->{sys}{peer_node}, 
			password => $an->data->{sys}{anvil_password}, 
		});
		my $local_rgmanager_state = $local_clustat_data->{node}{'local'}{rgmanager} ? $local_clustat_data->{node}{'local'}{rgmanager} : "";
		my $peer_rgmanager_state  = $peer_clustat_data->{node}{'local'}{rgmanager}  ? $peer_clustat_data->{node}{'local'}{rgmanager}  : "";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "local_rgmanager_state", value1 => $local_rgmanager_state, 
			name2 => "peer_rgmanager_state",  value2 => $peer_rgmanager_state, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $local_rgmanager_state)
		{
			# I'm not in the cluster, so we won't have anything to migrate anyway.
			$migrate_servers = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "migrate_servers", value1 => $migrate_servers, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif (not $peer_rgmanager_state)
		{
			# The peer is not in the cluster, so migration isn't possible.
			$migrate_servers = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "migrate_servers", value1 => $migrate_servers, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# We're both in the cluster. Are we sync source?
			my ($i_am_synctarget, $peer_is_synctarget) = check_drbd($an);
			
			# If both are SyncTarget (on different resources), abort.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "i_am_synctarget",    value1 => $i_am_synctarget, 
				name2 => "peer_is_synctarget", value2 => $peer_is_synctarget, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($i_am_synctarget) && ($peer_is_synctarget))
			{
				$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "assp_error_0003", code => 4, file => "$THIS_FILE", line => __LINE__});
				exit(4);
			}
			
			# If we're sync target (or the peer is diskless), abort.
			if ($i_am_synctarget)
			{
				$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "assp_error_0004", code => 5, file => "$THIS_FILE", line => __LINE__});
				exit(5);
			}
			
			# If we're still alive, the last thing to check is whether the peer is 'critical' or
			# 'shutdown'. We won't check that now though, we'll check before processing each 
			# server.
		}
	}
	else
	{
		$migrate_servers = 0;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "migrate_servers", value1 => $migrate_servers, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# If our health isn't 'critical', set it to 'shutdown'.
	my $current_health = $an->ScanCore->host_state();
	if (($current_health) && ($current_health ne "critical") && ($current_health ne "shutdown"))
	{
		$an->ScanCore->host_state({set => "shutdown"});
	}
	
	### TODO: This might be racy if the other node is also shutting down. Might be worth making this a 
	###       loop that doesn't exit until all servers are on the peer or off.
	# If we're not dead, the peer can run on it's own. That said, it may be critical and shutting down, 
	# too. So despite planning to migrate, we'll check the peer's health before each migration starts and
	# switch to shutting down servers if it goes critical.
	my $local_clustat_data = $an->Cman->get_clustat_data({
		target   => $an->data->{sys}{local_node}, 
		password => $an->data->{sys}{anvil_password}, 
	});
	foreach my $server (sort {$a cmp $b} keys %{$local_clustat_data->{server}})
	{
		my $status = $local_clustat_data->{server}{$server}{status};
		my $host   = $local_clustat_data->{server}{$server}{host};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "server",  value1 => $server, 
			name2 => "status",  value2 => $status, 
			name3 => "host",    value3 => $host, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($status !~ /start/)
		{
			# Ignore it
			next;
		}
		if ($host eq $an->hostname)
		{
			# It's on us, deal with it.
			if ($migrate_servers)
			{
				# Make sure the target is still OK.
				my $peer_health = $an->ScanCore->host_state({target => $an->data->{sys}{peer_node}});
				if (($peer_health eq "critical") or ($peer_health eq "shutdown"))
				{
					# Node is no longer a viable target, so we'll shut down.
					$migrate_servers = 0;
				}
			}
			
			if ($migrate_servers)
			{
				# OK, so we're still OK to migrate, do so.
				my ($success, $output) = do_migration($an, $server);
				
				# Shut it down if migration failed.
				$an->Log->entry({log_level => 0, message_key => "an_variables_0001", message_variables => {
					name1 => "success", value1 => $success, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $success)
				{
					$an->Cman->stop_server({
						server => $server, 
						reason => $an->data->{sys}{stop_reason},
					});
				}
			}
			else
			{
				# Shut 'er down.
				$an->Cman->stop_server({
					server => $server, 
					reason => $an->data->{sys}{stop_reason},
				});
			}
		}
		else
		{
			# It's on the peer, see if it is being migrated to us and shut it down if so.
			my $migration_target = $an->ScanCore->get_migration_target({server => $server});
			if ($migration_target eq $an->hostname)
			{
				### NOTE: to future-me; yes, you can call 'clusvcadm -d' while a 
				###       'clusvcadm -M' is in progress.
				# Crap. Stop it.
				$an->Cman->stop_server({
					server => $server, 
					reason => $an->data->{sys}{stop_reason},
				});
			}
		}
	}
	
	# Stop rgmanager, then stop cman.
	my ($return_code, $withdraw_output) = $an->Cman->withdraw_node();
	# 0 == success
	# 1 == failed, restart succeeded.
	# 2 == failed, restart also failed.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "return_code", value1 => $return_code, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($return_code eq "0")
	{
		# We're done, power off.
		$an->System->poweroff();
	}
	elsif ($return_code eq "2")
	{
		# TODO: self-fence?
	}
	
	return(0);
}

# This makes the actual call to 'anvil-migrate-server'.
sub do_migration
{
	my ($an, $server) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "shutdown_node" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "server", value1 => $server, 
	}, file => $THIS_FILE, line => __LINE__});

	my $output     = "";
	my $success    = 1;
	my $shell_call = $an->data->{path}{'anvil-migrate-server'}." --server $server";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /fail/i)
		{
			$success = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "success", value1 => $success, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		$output .= "$line\n";
	}
	close $file_handle;
	
	return($success, $output);
}

# This figures out what to do.
sub process_request
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_request" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Are we shutting down or shedding load?
	if ($an->data->{switches}{'shed-load'})
	{
		$an->data->{sys}{stop_reason} = "shed-load";
		shed_load($an);
	}
	elsif ($an->data->{switches}{'local'})
	{
		local_shut_down($an);
	}
	else
	{
		# Bad request
		print_usage($an);
		print $an->String->get({key => "assp_error_0001"})."\n";
		exit(2);
	}
	
	return(0);
}

# This figures out who I am, what Anvil! I am in and who my peer is.
sub find_myself
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_myself" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $hostname_full  = $an->hostname();
	my $hostname_short = $an->short_hostname();
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "hostname_full",  value1 => $hostname_full, 
		name2 => "hostname_short", value2 => $hostname_short, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Collect information about this Anvil!
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cluster_conf},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I am node 2, make note so that we can delay and let node 1 run first.
	if (($an->data->{sys}{local_node} =~ /n02/) or ($an->data->{sys}{local_node} =~ /node02/) or ($an->data->{sys}{local_node} =~ /node2/))
	{
		$an->data->{sys}{i_am_node2} = 1;
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::i_am_node2", value1 => $an->data->{sys}{i_am_node2}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Record the server(s) running on the nodes and record their RAM.
	foreach my $server (sort {$a cmp $b} keys %{$return->{server}})
	{
		my $server_data = $an->Get->server_data({server => $server});
		$an->data->{server}{$server}{'state'} = $return->{server}{$server}{'state'};
		$an->data->{server}{$server}{host}    = $return->{server}{$server}{host};
		$an->data->{server}{$server}{ram}     = $server_data->{current_ram};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "server::${server}::state", value1 => $an->data->{server}{$server}{'state'}, 
			name2 => "server::${server}::host",  value2 => $an->data->{server}{$server}{host}, 
			name3 => "server::${server}::ram",   value3 => $an->data->{server}{$server}{ram}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Figure out what my peer's BCN, SN and IFN names are
	$an->data->{peer}{short_name} =  $an->data->{sys}{peer_node};
	$an->data->{peer}{short_name} =~ s/\..*$//;
	$an->data->{peer}{bcn_name}   =  $an->data->{peer}{short_name}.".bcn";
	$an->data->{peer}{sn_name}    =  $an->data->{peer}{short_name}.".sn";
	$an->data->{peer}{ifn_name}   =  $an->data->{peer}{short_name}.".ifn";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "peer::short_name", value1 => $an->data->{peer}{short_name}, 
		name2 => "peer::bcn_name",   value2 => $an->data->{peer}{bcn_name}, 
		name3 => "peer::sn_name",    value3 => $an->data->{peer}{sn_name}, 
		name4 => "peer::ifn_name",   value4 => $an->data->{peer}{ifn_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{sys}{local_health} = $return->{health}{'local'};
	$an->data->{sys}{peer_health}  = $return->{health}{peer};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "sys::local_health", value1 => $an->data->{sys}{local_health}, 
		name2 => "sys::peer_health",  value2 => $an->data->{sys}{peer_health}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This exits if any other instance of this program is running already.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $pids  = $an->Get->pids({program_name => $an->data->{sys}{program_name}});
	my $count = @{$pids};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		exit(1);
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "assp_message_0001"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
