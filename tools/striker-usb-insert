#!/usr/bin/perl
#
# Install:
# - Copy:
#   - rsync -av /var/www/tools/striker-usb.conf root@10.20.4.1:/etc/striker/ && rsync -av /var/www/tools/striker-usb.lib root@10.20.4.1:/sbin/ && rsync -av /var/www/tools/striker-usb-* root@10.20.4.1:/sbin/
# 
# Create:
# - /etc/udev/rules/99-striker-usb.rules
#   - Containing:
=pod
# This triggers the insert and eject scripts to mount and unmount USB drives on
# remote servers when a USB storage device is plugged into a managed port.

ACTION=="add", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker-usb-insert"

ACTION=="remove", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker-usb-remove"
=cut
# 
# Exit codes:
# 0  = Normal exit.
# 1  = Failed to unmount a device.
# 2  = Failed to create the local mount point.
# 3  = Local mount point is in use.
# 4  = Local mount point is a file.
# 5  = Unable to find a free mount point on the remote system.
# 6  = Unable to create the remote mount point
# 7  = Remote machine does not have 'sshfs' installed.
# 8  = sshfs call to ourselves failed.
# 9  = The remote user does not have permission to create the remote mount point.
# 10 = No mountable device found.
# 11 = The file system on the device can not be mounted locally.
# 12 = Loop detected trying to find a mount point on the remote machine.
# 13 = Unknown error trying to create a directory on the remote machine.
# 

use strict;
use warnings;
require "/sbin/striker-usb.lib";

my $THIS_FILE = "striker-usb-insert";
my $conf = inititialize_configuration();

logger($conf, __LINE__, "Striker USB Insert Script started.");
read_configuration($conf);
read_syslog($conf);
parse_syslog($conf);
logger($conf, __LINE__, "Striker USB Insert Script finished.");

exit(0);

# Parse syslog and decide what, if anything, to do.
sub parse_syslog
{
	my ($conf) = @_;
	logger($conf, __LINE__, "[ Debug ] - parse_syslog().");
	
	my $this_usb        = "";
	my $is_mass_storage = 0;
	my $block_device    = "";
	my $rule_found      = 0;
	foreach my $line (@{$conf->{syslog}})
	{
		#logger($conf, __LINE__, "[ Debug ] - line: [$line].");
		if ($line =~ /kernel: usb (.*?): New USB device found/)
		{
			$this_usb = $1;
			logger($conf, __LINE__, "[ Debug ] - this_usb: [$this_usb].");
		}
		if ($line =~ /Uniform CD-ROM driver/)
		{
			$block_device = 1;
			logger($conf, __LINE__, "[ Debug ] - block_device: [$block_device].");
			last;
		}
		next if not $this_usb;
		$line =~ s/^.*?kernel: //;
		if ($line =~ /SCSI emulation for USB Mass Storage devices/)
		{
			$is_mass_storage = 1;
			logger($conf, __LINE__, "[ Debug ] - is_mass_storage: [$is_mass_storage].");
		}
		next if not $is_mass_storage;
		if ($line =~ /sd(\w+): sd(\w+)\d/)
		{
			my $lhs = $1;
			my $rhs = $2;
			logger($conf, __LINE__, "[ Debug ] - lhs: [$lhs], rhs: [$rhs]");
			next if (($lhs) && ($lhs ne $rhs));
			$block_device = "sd".$lhs;
			logger($conf, __LINE__, "[ Debug ] - block_device: [$block_device].");
		}
		next if not $block_device;
		last;
	}
	if ($block_device)
	{
		$conf->{this_usb} = $this_usb;
		logger($conf, __LINE__, "[ Debug ] - USB device: [$this_usb], block device: [$block_device]");
		foreach my $usb (sort {$a cmp $b} keys %{$conf->{usb}})
		{
			if (exists $conf->{usb}{$this_usb})
			{
				$rule_found   = 1;
				my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
				my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
				my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
				my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
				my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
				my $device       = "/dev/".$block_device;
				logger($conf, __LINE__, "[ Debug ] - I will mount filesystems on: [$device] locally as: [$local_mount] and remotely on: [$user\@$host] as: [$remote_mount]");
				last;
			}
		}
		if (not $rule_found)
		{
			logger($conf, __LINE__, "The inserted block device is not using a managed USB port.");
		}
	}
	else
	{
		logger($conf, __LINE__, "The inserted device is not a block device.");
		exit(0);
	}

	if ($rule_found)
	{
		my $this_usb     = $conf->{this_usb};
		my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
		my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
		my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
		my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
		my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
		my $device       = "/dev/".$block_device;
		logger($conf, __LINE__, "I will mount the partition on: [$device] locally as: [$local_mount] and remotely on: [$user\@$host] as: [$remote_mount]");
		
		find_file_systems($conf, $device);
		mount_filesystems($conf);
	}
}

# This tries to read the UUIS of a LUKS encypted device then checks to see if
# we have a passphrase for the UUID. If so, it tries to decrypt the device. If
# that works, it returns the new DM device path. If it fails, it returns an
# empty string.
sub decrypt_luks
{
	my ($conf, $device) = @_;
	
	my $device_uuid = "";
	
	
	return($device);
}

# This mounts the file system locally and then connects to the remote machine
# and uses sshfs to mount our just-mounted FS.
sub mount_filesystems
{
	my ($conf) = @_;
	
	### TODO: If I can't make a directory, make an alternative.
	### TODO: Make the failure to mount one partition not block further
	###       partitions.
	my $i = 0;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{devices}})
	{
		logger($conf, __LINE__, "Device: [$device].");
		my $this_usb        = $conf->{this_usb};
		my $remote          = $conf->{usb}{$this_usb}{sshfs}{host};
		my $remote_user     = $conf->{usb}{$this_usb}{sshfs}{user};
		my $remote_password = $conf->{usb}{$this_usb}{sshfs}{password};
		my $local_mount     = $conf->{usb}{$this_usb}{local_mount};
		my $remote_mount    = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
		if ($i)
		{
			$local_mount  .= "-$i";
			$remote_mount .= "-$i";
		}
		
		# Check for unmountable stuff.
		my $mountable = 0;
		if ($conf->{devices}{$device}{fs} eq "crypto_LUKS")
		{
			# We need to get the device's UUID and, if there is an
			# entry in the config file, decrypt it and modify the
			# $device variable with the new dm path.
			logger($conf, __LINE__, "Device: [$device] is a LUKS encypted device. Checking if I have the passphrase.");
			my ($new_device) = get_luks_uuid($conf, $device);
			#: [$conf->{devices}{$device}{fs}]. Skipping it.");
			if ($new_device)
			{
				# Decrypted! Copy 'device's hash to
				# 'new_device' and then delete the old hash.
			}
			else
			{
				# Failed. ;_;
				delete $conf->{devices}{$device};
			}
		}
		else
		{
			$mountable = 1;
			logger($conf, __LINE__, "Checking if: [$device ($conf->{devices}{$device}{fs})] is already mounted or not.");
			unmount($conf, $device);
		}
		
		if (not $mountable)
		{
			logger($conf, __LINE__, "No mountable devices. Exiting.");
			exit(10);
		}
		
		if (not -e $local_mount)
		{
			make_path($local_mount, {
				mode	=>	0777,
			});
			if (not -e $local_mount)
			{
				logger($conf, __LINE__, "Failed to create the local mount directory: [$local_mount]");
				exit(2);
			}
		}
		elsif (not -d $local_mount)
		{
			logger($conf, __LINE__, "There is a file called: [$local_mount], which is where I wanted to create a mount point. Unable to proceed.");
			exit(3);
		}
		$i++;
		
		# Make sure the mount point is empty.
		local(*DIR);
		opendir(DIR, $local_mount) or die "Failed to open the directory: [$local_mount], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			logger($conf, __LINE__, "Found a file: [$local_mount/$file], the mount point is not empty. Unable to proceed.");
			exit(4);
		}
		
		# Finally, mount the FS.
		my $shell_call = "$conf->{path}{mount} $device $local_mount";
		logger($conf, __LINE__, "Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, __LINE__, "mount: [$line]");
			if ($line =~ /unknown filesystem type '(.*?)'/)
			{
				my $fs = $1;
				logger($conf, __LINE__, "Inserted device has the file system: [$fs] which this system can not mount. Unable to proceed.");
				exit(11);
			}
		}
		close $file_handle;
		
		# Check that it actually mounted.
		my $mounted    = 0;
		   $shell_call = "$conf->{path}{df} -hP";
		logger($conf, __LINE__, "Calling: [$shell_call].");
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, __LINE__, "line: [$line].");
			if (($line =~ /^$device /) && ($line =~ /$local_mount$/))
			{
				$mounted = 1;
				logger($conf, __LINE__, " - Mounted.");
			}
		}
		close $file_handle;
		
		if ($mounted)
		{
			logger($conf, __LINE__, "Successfully mounted: [$device] locally on: [$local_mount].");
		}
		else
		{
			logger($conf, __LINE__, "Failed to mount: [$device] locally on: [$local_mount]. Unable to proceed.");
			exit(9);
		}
		
		# See if the desired mount point is available.
		my $directory_found  = 0;
		my $directory_in_use = 0; 
		my $j                = 0;
		my $use_directory    = $remote_mount;
		until($directory_found)
		{
			$directory_in_use = 0;
			if ($j)
			{
				$use_directory = "${remote_mount}-$j";
			}
			my $shell_call = "ls -A $use_directory";
			logger($conf, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
			my ($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				next if not $line;
				logger($conf, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /No such file or directory/i)
				{
					# We're good, create the directory.
					my $shell_call = "/bin/mkdir $use_directory; if [ -e '$use_directory' ]; then echo created; else echo failed; fi";
					logger($conf, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
					my ($error, $ssh_fh, $return) = remote_call($conf, {
						remote		=>	$remote,
						port		=>	22,
						user		=>	$remote_user,
						password	=>	$remote_password,
						ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
						'close'		=>	0,
						shell_call	=>	$shell_call,
					});
					foreach my $line (@{$return})
					{
						logger($conf, __LINE__, "[ Debug ] - line: [$line]");
						if ($line eq "failed")
						{
							# WTF?!
							logger($conf, __LINE__, "Unknown error trying to create the directory: [$use_directory] on the remote machine: [$remote] as the user: [$remote_user]");
							exit(13);
						}
						elsif ($line eq "created")
						{
							logger($conf, __LINE__, "[ Debug ] - Directory created");
							$directory_found = 1;
						}
					}
				}
				else
				{
					# Directory exists and I got output, so
					# something is in it.
					logger($conf, __LINE__, "[ Debug ] - Found data in: [$use_directory], skipping it.");
					$directory_in_use = 1;
				}
			}
			if (not $directory_in_use)
			{
				# This directory is empty, we can use it.
				logger($conf, __LINE__, "[ Debug ] - No data in: [$use_directory], using it.");
				$directory_found = 1;
			}
			$j++;
			if ($j > 5)
			{
				logger($conf, __LINE__, "[ Debug ] - Loop detected trying to find a mount point on the remote machine.");
				exit(12);
			}
		}
		$remote_mount = $use_directory;
		logger($conf, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
		
		# If I am still alive, I can mount.
		my $local_host         = $conf->{'local'}{host};
		my $local_user         = $conf->{'local'}{user};
		my $local_password     = $conf->{'local'}{password};
		my $remote_known_hosts = "/home/$remote_user/.ssh/known_hosts";
		if ($remote_user eq "root")
		{
			$remote_known_hosts = "/root/.ssh/known_hosts";
		}
		
		# TODO: Make sure this works if a stale mount exists on the
		#       remote machine.
		my $remote_shell_call  = "
if [ ! -e '$remote_known_hosts' ] || \$(grep -q $local_host $remote_known_hosts)
then
    ssh-keyscan $local_host >> $remote_known_hosts
    echo key added
fi
echo $local_password | sshfs -o password_stdin -o idmap=user -o sshfs_sync -o no_readahead $local_user\@$local_host:$local_mount $remote_mount";
		logger($conf, __LINE__, "Ready to mount local: [$local_mount] on remote: [$remote] at: [$remote_mount].");
		logger($conf, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], remote_shell_call: [$remote_shell_call].");
		
		#$shell_call = "echo $local_password | $remote_shell_call";
		$shell_call = "echo $local_password | $remote_shell_call";
		logger($conf, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
		my ($error, $ssh_fh, $return) = remote_call($conf, {
			remote		=>	$remote,
			port		=>	22,
			user		=>	$remote_user,
			password	=>	$remote_password,
			ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			logger($conf, __LINE__, "[ Debug ] - line: [$line]");
			if ($line =~ /sshfs: command not found/)
			{
				logger($conf, __LINE__, "Remote machine: [$remote] does not have 'sshfs' installed. Unable to proceed.");
				unmount($conf, $device);
				exit(7);
			}
			elsif ($line =~ /fuse: failed to exec fusermount: Permission denied/)
			{
				logger($conf, __LINE__, "Calling: [$remote_shell_call] on the remote machine returned a 'permission denied' error. Please run this manually and resolve any permissions issues. Is the '$remote_user' user in the 'fuse' group? If not, please run: [usermod -a -G fuse $remote_user] on the target server and try again. Unable to proceed.");
				unmount($conf, $device);
				exit(8);
			}
		}
	}
	
	return(0);
}

# Unmount the specified device.
sub unmount
{
	my ($conf, $device) = @_;
	
	my $mount_point = get_mount_point($conf, $device);
	if ($mount_point)
	{
		logger($conf, __LINE__, "device: [$device] is mounted on: [$mount_point]. Unmounting.");
		my $shell_call = "$conf->{path}{umount} $device";
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call] Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
		}
		close $file_handle;
		$mount_point = get_mount_point($conf, $device);
		if ($mount_point)
		{
			logger($conf, __LINE__, "Failed to unmount: [$device] from: [$mount_point]");
			exit(1);
		}
		logger($conf, __LINE__, "Device: [$device] unmounted successfully.");
	}
	else
	{
		logger($conf, __LINE__, "device: [$device] is not mounted.");
	}
	
	return(0);
}

sub get_mount_point
{
	my ($conf, $device) = @_;
	
	my $mount_point = "";
	my $shell_call = "$conf->{path}{mount}";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, __LINE__, "line: [$line]");
		if ($line =~ /^$device on (.*?) /)
		{
			$mount_point = $1;
			#logger($conf, __LINE__, "mount_point: [$mount_point]");
		}
	}
	close $file_handle;
	
	return($mount_point);
}

sub find_file_systems
{
	my ($conf, $device) = @_;
	my @filesystems;
	
	my $shell_call = "$conf->{path}{ls} ${device}*";
	logger($conf, __LINE__, "Calling: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, __LINE__, "[ Debug ] - line: [$line]");
		if (($line eq $device) or ($line =~ /^$device\d+/))
		{
			call_blkid($conf, $line);
		}
	}
	close $file_handle;
		
	return(0);
}

sub call_blkid
{
	my ($conf, $device) = @_;
	
	my $uuid;
	my $fs;
	my $shell_call = "$conf->{path}{blkid} -c /dev/null $device";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
		}
	}
	close $file_handle;
	
	if ($fs)
	{
		$conf->{devices}{$device}{fs}   = $fs;
		$conf->{devices}{$device}{uuid} = $uuid;
		$conf->{devices}{$device}{path} = $device;
		logger($conf, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, __LINE__, "[ Debug ] - device: [$device] has no file system.");
	}
	
	return(0);
}
