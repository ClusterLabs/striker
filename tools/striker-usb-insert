#!/usr/bin/perl
#
# This program looks in the Striker configuration file:
# [/etc/striker/striker.conf] for managed USB ports. An example of how to
# configure a USB port to be managed are shown there.
# 
# Create:
# - /etc/udev/rules/99-striker-usb.rules
#   - Containing:
#------------------------------------------------------------------------------
# # This triggers the insert and eject scripts to mount and unmount USB drives on
# # remote servers when a USB storage device is plugged into a managed port.
# 
# ACTION=="add", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker/striker-usb-insert"
# 
# ACTION=="remove", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker/striker-usb-remove"
#------------------------------------------------------------------------------
# 
# Exit codes:
# 0  = Normal exit.
# 1  = Failed to unmount a device.
# 2  = Failed to create the local mount point.
# 3  = Local mount point is in use.
# 4  = Local mount point is a file.
# 5  = Unable to find a free mount point on the remote system.
# 6  = Unable to create the remote mount point
# 7  = Remote machine does not have 'sshfs' installed.
# 8  = sshfs call to ourselves failed.
# 9  = The remote user does not have permission to create the remote mount point.
# 10 = No mountable device found.
# 11 = The file system on the device can not be mounted locally.
# 12 = Loop detected trying to find a mount point on the remote machine.
# 13 = Unknown error trying to create a directory on the remote machine.
# 14 = Asked to format an device that didn't look like a proper block device path.
# 15 = Tried to format device as LUKS, but no luksUUID was found.
# 16 = Failed to decrypt LUKS-encrypted device.
# 17 = blkid called against the LUKS decrypted dm device didn't return the UUID and/or fs type.
# 18 = Attempt to mount the local mount on the remote machine using sshfs timed out.
# 19 = Permission denied error on the remote machine when trying to create the remote mount point.
# 20 = The remote machine failed to connect to this machine. Probably used a host name that didn't resolve to
#      an IP address.
# 21 = Failed to enable in striker.conf
# 22 = Failed to disable in striker.conf
# 23 = Asked to mount a device remotely but the USB address wasn't set.
# 24 = Asked to mount a device remotely but the remote mount point wasn't set.
# 25 = Failed to unmount a non-LUKS partition that needed to be reformatted LUKS.
# 26 = The 'use_directory' variable in the mount_filesystems() function was not set.
# 27 = Failed to find the local short host name.
# 
# TODO:
# - Verify that 'remote-usb::local::host' IP is accurate and/or use the subnet to find the actual local IP
# - Add the short host name to the remote mount directory (ie: remote_an-striker01_4-6)
# - Add the Striker host name and USB address (and/or make/model) to the 'formatting' /tmp file, like:
#   /tmp/.<short_host>_<usb_port>_formatting
# 

use strict;
use warnings;
require "/sbin/striker/striker-usb.lib";

my $THIS_FILE = "striker-usb-insert";
my $conf = inititialize_configuration();
read_configuration($conf);

# See if the user is enabling, disabling or forcing this run.
get_switches($conf);
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}))
{
	print_usage($conf);
	exit(0);
}
elsif ($conf->{switches}{enable})
{
	logger($conf, $THIS_FILE, __LINE__, "Enabling remote mount on USB insert.");
	my $exit = 0;
	my $ok   = update_configuration($conf, "enable");
	if (not $ok)
	{
		$exit = 21;
	}
	exit($exit);
}
elsif ($conf->{switches}{disable})
{
	logger($conf, $THIS_FILE, __LINE__, "Disabling remote mount on USB insert.");
	my $exit = 0;
	my $ok   = update_configuration($conf, "disable");
	if (not $ok)
	{
		$exit = 22;
	}
	exit($exit);
}
elsif ($conf->{switches}{force})
{
	logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert script running with '--force', ignoring $conf->{path}{striker_config} setting.", 0);
}
elsif (not $conf->{'remote-usb'}{enable_remote_usb_mount})
{
	logger($conf, $THIS_FILE, __LINE__, "- Striker USB Insert has been disabled, exiting.");
	exit(0);
}

logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert Script started.");

# Find the local hostname.
get_short_hostname($conf);

#find_usb_devices($conf);
check_sd_devices($conf);

#read_syslog($conf);
#parse_syslog($conf);
logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert Script finished.");

exit(0);

# This calls udevadm against all found /dev/sdX devices to find the ones that are using USB
sub check_sd_devices
{
	my ($conf) = @_;
	
	my $shell_call = "$conf->{path}{ls} /dev/sd*";
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $device        = $_;
		next if $device   =~ /\d$/;
		my $active_device =  ($device =~ /.*\/(.*)?/)[0];
		logger($conf, $THIS_FILE, __LINE__, "*** [ Debug ] - device: [$device], active_device: [$active_device] ***");
		
		my $this_device  = "";
		my $this_usb     = "";
		my $block_device = ($device =~ /\/dev\/(sd.*)/)[0];
		my $removable    = 0;
		my $size         = 0;
		my $read_only    = 0;
		
		my $shell_call  = "$conf->{path}{udevadm} info --attribute-walk --name $device";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line =~ /looking at parent device '(.*?)'/)
			{
				$this_device = $1;
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_device: [$this_device].");
				if ((not $this_usb) && ($this_device =~ /usb\d+\/(\d+-\d+)\//))
				{
					$this_usb = $1;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb] parsed from: [$this_device].");
				}
				next;
			}
			if ($line =~ /ATTR{removable}=="(\d+)"/)
			{
				$removable = $1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - removable: [$removable].");
			}
			if ($line =~ /ATTR{size}=="(\d+)"/)
			{
				$size = $1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - size: [$size].");
			}
			if ($line =~ /ATTR{ro}=="(\d+)"/)
			{
				$read_only = $1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_only: [$read_only].");
			}
		}
		close $file_handle;
		
		my $sector_size = get_sector_size($conf, $block_device);
		my $size_gib    = 0;
		my $size_gb     = 0;
		my $byte_size   = ($sector_size * $size);
		if ($block_device)
		{
			$size_gib = sprintf("%.2f", ($byte_size / (2 ** 30)));
			$size_gb  = sprintf("%.2f", ($byte_size / (10 ** 9)));
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb], block_device: [$block_device ($device)].");
		
		# If I've got a USB address, use it to set 'this_usb'. If this is also a root device, record
		# the USB address for this device.
		if ($this_usb)
		{
			$conf->{this_usb} = $this_usb;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ::this_usb: [$conf->{this_usb}].");
			if ($device !~ /\d$/)
			{
				$conf->{root_usb}{$device} = $this_usb;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - root_usb::$device: [$conf->{root_usb}{$device}].");
			}
		}
		
		# Now, if this is not a root device and no USB address was found, see if we have the address 
		# from the parent.
		if ((not $this_usb) && ($device =~ /\d$/))
		{
			my $parent = ($device =~ /^(.*)\d+$/)[0];
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parent: [$parent].");
			if ($conf->{root_usb}{$device})
			{
				$this_usb = $conf->{root_usb}{$device};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb], root_usb::$device: [$conf->{root_usb}{$device}].");
			}
		}
		
		logger($conf, $THIS_FILE, __LINE__, "remote-usb::remote::host: [$conf->{'remote-usb'}{remote}{host}], remote-usb::remote::user: [$conf->{'remote-usb'}{remote}{user}], remote-usb::remote::password: [$conf->{'remote-usb'}{remote}{password}], remote-usb::remote::mount: [$conf->{'remote-usb'}{remote}{mount}], remote-usb::local::mount: [$conf->{'remote-usb'}{'local'}{mount}], this_usb: [$this_usb]");
		my $host         = $conf->{'remote-usb'}{remote}{host};
		my $user         = $conf->{'remote-usb'}{remote}{user};
		my $password     = $conf->{'remote-usb'}{remote}{password};
		my $remote_mount = $conf->{'remote-usb'}{remote}{mount}."_$conf->{sys}{short_hostname}_$this_usb";
		my $local_mount  = $conf->{'remote-usb'}{'local'}{mount}."_$this_usb";
		logger($conf, $THIS_FILE, __LINE__, "host: [$host], user: [$user], password: [$password], remote_mount: [$remote_mount], local_mount: [$local_mount]");
		
		my $yn = ["No", "Yes"];
		logger($conf, $THIS_FILE, __LINE__, "This device: [$device] is: [$size_gib GiB ($size_gb GB)]; Removable? [".$yn->[$removable]."], Read only? [".$yn->[$read_only]."], USB Address: [$this_usb]");
		if (not $this_usb)
		{
			logger($conf, $THIS_FILE, __LINE__, "- The device: [$device] is not a USB device, skipping.");
		}
		elsif ($read_only)
		{
			logger($conf, $THIS_FILE, __LINE__, "- The device: [$device] is read-only, skipping it.");
		}
		elsif (not $size)
		{
			logger($conf, $THIS_FILE, __LINE__, "- The device: [$device] has no size (likely a removable device with no media), skipping it.");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- Looking for file systems on: [$device]");
			find_file_systems($conf, $device, $byte_size);
			logger($conf, $THIS_FILE, __LINE__, "- Mounting discovered filesystems, if needed.");
			mount_filesystems($conf, $active_device);
		}
		$conf->{this_usb} = $this_usb;
	}
	close $file_handle;
	
	return(0);
}

# This reads '/sys/block/${block_device}/queue/hw_sector_size' to get the sector size.
sub get_sector_size
{
	my ($conf, $block_device) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "get_sector_size(); block_device: [$block_device]");
	
	# Return 0 if the sysfs file doesn't exist;
	return(0) if not -e "/sys/block/${block_device}/queue/hw_sector_size";
	
	my $sector_size = 0;
	my $shell_call  = "/sys/block/${block_device}/queue/hw_sector_size";
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		$sector_size = $_;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sector_size: [$sector_size].");
	}
	close $file_handle;
	
	#logger($conf, $THIS_FILE, __LINE__, "sector_size: [$sector_size]");
	return($sector_size);
}

# This tries to read the UUIS of a LUKS encypted device then checks to see if
# we have a passphrase for the UUID. If so, it tries to decrypt the device. If
# that works, it returns the new DM device path. If it fails, it returns an
# empty string.
sub decrypt_luks
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - decrypt_luks(); device: [$device].");
	
	# Try to decrypt the passed device using the passphrase in the config file.
	my $decypted    = 1;
	my $device_name = ($device =~ /^.*\/(.*?)$/)[0];
	my $dm_path     = "/dev/mapper/$device_name";
	my $temp_file   = "/tmp/".time;
	my $fs          = "";
	my $uuid        = "";
	my $label       = "";
	my $shell_call  = "
if [ -e '$dm_path' ];
then
    echo 'already decrypted'
    $conf->{path}{blkid} -p $dm_path
else
    $conf->{path}{echo} '$conf->{'remote-usb'}{luks}{passphrase}' > $temp_file
    $conf->{path}{cryptsetup} luksOpen $device $device_name --key-file $temp_file
    unlink $temp_file
    if [ -e '$dm_path' ]
    then
        $conf->{path}{blkid} -p $dm_path
    else
        echo 'dm path: '$dm_path' not found'
    fi;
fi;";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line eq "already decrypted")
		{
			logger($conf, $THIS_FILE, __LINE__, "The device: [$device] appears to be decrypted already.");
			$decypted = 0;
		}
		if ($line =~ /dm path: .* not found/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to decrypt: [$device], unable to proceed.");
			exit(16);
		}
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s UUID is: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s filesystem type is: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s filesystem label is: [$label]");
		}
	}
	close $file_handle;
	
	if (($fs) && ($uuid))
	{
		# If I am still alive, record the new details.
		$device = $dm_path;
		$conf->{devices}{$device}{fs}    = $fs;
		$conf->{devices}{$device}{uuid}  = $uuid;
		$conf->{devices}{$device}{label} = $label;
		$conf->{devices}{$device}{path}  = $device;
		if ($decypted)
		{
			logger($conf, $THIS_FILE, __LINE__, "Decryption was successful!");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "Previously decrypted device appears accessible.");
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "The decrypted device: [$dm_path] doesn't appear to have a file system on it. The UUID and/or filesystem Type were not read.");
		if ($conf->{'remote-usb'}{luks}{force_initialize})
		{
			logger($conf, $THIS_FILE, __LINE__, "The 'remote-usb::luks::force_initialize' option is set, formatting it now.");
			my ($fs, $uuid, $label) = format_device($conf, $dm_path);
			$device = $dm_path;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
			$conf->{devices}{$device}{fs}    = $fs;
			$conf->{devices}{$device}{uuid}  = $uuid;
			$conf->{devices}{$device}{label} = $label;
			$conf->{devices}{$device}{path}  = $dm_path;
			logger($conf, $THIS_FILE, __LINE__, "Decryption was successful!");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "The 'luks::force_initialize' option is not set, so will not format. Unable to proceed.");
			exit(17);
		}
	}
	
	return($device);
}

# This will forcibly reformat the passed device as a LUKS partition with the
# passphrase set in the config file.
sub format_device_luks
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "Device: [$device].");
	
	# If I wasn't passed a proper device, die die die!
	if ($device !~ /\/dev\/sd(\w+\d+)/)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] I was asked to format: [$device] as a LUKS partition, but it appears to be an invalid device. Unable to proceed.");
		exit(14);
	}
	
	# Delete all existing partition and create a single one using all the space on the disk.
	my $device_name = ($device =~ /^.*\/(.*?)$/)[0];
	my $dm_path     = "/dev/mapper/$device_name";
	my $temp_file   = "/tmp/".time;
	my $shell_call  = "
$conf->{path}{echo} '$conf->{'remote-usb'}{luks}{passphrase}' > $temp_file
$conf->{path}{echo} YES | $conf->{path}{cryptsetup} luksFormat $device $temp_file
";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cryptsetup output: [$line]");
	}
	close $file_handle;
	
	# Now check to be sure the partition is now LUKS
	$shell_call = "$conf->{path}{cryptsetup} luksUUID $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /not a valid LUKS device/)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] Failed to format: [$device] as a LUKS partition. No 'luksUUID' was found. Unable to proceed.");
			exit(15);
		}
		else
		{
			my $luksuuid = $line;
			logger($conf, $THIS_FILE, __LINE__, "Successfully formatted: [$device] as a LUKS partition with UUID: [$luksuuid], unlocking it now.");
			my $shell_call = "
$conf->{path}{cryptsetup} luksOpen $device $device_name --key-file $temp_file
unlink $temp_file
if [ -e '$dm_path' ]
then
    echo 'unlocked successfully'
else
    echo 'unlock failed, dm path: [$dm_path] not found'
fi
";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /dm path: .* not found/)
				{
					logger($conf, $THIS_FILE, __LINE__, "Failed to decrypt: [$device], unable to proceed.");
					exit(16);
				}
				elsif ($line =~ /unlockes successfully/)
				{
					logger($conf, $THIS_FILE, __LINE__, "Unlocked successfully, device mapper path is: [$dm_path].");
				}
			}
			close $file_handle;
			
			my ($fs, $uuid, $label) = format_device($conf, $dm_path);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
			
			if ($fs)
			{
				# If I am still alive, record the new details.
				$device = $dm_path;
				$conf->{devices}{$device}{fs}    = $fs;
				$conf->{devices}{$device}{uuid}  = $uuid;
				$conf->{devices}{$device}{label} = $label;
				$conf->{devices}{$device}{path}  = $device;
				logger($conf, $THIS_FILE, __LINE__, "Format was successful!");
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}] and the label: [$conf->{devices}{$device}{label}].");
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "Format appears to have failed. The new file system type and/or UUID were not read.");
				exit(17);
			}
		}
	}
	close $file_handle;
	
	return($dm_path);
}

# This does the work of formatting a device.
sub format_device
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - format_device(); device: [$device]");
	
	# Touch the 'formatting' file on the target so they know to be patient.
	my $remote          = $conf->{'remote-usb'}{remote}{host};
	my $remote_user     = $conf->{'remote-usb'}{remote}{user};
	my $remote_password = $conf->{'remote-usb'}{remote}{password};
	my $shell_call      = "$conf->{path}{touch} $conf->{path}{format_running};";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$remote,
		port		=>	22,
		user		=>	$remote_user,
		password	=>	$remote_password,
		ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	foreach my $line (@{$return})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
	}
	
	# Put together our format call
	my $mkfs_call = "$conf->{path}{mkfs} -t $conf->{'remote-usb'}{luks}{use_filesystem} $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote-usb::luks::use_filesystem: [$conf->{'remote-usb'}{luks}{use_filesystem}], remote-usb::luks::fs_label: [$conf->{'remote-usb'}{luks}{fs_label}]");
	if ($conf->{'remote-usb'}{luks}{fs_label})
	{
		$mkfs_call = "$conf->{path}{mkfs} -t $conf->{'remote-usb'}{luks}{use_filesystem} -L '$conf->{'remote-usb'}{luks}{fs_label}' $device";
	}
	my $fs    = "";
	my $uuid  = "";
	my $label = "";
	logger($conf, $THIS_FILE, __LINE__, "Will now format the device: [$device] as: [$conf->{'remote-usb'}{luks}{use_filesystem}]");
	$shell_call = "
echo 'formatting $device now'
$conf->{path}{touch} $conf->{path}{format_running}; 
$mkfs_call
sync
echo 'formatted, checking with blkid'
$conf->{path}{blkid} -p $device
$conf->{path}{rm} -f $conf->{path}{format_running}
";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		# Don't print the progress, it just creates a mess in the logs.
		if ($line =~ /Writing inode tables/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [Writing inode tables: <progress messages supressed>]");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		if ($line =~ /formatting .* now/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Formatting: [$device]. Please wait, this might take a few minutes...");
		}
		if ($line =~ /formatted/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Format appears to be complete, checking with 'blkid' now.");
		}
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem's UUID: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem type is: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem label is: [$fs]");
		}
	}
	close $file_handle;
	
	# Now remove the 'formatting' file on the target
	$shell_call = "$conf->{path}{rm} -f $conf->{path}{format_running};";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$remote,
		port		=>	22,
		user		=>	$remote_user,
		password	=>	$remote_password,
		ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	foreach my $line (@{$return})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
	return($fs, $uuid, $label);
}

# This mounts the file system locally and then connects to the remote machine
# and uses sshfs to mount our just-mounted FS.
sub mount_filesystems
{
	my ($conf, $active_device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mount_filesystems(); active_device: [$active_device]");
	
	### TODO: If I can't make a directory, make an alternative.
	### TODO: Make the failure to mount one partition not block further partitions.
	my $i = 0;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{devices}})
	{
		next if $device !~ /\d$/;
		next if $device !~ /$active_device/;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Device: [$device].");
		
		# Check the remote mount
		my $shell_call = "
if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
then
    echo 'already mounted'; 
else 
    echo 'not mounted';
fi";

		# If this is a USB device (be very sure!), and if force_initialize is set, and if this is not
		# and LUKS FS, and if this is not a device-mapped device, dismount and reformat.
		my $parent = ($device =~ /^(.*)\d+$/)[0];
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parent: [$parent], device: [$device]");
		if ((not $parent) && ($device =~ /mapper/))
		{
			$parent =  $device;
			$parent =~ s/\/mapper//;
			$parent =  ($device =~ /^(.*)\d+$/)[0];
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parent: [$parent]");
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - root_usb::$parent: [$conf->{root_usb}{$parent}], remote-usb::luks::force_initialize: [$conf->{'remote-usb'}{luks}{force_initialize}], device: [$device]");
		if (($conf->{root_usb}{$parent}) && ($conf->{'remote-usb'}{luks}{force_initialize}) && ($device !~ /\/mapper/))
		{
			# If this isn't a LUKS FS, unmount it.
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - devices::${device}::fs: [$conf->{devices}{$device}{fs}]");
			if ($conf->{devices}{$device}{fs} =~ /LUKS/i)
			{
				# This is a LUKS partition already, so skip it entirely.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - This is a LUKS partition, skipping it.");
				$shell_call = "";
			}
			else
			{
				# Not encypted, but should be.
				$shell_call = "
if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
then
    echo \"Mounted, but not LUKS encrypted and 'remote-usb::luks::force_initialize' is set, unmounting to prepare to format\"; 
    $conf->{path}{umount} $device
    if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
    then 
        echo 'failed to unmount device before LUKS format.'
    else
        echo 'unmounted for LUKS format successfully.'
    fi
else 
    echo 'not mounted';
fi";
			}
		}
		
		# Now call which-ever shell call is needed.
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
		if ($shell_call)
		{
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line]");
				if ($line eq "already mounted")
				{
					logger($conf, $THIS_FILE, __LINE__, "The device: [$device] is already mounted, skipping it.");
					$conf->{skip}{$device} = 1;
				}
				if ($line =~ /failed to unmount/)
				{
					# Error out.
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The device: [$device], which was mounted but not LUKS encrypted and force_initialize is set, failed to unmount. Format not possible.");
					exit(25);
				}
			}
			close $file_handle;
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote-usb::remote::host: [$conf->{'remote-usb'}{remote}{host}], remote-usb::remote::user: [$conf->{'remote-usb'}{remote}{user}], remote-usb::remote::password: [$conf->{'remote-usb'}{remote}{password}], remote-usb::remote::mount: [$conf->{'remote-usb'}{remote}{mount}], remote-usb::local::mount: [$conf->{'remote-usb'}{'local'}{mount}], ::this_usb: [$conf->{this_usb}]");
		my $this_usb        = $conf->{this_usb};
		my $remote          = $conf->{'remote-usb'}{remote}{host};
		my $remote_user     = $conf->{'remote-usb'}{remote}{user};
		my $remote_password = $conf->{'remote-usb'}{remote}{password};
		my $remote_mount    = $conf->{'remote-usb'}{remote}{mount}."_$conf->{sys}{short_hostname}_$this_usb";
		my $local_mount     = $conf->{'remote-usb'}{'local'}{mount}."_$this_usb";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote: [$remote], remote_user: [$remote_user], remote_password: [$remote_password], remote_mount: [$remote_mount], local_mount: [$local_mount]");
		
		# If, for some reason, the USB address or remote mount variables are blank, exit.
		if (not $this_usb)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - I was asked to mount: [$device], but no USB address was set.");
			exit(23);
		}
		if (not $remote_mount)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - I was asked to mount: [$device], but a remote mount point wasn't set.");
			exit(24);
		}
		
		if ($conf->{devices}{$device}{label})
		{
			$remote_mount .= "_$conf->{devices}{$device}{label}";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]", 0);
		}
		if ($i)
		{
			$local_mount  .= "_$i";
			$remote_mount .= "_$i";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount], local_mount: [$local_mount]", 0);
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - i: [$i], device: [$device], this_usb: [$this_usb], remote: [$remote], remote_user: [$remote_user], remote_password: [$remote_password], local_mount: [$local_mount], remote_mount: [$remote_mount]");
		
		# Check for unmountable stuff.
		my $mountable = 0;
		if ($conf->{devices}{$device}{fs} eq "crypto_LUKS")
		{
			# We need to get the device's UUID and, if there is an entry in the config file, 
			# decrypt it and modify the $device variable with the new dm path.
			logger($conf, $THIS_FILE, __LINE__, "Device: [$device] is a LUKS encypted device. Checking if I have the passphrase.");
			($device) = decrypt_luks($conf, $device);
			logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
			$mountable = 1;
			
			# If there was a label on the decrypted FS, update the mount directory name.
			if ($conf->{devices}{$device}{label})
			{
				# A label was set, update the mount name.
				$remote_mount .= "_$conf->{devices}{$device}{label}";
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount], i: [$i]");
				if ($i)
				{
					$remote_mount .= "_$i";
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
				}
			}
		}
		else
		{
			# Start by making sure it is unmounted
			logger($conf, $THIS_FILE, __LINE__, "We're about to start, but we're going to sleep for 5 seconds to give other processes time to mount the partitions.");
			sleep 5;
			logger($conf, $THIS_FILE, __LINE__, "Done waiting; Now checking if: [$device ($conf->{devices}{$device}{fs})] is already mounted or not.");
			unmount($conf, $device);
			
			# If the user has requested 'luks::force_initialize', 
			# then we're going to have to format this partition.
			if (($conf->{'remote-usb'}{luks}{force_initialize}) && ($device !~ /\/mapper/))
			{
				# Before we format, see if the user has set a protected label and, if so, if
				# this FS is protected.
				my $proceed = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - About to format, but checking first for a protected label: [$conf->{'remote-usb'}{luks}{protected_label}] that matches the partition's label: [$conf->{devices}{$device}{label}].");
				if (($conf->{'remote-usb'}{luks}{protected_label}) && ($conf->{devices}{$device}{label}))
				{
					# They have and there is a label, see 
					# if they match.
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Label found on file system, seeing if it is protected.");
					my $wildcard = 0;
					my $string   = $conf->{'remote-usb'}{luks}{protected_label};
					my $label    = $conf->{devices}{$device}{label};
					if ($conf->{'remote-usb'}{luks}{protected_label} =~ /^(.*?)\*/)
					{
						$string   = $1;
						$wildcard = 1;
					}
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - label: [$label], string: [$string], wildcard: [$wildcard]");
					if ($wildcard)
					{
						if ($label =~ /^($string).*/)
						{
							$proceed = 0;
							logger($conf, $THIS_FILE, __LINE__, "File system label: [$label] is protected.");
						}
						else
						{
							logger($conf, $THIS_FILE, __LINE__, "Unprotected label, will proceed with format.");
						}
					}
					elsif ($label eq $string)
					{
						$proceed = 0;
						logger($conf, $THIS_FILE, __LINE__, "File system label: [$label] is protected.");
					}
					else
					{
						logger($conf, $THIS_FILE, __LINE__, "Unprotected label, will proceed with format.");
					}
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - No protected label set or no label found on the partition, proceeding.");
				}
				# Format. This will return the new device mapper path for the decrypted
				# device. If anything goes wrong, it will exit, so we don't need to sanity 
				# check the returned device.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - proceed: [$proceed].");
				if ($proceed)
				{
					logger($conf, $THIS_FILE, __LINE__, "LUKS initialization required on: [$device].");
					($device) = format_device_luks($conf, $device);
					logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
					
					# If the formatted FS has a label, and
					# the old FS didn't, we'll want to 
					# append the label to the mount point 
					# now.
					if ($conf->{devices}{$device}{label})
					{
						# A label was set, update the mount name.
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
						if ($conf->{devices}{$device}{label})
						{
							$remote_mount .= "_$conf->{devices}{$device}{label}";
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
						}
						if ($i)
						{
							$remote_mount .= "_$i";
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
						}
					}
				}
				$mountable = 1;
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "I will try to mount: [$device].");
				$mountable = 1;
			}
		}
		
		if (not $mountable)
		{
			logger($conf, $THIS_FILE, __LINE__, "No mountable devices. Exiting.");
			exit(10);
		}
		
		# See if the device is already mounted locally.
		my $already_mounted = 0;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device], local_mount: [$local_mount]");
		$shell_call = "
if $conf->{path}{mount} | $conf->{path}{grep} -q '$device on $local_mount';
then 
    echo 'already mounted';
else 
    echo 'mount needed';
fi;";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
			if ($line eq "already mounted")
			{
				logger($conf, $THIS_FILE, __LINE__, "The device: [$device] is already mounted on: [$local_mount].");
				$already_mounted = 1;
			}
		}
		close $file_handle;
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - already_mounted: [$already_mounted].");
		if (not $already_mounted)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - local_mount: [$local_mount].");
			if (not -e $local_mount)
			{
				make_path($local_mount, {
					mode	=>	0777,
				});
				if (not -e $local_mount)
				{
					logger($conf, $THIS_FILE, __LINE__, "Failed to create the local mount directory: [$local_mount]");
					exit(2);
				}
			}
			elsif (not -d $local_mount)
			{
				logger($conf, $THIS_FILE, __LINE__, "There is a file called: [$local_mount], which is where I wanted to create a mount point. Unable to proceed.");
				exit(3);
			}
			$i++;
			
			# Make sure the mount point is empty.
			local(*DIR);
			opendir(DIR, $local_mount) or die "Failed to open the directory: [$local_mount], error was: $!\n";
			while (my $file = readdir(DIR))
			{
				next if (($file eq ".") or ($file eq ".."));
				logger($conf, $THIS_FILE, __LINE__, "Found a file: [$local_mount/$file], the mount point is not empty. Unable to proceed.");
				exit(4);
			}
			
			# Finally, mount the FS.
			$shell_call = "$conf->{path}{mount} $device $local_mount";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
				if ($line =~ /unknown filesystem type '(.*?)'/)
				{
					my $fs = $1;
					logger($conf, $THIS_FILE, __LINE__, "Inserted device has the file system: [$fs] which this system can not mount. Unable to proceed.");
					exit(11);
				}
			}
			close $file_handle;
			
			# Check that it actually mounted.
			my $mounted    = 0;
			$shell_call = "$conf->{path}{df} -hP";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line].");
				if (($line =~ /^$device /) && ($line =~ /$local_mount$/))
				{
					$mounted = 1;
					logger($conf, $THIS_FILE, __LINE__, " - Mounted.");
				}
			}
			close $file_handle;
			
			if ($mounted)
			{
				logger($conf, $THIS_FILE, __LINE__, "Successfully mounted: [$device] locally on: [$local_mount].");
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "Failed to mount: [$device] locally on: [$local_mount]. Unable to proceed.");
				exit(9);
			}
		}
		
		# See if this device is already mounted on the remote node.
		my $local_host         = $conf->{'remote-usb'}{'local'}{host};
		my $local_user         = $conf->{'remote-usb'}{'local'}{user};
		my $local_password     = $conf->{'remote-usb'}{'local'}{password};
		my $remote_known_hosts = "/home/$remote_user/.ssh/known_hosts";
		if ($remote_user eq "root")
		{
			$remote_known_hosts = "/$remote_user/.ssh/known_hosts";
		}
		my $mount_needed       = 1;
		   $shell_call         = "
if mount | grep -q '$local_user\@$local_host:$local_mount';
then 
    echo 'already mounted'; 
else 
    echo 'mount needed'; 
fi;";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
		my ($error, $ssh_fh, $return) = remote_call($conf, {
			remote		=>	$remote,
			port		=>	22,
			user		=>	$remote_user,
			password	=>	$remote_password,
			ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line eq "already mounted")
			{
				logger($conf, $THIS_FILE, __LINE__, "Our local mount: [$local_user\@$local_host:$local_mount] is already mounted on the remote machine.");
				$mount_needed = 0;
			}
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mount_needed: [$mount_needed]");
		if ($mount_needed)
		{
			# See if the desired *remote* mount point is available.
			my $directory_found  = 0;
			my $directory_in_use = 0; 
			my $j                = 0;
			my $use_directory    = $remote_mount;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - use_directory: [$use_directory]");
			if (not $use_directory)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The 'use_directory' variable should have been set to match the remote mount directory but was not.");
				exit(26);
			}
			until($directory_found)
			{
				$directory_in_use = 0;
				if ($j)
				{
					$use_directory = "${remote_mount}-$j";
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - use_directory: [$use_directory]");
				}
				my $shell_call = "$conf->{path}{ls} -A $use_directory";
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
				my ($error, $ssh_fh, $return) = remote_call($conf, {
					remote		=>	$remote,
					port		=>	22,
					user		=>	$remote_user,
					password	=>	$remote_password,
					ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
					'close'		=>	0,
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					next if not $line;
					next if $directory_in_use;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
					if ($line =~ /No such file or directory/i)
					{
						# We're good, create the directory.
						logger($conf, $THIS_FILE, __LINE__, "Remote mount point: [$use_directory] doesn't exist, creating it.");
						my $shell_call = "
$conf->{path}{mkdir} $use_directory;
if [ -e '$use_directory' ];
then 
    echo created; 
else 
    echo failed; 
fi";
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
						my ($error, $ssh_fh, $return) = remote_call($conf, {
							remote		=>	$remote,
							port		=>	22,
							user		=>	$remote_user,
							password	=>	$remote_password,
							ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
							'close'		=>	0,
							shell_call	=>	$shell_call,
						});
						foreach my $line (@{$return})
						{
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
							if ($line =~ /cannot create directory/)
							{
								logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to create the directory: [$use_directory].");
								logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Does the user: [$remote_user] have sufficient rights on the remote machine: [$remote] to create this directory?");
								exit(19);
							}
							elsif ($line eq "failed")
							{
								# <sad trombone />
								logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Unknown error trying to create the directory: [$use_directory] on the remote machine: [$remote] as the user: [$remote_user]");
								exit(13);
							}
							elsif ($line eq "created")
							{
								logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Directory created");
								$directory_found = 1;
							}
						}
					}
					else
					{
						# Directory exists and I got output, so
						# something is in it.
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Found data in: [$use_directory], skipping it.");
						$directory_in_use = 1;
					}
				}
				if (not $directory_in_use)
				{
					# This directory is empty, we can use it.
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - No data in: [$use_directory], using it.");
					$directory_found = 1;
				}
				$j++;
				if ($j > 5)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Loop detected trying to find a mount point on the remote machine.");
					exit(12);
				}
			}
			$remote_mount = $use_directory;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
			
			# If I am still alive, I can mount.
			if ($remote_user eq "root")
			{
				$remote_known_hosts = "/root/.ssh/known_hosts";
			}
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - local_host: [$local_host], local_user: [$local_user], local_password: [$local_password], remote_known_hosts: [$remote_known_hosts]");
			
			# Make sure the remote machine's user has us in their
			# known_hosts file.
			logger($conf, $THIS_FILE, __LINE__, "Ready to mount local: [$local_mount] on remote: [$remote] at: [$remote_mount].");
			$shell_call = "
if [ ! -e '$remote_known_hosts' ] || ! \$($conf->{path}{grep} -q $local_host $remote_known_hosts)
then
    ssh-keyscan $local_host >> $remote_known_hosts
    echo 'RSA key added'
else
    echo 'RSA key exists'
fi";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
			my ($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /getaddrinfo (.*?): Name or service not known/)
				{
					my $name = $1;
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Asked the remote machine: [$remote] to connect to this machine using the name or IP: [$name].");
					logger($conf, $THIS_FILE, __LINE__, "[ Error ]   If this is a host name, can the remote machine resolve it to an IP?");
					logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Perhaps the remote machine's '/etc/hosts' file needs to be updated?");
					unmount($conf, $device);
					exit(20);
				}
			}
			
			# Try the mount
			$shell_call  = "$conf->{path}{echo} $local_password | $conf->{path}{sshfs} -o password_stdin -o idmap=user -o sshfs_sync -o no_readahead $local_user\@$local_host:$local_mount $remote_mount";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
			($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /sshfs: command not found/)
				{
					# Make this stand out in syslog
					logger($conf, $THIS_FILE, __LINE__, "ERROR: ========================================================================");
					logger($conf, $THIS_FILE, __LINE__, "ERROR: Remote machine: [$remote] does not have 'sshfs' installed.");
					logger($conf, $THIS_FILE, __LINE__, "ERROR: Unable to mount this USB device on the target node.");
					logger($conf, $THIS_FILE, __LINE__, "ERROR: ========================================================================");
					unmount($conf, $device);
					exit(7);
				}
				elsif ($line =~ /fuse: failed to exec fusermount: Permission denied/)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Calling: [$shell_call] on the remote machine returned a 'permission denied' error.");
					logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Is the remote user: [$remote_user] user in the 'fuse' group?");
					logger($conf, $THIS_FILE, __LINE__, "[ Error ]   If not, please run: [usermod -a -G fuse $remote_user] on the remote server and try again.");
					logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Unable to proceed.");
					unmount($conf, $device);
					exit(8);
				}
				elsif ($line =~ /Timeout waiting for prompt/i)
				{
					logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call] on the remote machine returned a timed out. Unable to proceed.");
					unmount($conf, $device);
					exit(18);
				}
			}
			
			# Now call the .post_mount script, if it exists.
			$shell_call = "
if [ -x '/home/$remote_user/.post_mount' ]
then
	/home/$remote_user/.post_mount 
fi
";
			if ($remote_user eq "root")
			{
				$shell_call = "
if [ -x '/$remote_user/.post_mount' ]
then
	/$remote_user/.post_mount 
fi
";
			}
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
			($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			}
		}
	}
	
	return(0);
}

# Unmount the specified device.
sub unmount
{
	my ($conf, $device) = @_;
	
	my $mount_point = get_mount_point($conf, $device);
	if ($mount_point)
	{
		logger($conf, $THIS_FILE, __LINE__, "device: [$device] is mounted on: [$mount_point]. Unmounting.");
		my $shell_call = "$conf->{path}{umount} $device";
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call] Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
		}
		close $file_handle;
		$mount_point = get_mount_point($conf, $device);
		if ($mount_point)
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to unmount: [$device] from: [$mount_point]");
			exit(1);
		}
		logger($conf, $THIS_FILE, __LINE__, "Device: [$device] unmounted successfully.");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "device: [$device] is not mounted.");
	}
	
	return(0);
}

sub get_mount_point
{
	my ($conf, $device) = @_;
	
	my $mount_point = "";
	my $shell_call = "$conf->{path}{mount}";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, $THIS_FILE, __LINE__, "line: [$line]");
		if ($line =~ /^$device on (.*?) /)
		{
			$mount_point = $1;
			#logger($conf, $THIS_FILE, __LINE__, "mount_point: [$mount_point]");
		}
	}
	close $file_handle;
	
	return($mount_point);
}

# Find any filesystems on a given device
sub find_file_systems
{
	my ($conf, $device, $byte_size) = @_;
	my @filesystems;
	
	# First thing, call 'parted' and see if there is a label
	my $shell_call = "$conf->{path}{parted} -s $device print free";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		# If there is a partition already on the device, I will need to know
		# later if I need to encrypt the drive.
		if ($line =~ /unrecognised disk label/)
		{
			# Make a label, gpt if > 2 TiB
			my $shell_call = "$conf->{path}{parted} -s $device mklabel msdos";
			if ($byte_size > 2199023255552)
			{
				$shell_call = "$conf->{path}{parted} -s $device mklabel gpt";
			}
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			}
			close $file_handle;
			
			$shell_call = "$conf->{path}{partprobe} $device";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			}
			close $file_handle;
		}
	}
	close $file_handle;
	
	# Now if there are no partitions, create one.
	my $new_device = "${device}1";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check if: [$new_device] exists.");
	if (not -e "$new_device")
	{
		# Create the partition
		my $shell_call = "$conf->{path}{parted} -s -a opt $device mkpart primary 0% 100%";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		close $file_handle;
		
		$shell_call = "$conf->{path}{partprobe} $device";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		close $file_handle;
		
		# Now format, with LUKS if a passphrase has been set.
		if ($conf->{'remote-usb'}{luks}{passphrase})
		{
			logger($conf, $THIS_FILE, __LINE__, "LUKS initialization required on: [$new_device].");
			($device) = format_device_luks($conf, "$new_device");
			logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
		}
		else
		{
			my ($fs, $uuid, $label) = format_device($conf, "$new_device");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
		}
		
		# Get the info on the new device
		call_blkid($conf, $new_device);
	}
	else
	{
		$shell_call = "$conf->{path}{ls} ${device}*";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			# If there is a partition already on the device, I will need to know
			# later if I need to encrypt the drive.
			if ($line =~ /^$device\d+/)
			{
				$conf->{sys}{partition_seen} = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sys::partition_seen: [$conf->{sys}{partition_seen}]");
			}
			
			# Now see if I can find out more about the drive/partition
			if (($line eq $device) or ($line =~ /^$device\d+/))
			{
				call_blkid($conf, $line);
			}
			
		}
		close $file_handle;
	}
	
	return(0);
}

# For a given device, see if there is a filesystem
sub call_blkid
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - call_blkid; device: [$device].");
	
	my $uuid  = "";
	my $fs    = "";
	my $label = "";
	my $shell_call = "$conf->{path}{blkid} -c /dev/null $device";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - uuid: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - label: [$label]");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs]");
	if ($fs)
	{
		$conf->{devices}{$device}{fs}    = $fs;
		$conf->{devices}{$device}{uuid}  = $uuid;
		$conf->{devices}{$device}{label} = $label;
		$conf->{devices}{$device}{path}  = $device;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device] has no file system.");
		$conf->{devices}{$device}{fs}    = "";
		$conf->{devices}{$device}{uuid}  = "";
		$conf->{devices}{$device}{label} = "";
		$conf->{devices}{$device}{path}  = "";
	}
	
	return(0);
}

# This looks for USB devices plugged into the dashboard
sub find_usb_devices
{
	my ($conf) = @_;
	
	my $device     = "";
	my $shell_call = "$conf->{path}{lsusb} -v";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if (not $line)
		{
			$device = "";
			next;
		}
		if (not $device)
		{
			if ($line =~ /^Bus (\d+) .* hub$/)
			{
				$device = "hub";
				#logger($conf, $THIS_FILE, __LINE__, "device: [$device]");
			}
			else
			{
				(my $bus, my $device_id, my $vendor, my $product, $device) = ($line =~ /Bus (\d+) Device (\d+): ID (\w\w\w\w):(\w\w\w\w) (.*)$/);
				#logger($conf, $THIS_FILE, __LINE__, "device: [$device], bus: [$bus], device_id: [$device_id]");
				$conf->{device}{$device} = {
					bus			=>	$bus,
					device_id		=>	$device_id,
					vendor			=>	$vendor,
					say_vendor		=>	"",
					product			=>	$product,
					say_product		=>	"",
					id_product		=>	"",
					manufacturer		=>	"",
					serial			=>	"",
					interface_class		=>	"",
				};
			}
		}
		if (($device) && ($device ne "hub"))
		{
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line =~ /idVendor\s+0x\w\w\w\w (.*)$/)
			{
				$conf->{device}{$device}{say_vendor} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- Vendor: ............ [$conf->{device}{$device}{say_vendor}]");
			}
			if ($line =~ /idProduct\s+0x\w\w\w\w (.*)$/)
			{
				$conf->{device}{$device}{id_product} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- ID Product: ........ [$conf->{device}{$device}{id_product}]");
			}
			if ($line =~ /iManufacturer\s+\d+ (.*)$/)
			{
				$conf->{device}{$device}{manufacturer} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- Manufacturer: ...... [$conf->{device}{$device}{manufacturer}]");
			}
			if ($line =~ /iProduct\s+\d+ (.*)$/)
			{
				$conf->{device}{$device}{say_product} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- Product: ........... [$conf->{device}{$device}{say_product}]");
			}
			if ($line =~ /iSerial\s+\d+ (.*)$/)
			{
				$conf->{device}{$device}{serial} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- Serial: ............ [$conf->{device}{$device}{serial}]");
			}
			if ($line =~ /bInterfaceClass\s+\d+ (.*)$/)
			{
				$conf->{device}{$device}{interface_class} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- Interface Class: ... [$conf->{device}{$device}{interface_class}]");
			}
			if ($line =~ /bInterfaceSubClass\s+\d+ (.*)$/)
			{
				$conf->{device}{$device}{interface_subclass} = $1;
				#logger($conf, $THIS_FILE, __LINE__, "- Interface Sub-Class: [$conf->{device}{$device}{interface_subclass}]");
			}
		}
	}
	close $file_handle;
	
	foreach my $device (sort {$a cmp $b} keys %{$conf->{device}})
	{
		next if $conf->{device}{$device}{interface_class}    ne "Mass Storage";
		next if $conf->{device}{$device}{interface_subclass} ne "SCSI";
		
		# Skip flash readers
		next if $device =~ /Flash Reader/;
		
		my $id = "$conf->{device}{$device}{bus}:$conf->{device}{$device}{device_id}";
		logger($conf, $THIS_FILE, __LINE__, "Device: [$id - $device]");
		logger($conf, $THIS_FILE, __LINE__, "- Bus: ..,............ [$conf->{device}{$device}{bus}]");
		logger($conf, $THIS_FILE, __LINE__, "- Device ID: ..,...... [$conf->{device}{$device}{device_id}]");
		logger($conf, $THIS_FILE, __LINE__, "- Vendor: ............ [0x$conf->{device}{$device}{vendor} ($conf->{device}{$device}{say_vendor})]");
		logger($conf, $THIS_FILE, __LINE__, "- ID Product: ........ [$conf->{device}{$device}{id_product}]");
		logger($conf, $THIS_FILE, __LINE__, "- Manufacturer: ...... [$conf->{device}{$device}{manufacturer}]");
		logger($conf, $THIS_FILE, __LINE__, "- Product: ........... [0x$conf->{device}{$device}{product} ($conf->{device}{$device}{say_product})]");
		logger($conf, $THIS_FILE, __LINE__, "- Serial: ............ [$conf->{device}{$device}{serial}]");
		logger($conf, $THIS_FILE, __LINE__, "- Interface Class: ... [$conf->{device}{$device}{interface_class}]");
		logger($conf, $THIS_FILE, __LINE__, "- Interface Sub-Class: [$conf->{device}{$device}{interface_subclass}]");
	}
	
	return(0);
}
