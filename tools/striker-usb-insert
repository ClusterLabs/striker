#!/usr/bin/perl
#
# Install:
# - Copy:
#   - rsync -av /var/www/tools/striker-usb.conf root@10.20.4.1:/etc/striker/ && rsync -av /var/www/tools/striker-usb.lib root@10.20.4.1:/sbin/ && rsync -av /var/www/tools/striker-usb-* root@10.20.4.1:/sbin/
# 
# Create:
# - /etc/udev/rules/99-striker-usb.rules
#   - Containing:
=pod
# This triggers the insert and eject scripts to mount and unmount USB drives on
# remote servers when a USB storage device is plugged into a managed port.

ACTION=="add", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker-usb-insert"

ACTION=="remove", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker-usb-remove"
=cut
# 
# Exit codes:
# 0  = Normal exit.
# 1  = Failed to unmount a device.
# 2  = Failed to create the local mount point.
# 3  = Local mount point is in use.
# 4  = Local mount point is a file.
# 5  = Unable to find a free mount point on the remote system.
# 6  = Unable to create the remote mount point
# 7  = Remote machine does not have 'sshfs' installed.
# 8  = sshfs call to ourselves failed.
# 9  = The remote user does not have permission to create the remote mount point.
# 10 = No mountable device found.
# 11 = The file system on the device can not be mounted locally.
# 12 = Loop detected trying to find a mount point on the remote machine.
# 13 = Unknown error trying to create a directory on the remote machine.
# 14 = Asked to format an device that didn't look like a proper block device path.
# 15 = Tried to format device as LUKS, but reported post-format FS was not 'crypto_LUKS'.
# 16 = Failed to decrypt LUKS-encrypted device.
# 17 = blkid called against the LUKS decrypted dm device didn't return the UUID and/or fs type.
# 18 = Attempt to mount the local mount on the remote machine using sshfs timed out.
# 

use strict;
use warnings;
require "/sbin/striker-usb.lib";

my $THIS_FILE = "striker-usb-insert";
my $conf = inititialize_configuration();

logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert Script started.");
read_configuration($conf);
read_syslog($conf);
parse_syslog($conf);
logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert Script finished.");

exit(0);

# Parse syslog and decide what, if anything, to do.
sub parse_syslog
{
	my ($conf) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parse_syslog().");
	
	my $this_usb        = "";
	my $is_mass_storage = 0;
	my $block_device    = "";
	my $rule_found      = 0;
	foreach my $line (@{$conf->{syslog}})
	{
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line].");
		if ($line =~ /kernel: usb (.*?): New USB device found/)
		{
			$this_usb = $1;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb].");
		}
		if ($line =~ /Uniform CD-ROM driver/)
		{
			$block_device = 1;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - block_device: [$block_device].");
			last;
		}
		next if not $this_usb;
		$line =~ s/^.*?kernel: //;
		if ($line =~ /SCSI emulation for USB Mass Storage devices/)
		{
			$is_mass_storage = 1;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - is_mass_storage: [$is_mass_storage].");
		}
		next if not $is_mass_storage;
		if ($line =~ /sd(\w+): sd(\w+)\d/)
		{
			my $lhs = $1;
			my $rhs = $2;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - lhs: [$lhs], rhs: [$rhs]");
			next if (($lhs) && ($lhs ne $rhs));
			$block_device = "sd".$lhs;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - block_device: [$block_device].");
		}
		next if not $block_device;
		last;
	}
	if ($block_device)
	{
		$conf->{this_usb} = $this_usb;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - USB device: [$this_usb], block device: [$block_device]");
		foreach my $usb (sort {$a cmp $b} keys %{$conf->{usb}})
		{
			if (exists $conf->{usb}{$this_usb})
			{
				$rule_found   = 1;
				my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
				my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
				my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
				my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
				my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
				my $device       = "/dev/".$block_device;
				#logger($conf, $THIS_FILE, __LINE__, "I will mount filesystems on: [$device] locally as: [$local_mount] and remotely on: [$user\@$host] as: [$remote_mount]");
				last;
			}
		}
		if (not $rule_found)
		{
			logger($conf, $THIS_FILE, __LINE__, "The inserted block device is not using a managed USB port.");
		}
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "The inserted device is not a block device.");
		exit(0);
	}

	if ($rule_found)
	{
		my $this_usb     = $conf->{this_usb};
		my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
		my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
		my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
		my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
		my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
		my $device       = "/dev/".$block_device;
		logger($conf, $THIS_FILE, __LINE__, "I will mount the partition on: [$device] locally as: [$local_mount] and remotely on: [$user\@$host] as: [$remote_mount]");
		
		find_file_systems($conf, $device);
		mount_filesystems($conf);
	}
}

# This tries to read the UUIS of a LUKS encypted device then checks to see if
# we have a passphrase for the UUID. If so, it tries to decrypt the device. If
# that works, it returns the new DM device path. If it fails, it returns an
# empty string.
sub decrypt_luks
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - decrypt_luks(); device: [$device].");
	
	# Try to decrypt the passed device using the passphrase in the config file.
	my $device_name = ($device =~ /^.*\/(.*?)$/)[0];
	my $dm_path     = "/dev/mapper/$device_name";
	my $temp_file   = "/tmp/".time;
	my $fs          = "";
	my $uuid        = "";
	my $label       = "";
	my $shell_call  = "
$conf->{path}{echo} '$conf->{luks}{passphrase}' > $temp_file
$conf->{path}{cryptsetup} luksOpen $device $device_name --key-file $temp_file
unlink $temp_file
if [ -e '$dm_path' ]
then
    $conf->{path}{blkid} -p $dm_path
else
    echo 'dm path: '$dm_path' not found'
fi
";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /dm path: .* not found/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to decrypt: [$device], unable to proceed.");
			exit(16);
		}
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s UUID is: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s filesystem type is: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s filesystem label is: [$label]");
		}
	}
	close $file_handle;
	
	if (($fs) && ($uuid))
	{
		# If I am still alive, record the new details.
		$device = $dm_path;
		$conf->{devices}{$device}{fs}    = $fs;
		$conf->{devices}{$device}{uuid}  = $uuid;
		$conf->{devices}{$device}{label} = $label;
		$conf->{devices}{$device}{path}  = $device;
		logger($conf, $THIS_FILE, __LINE__, "Decryption was successful!");
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "The decrypted device: [$dm_path] doesn't appear to have a file system on it. The UUID and/or filesystem Type were not read.");
		if ($conf->{luks}{force_initialize})
		{
			logger($conf, $THIS_FILE, __LINE__, "The 'luks::force_initialize' option is set, formatting it now.");
			my ($fs, $uuid, $label) = format_device($conf, $dm_path);
			$device = $dm_path;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
			$conf->{devices}{$device}{fs}    = $fs;
			$conf->{devices}{$device}{uuid}  = $uuid;
			$conf->{devices}{$device}{label} = $label;
			$conf->{devices}{$device}{path}  = $dm_path;
			logger($conf, $THIS_FILE, __LINE__, "Decryption was successful!");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "The 'luks::force_initialize' option is not set, so will not format. Unable to proceed.");
			exit(17);
		}
	}
	
	return($device);
}

# This will forcibly reformat the passed device as a LUKS partition with the
# passphrase set in the config file.
sub format_device_luks
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "Device: [$device].");
	
	# If I wasn't passed a proper device, die die die!
	if ($device !~ /\/dev\/sd(\w+\d+)/)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] I was asked to format: [$device] as a LUKS partition, but it appears to be an invalid device. Unable to proceed.");
		exit(14);
	}
	
	my $device_name = ($device =~ /^.*\/(.*?)$/)[0];
	my $dm_path     = "/dev/mapper/$device_name";
	my $temp_file   = "/tmp/".time;
	my $shell_call  = "
$conf->{path}{echo} '$conf->{luks}{passphrase}' > $temp_file
$conf->{path}{echo} YES | $conf->{path}{cryptsetup} luksFormat $device $temp_file
";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cryptsetup output: [$line]");
	}
	close $file_handle;
	
	# Now check to be sure the partition is now LUKS
	$shell_call = "$conf->{path}{blkid} -c /dev/null $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /^$device: .* TYPE="(.*?)"/)
		{
			my $fs = $1;
			if ($fs eq "crypto_LUKS")
			{
				logger($conf, $THIS_FILE, __LINE__, "Successfully formatted: [$device] as a LUKS partition, unlocking it now.");
				my $shell_call = "
$conf->{path}{cryptsetup} luksOpen $device $device_name --key-file $temp_file
unlink $temp_file
if [ -e '$dm_path' ]
then
    echo 'unlocked successfully'
else
    echo 'unlock failed, dm path: [$dm_path] not found'
fi
";
				logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
				while (<$file_handle>)
				{
					chomp;
					my $line = $_;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
					if ($line =~ /dm path: .* not found/)
					{
						logger($conf, $THIS_FILE, __LINE__, "Failed to decrypt: [$device], unable to proceed.");
						exit(16);
					}
					elsif ($line =~ /unlockes successfully/)
					{
						logger($conf, $THIS_FILE, __LINE__, "Unlocked successfully, device mapper path is: [$dm_path].");
					}
				}
				close $file_handle;
				
				my ($fs, $uuid, $label) = format_device($conf, $dm_path);
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
				
				if ($fs)
				{
					# If I am still alive, record the new details.
					$device = $dm_path;
					$conf->{devices}{$device}{fs}    = $fs;
					$conf->{devices}{$device}{uuid}  = $uuid;
					$conf->{devices}{$device}{label} = $label;
					$conf->{devices}{$device}{path}  = $device;
					logger($conf, $THIS_FILE, __LINE__, "Format was successful!");
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}] and the label: [$conf->{devices}{$device}{label}].");
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "Format appears to have failed. The new file system type and/or UUID were not read.");
					exit(17);
				}
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] Failed to format: [$device] as a LUKS partition. The post-format filesystem is reported as: [$fs], 'crypto_LUKS' expected. Unable to proceed.");
				exit(15);
			}
		}
	}
	close $file_handle;
	
	return($dm_path);
}

# This does the work of formatting a device.
sub format_device
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - format_device(); device: [$device]");
	
	my $mkfs_call = "$conf->{path}{mkfs} -t $conf->{luks}{use_filesystem} $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - luks::use_filesystem: [$conf->{luks}{use_filesystem}], luks::fs_label: [$conf->{luks}{fs_label}]");
	if ($conf->{luks}{fs_label})
	{
		$mkfs_call = "$conf->{path}{mkfs} -t $conf->{luks}{use_filesystem} -L '$conf->{luks}{fs_label}' $device";
	}
	my $fs    = "";
	my $uuid  = "";
	my $label = "";
	logger($conf, $THIS_FILE, __LINE__, "Will now format the device: [$device] as: [$conf->{luks}{use_filesystem}]");
	my $shell_call = "
echo 'formatting $device now'
$mkfs_call
sync
echo 'formatted, checking with blkid'
$conf->{path}{blkid} -p $device
";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		# Don't print the progress, it just creates a mess in the logs.
		if ($line =~ /Writing inode tables/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [Writing inode tables: <progress messages supressed>]");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		if ($line =~ /formatting .* now/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Formatting: [$device]. Please wait, this might take a few minutes...");
		}
		if ($line =~ /formatted/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Format appears to be complete, checking with 'blkid' now.");
		}
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem's UUID: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem type is: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem label is: [$fs]");
		}
	}
	close $file_handle;
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
	return($fs, $uuid, $label);
}

# This mounts the file system locally and then connects to the remote machine
# and uses sshfs to mount our just-mounted FS.
sub mount_filesystems
{
	my ($conf) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mount_filesystems()");
	
	### TODO: If I can't make a directory, make an alternative.
	### TODO: Make the failure to mount one partition not block further
	###       partitions.
	my $i = 0;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{devices}})
	{
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Device: [$device].");
		my $this_usb        = $conf->{this_usb};
		my $remote          = $conf->{usb}{$this_usb}{sshfs}{host};
		my $remote_user     = $conf->{usb}{$this_usb}{sshfs}{user};
		my $remote_password = $conf->{usb}{$this_usb}{sshfs}{password};
		my $local_mount     = $conf->{usb}{$this_usb}{local_mount};
		my $remote_mount    = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
		if ($conf->{devices}{$device}{label})
		{
			$remote_mount .= "-$conf->{devices}{$device}{label}";
		}
		if ($i)
		{
			$local_mount  .= "-$i";
			$remote_mount .= "-$i";
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - i: [$i], device: [$device], this_usb: [$this_usb], remote: [$remote], remote_user: [$remote_user], remote_password: [$remote_password], local_mount: [$local_mount], remote_mount: [$remote_mount]");
		
		# Check for unmountable stuff.
		my $mountable = 0;
		if ($conf->{devices}{$device}{fs} eq "crypto_LUKS")
		{
			# We need to get the device's UUID and, if there is an
			# entry in the config file, decrypt it and modify the
			# $device variable with the new dm path.
			logger($conf, $THIS_FILE, __LINE__, "Device: [$device] is a LUKS encypted device. Checking if I have the passphrase.");
			($device) = decrypt_luks($conf, $device);
			logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
			$mountable = 1;
			
			# If there was a label on the decrypted FS, update the
			# mount directory name.
			if ($conf->{devices}{$device}{label})
			{
				# A label was set, update the mount name.
				$remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
				if ($conf->{devices}{$device}{label})
				{
					$remote_mount = "$conf->{usb}{$this_usb}{sshfs}{remote_mount}-$conf->{devices}{$device}{label}";
				}
				if ($i)
				{
					$remote_mount .= "-$i";
				}
			}
		}
		else
		{
			# Start by making sure it is unmounted
			logger($conf, $THIS_FILE, __LINE__, "We're about to start, but we're going to sleep for 10 seconds to give other processes time to mount the partitions.");
			sleep 10;
			logger($conf, $THIS_FILE, __LINE__, "Done waiting; Now checking if: [$device ($conf->{devices}{$device}{fs})] is already mounted or not.");
			unmount($conf, $device);
			
			# If the user has requested 'luks::force_initialize', 
			# then we're going to have to format this partition.
			if ($conf->{luks}{force_initialize})
			{
				# Before we format, see if the user has set a
				# protected label and, if so, if this FS is
				# protected.
				my $proceed = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - About to format, but checking first for a protected label: [$conf->{luks}{protected_label}] that matches the partition's label: [$conf->{devices}{$device}{label}].");
				if (($conf->{luks}{protected_label}) && ($conf->{devices}{$device}{label}))
				{
					# They have and there is a label, see 
					# if they match.
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Label found on file system, seeing if it is protected.");
					my $wildcard = 0;
					my $string   = $conf->{luks}{protected_label};
					my $label    = $conf->{devices}{$device}{label};
					if ($conf->{luks}{protected_label} =~ /^(.*?)\*/)
					{
						$string   = $1;
						$wildcard = 1;
					}
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - label: [$label], string: [$string], wildcard: [$wildcard]");
					if ($wildcard)
					{
						if ($label =~ /^($string).*/)
						{
							$proceed = 0;
							logger($conf, $THIS_FILE, __LINE__, "File system label: [$label] is protected.");
						}
						else
						{
							logger($conf, $THIS_FILE, __LINE__, "Unprotected label, will proceed with format.");
						}
					}
					elsif ($label eq $string)
					{
						$proceed = 0;
						logger($conf, $THIS_FILE, __LINE__, "File system label: [$label] is protected.");
					}
					else
					{
						logger($conf, $THIS_FILE, __LINE__, "Unprotected label, will proceed with format.");
					}
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - No protected label set or no label found on the partition, proceeding.");
				}
				# Format. This will return the new device
				# mapper path for the decrypted device. If
				# anything goes wrong, it will exit, so we
				# don't need to sanity check the returned
				# device.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - proceed: [$proceed].");
				if ($proceed)
				{
					logger($conf, $THIS_FILE, __LINE__, "LUKS initialization required on: [$device].");
					($device) = format_device_luks($conf, $device);
					logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
					
					# If the formatted FS has a label, and
					# the old FS didn't, we'll want to 
					# append the label to the mount point 
					# now.
					if ($conf->{devices}{$device}{label})
					{
						# A label was set, update the mount name.
						$remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
						if ($conf->{devices}{$device}{label})
						{
							$remote_mount = "$conf->{usb}{$this_usb}{sshfs}{remote_mount}-$conf->{devices}{$device}{label}";
						}
						if ($i)
						{
							$remote_mount .= "-$i";
						}
					}
				}
				$mountable = 1;
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "I will try to mount: [$device].");
				$mountable = 1;
			}
		}
		
		if (not $mountable)
		{
			logger($conf, $THIS_FILE, __LINE__, "No mountable devices. Exiting.");
			exit(10);
		}
		
		if (not -e $local_mount)
		{
			make_path($local_mount, {
				mode	=>	0777,
			});
			if (not -e $local_mount)
			{
				logger($conf, $THIS_FILE, __LINE__, "Failed to create the local mount directory: [$local_mount]");
				exit(2);
			}
		}
		elsif (not -d $local_mount)
		{
			logger($conf, $THIS_FILE, __LINE__, "There is a file called: [$local_mount], which is where I wanted to create a mount point. Unable to proceed.");
			exit(3);
		}
		$i++;
		
		# Make sure the mount point is empty.
		local(*DIR);
		opendir(DIR, $local_mount) or die "Failed to open the directory: [$local_mount], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			logger($conf, $THIS_FILE, __LINE__, "Found a file: [$local_mount/$file], the mount point is not empty. Unable to proceed.");
			exit(4);
		}
		
		# Finally, mount the FS.
		my $shell_call = "$conf->{path}{mount} $device $local_mount";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
			if ($line =~ /unknown filesystem type '(.*?)'/)
			{
				my $fs = $1;
				logger($conf, $THIS_FILE, __LINE__, "Inserted device has the file system: [$fs] which this system can not mount. Unable to proceed.");
				exit(11);
			}
		}
		close $file_handle;
		
		# Check that it actually mounted.
		my $mounted    = 0;
		   $shell_call = "$conf->{path}{df} -hP";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "line: [$line].");
			if (($line =~ /^$device /) && ($line =~ /$local_mount$/))
			{
				$mounted = 1;
				logger($conf, $THIS_FILE, __LINE__, " - Mounted.");
			}
		}
		close $file_handle;
		
		if ($mounted)
		{
			logger($conf, $THIS_FILE, __LINE__, "Successfully mounted: [$device] locally on: [$local_mount].");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to mount: [$device] locally on: [$local_mount]. Unable to proceed.");
			exit(9);
		}
		
		# See if the desired mount point is available.
		my $directory_found  = 0;
		my $directory_in_use = 0; 
		my $j                = 0;
		my $use_directory    = $remote_mount;
		until($directory_found)
		{
			$directory_in_use = 0;
			if ($j)
			{
				$use_directory = "${remote_mount}-$j";
			}
			my $shell_call = "ls -A $use_directory";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
			my ($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /No such file or directory/i)
				{
					# We're good, create the directory.
					my $shell_call = "/bin/mkdir $use_directory; if [ -e '$use_directory' ]; then echo created; else echo failed; fi";
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
					my ($error, $ssh_fh, $return) = remote_call($conf, {
						remote		=>	$remote,
						port		=>	22,
						user		=>	$remote_user,
						password	=>	$remote_password,
						ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
						'close'		=>	0,
						shell_call	=>	$shell_call,
					});
					foreach my $line (@{$return})
					{
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
						if ($line eq "failed")
						{
							# WTF?!
							logger($conf, $THIS_FILE, __LINE__, "Unknown error trying to create the directory: [$use_directory] on the remote machine: [$remote] as the user: [$remote_user]");
							exit(13);
						}
						elsif ($line eq "created")
						{
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Directory created");
							$directory_found = 1;
						}
					}
				}
				else
				{
					# Directory exists and I got output, so
					# something is in it.
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Found data in: [$use_directory], skipping it.");
					$directory_in_use = 1;
				}
			}
			if (not $directory_in_use)
			{
				# This directory is empty, we can use it.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - No data in: [$use_directory], using it.");
				$directory_found = 1;
			}
			$j++;
			if ($j > 5)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Loop detected trying to find a mount point on the remote machine.");
				exit(12);
			}
		}
		$remote_mount = $use_directory;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
		
		# If I am still alive, I can mount.
		my $local_host         = $conf->{'local'}{host};
		my $local_user         = $conf->{'local'}{user};
		my $local_password     = $conf->{'local'}{password};
		my $remote_known_hosts = "/home/$remote_user/.ssh/known_hosts";
		if ($remote_user eq "root")
		{
			$remote_known_hosts = "/root/.ssh/known_hosts";
		}
		
		# Make sure the remote machine's user has us in their
		# known_hosts file.
		logger($conf, $THIS_FILE, __LINE__, "Ready to mount local: [$local_mount] on remote: [$remote] at: [$remote_mount].");
		$shell_call = "
if [ ! -e '$remote_known_hosts' ] || ! \$(grep -q $local_host $remote_known_hosts)
then
    ssh-keyscan $local_host >> $remote_known_hosts
    echo 'RSA key added'
else
    echo 'RSA key exists'
fi";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
		my ($error, $ssh_fh, $return) = remote_call($conf, {
			remote		=>	$remote,
			port		=>	22,
			user		=>	$remote_user,
			password	=>	$remote_password,
			ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		
		# Try the mount
		$shell_call  = "echo $local_password | sshfs -o password_stdin -o idmap=user -o sshfs_sync -o no_readahead $local_user\@$local_host:$local_mount $remote_mount";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
		($error, $ssh_fh, $return) = remote_call($conf, {
			remote		=>	$remote,
			port		=>	22,
			user		=>	$remote_user,
			password	=>	$remote_password,
			ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line =~ /sshfs: command not found/)
			{
				logger($conf, $THIS_FILE, __LINE__, "Remote machine: [$remote] does not have 'sshfs' installed. Unable to proceed.");
				unmount($conf, $device);
				exit(7);
			}
			elsif ($line =~ /fuse: failed to exec fusermount: Permission denied/)
			{
				logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call] on the remote machine returned a 'permission denied' error. Please run this manually and resolve any permissions issues. Is the '$remote_user' user in the 'fuse' group? If not, please run: [usermod -a -G fuse $remote_user] on the target server and try again. Unable to proceed.");
				unmount($conf, $device);
				exit(8);
			}
			elsif ($line =~ /Timeout waiting for prompt/i)
			{
				logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call] on the remote machine returned a timed out. Unable to proceed.");
				unmount($conf, $device);
				exit(18);
			}
		}
		
		# Now call the .post_mount script, if it exists.
		$shell_call = "
if [ -x '/home/$remote_user/.post_mount' ]
then
	/home/$remote_user/.post_mount 
fi";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
		($error, $ssh_fh, $return) = remote_call($conf, {
			remote		=>	$remote,
			port		=>	22,
			user		=>	$remote_user,
			password	=>	$remote_password,
			ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
	}
	
	return(0);
}

# Unmount the specified device.
sub unmount
{
	my ($conf, $device) = @_;
	
	my $mount_point = get_mount_point($conf, $device);
	if ($mount_point)
	{
		logger($conf, $THIS_FILE, __LINE__, "device: [$device] is mounted on: [$mount_point]. Unmounting.");
		my $shell_call = "$conf->{path}{umount} $device";
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call] Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
		}
		close $file_handle;
		$mount_point = get_mount_point($conf, $device);
		if ($mount_point)
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to unmount: [$device] from: [$mount_point]");
			exit(1);
		}
		logger($conf, $THIS_FILE, __LINE__, "Device: [$device] unmounted successfully.");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "device: [$device] is not mounted.");
	}
	
	return(0);
}

sub get_mount_point
{
	my ($conf, $device) = @_;
	
	my $mount_point = "";
	my $shell_call = "$conf->{path}{mount}";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, $THIS_FILE, __LINE__, "line: [$line]");
		if ($line =~ /^$device on (.*?) /)
		{
			$mount_point = $1;
			#logger($conf, $THIS_FILE, __LINE__, "mount_point: [$mount_point]");
		}
	}
	close $file_handle;
	
	return($mount_point);
}

sub find_file_systems
{
	my ($conf, $device) = @_;
	my @filesystems;
	
	my $shell_call = "$conf->{path}{ls} ${device}*";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		# If there is a partition already on the device, I will need to know
		# later if I need to encrypt the drive.
		if ($line =~ /^$device\d+/)
		{
			$conf->{sys}{partition_seen} = 1;
		}
		# Now see if I can find out more about the drive/partition
		if (($line eq $device) or ($line =~ /^$device\d+/))
		{
			call_blkid($conf, $line);
		}
	}
	close $file_handle;
		
	return(0);
}

sub call_blkid
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - call_blkid; device: [$device].");
	
	my $uuid  = "";
	my $fs    = "";
	my $label = "";
	my $shell_call = "$conf->{path}{blkid} -c /dev/null $device";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
		}
	}
	close $file_handle;
	
	if ($fs)
	{
		$conf->{devices}{$device}{fs}    = $fs;
		$conf->{devices}{$device}{uuid}  = $uuid;
		$conf->{devices}{$device}{label} = $label;
		$conf->{devices}{$device}{path}  = $device;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device] has no file system.");
	}
	
	return(0);
}
