#!/usr/bin/perl
#
# This program looks in the Striker configuration file:
# [/etc/striker/striker.conf] for managed USB ports. An example of how to
# configure a USB port to be managed are shown there.
# 
# Create:
# - /etc/udev/rules/99-striker-usb.rules
#   - Containing:
#------------------------------------------------------------------------------
# # This triggers the insert and eject scripts to mount and unmount USB drives on
# # remote servers when a USB storage device is plugged into a managed port.
# 
# ACTION=="add", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker/striker-usb-insert"
# 
# ACTION=="remove", KERNEL=="sd*[!0-9]", RUN+="/sbin/striker/striker-usb-remove"
#------------------------------------------------------------------------------
# 
# Exit codes:
# 0  = Normal exit.
# 1  = Failed to unmount a device.
# 2  = Failed to create the local mount point.
# 3  = Local mount point is in use.
# 4  = NOTE: No longer fatal, just a warning - Local mount point is a file.
# 5  = Unable to find a free mount point on the remote system.
# 6  = Unable to create the remote mount point
# 7  = Remote machine does not have 'nfs-utils' installed.
# 8  = 
# 9  = The remote user does not have permission to create the remote mount point.
# 10 = No mountable device found.
# 11 = The file system on the device can not be mounted locally.
# 12 = Loop detected trying to find a mount point on the remote machine.
# 13 = Unknown error trying to create a directory on the remote machine.
# 14 = Asked to format an device that didn't look like a proper block device path.
# 15 = Tried to format device as LUKS, but no luksUUID was found.
# 16 = Failed to decrypt LUKS-encrypted device.
# 17 = blkid called against the LUKS decrypted dm device didn't return the UUID and/or fs type.
# 18 = Attempt to mount the local mount on the remote machine using sshfs timed out.
# 19 = Permission denied error on the remote machine when trying to create the remote mount point.
# 20 = The remote machine failed to connect to this machine. Probably used a host name that didn't resolve to
#      an IP address.
# 21 = Failed to enable in striker.conf
# 22 = Failed to disable in striker.conf
# 23 = Asked to mount a device remotely but the USB address wasn't set.
# 24 = Asked to mount a device remotely but the remote mount point wasn't set.
# 25 = Failed to unmount a non-LUKS partition that needed to be reformatted LUKS.
# 26 = The 'use_directory' variable in the mount_filesystems() function was not set.
# 27 = Failed to find the local short host name.
# 28 = The USB drive has the protected file '.protected' and, as such, won't be reformatted and encrypted.
# 29 = Failed to unmount the device from the specified temporary mount point.
# 
# TODO:
# - Verify that 'remote-usb::local::host' IP is accurate and/or use the subnet to find the actual local IP
# - Add the short host name to the remote mount directory (ie: remote_an-striker01_4-6)
# - Add the Striker host name and USB address (and/or make/model) to the 'formatting' /tmp file, like:
#   /tmp/.<short_host>_<usb_port>_formatting
# 

use strict;
use warnings;
require "/sbin/striker/striker-usb.lib";

my $THIS_FILE = "striker-usb-insert";
my $conf = inititialize_configuration();
read_configuration($conf);

# See if the user is enabling, disabling or forcing this run.
get_switches($conf);
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}))
{
	print_usage($conf);
	exit(0);
}
elsif ($conf->{switches}{enable})
{
	logger($conf, $THIS_FILE, __LINE__, "Enabling remote mount on USB insert.");
	my $exit = 0;
	my $ok   = update_configuration($conf, "enable");
	if ($ok)
	{
		print "Striker USB tool has been enabled successfully.\n";
	}
	else
	{
		$exit = 21;
	}
	exit($exit);
}
elsif ($conf->{switches}{disable})
{
	logger($conf, $THIS_FILE, __LINE__, "Disabling remote mount on USB insert.");
	my $exit = 0;
	my $ok   = update_configuration($conf, "disable");
	if ($ok)
	{
		print "Striker USB tool has been disabled successfully.\n";
	}
	else
	{
		$exit = 22;
	}
	exit($exit);
}
elsif ($conf->{switches}{force})
{
	logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert script running with '--force', ignoring $conf->{path}{striker_config} setting.", 0);
}
elsif (not $conf->{'remote-usb'}{enable_remote_usb_mount})
{
	logger($conf, $THIS_FILE, __LINE__, "- Striker USB Insert has been disabled, exiting.");
	exit(0);
}

logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert Script started.");

check_sd_devices($conf);

logger($conf, $THIS_FILE, __LINE__, "Striker USB Insert Script finished.");

exit(0);

# This calls udevadm against all found /dev/sdX devices to find the ones that are using USB
sub check_sd_devices
{
	my ($conf) = @_;
	
	my $shell_call = "$conf->{path}{ls} /dev/sd*";
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $device        = $_;
		next if $device   =~ /\d$/;
		my $active_device =  ($device =~ /.*\/(.*)?/)[0];
		logger($conf, $THIS_FILE, __LINE__, "*** [ Debug ] - device: [$device], active_device: [$active_device] ***");
		
		my $this_device  = "";
		my $this_usb     = "";
		my $block_device = ($device =~ /\/dev\/(sd.*)/)[0];
		my $removable    = 0;
		my $size         = 0;
		my $read_only    = 0;
		
		my $shell_call  = "$conf->{path}{udevadm} info --attribute-walk --name $device";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line =~ /looking at parent device '(.*?)'/)
			{
				$this_device = $1;
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_device: [$this_device].");
				if ((not $this_usb) && ($this_device =~ /usb\d+\/(\d+-\d+)\//))
				{
					$this_usb = $1;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb] parsed from: [$this_device].");
				}
				next;
			}
			if ($line =~ /ATTR\{removable\}=="(\d+)"/)
			{
				$removable = $1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - removable: [$removable].");
			}
			if ($line =~ /ATTR\{size\}=="(\d+)"/)
			{
				$size = $1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - size: [$size].");
			}
			if ($line =~ /ATTR\{ro\}=="(\d+)"/)
			{
				$read_only = $1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - read_only: [$read_only].");
			}
		}
		close $file_handle;
		
		my $sector_size = get_sector_size($conf, $block_device);
		my $size_gib    = 0;
		my $size_gb     = 0;
		my $byte_size   = ($sector_size * $size);
		if ($block_device)
		{
			$size_gib = sprintf("%.2f", ($byte_size / (2 ** 30)));
			$size_gb  = sprintf("%.2f", ($byte_size / (10 ** 9)));
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb], block_device: [$block_device ($device)].");
		
		# If I've got a USB address, use it to set 'this_usb'. If this is also a root device, record
		# the USB address for this device.
		if ($this_usb)
		{
			$conf->{this_usb} = $this_usb;
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ::this_usb: [$conf->{this_usb}].");
			if ($device !~ /\d$/)
			{
				$conf->{root_usb}{$device} = $this_usb;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - root_usb::$device: [$conf->{root_usb}{$device}].");
			}
		}
		
		# Now, if this is not a root device and no USB address was found, see if we have the address 
		# from the parent.
		if ((not $this_usb) && ($device =~ /\d$/))
		{
			my $parent = ($device =~ /^(.*)\d+$/)[0];
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parent: [$parent].");
			if ($conf->{root_usb}{$device})
			{
				$this_usb = $conf->{root_usb}{$device};
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - this_usb: [$this_usb], root_usb::$device: [$conf->{root_usb}{$device}].");
			}
		}
		
		logger($conf, $THIS_FILE, __LINE__, "remote-usb::remote::host: [$conf->{'remote-usb'}{remote}{host}], remote-usb::remote::user: [$conf->{'remote-usb'}{remote}{user}], remote-usb::remote::password: [$conf->{'remote-usb'}{remote}{password}], remote-usb::remote::mount: [$conf->{'remote-usb'}{remote}{mount}], remote-usb::local::mount: [$conf->{'remote-usb'}{'local'}{mount}], this_usb: [$this_usb]");
		my $host         = $conf->{'remote-usb'}{remote}{host};
		my $user         = $conf->{'remote-usb'}{remote}{user};
		my $password     = $conf->{'remote-usb'}{remote}{password};
		my $remote_mount = $conf->{'remote-usb'}{remote}{mount}."_$conf->{sys}{short_hostname}_$this_usb";
		my $local_mount  = $conf->{'remote-usb'}{'local'}{mount}."_$this_usb";
		logger($conf, $THIS_FILE, __LINE__, "host: [$host], user: [$user], password: [$password], remote_mount: [$remote_mount], local_mount: [$local_mount]");
		
		my $yn = ["No", "Yes"];
		logger($conf, $THIS_FILE, __LINE__, "This device: [$device] is: [$size_gib GiB ($size_gb GB)]; Removable? [".$yn->[$removable]."], Read only? [".$yn->[$read_only]."], USB Address: [$this_usb]");
		if (not $this_usb)
		{
			logger($conf, $THIS_FILE, __LINE__, "- The device: [$device] is not a USB device, skipping.");
		}
		elsif ($read_only)
		{
			logger($conf, $THIS_FILE, __LINE__, "- The device: [$device] is read-only, skipping it.");
		}
		elsif (not $size)
		{
			logger($conf, $THIS_FILE, __LINE__, "- The device: [$device] has no size (likely a removable device with no media), skipping it.");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "- Looking for file systems on: [$device]");
			find_file_systems($conf, $device, $byte_size);
			logger($conf, $THIS_FILE, __LINE__, "- Mounting discovered filesystems, if needed.");
			mount_filesystems($conf, $active_device);
		}
		$conf->{this_usb} = $this_usb;
	}
	close $file_handle;
	
	return(0);
}

# This reads '/sys/block/${block_device}/queue/hw_sector_size' to get the sector size.
sub get_sector_size
{
	my ($conf, $block_device) = @_;
	#logger($conf, $THIS_FILE, __LINE__, "get_sector_size(); block_device: [$block_device]");
	
	# Return 0 if the sysfs file doesn't exist;
	return(0) if not -e "/sys/block/${block_device}/queue/hw_sector_size";
	
	my $sector_size = 0;
	my $shell_call  = "/sys/block/${block_device}/queue/hw_sector_size";
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "<$shell_call") or die "Failed to read: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		$sector_size = $_;
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sector_size: [$sector_size].");
	}
	close $file_handle;
	
	#logger($conf, $THIS_FILE, __LINE__, "sector_size: [$sector_size]");
	return($sector_size);
}

# This tries to read the UUIS of a LUKS encypted device then checks to see if
# we have a passphrase for the UUID. If so, it tries to decrypt the device. If
# that works, it returns the new DM device path. If it fails, it returns an
# empty string.
sub decrypt_luks
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - decrypt_luks(); device: [$device].");
	
	# Try to decrypt the passed device using the passphrase in the config file.
	my $decypted    = 1;
	my $device_name = ($device =~ /^.*\/(.*?)$/)[0];
	my $dm_path     = "/dev/mapper/$device_name";
	my $temp_file   = "/tmp/".time;
	my $fs          = "";
	my $uuid        = "";
	my $label       = "";
	my $shell_call  = "
if [ -e '$dm_path' ];
then
    echo 'already decrypted'
    $conf->{path}{blkid} -p $dm_path
else
    $conf->{path}{echo} '$conf->{'remote-usb'}{luks}{passphrase}' > $temp_file
    $conf->{path}{cryptsetup} luksOpen $device $device_name --key-file $temp_file
    unlink $temp_file
    if [ -e '$dm_path' ]
    then
        $conf->{path}{blkid} -p $dm_path
    else
        echo 'dm path: '$dm_path' not found'
    fi;
fi;";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line eq "already decrypted")
		{
			logger($conf, $THIS_FILE, __LINE__, "The device: [$device] appears to be decrypted already.");
			$decypted = 0;
		}
		if ($line =~ /dm path: .* not found/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to decrypt: [$device], unable to proceed.");
			exit(16);
		}
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s UUID is: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s filesystem type is: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$dm_path]'s filesystem label is: [$label]");
		}
	}
	close $file_handle;
	
	if (($fs) && ($uuid))
	{
		# If I am still alive, record the new details.
		$device = $dm_path;
		$conf->{devices}{$device}{fs}    = $fs;
		$conf->{devices}{$device}{uuid}  = $uuid;
		$conf->{devices}{$device}{label} = $label;
		$conf->{devices}{$device}{path}  = $device;
		if ($decypted)
		{
			logger($conf, $THIS_FILE, __LINE__, "Decryption was successful!");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "Previously decrypted device appears accessible.");
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "The decrypted device: [$dm_path] doesn't appear to have a file system on it. The UUID and/or filesystem Type were not read.");
		if ($conf->{'remote-usb'}{luks}{force_initialize})
		{
			logger($conf, $THIS_FILE, __LINE__, "The 'remote-usb::luks::force_initialize' option is set, formatting it now.");
			my ($fs, $uuid, $label) = format_device($conf, $dm_path);
			$device = $dm_path;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
			$conf->{devices}{$device}{fs}    = $fs;
			$conf->{devices}{$device}{uuid}  = $uuid;
			$conf->{devices}{$device}{label} = $label;
			$conf->{devices}{$device}{path}  = $dm_path;
			logger($conf, $THIS_FILE, __LINE__, "Decryption was successful!");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "The 'luks::force_initialize' option is not set, so will not format. Unable to proceed.");
			exit(17);
		}
	}
	
	return($device);
}

# This will forcibly reformat the passed device as a LUKS partition with the
# passphrase set in the config file.
sub format_device_luks
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "Device: [$device].");
	
	# If I wasn't passed a proper device, die die die!
	if ($device !~ /\/dev\/sd(\w+\d+)/)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Error ] I was asked to format: [$device] as a LUKS partition, but it appears to be an invalid device. Unable to proceed.");
		exit(14);
	}
	
	# Delete all existing partitions and create a single one using all the space on the disk.
	my $device_name = ($device =~ /^.*\/(.*?)$/)[0];
	my $dm_path     = "/dev/mapper/$device_name";
	my $temp_file   = "/tmp/".time;
	my $shell_call  = "
$conf->{path}{echo} '$conf->{'remote-usb'}{luks}{passphrase}' > $temp_file
$conf->{path}{echo} YES | $conf->{path}{cryptsetup} luksFormat $device $temp_file
";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - cryptsetup output: [$line]");
	}
	close $file_handle;
	
	# Now check to be sure the partition is now LUKS
	$shell_call = "$conf->{path}{cryptsetup} luksUUID $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /not a valid LUKS device/)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] Failed to format: [$device] as a LUKS partition. No 'luksUUID' was found. Unable to proceed.");
			exit(15);
		}
		else
		{
			my $luksuuid = $line;
			logger($conf, $THIS_FILE, __LINE__, "Successfully formatted: [$device] as a LUKS partition with UUID: [$luksuuid], unlocking it now.");
			my $shell_call = "
$conf->{path}{cryptsetup} luksOpen $device $device_name --key-file $temp_file
unlink $temp_file
if [ -e '$dm_path' ]
then
    echo 'unlocked successfully'
else
    echo 'unlock failed, dm path: [$dm_path] not found'
fi
";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /dm path: .* not found/)
				{
					logger($conf, $THIS_FILE, __LINE__, "Failed to decrypt: [$device], unable to proceed.");
					exit(16);
				}
				elsif ($line =~ /unlockes successfully/)
				{
					logger($conf, $THIS_FILE, __LINE__, "Unlocked successfully, device mapper path is: [$dm_path].");
				}
			}
			close $file_handle;
			
			my ($fs, $uuid, $label) = format_device($conf, $dm_path);
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
			
			if ($fs)
			{
				# If I am still alive, record the new details.
				$device = $dm_path;
				$conf->{devices}{$device}{fs}    = $fs;
				$conf->{devices}{$device}{uuid}  = $uuid;
				$conf->{devices}{$device}{label} = $label;
				$conf->{devices}{$device}{path}  = $device;
				logger($conf, $THIS_FILE, __LINE__, "Format was successful!");
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}] and the label: [$conf->{devices}{$device}{label}].");
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "Format appears to have failed. The new file system type and/or UUID were not read.");
				exit(17);
			}
		}
	}
	close $file_handle;
	
	return($dm_path);
}

# This does the work of formatting a device.
sub format_device
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - format_device(); device: [$device]");
	
	# Touch the 'formatting' file on the target so they know to be patient.
	$conf->{path}{format_running} = "$conf->{path}{format_running}_$conf->{sys}{short_hostname}_$conf->{this_usb}";
	my $remote          = $conf->{'remote-usb'}{remote}{host};
	my $remote_user     = $conf->{'remote-usb'}{remote}{user};
	my $remote_password = $conf->{'remote-usb'}{remote}{password};
	my $shell_call      = "$conf->{path}{touch} $conf->{path}{format_running};";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	my ($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$remote,
		port		=>	22,
		user		=>	$remote_user,
		password	=>	$remote_password,
		ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	foreach my $line (@{$return})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
	}
	
	# Put together our format call
	my $mkfs_call = "$conf->{path}{mkfs} -O ^has_journal -t $conf->{'remote-usb'}{luks}{use_filesystem} $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote-usb::luks::use_filesystem: [$conf->{'remote-usb'}{luks}{use_filesystem}], remote-usb::luks::fs_label: [$conf->{'remote-usb'}{luks}{fs_label}]");
	if ($conf->{'remote-usb'}{luks}{fs_label})
	{
		$mkfs_call = "$conf->{path}{mkfs} -O ^has_journal -t $conf->{'remote-usb'}{luks}{use_filesystem} -L '$conf->{'remote-usb'}{luks}{fs_label}' $device";
	}
	my $fs    = "";
	my $uuid  = "";
	my $label = "";
	logger($conf, $THIS_FILE, __LINE__, "Will now format the device: [$device] as: [$conf->{'remote-usb'}{luks}{use_filesystem}]");
	$shell_call = "
echo 'formatting $device now'
$conf->{path}{touch} $conf->{path}{format_running}; 
$mkfs_call
sync
echo 'formatted, checking with blkid'
$conf->{path}{blkid} -p $device
$conf->{path}{rm} -f $conf->{path}{format_running}
";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		# Don't print the progress, it just creates a mess in the logs.
		if ($line =~ /Writing inode tables/i)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [Writing inode tables: <progress messages supressed>]");
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		if ($line =~ /formatting .* now/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Formatting: [$device]. Please wait, this might take a few minutes...");
		}
		if ($line =~ /formatted/)
		{
			logger($conf, $THIS_FILE, __LINE__, "Format appears to be complete, checking with 'blkid' now.");
		}
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem's UUID: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem type is: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - new filesystem label is: [$fs]");
		}
	}
	close $file_handle;
	
	# Now remove the 'formatting' file on the target
	$shell_call = "$conf->{path}{rm} -f $conf->{path}{format_running};";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	($error, $ssh_fh, $return) = remote_call($conf, {
		remote		=>	$remote,
		port		=>	22,
		user		=>	$remote_user,
		password	=>	$remote_password,
		ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
		'close'		=>	0,
		shell_call	=>	$shell_call,
	});
	foreach my $line (@{$return})
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
	}
	
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
	return($fs, $uuid, $label);
}

# This checks for a .protected file on the USB drive and exits if it is found.
sub check_if_protected
{
	my ($conf, $device) = @_;
	
	my $mounted     = 0;
	my $mount_point = get_mount_point($conf, $device);
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mount_point: [$mount_point]");
	if (not $mount_point)
	{
		# Mount it for a moment.
		$mounted     = 1;
		$mount_point = "/tmp/anvil.".time;
		mkdir $mount_point or die "Failed to create the temporary mount point: [$mount_point], the error was: $!\n";
		
		my $shell_call  = "$conf->{path}{mount} $device $mount_point";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line =~ /unknown filesystem type '(.*?)'/)
			{
				my $fs = $1;
				logger($conf, $THIS_FILE, __LINE__, "Inserted device has the file system: [$fs] which this system can not mount. Unable to proceed.");
				unlink $mount_point or die "Failed to remove the temporary mount point: [$mount_point], the error was: $!\n";
				exit(11);
			}
		}
		close $file_handle;
	}
	my $protected_file = $mount_point."/.protected";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - protected_file: [$protected_file]");
	if (-e $protected_file)
	{
		logger($conf, $THIS_FILE, __LINE__, "The device: [$device] has a protection file: [.protected], so this drive will NOT be reformatted or used.");
		
		# Clean up the temporary mount, if needed.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mounted: [$mounted]");
		if ($mounted)
		{
			my $shell_call  = "
$conf->{path}{umount} $device
if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
then 
    echo 'failed to unmount the device: [$device] from the temporary mount point: [$mount_point]'
fi
";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /failed/)
				{
					logger($conf, $THIS_FILE, __LINE__, "$line\n");
					exit(29);
				}
			}
			close $file_handle;
			rmdir $mount_point or die "Failed to remove the temporary mount point: [$mount_point], the error was: $!\n";
			logger($conf, $THIS_FILE, __LINE__, "Cleaned up temporary mount point: [$mount_point], exiting.");
		}
		exit(28);
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "The device: [$device] does NOT have a: [.protected] file.");
	}
	
	return(0);
}

# This mounts the file system locally and then connects to the remote machine and uses nfs to mount our just-mounted FS.
sub mount_filesystems
{
	my ($conf, $active_device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mount_filesystems(); active_device: [$active_device]");
	
	### TODO: If I can't make a directory, make an alternative.
	### TODO: Make the failure to mount one partition not block further partitions.
	my $i = 0;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{devices}})
	{
		next if $device !~ /\d$/;
		next if $device !~ /$active_device/;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Device: [$device].");
		
		# Check the remote mount
		my $shell_call = "
if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
then
    echo 'already mounted'; 
else 
    echo 'not mounted';
fi";

		# If this is a USB device (be very sure!), and if force_initialize is set, and if this is not
		# and LUKS FS, and if this is not a device-mapped device, dismount and reformat.
		my $parent = ($device =~ /^(.*)\d+$/)[0];
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parent: [$parent], device: [$device]");
		if ((not $parent) && ($device =~ /mapper/))
		{
			$parent =  $device;
			$parent =~ s/\/mapper//;
			$parent =  ($device =~ /^(.*)\d+$/)[0];
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parent: [$parent]");
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - root_usb::$parent: [$conf->{root_usb}{$parent}], remote-usb::luks::force_initialize: [$conf->{'remote-usb'}{luks}{force_initialize}], device: [$device]");
		if (($conf->{root_usb}{$parent}) && ($conf->{'remote-usb'}{luks}{force_initialize}) && ($device !~ /\/mapper/))
		{
			# If this isn't a LUKS FS, unmount it.
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - devices::${device}::fs: [$conf->{devices}{$device}{fs}]");
			if ($conf->{devices}{$device}{fs} =~ /LUKS/i)
			{
				# This is a LUKS partition already, so skip it entirely.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - This is a LUKS partition, skipping it.");
				$shell_call = "";
			}
			else
			{
				# Not encypted, but should be. Before we reformat it though, see if there is
				# a '.protected' file. If there is a .protected file, it will exit.
				check_if_protected($conf, $device);
				$shell_call = "
if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
then
    echo \"Mounted, but not LUKS encrypted and 'remote-usb::luks::force_initialize' is set, unmounting to prepare to format\"; 
    $conf->{path}{umount} $device
    if $conf->{path}{mount} | $conf->{path}{grep} -q $device; 
    then 
        echo 'failed to unmount device before LUKS format.'
    else
        echo 'unmounted for LUKS format successfully.'
    fi
else 
    echo 'not mounted';
fi";
			}
		}
		
		# Now call which-ever shell call is needed.
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call].");
		if ($shell_call)
		{
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line]");
				if ($line eq "already mounted")
				{
					logger($conf, $THIS_FILE, __LINE__, "The device: [$device] is already mounted, skipping it.");
					$conf->{skip}{$device} = 1;
				}
				if ($line =~ /failed to unmount/)
				{
					# Error out.
					logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The device: [$device], which was mounted but not LUKS encrypted and force_initialize is set, failed to unmount. Format not possible.");
					exit(25);
				}
			}
			close $file_handle;
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote-usb::remote::host: [$conf->{'remote-usb'}{remote}{host}], remote-usb::remote::user: [$conf->{'remote-usb'}{remote}{user}], remote-usb::remote::password: [$conf->{'remote-usb'}{remote}{password}], remote-usb::remote::mount: [$conf->{'remote-usb'}{remote}{mount}], remote-usb::local::mount: [$conf->{'remote-usb'}{'local'}{mount}], ::this_usb: [$conf->{this_usb}]");
		my $this_usb        = $conf->{this_usb};
		my $remote          = $conf->{'remote-usb'}{remote}{host};
		my $remote_user     = $conf->{'remote-usb'}{remote}{user};
		my $remote_password = $conf->{'remote-usb'}{remote}{password};
		my $remote_mount    = $conf->{'remote-usb'}{remote}{mount}."_$conf->{sys}{short_hostname}_$this_usb";
		my $local_mount     = $conf->{'remote-usb'}{'local'}{mount}."_$this_usb";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote: [$remote], remote_user: [$remote_user], remote_password: [$remote_password], remote_mount: [$remote_mount], local_mount: [$local_mount]");
		
		# If, for some reason, the USB address or remote mount variables are blank, exit.
		if (not $this_usb)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - I was asked to mount: [$device], but no USB address was set.");
			exit(23);
		}
		if (not $remote_mount)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - I was asked to mount: [$device], but a remote mount point wasn't set.");
			exit(24);
		}
		
		if ($conf->{devices}{$device}{label})
		{
			$remote_mount .= "_$conf->{devices}{$device}{label}";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]", 0);
		}
		if ($i)
		{
			$local_mount  .= "_$i";
			$remote_mount .= "_$i";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount], local_mount: [$local_mount]", 0);
		}
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - i: [$i], device: [$device], this_usb: [$this_usb], remote: [$remote], remote_user: [$remote_user], remote_password: [$remote_password], local_mount: [$local_mount], remote_mount: [$remote_mount]");
		
		# Check for unmountable stuff.
		my $mountable = 0;
		if ($conf->{devices}{$device}{fs} eq "crypto_LUKS")
		{
			# We need to get the device's UUID and, if there is an entry in the config file, 
			# decrypt it and modify the $device variable with the new dm path.
			logger($conf, $THIS_FILE, __LINE__, "Device: [$device] is a LUKS encypted device. Checking if I have the passphrase.");
			($device) = decrypt_luks($conf, $device);
			logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
			$mountable = 1;
			
			# If there was a label on the decrypted FS, update the mount directory name.
			if ($conf->{devices}{$device}{label})
			{
				# A label was set, update the mount name.
				$remote_mount .= "_$conf->{devices}{$device}{label}";
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount], i: [$i]");
				if ($i)
				{
					$remote_mount .= "_$i";
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
				}
			}
		}
		else
		{
			# Start by making sure it is unmounted
			logger($conf, $THIS_FILE, __LINE__, "We're about to start, but we're going to sleep for 5 seconds to give other processes time to mount the partitions.");
			sleep 5;
			logger($conf, $THIS_FILE, __LINE__, "Done waiting; Now checking if: [$device ($conf->{devices}{$device}{fs})] is already mounted or not.");
			unmount($conf, $device);
			
			# If the user has requested 'luks::force_initialize', 
			# then we're going to have to format this partition.
			if (($conf->{'remote-usb'}{luks}{force_initialize}) && ($device !~ /\/mapper/))
			{
				# Before we format, see if the user has set a protected label and, if so, if
				# this FS is protected.
				my $proceed = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - About to format, but checking first for a protected label: [$conf->{'remote-usb'}{luks}{protected_label}] that matches the partition's label: [$conf->{devices}{$device}{label}].");
				if (($conf->{'remote-usb'}{luks}{protected_label}) && ($conf->{devices}{$device}{label}))
				{
					# They have and there is a label, see 
					# if they match.
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Label found on file system, seeing if it is protected.");
					my $wildcard = 0;
					my $string   = $conf->{'remote-usb'}{luks}{protected_label};
					my $label    = $conf->{devices}{$device}{label};
					if ($conf->{'remote-usb'}{luks}{protected_label} =~ /^(.*?)\*/)
					{
						$string   = $1;
						$wildcard = 1;
					}
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - label: [$label], string: [$string], wildcard: [$wildcard]");
					if ($wildcard)
					{
						if ($label =~ /^($string).*/)
						{
							$proceed = 0;
							logger($conf, $THIS_FILE, __LINE__, "File system label: [$label] is protected.");
						}
						else
						{
							logger($conf, $THIS_FILE, __LINE__, "Unprotected label, will proceed with format.");
						}
					}
					elsif ($label eq $string)
					{
						$proceed = 0;
						logger($conf, $THIS_FILE, __LINE__, "File system label: [$label] is protected.");
					}
					else
					{
						logger($conf, $THIS_FILE, __LINE__, "Unprotected label, will proceed with format.");
					}
				}
				else
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - No protected label set or no label found on the partition, proceeding.");
				}
				# Format. This will return the new device mapper path for the decrypted
				# device. If anything goes wrong, it will exit, so we don't need to sanity 
				# check the returned device.
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - proceed: [$proceed].");
				if ($proceed)
				{
					# Remove the old FS label from the remote mount name.
					$conf->{'remote-usb'}{remote}{mount} =~ s/_$conf->{devices}{$device}{label}//;
					
					logger($conf, $THIS_FILE, __LINE__, "LUKS initialization required on: [$device].");
					($device) = format_device_luks($conf, $device);
					logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
					
					# If the formatted FS has a label, and the old FS didn't, we'll want
					# to append the label to the mount point now.
					if ($conf->{devices}{$device}{label})
					{
						# A label was set, update the mount name.
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
						if ($conf->{devices}{$device}{label})
						{
							$remote_mount .= "_$conf->{devices}{$device}{label}";
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
						}
						if ($i)
						{
							$remote_mount .= "_$i";
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
						}
					}
				}
				$mountable = 1;
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "I will try to mount: [$device].");
				$mountable = 1;
			}
		}
		
		if (not $mountable)
		{
			logger($conf, $THIS_FILE, __LINE__, "No mountable devices. Exiting.");
			exit(10);
		}
		
		# See if the device is already mounted locally.
		my $already_mounted = 0;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device], local_mount: [$local_mount]");
		$shell_call = "
mount
if $conf->{path}{mount} | $conf->{path}{grep} -q '$device on $local_mount';
then 
    echo 'already mounted';
else 
    echo 'mount needed';
fi;";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
			if ($line eq "already mounted")
			{
				logger($conf, $THIS_FILE, __LINE__, "The device: [$device] is already mounted on: [$local_mount].");
				$already_mounted = 1;
			}
		}
		close $file_handle;
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - already_mounted: [$already_mounted].");
		if (not $already_mounted)
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - local_mount: [$local_mount].");
			if (not -e $local_mount)
			{
				make_path($local_mount, {
					mode	=>	0777,
				});
				if (not -e $local_mount)
				{
					logger($conf, $THIS_FILE, __LINE__, "Failed to create the local mount directory: [$local_mount]");
					exit(2);
				}
			}
			elsif (not -d $local_mount)
			{
				logger($conf, $THIS_FILE, __LINE__, "There is a file called: [$local_mount], which is where I wanted to create a mount point. Unable to proceed.");
				exit(3);
			}
			$i++;
			
			# Make sure the mount point is empty.
			local(*DIR);
			opendir(DIR, $local_mount) or die "Failed to open the directory: [$local_mount], error was: $!\n";
			while (my $file = readdir(DIR))
			{
				# Changed by client request because of issues with rapid insert/ejects.
				next if (($file eq ".") or ($file eq ".."));
				logger($conf, $THIS_FILE, __LINE__, "[ Warning] - Found a file: [$local_mount/$file], the mount point is not empty.");
				logger($conf, $THIS_FILE, __LINE__, "[ Warning]   Proceeding with mount, but any existing mount or data will be hidden.");
			}
			
			# Finally, mount the FS.
			### TODO: Make mount options a user-configured variable.
			$shell_call = "$conf->{path}{mount} -o sync $device $local_mount";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
				if ($line =~ /unknown filesystem type '(.*?)'/)
				{
					my $fs = $1;
					logger($conf, $THIS_FILE, __LINE__, "Inserted device has the file system: [$fs] which this system can not mount. Unable to proceed.");
					exit(11);
				}
			}
			close $file_handle;
			
			# Check that it actually mounted.
			my $mounted    = 0;
			   $shell_call = "$conf->{path}{df} -hP";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				logger($conf, $THIS_FILE, __LINE__, "line: [$line].");
				if (($line =~ /^$device /) && ($line =~ /$local_mount$/))
				{
					$mounted = 1;
					logger($conf, $THIS_FILE, __LINE__, " - Mounted.");
				}
			}
			close $file_handle;
			
			if ($mounted)
			{
				logger($conf, $THIS_FILE, __LINE__, "Successfully mounted: [$device] locally on: [$local_mount].");
				
				# Make sure NFS is running and start it if not.
				logger($conf, $THIS_FILE, __LINE__, "Verifying that NFS is running.");
				my $start_nfs  = 0;
				my $shell_call = $conf->{path}{initd_nfs}." status; echo rc:\$?";
				logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
				while (<$file_handle>)
				{
					chomp;
					my $line = $_;
					logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
					if ($line =~ /rc:(\d+)/)
					{
						my $return_code = $1;
						if ($return_code eq "0")
						{
							# It's not running.
							$start_nfs = 1;
							logger($conf, $THIS_FILE, __LINE__, "NFS is NOT running, it will be started now.");
						}
						elsif ($return_code eq "3")
						{
							logger($conf, $THIS_FILE, __LINE__, "NFS is running, no further action needed.");
						}
						else
						{
							logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - NFS is in an unknown state (return code was: [$return_code], expected 0 or 3). We will attempt to proceed, but errors are likely.");
						}
					}
				}
				close $file_handle;
				
				if ($start_nfs)
				{
					# We need to start it.
					my $shell_call = $conf->{path}{initd_nfs}." start; echo rc:\$?";
					logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
					open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
					while (<$file_handle>)
					{
						chomp;
						my $line = $_;
						logger($conf, $THIS_FILE, __LINE__, "mount: [$line]");
						if ($line =~ /rc:(\d+)/)
						{
							my $return_code = $1;
							if ($return_code eq "0")
							{
								# Started!
								logger($conf, $THIS_FILE, __LINE__, "NFS has been started.");
							}
							else
							{
								# Uh oh...
								logger($conf, $THIS_FILE, __LINE__, "[ Warning ] - Starting NFS returned an unknown state (return code was: [$return_code], expected 0). We will attempt to proceed, but errors are likely.");
							}
						}
					}
					close $file_handle;
				}
				
				# Now export the mount.
				logger($conf, $THIS_FILE, __LINE__, "Exporting: [$local_mount] to the host: [$remote].");
				$shell_call = $conf->{path}{exportfs}." ".$conf->{'remote-usb'}{'local'}{export_options}." $remote:$local_mount";
				logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call].");
				open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
				while (<$file_handle>)
				{
					chomp;
					my $line = $_;
					logger($conf, $THIS_FILE, __LINE__, "export: [$line]");
					### TODO: Parse the output and handle errors.
				}
				close $file_handle;
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "Failed to mount: [$device] locally on: [$local_mount]. Unable to proceed.");
				exit(9);
			}
		}
		
		# See if this device is already mounted on the remote node.
		my $local_host         = $conf->{'remote-usb'}{'local'}{host};
		my $local_user         = $conf->{'remote-usb'}{'local'}{user};
		my $local_password     = $conf->{'remote-usb'}{'local'}{password};
		my $remote_known_hosts = "/home/$remote_user/.ssh/known_hosts";
		if ($remote_user eq "root")
		{
			$remote_known_hosts = "/$remote_user/.ssh/known_hosts";
		}
		my $mount_needed       = 1;
		   $shell_call         = "
if mount | grep -q '$local_host:$local_mount';
then 
    echo 'already mounted'; 
else 
    echo 'mount needed'; 
fi;";
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
		my ($error, $ssh_fh, $return) = remote_call($conf, {
			remote		=>	$remote,
			port		=>	22,
			user		=>	$remote_user,
			password	=>	$remote_password,
			ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			if ($line eq "already mounted")
			{
				logger($conf, $THIS_FILE, __LINE__, "Our local mount: [$local_host:$local_mount] is already mounted on the remote machine.");
				$mount_needed = 0;
			}
		}
		
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - mount_needed: [$mount_needed]");
		if ($mount_needed)
		{
			# See if the desired *remote* mount point is available.
			my $directory_found  = 0;
			my $directory_in_use = 0; 
			my $j                = 0;
			my $use_directory    = $remote_mount;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - use_directory: [$use_directory]");
			if (not $use_directory)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The 'use_directory' variable should have been set to match the remote mount directory but was not.");
				exit(26);
			}
			until($directory_found)
			{
				$directory_in_use = 0;
				if ($j)
				{
					$use_directory = "${remote_mount}-$j";
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - use_directory: [$use_directory]");
				}
				my $shell_call = "$conf->{path}{ls} -A $use_directory";
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
				my ($error, $ssh_fh, $return) = remote_call($conf, {
					remote		=>	$remote,
					port		=>	22,
					user		=>	$remote_user,
					password	=>	$remote_password,
					ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
					'close'		=>	0,
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					next if not $line;
					next if $directory_in_use;
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
					if ($line =~ /No such file or directory/i)
					{
						# We're good, create the directory.
						logger($conf, $THIS_FILE, __LINE__, "Remote mount point: [$use_directory] doesn't exist, creating it.");
						my $shell_call = "
$conf->{path}{mkdir} $use_directory;
if [ -e '$use_directory' ];
then 
    echo created; 
else 
    echo failed; 
fi";
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
						my ($error, $ssh_fh, $return) = remote_call($conf, {
							remote		=>	$remote,
							port		=>	22,
							user		=>	$remote_user,
							password	=>	$remote_password,
							ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
							'close'		=>	0,
							shell_call	=>	$shell_call,
						});
						foreach my $line (@{$return})
						{
							logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
							if ($line =~ /cannot create directory/)
							{
								logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to create the directory: [$use_directory].");
								logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Does the user: [$remote_user] have sufficient rights on the remote machine: [$remote] to create this directory?");
								exit(19);
							}
							elsif ($line eq "failed")
							{
								# <sad trombone />
								logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Unknown error trying to create the directory: [$use_directory] on the remote machine: [$remote] as the user: [$remote_user]");
								exit(13);
							}
							elsif ($line eq "created")
							{
								logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Directory created");
								$directory_found = 1;
							}
						}
					}
					else
					{
						# Directory exists and I got output, so
						# something is in it.
						logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Found data in: [$use_directory], skipping it.");
						$directory_in_use = 1;
					}
				}
				if (not $directory_in_use)
				{
					# This directory is empty, we can use it.
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - No data in: [$use_directory], using it.");
					$directory_found = 1;
				}
				$j++;
				if ($j > 5)
				{
					logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Loop detected trying to find a mount point on the remote machine.");
					exit(12);
				}
			}
			$remote_mount = $use_directory;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote_mount: [$remote_mount]");
			
			# If I am still alive, I can mount.
			if ($remote_user eq "root")
			{
				$remote_known_hosts = "/root/.ssh/known_hosts";
			}
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - local_host: [$local_host], local_user: [$local_user], local_password: [$local_password], remote_known_hosts: [$remote_known_hosts]");
			
			# Try the mount
			#              mount                   -t nfs                                         <dashboard_ifn_ip_addr>:/mnt/<USB drive mount point> <local mount point>
			$shell_call = $conf->{path}{mount}." ".$conf->{'remote-usb'}{remote}{mount_options}." ".$conf->{'remote-usb'}{'local'}{host}.":$local_mount $remote_mount";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
			($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /missing codepage or helper program, or other error/)
				{
					print "[ Error ] - It appears that the NFS client is not installed on: [$remote]\n";
					print "[ Error ]   Please install: [nfs-utils] and reinsert the USB drive again.\n";
					print "[ Error ]   Unable to proceed.\n";
					exit(7);
				}
			}
			
			# Verify that it mounted
			$shell_call = "df -hP";
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
			($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
				if ($line =~ /$remote_mount/)
				{
					print "[ Success ] - The USB drive is now mounted on: [$remote] at: [$remote_mount]\n";
				}
			}
			
			# Now call the .post_mount script, if it exists.
			$shell_call = "
if [ -x '/home/$remote_user/.post_mount' ]
then
	/home/$remote_user/.post_mount 
fi
";
			if ($remote_user eq "root")
			{
				$shell_call = "
if [ -x '/$remote_user/.post_mount' ]
then
	/$remote_user/.post_mount 
fi
";
			}
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Remote: [$remote_user\@$remote], shell_call: [$shell_call].");
			($error, $ssh_fh, $return) = remote_call($conf, {
				remote		=>	$remote,
				port		=>	22,
				user		=>	$remote_user,
				password	=>	$remote_password,
				ssh_fh		=>	$conf->{node}{$remote}{ssh_fh},
				'close'		=>	0,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			}
		}
	}
	
	return(0);
}

# Unmount the specified device.
sub unmount
{
	my ($conf, $device) = @_;
	
	my $mount_point = get_mount_point($conf, $device);
	if ($mount_point)
	{
		logger($conf, $THIS_FILE, __LINE__, "device: [$device] is mounted on: [$mount_point]. Unmounting.");
		my $shell_call = "$conf->{path}{umount} $device";
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call] Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
		}
		close $file_handle;
		$mount_point = get_mount_point($conf, $device);
		if ($mount_point)
		{
			logger($conf, $THIS_FILE, __LINE__, "Failed to unmount: [$device] from: [$mount_point]");
			exit(1);
		}
		logger($conf, $THIS_FILE, __LINE__, "Device: [$device] unmounted successfully.");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "device: [$device] is not mounted.");
	}
	
	return(0);
}

sub get_mount_point
{
	my ($conf, $device) = @_;
	
	my $mount_point = "";
	my $shell_call = "$conf->{path}{mount}";
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, $THIS_FILE, __LINE__, "line: [$line]");
		if ($line =~ /^$device on (.*?) /)
		{
			$mount_point = $1;
			#logger($conf, $THIS_FILE, __LINE__, "mount_point: [$mount_point]");
		}
	}
	close $file_handle;
	
	return($mount_point);
}

# Find any filesystems on a given device
sub find_file_systems
{
	my ($conf, $device, $byte_size) = @_;
	my @filesystems;
	
	# First thing, call 'parted' and see if there is a label
	my $shell_call = "$conf->{path}{parted} -s $device print free";
	logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		# If there is a partition already on the device, I will need to know
		# later if I need to encrypt the drive.
		if ($line =~ /unrecognised disk label/)
		{
			# Make a label, gpt if > 2 TiB
			my $shell_call = "$conf->{path}{parted} -s $device mklabel msdos";
			if ($byte_size > 2199023255552)
			{
				$shell_call = "$conf->{path}{parted} -s $device mklabel gpt";
			}
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			}
			close $file_handle;
			
			$shell_call = "$conf->{path}{partprobe} $device";
			logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
			open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
			while (<$file_handle>)
			{
				chomp;
				my $line = $_;
				next if not $line;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			}
			close $file_handle;
		}
	}
	close $file_handle;
	
	# Now if there are no partitions, create one.
	my $new_device = "${device}1";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - check if: [$new_device] exists.");
	if (not -e "$new_device")
	{
		# Create the partition
		my $shell_call = "$conf->{path}{parted} -s -a opt $device mkpart primary 0% 100%";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		close $file_handle;
		
		$shell_call = "$conf->{path}{partprobe} $device";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		}
		close $file_handle;
		
		# Now format, with LUKS if a passphrase has been set.
		if ($conf->{'remote-usb'}{luks}{passphrase})
		{
			logger($conf, $THIS_FILE, __LINE__, "LUKS initialization required on: [$new_device].");
			($device) = format_device_luks($conf, "$new_device");
			logger($conf, $THIS_FILE, __LINE__, "returned device: [$device].");
		}
		else
		{
			my ($fs, $uuid, $label) = format_device($conf, "$new_device");
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs], uuid: [$uuid], label: [$label]");
		}
		
		# Get the info on the new device
		call_blkid($conf, $new_device);
	}
	else
	{
		$shell_call = "$conf->{path}{ls} ${device}*";
		logger($conf, $THIS_FILE, __LINE__, "Calling: [$shell_call]");
		open ($file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
		while (<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
			# If there is a partition already on the device, I will need to know
			# later if I need to encrypt the drive.
			if ($line =~ /^$device\d+/)
			{
				$conf->{sys}{partition_seen} = 1;
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - sys::partition_seen: [$conf->{sys}{partition_seen}]");
			}
			
			# Now see if I can find out more about the drive/partition
			if (($line eq $device) or ($line =~ /^$device\d+/))
			{
				call_blkid($conf, $line);
			}
			
		}
		close $file_handle;
	}
	
	return(0);
}

# For a given device, see if there is a filesystem
sub call_blkid
{
	my ($conf, $device) = @_;
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - call_blkid; device: [$device].");
	
	my $uuid  = "";
	my $fs    = "";
	my $label = "";
	my $shell_call = "$conf->{path}{blkid} -c /dev/null $device";
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - shell_call: [$shell_call]");
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call]. Error: $!\n";
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - line: [$line]");
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - uuid: [$uuid]");
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs]");
		}
		if ($line =~ /LABEL="(.*?)"/)
		{
			$label = $1;
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - label: [$label]");
		}
	}
	close $file_handle;
	
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - fs: [$fs]");
	if ($fs)
	{
		$conf->{devices}{$device}{fs}    = $fs;
		$conf->{devices}{$device}{uuid}  = $uuid;
		$conf->{devices}{$device}{label} = $label;
		$conf->{devices}{$device}{path}  = $device;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - device: [$device] has no file system.");
		$conf->{devices}{$device}{fs}    = "";
		$conf->{devices}{$device}{uuid}  = "";
		$conf->{devices}{$device}{label} = "";
		$conf->{devices}{$device}{path}  = "";
	}
	
	return(0);
}
