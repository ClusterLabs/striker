#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - The referenced network interface seen when the user unplugged a network
#      cable did not (properly) record that interfaces MAC address.
# 2  - The referenced network interface seen when the user unplugged a network
#      cable did not (properly) record that interfaces current device name.
# 3  - 
# 4  - 
# 5  - The '$conf->{path}{backups}' value is not set.
# 6  - The '$conf->{path}{backups}' backup directory failed to be created. The
#      failure warning should be displayed immediately prior to this error.
# 7  - backup_file() was called without a specified file to backup.
# 8  - Failed to find the '$conf->{path}{network_configs}' directory. I hope
#      for the user's sake that this is a program problem...
# 9  - There was one or more problems while sanity checking the command line
#      options. The problems will be displayed prior to the exit.
# 10 - No switches passed.
# 11 - Failed to bring up a network interface and network configuration was
#      requested.
# 12 - 
# 13 - 
# 14 - 
# 15 - 
# 16 - 
# 17 - Installer didn't run as 'root'.
# 18 - 
# 19 - Failed to copy a file.
# 20 - 
# 21 - Failed to rsync a file or directory.
# 
# TODO: Create an init script that deletes anything in the media directory on
#       boot. Can't use /tmp as it's usually too small.

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

use strict;
use warnings;

# No capes!^H^H^H^Hbuffers!
$| = 1;

my $conf = {
	executable	=>	{
		cp			=>	"/bin/cp",
		ifup			=>	"/sbin/ifup",
		ip			=>	"/sbin/ip",
		sed			=>	"/bin/sed",
	},
	path		=>	{
		backups			=>	"/root/anvil",
		network_configs		=>	"/etc/sysconfig/network-scripts",
		persistent_net		=>	"/etc/udev/rules.d/70-persistent-net.rules",
	},
	mode		=>	"interactive",
	nics		=>	["bcn-link1", "bcn-link2", "sn-link1", "sn-link2", "ifn-link1", "ifn-link2"],
	network		=>	{
		bcn		=>	{
			ip		=>	"",
			netmask		=>	"",
		},
		sn		=>	{
			ip		=>	"",
			netmask		=>	"",
		},
		ifn		=>	{
			ip		=>	"",
			netmask		=>	"",
			gateway		=>	"",
			dns1		=>	"8.8.8.8",
			dns2		=>	"8.8.4.4",
		},
	},
};

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	print "[ Error ] - I am sorry, but this program must be run as the root user.\n\n";
	exit(17);
}

# Make sure we got what we needed from the command line.
get_switches($conf);
if (not $conf->{sys}{switch_count})
{
	print_usage($conf);
	exit(10);
}
# This sanity-checks the passed in command line switches and returns '1' if
# any problems were found.
if (sanity_check_switches($conf))
{
	exit(9);
}

# Make sure we've got the right paths to executables.
find_executables($conf);

# Make backups, of course.
backup_original_files($conf);

# Make sure all NICs are up. If any aren't, start them.
start_all_nics($conf);

# Go into the loop that asks the user to unplug cables until they are happy 
# with their selection. When it exits, we go to work.
until(select_nics($conf))
{
	sleep 1;
}

# If we're here, the user has OK'ed the changes.
reconfigure_network($conf);

# If the user reconfigured the network, tell them they will need to reboot.
if (not $conf->{sys}{skip_network})
{
	print "\n[ Warning ] - You may need to reboot the network if the network interfances\n";
	print "[ Warning ] - were renamed. Simply restarting the network will likely not\n";
	print "[ Warning ] - work.\n\n";
}
print "Anvil! node network configuration is complete!\n\n";
exit(0);


###############################################################################
# Here be function!                                                           #
###############################################################################

# This copies multiple files using rsync
sub rsync_files
{
	my ($conf, $source, $destination) = @_;
	
	my $shell_call = "$conf->{executable}{rsync} -a $source $destination";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	
	# Verify it copied successfully.
	my $file = ($source =~ /^.*\/(.*)$/)[0];
	   $file = "$destination/$file";
	if (not -e $file)
	{
		print "[ Error ] - Failed to rsync: [$source]\n";
		print "[ Error ] -              to: [$destination]\n";
		exit(21);
	}
}

# This copies a file... Hey, what it says on the tin.
sub copy_file
{
	my ($conf, $source, $destination) = @_;
	
	my $shell_call = "$conf->{executable}{cp} -af $source $destination";
	#print "[ Debug ] - shell_call: [$shell_call]\n";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	
	# Verify it copied successfully.
	my $file = ($source =~ /^.*\/(.*)$/)[0];
	   $file = "$destination/$file";
	if (not -e $file)
	{
		print "[ Error ] - Failed to copy: [$source]\n";
		print "[ Error ] -             to: [$destination]\n";
		exit(19);
	}
	
	return(0);
}

# This looks at all NICs and 'ifup's any that are down.
sub start_all_nics
{
	my ($conf) = @_;
	
	print "Making sure all network interfaces are up.\n";
	check_nic_states($conf);
	foreach my $this_iface (sort {$a cmp $b} keys %{$conf->{nic}{by_name}})
	{
		# See if it is up already.
		my $link_state = $conf->{nic}{by_name}{$this_iface}{link_state};
		my $mac        = $conf->{nic}{by_name}{$this_iface}{mac};
		next if $link_state != 2;
		
		# If I am here, the interface is down
		my $nic       = $this_iface;
		my $nic_file = "$conf->{path}{network_configs}/ifcfg-$nic";
		print "- The network interface: [$nic] is down. It must be started for the next stage.\n";
		print "- Checking if: [$nic_file] exists.\n";
		if (not -e $nic_file)
		{
			print "- New device, writing a skeleton config file for: [$this_iface] ... ";
			my $shell_call = $nic_file;
			open (my $file_handle, '>', "$shell_call") || die "\nFailed to write: [$shell_call], error was: $!\n";
			print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
			print $file_handle "# Temporary configuration file for discovered NIC.\n";
			print $file_handle "HWADDR=\"$mac\"\n" if $mac;
			print $file_handle "DEVICE=\"$nic\"\n";
			print $file_handle "BOOTPROTO=\"none\"\n";
			print $file_handle "NM_CONTROLLED=\"no\"\n";
			close $file_handle;
			print "- Done.\n";
		}
		else
		{
			# It exists, edit it if needed.
			print "- Config file exists, changing BOOTPROTO to 'none'.\n";
			my $shell_call = "$conf->{executable}{sed} -i 's/BOOTPROTO=.*/BOOTPROTO=\"none\"/\' $nic_file";
			#print "[ Debug ] - Calling: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				# TODO: Should this cause the installer to bail?
				# This should not return anything, but just in case...
				chomp;
				my $line = $_;
				print "[ Warning ] - Unexpected output: [$line]\n";
			}
			close $file_handle;
		}
			
		# Now start the nic.
		print "- Attempting to bring up: [$nic]...\n";
		my $shell_call = "$conf->{executable}{ifup} $nic";
		open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			print "- Output: [$line]\n";
		}
		close $file_handle;
		
		# See that it came up.
		print "- Checking to see if it is up now.\n";
		sleep 2;
		my $is_up   = 0;
		$shell_call = "$conf->{executable}{ip} link show $nic";
		open ($file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /UP/)
			{
				$is_up = 1;
				last;
			}
		}
		close $file_handle;
		if ($is_up)
		{
			print "- The interface: [$nic] is now up!\n";
		}
		else
		{
			print "[ Error ] - Unable to bring up the interface: [$nic]!\n";
			print "[ Error ] - Please bring it up manually and try again.\n";
			exit(11);
		}
	}
	print "Done.\n\n";
	
	return(0);
}

# This is a wrapper function that calls the various task-specific functions
# that make the actual changes to the network.
sub reconfigure_network
{
	my ($conf) = @_;
	
	### TODO: Confirm that this is needed, may have to reboot anyway
	# Stop the network.
	#daemon_control($conf, "NetworkManager.service", "stop");
	
	# Write the udev file
	write_udev_persistent_net($conf);
	
	# Remove existing ifcfg-* files and then write the new ones.
	update_network_config_files($conf);
	
	return(0);
}

# This will remove all 'ifcfg-*' (save for 'ifcfg-lo') files and the writes
# the new config files.
sub update_network_config_files
{
	my ($conf) = @_;
	
	# First up, delete the old files.
	print "Deleting old network configuration files:\n"; 
	$conf->{path}{network_configs} =~ s/\/$//g;
	local(*DIRECTORY);
	opendir(DIRECTORY, $conf->{path}{network_configs});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		next if $file eq "ifcfg-lo";
		if ($file =~ /^ifcfg-/)
		{
			my $full_path = "$conf->{path}{network_configs}/$file";
			print "- Deleting file: [$full_path]\n";
			unlink $full_path or die "Unable to delete: [$full_path]. The error was: $!\n";
		}
	}
	print "Done.\n\n";
	print "Writing new network configuration files.\n";
	
	# Now write out the config files.
	print "Writing new network configuration files.\n";
	
	# Bridge first
	my $ifn_bridge_file = "$conf->{path}{network_configs}/ifcfg-ifn-bridge1";
	print "- IFN Bridge: [$ifn_bridge_file]\n";
	my $shell_call = $ifn_bridge_file;
	open (my $file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	print $file_handle "# Internet-Facing Network - Bridge 1\n";
	print $file_handle "DEVICE=\"ifn-bridge1\"\n";
	print $file_handle "TYPE=\"Bridge\"\n";
	print $file_handle "BOOTPROTO=\"static\"\n";
	print $file_handle "IPADDR=\"$conf->{network}{ifn}{ip}\"\n";
	print $file_handle "NETMASK=\"$conf->{network}{ifn}{netmask}\"\n";
	print $file_handle "GATEWAY=\"$conf->{network}{ifn}{gateway}\"\n";
	print $file_handle "DNS1=\"$conf->{network}{ifn}{dns1}\"\n";
	print $file_handle "DNS2=\"$conf->{network}{ifn}{dns2}\"\n";
	print $file_handle "DEFROUTE=\"yes\"\n";
	close $file_handle;

	### Bonds:
	# IFN
	my $ifn_bond_file = "$conf->{path}{network_configs}/ifcfg-ifn-bond1";
	print "- IFN Bond: [$ifn_bond_file]\n";
	$shell_call = $ifn_bond_file;
	open ($file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	print $file_handle "# Internet-Facing Network - Bond 1\n";
	print $file_handle "DEVICE=\"ifn-bond1\"\n";
	print $file_handle "BRIDGE=\"ifn-bridge1\"\n";
	print $file_handle "BOOTPROTO=\"static\"\n";
	print $file_handle "ONBOOT=\"yes\"\n";
	print $file_handle "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=ifn-link1\"\n";
	close $file_handle;

	# SN
	my $sn_bond_file = "$conf->{path}{network_configs}/ifcfg-sn-bond1";
	print "- SN Bond: [$sn_bond_file]\n";
	$shell_call = $sn_bond_file;
	open ($file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	print $file_handle "# Storage Network - Bond 1\n";
	print $file_handle "DEVICE=\"sn-bond1\"\n";
	print $file_handle "BOOTPROTO=\"static\"\n";
	print $file_handle "ONBOOT=\"yes\"\n";
	print $file_handle "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=sn-link1\"\n";
	print $file_handle "IPADDR=\"$conf->{network}{sn}{ip}\"\n";
	print $file_handle "NETMASK=\"$conf->{network}{sn}{netmask}\"\n";
	print $file_handle "DEFROUTE=\"no\"\n";
	close $file_handle;

	# BCN
	my $bcn_bond_file = "$conf->{path}{network_configs}/ifcfg-bcn-bond1";
	print "- BCN Bond: [$bcn_bond_file]\n";
	$shell_call = $bcn_bond_file;
	open ($file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	print $file_handle "# Back-Channel Network - Bond 1\n";
	print $file_handle "DEVICE=\"bcn-bond1\"\n";
	print $file_handle "BOOTPROTO=\"static\"\n";
	print $file_handle "ONBOOT=\"yes\"\n";
	print $file_handle "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=bcn-link1\"\n";
	print $file_handle "IPADDR=\"$conf->{network}{bcn}{ip}\"\n";
	print $file_handle "NETMASK=\"$conf->{network}{bcn}{netmask}\"\n";
	print $file_handle "DEFROUTE=\"no\"\n";
	close $file_handle;

	### NICs
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic   = $nic;
		my $say_short = "";
		my $say_bond  = "";
		if ($nic =~ /^bcn-link(\d)/)
		{
			my $i = $1;
			$say_nic = "Back-Channel Network - Link $i";
			$say_short = "BCN Link $i";
			$say_bond  = "bcn-bond1";
		}
		elsif ($nic =~ /^sn-link(\d)/)
		{
			my $i = $1;
			$say_nic = "Storage Network - Link $i";
			$say_short = "SN Link $i";
			$say_bond  = "sn-bond1";
		}
		elsif ($nic =~ /^ifn-link(\d)/)
		{
			my $i = $1;
			$say_nic = "Internet-Facing Network - Link $i";
			$say_short = "IFN Link $i";
			$say_bond  = "ifn-bond1";
		}
		
		my $this_mac = $conf->{nic}{name}{$nic};
		my $iface_file = "$conf->{path}{network_configs}/ifcfg-$nic";
		print "- $say_short: [$iface_file]\n";
		my $shell_call = $iface_file;
		open (my $file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
		print $file_handle "# $say_nic\n";
		print $file_handle "DEVICE=\"$nic\"\n";
		print $file_handle "NM_CONTROLLED=\"no\"\n";
		print $file_handle "BOOTPROTO=\"none\"\n";
		print $file_handle "ONBOOT=\"yes\"\n";
		print $file_handle "SLAVE=\"yes\"\n";
		print $file_handle "MASTER=\"$say_bond\"\n";
		close $file_handle;
	}
	
	return(0);
}

# This returns the current date and time in 'YYYY/MM/DD HH:MM:SS' format. It
# always uses 24-hour time and it zero-pads single digits.
sub get_date
{
	my ($conf) = @_;
	my $date = "";
	
	# This doesn't support offsets or other advanced features.
	my %time;
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	$date = "$time{year}/$time{pad_mon}/$time{pad_mday} $time{pad_hour}:$time{pad_min}:$time{pad_sec}";
	
	return($date);
}

# This writes out the udev 70-persistent-net.rules file.
sub write_udev_persistent_net
{
	my ($conf) = @_;
	
	my $shell_call = "$conf->{path}{persistent_net}";
	print "Writing the new udev rules file: [$conf->{path}{persistent_net}]\n";
	open (my $file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic = $nic;
		if    ($nic =~ /^bcn-link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^sn-link(\d)/)  { $say_nic = "Internet-Facing Network, Link $1" }
		elsif ($nic =~ /^ifn-link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		my $this_mac = $conf->{nic}{name}{$nic};
		if (not $this_mac)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ] - Desired NIC: [$nic] doesn't have a referenced MAC address!\n";
			print "[ Error ] - Exiting.\n";
			exit(1);
		}
		print $file_handle "# $say_nic\n";
		print $file_handle "SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR{address}==\"$this_mac\", NAME=\"$nic\"\n\n";
		#print "[ DEBUG ] - line: [# $say_nic]\n";
		#print "[ DEBUG ] - line: [SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR{address}==\"$this_mac\", NAME=\"$nic\"]\n";
	}
	close $file_handle;
	print "Done.\n\n";
	
	return(0);
}

# This backs up the udev (if it exists) and network files before making any
# actual changes to the system.
sub backup_original_files
{
	my ($conf) = @_;
	
	print "Backing up some network related system files.\n";
	if (not $conf->{path}{backups})
	{
		print "[ Error ] - The backup directory is not defined!\n";
		print "[ Error ] - Unable to safely proceed, exiting.\n";
		exit(5);
	}
	elsif (not -e $conf->{path}{backups})
	{
		print "- The backup directory: [$conf->{path}{backups}] doesn't exist, creting it.\n";
		mkdir $conf->{path}{backups} or die warn "[ Warning ] - Failed to create the directory: [$conf->{path}{backups}].\n[ Warning ] - The error was: $!\n";
		if (not -e $conf->{path}{backups})
		{
			print "[ Error ] - The backup directory was not created.\n";
			print "[ Error ] - Unable to safely proceed, exiting.\n";
			exit(6);
		}
		else
		{
			print "- Backup directory successfully created.\n";
		}
	}
	
	# If there is already a backup created, skip it as we're probably being
	# run a second (of thirteenth) time.
	print "- Backing up: [$conf->{path}{persistent_net}]\n";
	if (-e "$conf->{path}{backups}/70-persistent-net.rules")
	{
		print "- Previous backup exists, skipping.\n";
	}
	else
	{
		# Backup '70-persistent-net.rules' if it exists.
		if (-e $conf->{path}{persistent_net})
		{
			print "- It exists, backing it up.\n";
			backup_file($conf, $conf->{path}{persistent_net});
		}
		else
		{
			print "- Doesn't exist, skipping.\n";
		}
	}
	
	# Backup the '/etc/sysconfig/network-scripts' directory.
	print "- Backing up: [$conf->{path}{network_configs}]\n";
	if (-e "$conf->{path}{backups}/network-scripts")
	{
		print "- Previous backup exists, skipping.\n";
	}
	else
	{
		if (-e $conf->{path}{network_configs})
		{
			# No need to say it exists
			backup_file($conf, $conf->{path}{network_configs});
		}
		else
		{
			# Ok, the user has bigger problems
			print "[ Error ] - The network configuration directory was not found!\n";
			print "[ Error ] - This should not be possible.\n";
			print "[ Error ] - Please check the internal path::network_configs value.\n";
			exit(8);
		}
	}
	print "Done.\n\n";
	
	return(0);
}

# This backups up a file (or directory) to the backups directory. It is
# expected that the existance of the source and backup directories are done.
sub backup_file
{
	my ($conf, $file) = @_;
	
	if (not $file)
	{
		print "[ Error ] - The backup function was called, but no source file was given.\n";
		print "[ Error ] - This is likely a program error, exiting.\n";
		exit(7);
	}
	
	# I want the source, if it is a directory, to not have a trailing
	# slash. Conversly, I want the backup directory to have a trailing
	# slash, if it doesn't have it already.
	$file =~ s/\/$//g;
	$conf->{path}{backups} .= "/" if $conf->{path}{backups} !~ /\/$/;
	
	my $shell_call = "$conf->{executable}{cp} -ab $file $conf->{path}{backups}";
	print "- Copying: [$file] to: [$conf->{path}{backups}]\n";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Shell output: [$line]\n";
	}
	close $file_handle;
	
	### TODO: Verify the backed up file exists in the backup directory.
	#print "- Done\n";
	
	return(0);
}

# This breaks out the command-line switches and varifies that their values are
# (more or less) sane
sub sanity_check_switches
{
	my ($conf) = @_;
	
	# Something has been set for all values, sanity check them.
	# This will fail out if set to '1' once all sanity checking is done.
	my $bad_value = 0;

	# The network is a little tricker
	if (($conf->{switches}{h}) or ($conf->{switches}{help}) or ($conf->{switches}{'?'}))
	{
		print_usage($conf);
		exit(0);
	}
	if (($conf->{switches}{b}) && ($conf->{switches}{s}) && ($conf->{switches}{i}))
	{
		# All defined, sanity check them.
		($bad_value) = sanity_check_network($conf, $bad_value);
	}
	elsif (not $conf->{switches}{b})
	{
		print "[ Error ] - The Back-Channel Network details were not given.\n";
		$bad_value = 1;
	}
	elsif (not $conf->{switches}{s})
	{
		print "[ Error ] - The Storage Network details were not given.\n";
		$bad_value = 1;
	}
	elsif (not $conf->{switches}{i})
	{
		print "[ Error ] - The Internet-Facing Network details were not given.\n";
		$bad_value = 1;
	}
	print "Sanity checks complete.\n\n";
	
	return($bad_value);
}

# This sanity checks the network settings passed by the user.
sub sanity_check_network
{
	my ($conf, $bad_value) = @_;
	
	### Now sanity check passed values
	# First up, the BCN
	if ($conf->{switches}{b} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified BCN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{bcn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified BCN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{bcn}{netmask} = $netmask;
		}
	}
	else
	{
		print "[ Error ] - The specified BCN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}
	
	# Next is the SN
	if ($conf->{switches}{s} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified SN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{sn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified SN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{sn}{netmask} = $netmask;
		}
	}
	else
	{
		print "[ Error ] - The specified SN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}

	# Now the IFN, which is a little more complicated.
	if ($conf->{switches}{i} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;
		my $gateway = "";
		my $dns1    = "";
		my $dns2    = "";
		
		# The netmask should have ',dg=X' and possibly 'dns[12]=[YZ]',
		# so pull those out.
		#print "$THIS_FILE ".__LINE__."; ip: [$ip], netmask: [$netmask]\n";
		if ($netmask =~ /,dg=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dg=(.*?),/)
			{
				$gateway = $1;
				#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			}
			else
			{
				$gateway = ($netmask =~ /,dg=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			}
		}
		
		# Now the nameservers.
		if ($netmask =~ /,dns1=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dns1=(.*?),/)
			{
				$dns1 = $1;
				#print "$THIS_FILE ".__LINE__."; dns1: [$dns1]\n";
			}
			else
			{
				$dns1 = ($netmask =~ /,dns1=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; dns1: [$dns1]\n";
			}
		}
		if ($netmask =~ /,dns2=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dns2=(.*?),/)
			{
				$dns2 = $1;
				#print "$THIS_FILE ".__LINE__."; dns2: [$dns2]\n";
			}
			else
			{
				$dns2 = ($netmask =~ /,dns2=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; dns2: [$dns2]\n";
			}
		}
		
		# Now delete everything from the netmask after the ','
		$netmask =~ s/,.*$//;
		#print "$THIS_FILE ".__LINE__."; netmask: [$netmask]\n";

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IFN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{ifn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IFN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{ifn}{netmask} = $netmask;
		}
		
		# Gateway
		#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
		if ($gateway)
		{
			$gateway = validate_ip_address($conf, $gateway);
			#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			if ($gateway eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN gateway value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{gateway} = $gateway;
				#print "$THIS_FILE ".__LINE__."; network::ifn::gateway: [$conf->{network}{ifn}{gateway}]\n";
			}
		}
		else
		{
			print "[ Error ] - The IFN gateway is not specified.\n";
			$bad_value = 1;
		}
		
		# DNS 1 and 2, if defined.
		if ($dns1)
		{
			$dns1 = validate_ip_address($conf, $dns1);
			if ($dns1 eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN dns1 value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{dns1} = $dns1;
			}
		}
		if ($dns2)
		{
			$dns2 = validate_ip_address($conf, $dns2);
			if ($dns2 eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN dns2 value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{dns2} = $dns2;
			}
		}
	}
	else
	{
		print "[ Error ] - The specified IFN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}
	
	return($bad_value);
}

# This validates a string as being an IPv4 address in dotted-decimal notation.
sub validate_ip_address
{
	my ($conf, $ip) = @_;

	if ($ip =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/)
	{
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		# First octal has to be >= 1. The rest can be 0.
		if (($first_octal < 1)  || ($first_octal > 255)  ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal < 0)  || ($third_octal > 255)  ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			$ip = "#!INVALID!#";
		}
	}
	else
	{
		# Not even formatted properl.
		$ip = "#!INVALID!#";
	}

	return($ip);
}

# This takes an integer and, if it is a valid CIDR range, returns the 
# dotted-decimal equivalent. If it's not, it returns '#!INVALID!#'.
sub convert_cidr_to_dotted_decimal
{
	my ($conf, $netmask) = @_;
	
	if ($netmask =~ /^\d{1,2}$/)
	{
		# Make sure it's a (useful) CIDR
		if (($netmask >= 1) && ($netmask <= 29))
		{
			# Yes, I know that technically '0' and '30-32' are 
			# valid, but not in our case.
			if    ($netmask == 1)  { $netmask = "128.0.0.0"; }
			elsif ($netmask == 2)  { $netmask = "192.0.0.0"; }
			elsif ($netmask == 3)  { $netmask = "224.0.0.0"; }
			elsif ($netmask == 4)  { $netmask = "240.0.0.0"; }
			elsif ($netmask == 5)  { $netmask = "248.0.0.0"; }
			elsif ($netmask == 6)  { $netmask = "252.0.0.0"; }
			elsif ($netmask == 7)  { $netmask = "254.0.0.0"; }
			elsif ($netmask == 8)  { $netmask = "255.0.0.0"; }
			elsif ($netmask == 9)  { $netmask = "255.128.0.0"; }
			elsif ($netmask == 10) { $netmask = "255.192.0.0"; }
			elsif ($netmask == 11) { $netmask = "255.224.0.0"; }
			elsif ($netmask == 12) { $netmask = "255.240.0.0"; }
			elsif ($netmask == 13) { $netmask = "255.248.0.0"; }
			elsif ($netmask == 14) { $netmask = "255.252.0.0"; }
			elsif ($netmask == 15) { $netmask = "255.254.0.0"; }
			elsif ($netmask == 16) { $netmask = "255.255.0.0"; }
			elsif ($netmask == 17) { $netmask = "255.255.128.0"; }
			elsif ($netmask == 18) { $netmask = "255.255.192.0"; }
			elsif ($netmask == 19) { $netmask = "255.255.224.0"; }
			elsif ($netmask == 20) { $netmask = "255.255.240.0"; }
			elsif ($netmask == 21) { $netmask = "255.255.248.0"; }
			elsif ($netmask == 22) { $netmask = "255.255.252.0"; }
			elsif ($netmask == 23) { $netmask = "255.255.254.0"; }
			elsif ($netmask == 24) { $netmask = "255.255.255.0"; }
			elsif ($netmask == 25) { $netmask = "255.255.255.128"; }
			elsif ($netmask == 26) { $netmask = "255.255.255.192"; }
			elsif ($netmask == 27) { $netmask = "255.255.255.224"; }
			elsif ($netmask == 28) { $netmask = "255.255.255.240"; }
			elsif ($netmask == 29) { $netmask = "255.255.255.248"; }
			else
			{
				# This should never be hit.
				$netmask = "#!INVALID!#";
			}
		}
		else
		{
			$netmask = "#!INVALID!#";
		}
	}
	
	return($netmask);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = q|
 -=] Anvil! Network Configuration

DESCRIPTION

This tool will remap the physical network interfaces to device names, create
the bonded interfaces and create a bridge. It will configure the IP address,
netmask and gateways of each as well.


SWITCHES

 -b <ip_address/netmask>
	
	This sets the IP address and subnet to be assigned to the Back-Channel
	Network bonded interface.

 -h, -?, --help

	Show this dialoge and exit.

 -i <ip_address/netmask>,dg=<ip_address>[,dns1=<ip_address>,dns2=<ip_address>]

	This sets the IP address and subnet to be assigned to the 
	Internet-Facing Network bridge interface. Unlike -b and -s switches,
	this switch requires a default gateway be specified after the IP
	address via:

	dg=<ip_address>
	
		IPv4 address of the default gateway.

	Optionally, one or two DNS servers may be specified via:
	
	dns1=<ip_address>
	dns2=<ip_address>

		IPv4 addresses of the first and/or secondary DNS server. If
		these are not set, dns1 will default to 8.8.8.8 and dns2 will
		default to 8.8.4.4

 -p, --parse

	Print output suitable for parsing by a script.

 -s <ip_address/netmask>
	
	This sets the IP address and subnet to be assigned to the Storage
	Network bonded interface.
	
NOTE: that all IP addresses must be IPv4 in dotted-decimal notation. The
netmask can be in CIDR or dotted-decimal notation. Do not leave a space
between the IP address and netmask


EXAMPLE

Normal install:

 ./striker-installer -b 10.20.10.1/16 -s 10.10.10.1/16 \
     -i 10.255.10.1/16,dg=10.255.255.254,dns1=8.8.8.8,dns2=8.8.4.4

                  
SUPPORT

https://alteeve.ca/w/Support

							      Alteeve's Niche!
|;
	open (my $file_handle, ">", "/tmp/striker-installer-help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/striker-installer-help");

	return(0);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}}) { print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# This asks the user to unplug (and plug back in) NICs to identify which
# physical interface they want to use for a given role.
sub select_nics
{
	my ($conf) = @_;

	print "-=] Configuring network to enable access to Anvil! systems.\n\n";
	print "Beginning NIC identification...\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $plug_in_message_printed = 0;
		while (my $down_links = check_nic_states($conf))
		{
			if (not $plug_in_message_printed)
			{
				print "- Please plug in all network cables to proceed.\n";
				$plug_in_message_printed = 1;
			}
			#print "MAC address of down links: [$down_links]\n";
			sleep 1;
		}
		my $say_nic = $nic;
		if    ($nic =~ /^bcn-link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^sn-link(\d)/)  { $say_nic = "Storage Network, Link $1" }
		elsif ($nic =~ /^ifn-link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		print "- Please unplug the interface you want to make:\n";
		print "- [$say_nic]\n";
		my $last_conflict = "";
		while(1)
		{
			my $down_links = check_nic_states($conf);
			if (($down_links) && ($down_links !~ /,/))
			{
				if ($conf->{nic}{mac}{$down_links}{new_name})
				{
					print "- The NIC with MAC address: [$down_links] is already allocated to: [$conf->{nic}{mac}{$down_links}{new_name}]\n" if ($last_conflict ne $down_links);
					$last_conflict = $down_links;
				}
				else
				{
					$conf->{nic}{mac}{$down_links}{new_name} = $nic;
					$conf->{nic}{name}{$nic}                 = $down_links;
					print "- NIC with MAC: [$down_links] will become: [$conf->{nic}{mac}{$down_links}{new_name}]\n";
					print "- (it is currently: [$conf->{nic}{mac}{$down_links}{current_name}])\n";
					last;
				}
			}
			sleep 1;
		}
	}
	my $plug_in_message_printed = 0;
	while (my $down_links = check_nic_states($conf))
	{
		if (not $plug_in_message_printed)
		{
			print "- Please plug in all network cables to proceed.\n";
			$plug_in_message_printed = 1;
		}
		sleep 1;
	}

	my $proceed = 1;
	print "\nHere is what you selected:\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic = $nic;
		if    ($nic =~ /^bcn-link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^sn-link(\d)/)  { $say_nic = "Storage Network, Link $1" }
		elsif ($nic =~ /^ifn-link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		my $this_mac = $conf->{nic}{name}{$nic};
		if (not $this_mac)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ] - Desired NIC: [$nic] doesn't have a referenced MAC address!\n";
			print "[ Error ] - Exiting.\n";
			exit(1);
		}
		my $current_name = $conf->{nic}{mac}{$this_mac}{current_name};
		if (not $current_name)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ] - Desired NIC: [$nic] doesn't have a referenced interface!\n";
			print "[ Error ] - Exiting.\n";
			exit(2);
		}
		print "- Interface: [".uc($this_mac)."], currently named: [$current_name],\n";
		print "- will be renamed to: [$nic]\n";
		#print "- $say_nic will use the NIC with MAC: [$this_mac] ($current_name -> $nic)\n";
	}
	my $bcn_ip      = $conf->{network}{bcn}{ip};
	my $bcn_netmask = $conf->{network}{bcn}{netmask};
	print "\nThe Back-Channel Network interface will be set to:\n";
	print "- IP:      [$bcn_ip]\n";
	print "- Netmask: [$bcn_netmask]\n\n";
	my $sn_ip      = $conf->{network}{sn}{ip};
	my $sn_netmask = $conf->{network}{sn}{netmask};
	print "\nThe Storage Network interface will be set to:\n";
	print "- IP:      [$sn_ip]\n";
	print "- Netmask: [$sn_netmask]\n\n";
	my $ifn_ip      = $conf->{network}{ifn}{ip};
	my $ifn_netmask = $conf->{network}{ifn}{netmask};
	my $ifn_gateway = $conf->{network}{ifn}{gateway};
	my $ifn_dns1    = $conf->{network}{ifn}{dns1};
	my $ifn_dns2    = $conf->{network}{ifn}{dns2};
	print "The Internet-Facing Network interface will be set to:\n";
	print "- IP:      [$ifn_ip]\n";
	print "- Netmask: [$ifn_netmask]\n";
	print "- Gateway: [$ifn_gateway]\n";
	print "- DNS1:    [$ifn_dns1]\n";
	print "- DNS2:    [$ifn_dns2]\n\n";
	print "Shall I proceed? [Y/n] ";
	my $answer = <STDIN>;
	chomp($answer);
	if (($answer) && (lc($answer) =~ /^n/))
	{
		$proceed = 0;
		print "- Ok, starting over.\n";
		sleep 2;
		system('clear');
	}
	else
	{
		print "- Thank you, I will start to work now.\n\n";
	}

	return($proceed);
}

sub check_nic_states
{
	my ($conf) = @_;
	
	my $unplugged_macs  = "";
	my $this_iface      = "";
	my $this_mac        = "";
	my $this_link_state = "";
	my $shell_call = "$conf->{executable}{ip} addr";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^\d+: (.*?): <(.*?)>/)
		{
			$this_iface      = $1;
			$this_link_state = $2;
			$this_mac        = "";
			if ($this_link_state =~ /UP/)
			{
				# This will be either BROADCAST or NO-CARRIER
				$this_link_state =~ s/,.*//;
			}
			else
			{
				# The interface has been 'ifdown'ed or was not
				# started on boot.
				$this_link_state = "DOWN";
			}
			next;
		}
		next if not $this_iface;
		next if $this_iface eq "lo";
		next if $this_iface =~ /wlan/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		if ($line =~ /ether ([0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2})/)
		{
			$this_mac = $1;
			#print "this_mac: [$this_mac]\n";
			if ($this_link_state eq "DOWN")
			{
				$this_link_state = 2;
			}
			else
			{
				$this_link_state = $this_link_state eq "NO-CARRIER" ? 0 : 1;
			}
			$conf->{nic}{mac}{$this_mac}{current_name}     = $this_iface;
			$conf->{nic}{mac}{$this_mac}{link_state}       = $this_link_state;
			$conf->{nic}{by_name}{$this_iface}{link_state} = $this_link_state;
			$conf->{nic}{by_name}{$this_iface}{mac}        = $this_mac;
		}
	}
	close $file_handle;

	my $nic_count = 0;
	foreach my $this_mac (sort {$a cmp $b} keys %{$conf->{nic}{mac}})
	{
		# Somewhere in the loop, an empty '$this_mac' is being created... 
		# (I'm looking at you, autovivication >_>)
		next if not $this_mac;
		my $this_iface = $conf->{nic}{mac}{$this_mac}{current_name};
		
		if (($this_iface eq "lo") || ($this_iface =~ /wlan/))
		{
			#print "[ Debug ] - Skipping interface: [$this_iface]\n";
		}
		else
		{
			$nic_count++;
			#print "[ Debug ] - NIC: [$this_iface] w/ MAC: [$this_mac]; Link: [$conf->{nic}{mac}{$this_mac}{link_state}], current name: [$conf->{nic}{mac}{$this_mac}{current_name}]\n";
		}
		if ($conf->{nic}{mac}{$this_mac}{link_state} ne "1")
		{
			$unplugged_macs .= "$this_mac,";
		}
	}
	
	$unplugged_macs =~ s/,$//;
	#print "- DEBUG: unpluggd_macs: [$unplugged_macs]\n";
	return($unplugged_macs);
}

# This looks for an executable.
sub find_executables
{
	my ($conf) = @_;
	
	my $search = $ENV{'PATH'};
	#print "Searching in: [$search] for programs.\n";
	foreach my $program (keys %{$conf->{executable}})
	{
		#print "Seeing if: [$program] is really at: [$conf->{executable}{$program}]: ";
		if ( -e $conf->{executable}{$program} )
		{
			#print "Found it.\n";
		}
		else
		{
			#print "Not found, searching for it now.\n";
			foreach my $directory (split /:/, $search)
			{
				my $full_path = "$directory/$program";
				if ( -e $full_path )
				{
					$conf->{executable}{$program} = $full_path;
					#print "Found it in: [$full_path]\n";
				}
			}
		}
	}
	
	return (0);
}
