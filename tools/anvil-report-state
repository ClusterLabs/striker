#!/usr/bin/perl
# 
# This tool does not do or change anything. It simply gathers information on the current state of the Anvil!
# and returns it as variable=value pairs.
# 
# NOTE:    This program is designed to be machine-readable. For this reason, the data is NOT translated.
# WARNING: This program reports passwords!
# 
# Return Codes:
# 0  = OK
# 1  = Failed to find local hostname.
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use XML::Simple;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({
	data		=> {
		sys		=>	{
			fast		=>	0,
			hide_empty	=>	1,
			log_level	=>	1,
		},
	},
	gathered	=>	{
		hostname	=>	{
			peer		=>	"unknown",
			me		=>	"unknown",
		},
	},
});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{$THIS_FILE}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

if (($an->data->{switches}{f}) or 
    ($an->data->{switches}{fast}))
{
	$an->data->{sys}{fast} = 1;
}

# Gather whatever we can find.
gather_data($an);
report_findings($an);

$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This is a wrapper to call all the various methods for data collection.
sub gather_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_data" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	gather_hostname($an);
	gather_cluster_conf($an);
	gather_clustat($an);
	gather_bonds($an);
	gather_hosts($an);
	gather_daemons($an);
	gather_drbd($an);
	gather_dmidecode($an);
	gather_meminfo($an);
	gather_gfs2($an);
	gather_lvm($an);
	gather_servers($an);
	gather_shared_files($an);
	
	return(0);
}

# This gathers a list of files in /shared/files
sub gather_shared_files
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_shared_files" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $months = {
		Jan => "01",
		Feb => "02",
		Mar => "03", 
		Apr => "04", 
		May => "05", 
		Jun => "06", 
		Jul => "07", 
		Aug => "08", 
		Sep => "09", 
		Oct => "10", 
		Nov => "11", 
		Dec => "12", 
	};
	my $shell_call = $an->data->{path}{ls}." -l ".$an->data->{path}{shared_files};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^(\S)(\S+)\s+\d+\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(.*)$/)
		{
			my $type   = $1;
			my $mode   = $2;
			my $user   = $3;
			my $group  = $4;
			my $size   = $5;
			my $month  = $6;
			my $day    = $7;
			my $time   = $8; # might be a year, look for '\d+:\d+'.
			my $file   = $9;
			my $target = "";
			if ($type eq "l")
			{
				# It is a symlink, strip off the destination.
				($file, $target) = ($file =~ /^(.*?) -> (.*)$/);
			}
			# These are so crude...
			my $is_iso = 0;
			if ($file =~ /\.iso$/i)
			{
				$is_iso = 1;
			}
			my $is_executable = 0;
			if (($mode =~ /x/) or ($mode =~ /s/))
			{
				$is_executable = 1;
			}
			my $year = 1900 + (localtime(time))[5];
			if ($time !~ /:/)
			{
				$year = $time;
				$time = "--";
			}
			# Change the month to a number
			my $say_month = $months->{$month};
			my $say_day   = sprintf("%02d", $day);
			my $say_date  = $year."-".$say_month."-".$say_day;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0015", message_variables => {
				name1  => "type",          value1  => $type, 
				name2  => "mode",          value2  => $mode, 
				name3  => "user",          value3  => $user, 
				name4  => "group",         value4  => $group, 
				name5  => "size",          value5  => $size, 
				name6  => "month",         value6  => $month, 
				name7  => "day",           value7  => $day, 
				name8  => "time",          value8  => $time, 
				name9  => "year",          value9  => $year, 
				name10 => "file",          value10 => $file, 
				name11 => "target",        value11 => $target, 
				name12 => "is_iso",        value12 => $is_iso, 
				name13 => "is_executable", value13 => $is_executable, 
				name14 => "say_month",     value14 => $say_month, 
				name15 => "say_day",       value15 => $say_day, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{gathered}{media_library}{$file} = {
				type       => $type, 
				mode       => $mode, 
				user       => $user, 
				group      => $group, 
				size       => $size, 
				date       => $say_date, 
				'time'     => $time,
				target     => $target, 
				optical    => $is_iso,
				executable => $is_executable,
			};
		}
	}
	close $file_handle;
	
	return(0);
}

# This is a wrapper for the server data gathering functions
sub gather_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_servers" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	gather_virsh($an);
	if (not $an->data->{sys}{fast})
	{
		# This won't run if clustat was hung.
		gather_definition_files($an);
		
		# Process the XML definition files.
		foreach my $server (sort {$a cmp $b} keys %{$an->data->{gathered}{server}})
		{
			foreach my $source (sort {$a cmp $b} keys %{$an->data->{gathered}{server}{$server}{definition}})
			{
				my $definition = $an->data->{gathered}{server}{$server}{definition}{$source};
				if (($definition =~ /<domain type='kvm' id='\d+'>/ms) && ($definition =~ /<\/domain>/ms))
				{
					# Valid XML.
					parse_definition($an, $server, $source, $definition);
				}
			}
		}
	}
	
	return(0);
}

# This parses out an XML definition file
sub parse_definition
{
	my ($an, $server, $source, $definition) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "parse_definition" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "server",     value1 => $server,  
		name2 => "source",     value2 => $source,  
		name3 => "definition", value3 => $definition, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# NOTE: This can get VERY complicated, beyond what we want to support (KISS, folks). For details on what is possible;
	#       https://libvirt.org/formatdomain.html
	
	my $xml  = XML::Simple->new();
	my $data = $xml->XMLin($definition, ForceArray => 1);
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "data", value1 => $data,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Memory needs to be pieced together.
	my $current_memory_value  = defined $data->{currentMemory}->[0]->{content} ? $data->{currentMemory}->[0]->{content} : 0;
	my $current_memory_unit   = defined $data->{currentMemory}->[0]->{unit}    ? $data->{currentMemory}->[0]->{unit}    : "KiB";
	my $assigned_memory_value = defined $data->{memory}->[0]->{content}        ? $data->{memory}->[0]->{content}        : 0;
	my $assigned_memory_unit  = defined $data->{memory}->[0]->{unit}           ? $data->{memory}->[0]->{unit}           : "KiB";
	
	my $current_memory        = $an->Readable->hr_to_bytes({size => $current_memory_value, type => $current_memory_unit});
	my $assigned_memory       = $an->Readable->hr_to_bytes({size => $assigned_memory_value, type => $assigned_memory_unit});
	$an->data->{gathered}{server}{$server}{details}{$source}{memory}{current}  = $current_memory." Bytes";
	$an->data->{gathered}{server}{$server}{details}{$source}{memory}{assigned} = $assigned_memory." Bytes";
	
	# Much stuff can be pulled out directly
	$an->data->{gathered}{server}{$server}{details}{$source}{name}              = defined $data->{name}->[0]                       ? $data->{name}->[0]                       : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{uuid}              = defined $data->{uuid}->[0]                       ? $data->{uuid}->[0]                       : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{on_poweroff}       = defined $data->{on_poweroff}->[0]                ? $data->{on_poweroff}->[0]                : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{on_reboot}         = defined $data->{on_reboot}->[0]                  ? $data->{on_reboot}->[0]                  : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{on_crash}          = defined $data->{on_crash}->[0]                   ? $data->{on_crash}->[0]                   : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{cpu}{architecture} = defined $data->{os}->[0]->{type}->[0]->{arch}    ? $data->{os}->[0]->{type}->[0]->{arch}    : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{cpu}{cores}        = defined $data->{vcpu}->[0]->{content}            ? $data->{vcpu}->[0]->{content}            : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{host}{machine}     = defined $data->{os}->[0]->{type}->[0]->{machine} ? $data->{os}->[0]->{type}->[0]->{machine} : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{clock}{offset}     = defined $data->{clock}->[0]->{offset}            ? $data->{clock}->[0]->{offset}            : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{emulator}          = defined $data->{devices}->[0]->{emulator}->[0]   ? $data->{devices}->[0]->{emulator}->[0]   : "";
	
	# A CPU's topology *might* be defined.
	if (exists $data->{cpu}->[0]->{topology})
	{
		$an->data->{gathered}{server}{$server}{details}{$source}{cpu}{topology}{sockets} = defined $data->{cpu}->[0]->{topology}->[0]->{sockets} ? $data->{cpu}->[0]->{topology}->[0]->{sockets} : "";
		$an->data->{gathered}{server}{$server}{details}{$source}{cpu}{topology}{cores}   = defined $data->{cpu}->[0]->{topology}->[0]->{cores}   ? $data->{cpu}->[0]->{topology}->[0]->{cores}   : "";
		$an->data->{gathered}{server}{$server}{details}{$source}{cpu}{topology}{threads} = defined $data->{cpu}->[0]->{topology}->[0]->{threads} ? $data->{cpu}->[0]->{topology}->[0]->{threads} : "";
	}
	
	### These devices are a bit deeper stored
	# Video
	$an->data->{gathered}{server}{$server}{details}{$source}{video}{heads}   = defined $data->{devices}->[0]->{video}->[0]->{model}->[0]->{heads} ? $data->{devices}->[0]->{video}->[0]->{model}->[0]->{heads} : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{video}{type}    = defined $data->{devices}->[0]->{video}->[0]->{model}->[0]->{type}  ? $data->{devices}->[0]->{video}->[0]->{model}->[0]->{type}  : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{graphics}{type} = defined $data->{devices}->[0]->{graphics}->[0]->{'listen'}->[0]    ? $data->{devices}->[0]->{video}->[0]->{model}->[0]->{type}  : "";
	
	# Digging out the IP it is listening on for video is a touch complicated.
	foreach my $entry (@{$data->{devices}->[0]->{graphics}->[0]->{'listen'}})
	{
		if ((ref($entry) eq "HASH") && ($entry->{type} eq "address"))
		{
			$an->data->{gathered}{server}{$server}{details}{$source}{graphics}{listening}{address} = $entry->{address};
		}
	}
	$an->data->{gathered}{server}{$server}{details}{$source}{graphics}{listening}{port} = defined $data->{devices}->[0]->{graphics}->[0]->{port} ? $data->{devices}->[0]->{graphics}->[0]->{port} : "";
	$an->data->{gathered}{server}{$server}{details}{$source}{graphics}{listening}{type} = defined $data->{devices}->[0]->{graphics}->[0]->{port} ? $data->{devices}->[0]->{graphics}->[0]->{type} : "";
	
	# Tease out the video RAM, if we can read it.
	$an->data->{gathered}{server}{$server}{details}{$source}{video}{ram}   = "";
	$an->data->{gathered}{server}{$server}{details}{$source}{video}{vram}  = "";
	my $video_ram  = defined $data->{devices}->[0]->{video}->[0]->{model}->[0]->{ram}  ? $data->{devices}->[0]->{video}->[0]->{model}->[0]->{ram}  : "";
	my $video_vram = defined $data->{devices}->[0]->{video}->[0]->{model}->[0]->{vram} ? $data->{devices}->[0]->{video}->[0]->{model}->[0]->{vram} : "";
	if ($video_ram)  { $an->data->{gathered}{server}{$server}{details}{$source}{video}{ram}  = $an->Readable->hr_to_bytes({size => $video_ram, type => "KiB"})." Bytes"; }
	if ($video_vram) { $an->data->{gathered}{server}{$server}{details}{$source}{video}{vram} = $an->Readable->hr_to_bytes({size => $video_vram, type => "KiB"})." Bytes"; }
	
	# Disks (and optical discs)
	foreach my $hash_ref (@{$data->{devices}->[0]->{disk}})
	{
		next if not $hash_ref->{device};
		my $disk_type     = $hash_ref->{device};									# disk or cdrom
		
		# The source device/file name might use a few different keys
		my $source_device = $hash_ref->{source}->[0]->{device} ? $hash_ref->{source}->[0]->{device} : "";
		if (not $source_device)
		{
			$source_device = $hash_ref->{source}->[0]->{dev} ? $hash_ref->{source}->[0]->{dev} : "";
		}
		if (not $source_device)
		{
			$source_device = $hash_ref->{source}->[0]->{file} ? $hash_ref->{source}->[0]->{file} : "";
		}
		my $source_type   = defined $hash_ref->{type}                    ? $hash_ref->{type}                    : "";	# Block or file
		my $target_bus    = defined $hash_ref->{target}->[0]->{bus}      ? $hash_ref->{target}->[0]->{bus}      : "";
		my $target_device = defined $hash_ref->{target}->[0]->{device}   ? $hash_ref->{target}->[0]->{device}   : "";
		my $driver_type   = defined $hash_ref->{driver}->{qemu}->{type}  ? $hash_ref->{driver}->{qemu}->{type}  : "";
		my $driver_io     = defined $hash_ref->{driver}->{qemu}->{io}    ? $hash_ref->{driver}->{qemu}->{io}    : "";
		my $driver_cache  = defined $hash_ref->{driver}->{qemu}->{cache} ? $hash_ref->{driver}->{qemu}->{cache} : "";
		
		$an->data->{gathered}{server}{$server}{details}{$source}{$disk_type}{$source_device}{source}{type}   = $source_type;
		$an->data->{gathered}{server}{$server}{details}{$source}{$disk_type}{$source_device}{target}{bus}    = $target_bus;
		$an->data->{gathered}{server}{$server}{details}{$source}{$disk_type}{$source_device}{target}{device} = $target_device;
		$an->data->{gathered}{server}{$server}{details}{$source}{$disk_type}{$source_device}{driver}{type}   = $driver_type;
		$an->data->{gathered}{server}{$server}{details}{$source}{$disk_type}{$source_device}{driver}{io}     = $driver_io;
		$an->data->{gathered}{server}{$server}{details}{$source}{$disk_type}{$source_device}{driver}{cache}  = $driver_cache;
	}
	
	# Network Interfaces
	foreach my $hash_ref (@{$data->{devices}->[0]->{interface}})
	{
		next if not $hash_ref->{mac}->[0]->{address};
		my $mac_address = $hash_ref->{mac}->[0]->{address};
		
		my $on_bridge   = defined $hash_ref->{source}->[0]->{bridge} ? $hash_ref->{source}->[0]->{bridge} : "";
		my $using_vnet  = defined $hash_ref->{target}->[0]->{dev}    ? $hash_ref->{target}->[0]->{dev}    : "";
		my $model       = defined $hash_ref->{model}->[0]->{type}    ? $hash_ref->{model}->[0]->{type}    : "";
		
		$an->data->{gathered}{server}{$server}{details}{$source}{network}{$mac_address}{source}{bridge} = $on_bridge;
		$an->data->{gathered}{server}{$server}{details}{$source}{network}{$mac_address}{source}{device} = $using_vnet;
		$an->data->{gathered}{server}{$server}{details}{$source}{network}{$mac_address}{model}          = $model;
	}
	
	# Sort out the boot devices and their order.
	my $boot = 1;
	foreach my $hash_ref (@{$data->{os}->[0]->{boot}})
	{
		$an->data->{gathered}{server}{$server}{details}{$source}{boot}{$boot}{device} = defined $hash_ref->{dev} ? $hash_ref->{dev} : "";
		$boot++;
	}

=cut
	# This is used for debugging/digging out additional info
	print "Server: [$server], source: [$source]\n";
	#print "==========\n$definition==========\n";
	foreach my $a (keys %{$data})
	{
		next if $a eq "name";
		next if $a eq "uuid";
		next if $a eq "on_poweroff";
		next if $a eq "on_reboot";
		next if $a eq "on_crash";
		next if $a eq "seclabel";	# We'll worry about this in m3
		next if $a eq "features";	# We'll worry about this in m3, unless the mode and model/features are needed in 2.1+
		next if $a eq "currentMemory";
		next if $a eq "memory";
		next if $a eq "os";
		next if $a eq "type";
		next if $a eq "id";		# We'll worry about this in m3
		next if $a eq "clock";
		next if $a eq "cpu";		# We only check for topology at this time
		next if $a eq "vcpu";
		print "a: [$a]\n";
		print "==========\n";
		print Dumper $data->{$a};
		print "==========\n";
	}
	die;
=cut
	
	return(0);
}

# This gets the XML definition from virsh, reflecting what is actually in memory at the time. The data here 
# best reflects what the server is consuming at this time.
sub gather_running_definition
{
	my ($an, $server) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_running_definition" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "server", value1 => $server,  
	}, file => $THIS_FILE, line => __LINE__});
	
	my $definition = "";
	my $lines      = 0;
	my $shell_call = $an->data->{path}{virsh}." dumpxml $server";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$definition .= $line."\n";
		$lines++;
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "definition", value1 => $definition,
		name2 => "lines",      value2 => $lines,
	}, file => $THIS_FILE, line => __LINE__});
	$an->data->{gathered}{server}{$server}{definition}{running} = $definition;
	
	return(0);
}

# This reads in the /shared/definitions data for the known servers.
sub gather_definition_files
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_definition_files" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If clustat was hung, this will hang, too.
	return(0) if $an->data->{gathered}{clustat}{hung};
	
	my $this_server = "";
	my $in_domain   = 0;
	my $definition  = "";
	my $lines       = 0;
	my $shell_call  = $an->data->{path}{cat}." ".$an->data->{path}{shared_definitions}."/* &>/dev/null; ".$an->data->{path}{echo}." rc:\$?";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /rc:(\d+)/)
		{
			my $return_code = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "return_code", value1 => $return_code,
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# Find the start of a domain.
		if ($line =~ /<domain/)
		{
			$in_domain = 1;
		}
		
		# Get this name of the current domain
		if ($line =~ /<name>(.*?)<\/name>/)
		{
			$this_server = $1;
		}
		
		# Push all lines into the current domain array.
		if ($in_domain)
		{
			$definition .= $line."\n";
			$lines++;
		}
		
		# When the end of a domain is found, push the array over to $an->data.
		if ($line =~ /<\/domain>/)
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "this_server", value1 => $this_server,
				name2 => "definition",  value2 => $definition,
				name3 => "lines",       value3 => $lines,
			}, file => $THIS_FILE, line => __LINE__});
			$an->data->{gathered}{server}{$this_server}{definition}{stored} = $definition;
			$in_domain  = 0;
			$lines      = 0;
			$definition = "";
		}
	}
	close $file_handle;
	
	return(0);
}

# Gather info from virsh list
sub gather_virsh
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_virsh" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{virsh}." list --all";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		next if $line =~ /--------/;
		next if not $line;
		
		my ($id, $server, $state) = split/ /, $line, 3;
		next if $id =~ /\D/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "id",     value1 => $id,
			name2 => "server", value2 => $server,
			name3 => "state",  value3 => $state,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record the state
		$an->data->{gathered}{server}{$server}{'state'} = $state;
		
		# And if we're alive, disable withdrawl because we're hosting a server (or are about to).
		$an->data->{gathered}{sys}{enable_withdraw} = 0;
		
		if ($state eq "paused")
		{
			# This server is being migrated here, disable migration of this server.
			$an->data->{gathered}{sys}{enable_poweroff}         = 0;
			$an->data->{gathered}{server}{$server}{can_migrate} = 0;
		}
		
		if (not $an->data->{sys}{fast})
		{
			# Now gather the in-memory XML definition.
			gather_running_definition($an, $server);
		}
	}
	close $file_handle;
	
	return(0);
}

# This is a wrapper for the LVM data gathering functions
sub gather_lvm
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_lvm" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If clustat was hung, this will hang, too.
	return(0) if $an->data->{gathered}{clustat}{hung};
	
	#gather_lvm_scan($an);	# This adds about 30~40ms to the call and should rarely be needed. MAYBE add it back later?
	gather_lvm_data($an);
	
	return(0);
}

# This gathers data from pvscan/vgscan/lvscan
sub gather_lvm_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_lvm_scan" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = "
".$an->data->{path}{pvscan}."; ".$an->data->{path}{echo}." pvscan:\$?; 
".$an->data->{path}{vgscan}."; ".$an->data->{path}{echo}." vgscan:\$?; 
".$an->data->{path}{lvscan},"; ".$an->data->{path}{echo}." lvscan:\$?;
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /pvscan:(\d+)/)
		{
			my $return_code = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "return_code", value1 => $return_code,
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if ($line =~ /vgscan:(\d+)/)
		{
			my $return_code = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "return_code", value1 => $return_code,
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if ($line =~ /lvscan:(\d+)/)
		{
			my $return_code = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "return_code", value1 => $return_code,
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		if ($line =~ /(.*?)\s+'(.*?)'\s+\[(.*?)\]/)
		{
			my $state = $1;
			my $lv    = $2;
			my $size  = $3;
			my $bytes = $an->Readable->hr_to_bytes({size => $size });
			my $vg    = ($lv =~ /^\/dev\/(.*?)\//)[0];
			
			$an->data->{gathered}{lvm}{lv}{$lv}{on_vg} = $vg;
			$an->data->{gathered}{lvm}{lv}{$lv}{size}  = $bytes." Bytes";
		}
	}
	close $file_handle;
	
	return(0);
}

# This gathers data from pvs/vgs/lvs
sub gather_lvm_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_lvm_data" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $in_pvs     = 0;
	my $in_vgs     = 0;
	my $in_lvs     = 0;
	my $timeout    = 5;
	my $shell_call = "
".$an->data->{path}{pvs}." --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid; ".$an->data->{path}{echo}." pvs:\$?; 
".$an->data->{path}{vgs}." --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name; ".$an->data->{path}{echo}." vgs:\$?; 
".$an->data->{path}{lvs}." --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices; ".$an->data->{path}{echo}." lvs:\$?;
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^PV/)
		{
			$in_pvs = 1;
			$in_vgs = 0;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^VG/)
		{
			$in_pvs = 0;
			$in_vgs = 1;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^LV/)
		{
			$in_pvs = 0;
			$in_vgs = 0;
			$in_lvs = 1;
			next;
		}
		
		if ($in_pvs)
		{
			# pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid
			if ($line =~ /pvs:(\d+)/)
			{
				my $return_code = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			#   pv_name,  vg_name,     pv_fmt,  pv_attr,     pv_size,     pv_free,   pv_used,     pv_uuid
			my ($this_pv, $used_by_vg, $format, $attributes, $total_size, $free_size, $used_size, $uuid) = (split /#!#/, $line);
			
			$total_size =~ s/B$//;
			$free_size  =~ s/B$//;
			$used_size  =~ s/B$//;
			
			$an->data->{gathered}{lvm}{pv}{$this_pv}{used_by_vg} = $used_by_vg;
			$an->data->{gathered}{lvm}{pv}{$this_pv}{attributes} = $attributes;
			$an->data->{gathered}{lvm}{pv}{$this_pv}{total_size} = $total_size." Bytes";
			$an->data->{gathered}{lvm}{pv}{$this_pv}{free_size}  = $free_size." Bytes";
			$an->data->{gathered}{lvm}{pv}{$this_pv}{used_size}  = $used_size." Bytes";
			$an->data->{gathered}{lvm}{pv}{$this_pv}{uuid}       = $uuid;
		}
		elsif ($in_vgs)
		{
			# vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name
			if ($line =~ /vgs:(\d+)/)
			{
				my $return_code = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			
			#   vg_name,  vg_attr,     vg_extent_size, vg_extent_count, vg_uuid, vg_size,  vg_free_count, vg_free,  pv_name
			my ($this_vg, $attributes, $pe_size,       $total_pe,       $uuid,   $vg_size, $free_pe,      $vg_free, $pv_name) = split /#!#/, $line;
			$pe_size    = "" if not defined $pe_size;
			$vg_size    = "" if not defined $vg_size;
			$vg_free    = "" if not defined $vg_free;
			$attributes = "" if not defined $attributes;
			
			$pe_size =~ s/B$//;
			$vg_size =~ s/B$//;
			$vg_free =~ s/B$//;
			
			my $used_pe    = $total_pe - $free_pe if (($total_pe) && ($free_pe));
			my $used_space = $vg_size - $vg_free  if (($vg_size) && ($vg_free));
			$an->data->{gathered}{lvm}{vg}{$this_vg}{clustered}  = $attributes =~ /c$/ ? 1 : 0;
			$an->data->{gathered}{lvm}{vg}{$this_vg}{pe_size}    = $pe_size." Bytes";
			$an->data->{gathered}{lvm}{vg}{$this_vg}{total_pe}   = $total_pe;
			$an->data->{gathered}{lvm}{vg}{$this_vg}{uuid}       = $uuid;
			$an->data->{gathered}{lvm}{vg}{$this_vg}{size}       = $vg_size." Bytes";
			$an->data->{gathered}{lvm}{vg}{$this_vg}{used_pe}    = $used_pe;
			$an->data->{gathered}{lvm}{vg}{$this_vg}{used_space} = $used_space;
			$an->data->{gathered}{lvm}{vg}{$this_vg}{free_pe}    = $free_pe;
			$an->data->{gathered}{lvm}{vg}{$this_vg}{free_space} = $vg_free." Bytes";
			$an->data->{gathered}{lvm}{vg}{$this_vg}{pv_name}    = $pv_name;
		}
		elsif ($in_lvs)
		{
			# lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices
			if ($line =~ /lvs:(\d+)/)
			{
				my $return_code = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "return_code", value1 => $return_code,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			my ($lv_name, $on_vg, $attributes, $total_size, $uuid, $path, $devices) = (split /#!#/, $line);

			$total_size =~ s/B$//;
			$devices    =~ s/\(\d+\)//g;	# Strip the starting PE number

			$an->data->{gathered}{lvm}{lv}{$path}{name}       = $lv_name;
			$an->data->{gathered}{lvm}{lv}{$path}{on_vg}      = $on_vg;
			$an->data->{gathered}{lvm}{lv}{$path}{active}     = ($attributes =~ /.{4}(.{1})/)[0] eq "a" ? 1 : 0;
			$an->data->{gathered}{lvm}{lv}{$path}{attributes} = $attributes;
			$an->data->{gathered}{lvm}{lv}{$path}{total_size} = $total_size." Bytes";
			$an->data->{gathered}{lvm}{lv}{$path}{uuid}       = $uuid;
			$an->data->{gathered}{lvm}{lv}{$path}{on_devices} = $devices;
		}
	}
	close $file_handle;
	
	return(0);
}

# This gathers data from /proc/meminfo
sub gather_meminfo
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_meminfo" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: Unites report as 'kB' but are 'KiB' (1024 bytes)
	my $shell_call = $an->data->{path}{proc_meminfo};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /MemTotal: (\d+) kB/)
		{
			$an->data->{gathered}{meminfo}{memory}{total} = ($1 * 1024)." Bytes";
		}
		elsif ($line =~ /MemFree: (\d+) kB/)
		{
			$an->data->{gathered}{meminfo}{memory}{free} = ($1 * 1024)." Bytes";
		}
		elsif ($line =~ /SwapTotal: (\d+) kB/)
		{
			$an->data->{gathered}{meminfo}{swap}{total} = ($1 * 1024)." Bytes";
		}
		elsif ($line =~ /SwapFree: (\d+) kB/)
		{
			$an->data->{gathered}{meminfo}{swap}{free} = ($1 * 1024)." Bytes";
		}
		elsif ($line =~ /HardwareCorrupted: (\d+) kB/)
		{
			$an->data->{gathered}{meminfo}{memory}{corrupted} = ($1 * 1024)." Bytes";
		}
	}
	close $file_handle;
	
	return(0);
}

# Read information from GFS2
sub gather_gfs2
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_gfs2" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	return if not -e $an->data->{path}{gfs2_lock};
	
	my $block_size    = 1024;
	my $in_filesystem = 0;
	my $shell_call    = $an->data->{path}{'grep'}." gfs2 ".$an->data->{path}{etc_fstab}."; ".$an->data->{path}{df}." -P";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Filesystem/)
		{
			if ($line =~ /(\d+)-blocks/)
			{
				$block_size = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "block_size", value1 => $block_size, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			$in_filesystem = 1;
			next;
		}
		
		if ($in_filesystem)
		{
			next if $line !~ /^\//;
			my ($device_path, $total_size, $used_space, $free_space, $percent_used, $mount_point) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)$/);
			
			next if not $mount_point;
			next if not exists $an->data->{gathered}{gfs}{$mount_point};
			
			# Still alive?
			$total_size   = 0 if not defined $total_size;
			$used_space   = 0 if not defined $used_space;
			$free_space   = 0 if not defined $free_space;
			$percent_used = 0 if not defined $percent_used;
			
			# Convert to bytes by multiplying the returned block count by the block size
			$total_size *= $block_size;
			$used_space *= $block_size;
			$free_space *= $block_size;
			
			$an->data->{gathered}{gfs}{$mount_point}{device_path}  = $device_path;
			$an->data->{gathered}{gfs}{$mount_point}{total_size}   = $total_size." Bytes";
			$an->data->{gathered}{gfs}{$mount_point}{used_space}   = $used_space." Bytes";
			$an->data->{gathered}{gfs}{$mount_point}{free_space}   = $free_space." Bytes";
			$an->data->{gathered}{gfs}{$mount_point}{percent_used} = $percent_used;
			$an->data->{gathered}{gfs}{$mount_point}{mounted}      = 1;
		}
		else
		{
			# Read the GFS info.
			next if $line !~ /gfs2/;
			my (undef, $mount_point, $filesystem) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s/);
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "mount_point", value1 => $mount_point,
				name2 => "filesystem",  value2 => $filesystem,
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{gathered}{gfs}{$mount_point}{device_path}  = "";
			$an->data->{gathered}{gfs}{$mount_point}{total_size}   = "";
			$an->data->{gathered}{gfs}{$mount_point}{used_space}   = "";
			$an->data->{gathered}{gfs}{$mount_point}{free_space}   = "";
			$an->data->{gathered}{gfs}{$mount_point}{percent_used} = "";
			$an->data->{gathered}{gfs}{$mount_point}{mounted}      = 0;
		}
	}
	close $file_handle;
	
	return(0);
}

# Gather dmidecode information
sub gather_dmidecode
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_dmidecode" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $in_cpu           = 0;
	my $in_system_ram    = 0;
	my $in_dimm_module   = 0;
	
	# On SMP machines, the CPU socket becomes important. This tracks which CPU I am looking at.
	my $this_socket      = "";
	
	# Same deal with volume groups.
	my $this_vg          = "";
	
	# RAM is all over the place, so I need to record all the bits in strings and push to the hash when I
	# see a blank line.
	my $dimm_locator     = "";
	my $dimm_bank        = "";
	my $dimm_size        = "";
	my $dimm_type        = "";
	my $dimm_speed       = "";
	my $dimm_form_factor = "";
	my $dimm_count       = 0;
	
	# This will be set to the values I find on this node.
	$an->data->{gathered}{dmidecode}{total_node_cores}   = 0;
	$an->data->{gathered}{dmidecode}{total_node_threads} = 0;
	$an->data->{gathered}{dmidecode}{total_memory}       = 0;
	
	# In some cases, like in servers, the CPU core count is not provided. So this keeps a running tally 
	# of how many times we've gone in and out of 'in_cpu' and will be used as the core count if, when 
	# it is all done, we have 0 cores listed.
	$an->data->{gathered}{dmidecode}{cpu}{sockets} = 0;
	
	my $shell_call = $an->data->{path}{dmidecode}." -t 4,16,17";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Find out what I am looking at.
		if (not $line)
		{
			# Blank lines break sections. If I had been reading DIMM info, push it into the hash.
			if ($in_dimm_module)
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
					name1 => "dimm_locator",     value1 => $dimm_locator, 
					name2 => "dimm_bank",        value2 => $dimm_bank, 
					name3 => "dimm_type",        value3 => $dimm_type, 
					name4 => "dimm_speed",       value4 => $dimm_speed, 
					name5 => "dimm_form_factor", value5 => $dimm_form_factor, 
					name6 => "dimm_size",        value6 => $dimm_size, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($dimm_size == 0)
				{
					$an->data->{gathered}{dmidecode}{dimm}{$dimm_locator}{size} = "open";
				}
				else
				{
					$an->data->{gathered}{dmidecode}{dimm}{$dimm_locator}{bank}        = $dimm_bank;
					$an->data->{gathered}{dmidecode}{dimm}{$dimm_locator}{size}        = $dimm_size;
					$an->data->{gathered}{dmidecode}{dimm}{$dimm_locator}{type}        = $dimm_type;
					$an->data->{gathered}{dmidecode}{dimm}{$dimm_locator}{speed}       = $dimm_speed;
					$an->data->{gathered}{dmidecode}{dimm}{$dimm_locator}{form_factor} = $dimm_form_factor;
				}
				$dimm_count++;
			}
			
			$in_cpu         = 0;
			$in_system_ram  = 0;
			$in_dimm_module = 0;
			$this_socket    = "";
			$this_vg        = "";
			next;
		}
		if ($line =~ /Processor Information/)
		{
			$in_cpu = 1;
			$an->data->{gathered}{dmidecode}{cpu}{sockets}++;
			next;
		}
		if ($line =~ /Physical Memory Array/)
		{
			$in_system_ram  = 1;
			next;
		}
		if ($line =~ /Memory Device/)
		{
			$in_dimm_module = 1;
			next;
		}
		if ((not $in_cpu) && (not $in_system_ram) && (not $in_dimm_module))
		{
			next;
		}
		
		# Now pull out data based on where I am.
		if ($in_cpu)
		{
			# The socket is the first line, so I can safely assume that 'this_socket' will be 
			# populated after this.
			if ($line =~ /Socket Designation: (.*)/)
			{
				$this_socket = $1;
				next;
			}
			
			# Grab some deets!
			if ($line =~ /Family: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{family} = $1;
			}
			if ($line =~ /Manufacturer: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{oem} = $1;
			}
			if ($line =~ /Version: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{version} = $1;
			}
			if ($line =~ /Max Speed: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{max_speed} = $1;
			}
			if ($line =~ /Status: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{status} = $1;
			}
			if ($line =~ /Core Count: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{cores} =  $1;
				$an->data->{gathered}{dmidecode}{total_node_cores}         += $an->data->{gathered}{dmidecode}{cpu}{$this_socket}{cores};
			}
			if ($line =~ /Thread Count: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{cpu}{$this_socket}{threads} =  $1;
				$an->data->{gathered}{dmidecode}{total_node_threads}         += $an->data->{gathered}{dmidecode}{cpu}{$this_socket}{threads};
			}
		}
		if ($in_system_ram)
		{
			# Not much in system RAM, but good to know stuff.
			if ($line =~ /Error Correction Type: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{ram}{ecc_support} = $1;
			}
			if ($line =~ /Number Of Devices: (.*)/)
			{
				# This doesn't seem to be accurate
				$an->data->{gathered}{dmidecode}{ram}{slots} = $1;
			}
			# This needs to be converted to bytes.
			if ($line =~ /Maximum Capacity: (\d+) (.*)$/)
			{
				my $size   = $1;
				my $suffix = $2;
				$an->data->{gathered}{dmidecode}{ram}{max_support} = $an->Readable->hr_to_bytes({size => $size, type => $suffix })." Bytes";
			}
			if ($line =~ /Maximum Capacity: (.*)/)
			{
				$an->data->{gathered}{dmidecode}{ram}{max_support} = $1;
				$an->data->{gathered}{dmidecode}{ram}{max_support} = $an->Readable->hr_to_bytes({size => $an->data->{gathered}{dmidecode}{ram}{max_support} })." Bytes";
			}
		}
		if ($in_dimm_module)
		{
			if    ($line =~ /^Bank Locator: (.*)/i) { $dimm_bank        = $1; }
			elsif ($line =~ /^Locator: (.*)/i)      { $dimm_locator     = $1; }
			elsif ($line =~ /^Type: (.*)/i)         { $dimm_type        = $1; }
			elsif ($line =~ /^Speed: (.*)/i)        { $dimm_speed       = $1; }
			elsif ($line =~ /^Form Factor: (.*)/i)  { $dimm_form_factor = $1; }
			elsif ($line =~ /^Size: (.*)/i)
			{
				$dimm_size = $1;

				# If the DIMM couldn't be read, it will show "Unknown". I set this to 0 in 
				# that case.
				if ($dimm_size !~ /^\d/)
				{
					$dimm_size = 0;
				}
				else
				{
					$dimm_size                                     =  $an->Readable->hr_to_bytes({size => $dimm_size });
					$an->data->{gathered}{dmidecode}{total_memory} += $dimm_size;
				}
			}
		}
	}
	close $file_handle;
	
	if ($dimm_count)
	{
		$an->data->{gathered}{dmidecode}{ram}{slots} = $dimm_count;
	}
	$an->data->{gathered}{dmidecode}{total_memory} .= " Bytes";
	
	return(0);
}

# Gather DRBD information
sub gather_drbd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_drbd" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Gather drbdadm data
	gather_drbdadm($an);	# Call this first!
	gather_proc_drbd($an);	# Call this second.
	
	return(0);
}

# This gathers data from /proc/drbd
sub gather_proc_drbd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_proc_drbd" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if (not -e $an->data->{path}{proc_drbd})
	{
		$an->data->{gathered}{drbd}{status} = "offline";
		return(0);
	}
	$an->data->{gathered}{drbd}{status} = "online";
	
	my $resource     = "";
	my $minor_number = "";
	my $shell_call   = $an->data->{path}{proc_drbd};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /version: (.*?) \(/)
		{
			$an->data->{gathered}{drbd}{version} = $1;
			next;
		}
		elsif ($line =~ /GIT-hash: (.*?) build by (.*?), (\S+) (.*)$/)
		{
			$an->data->{gathered}{drbd}{git_hash}   = $1;
			$an->data->{gathered}{drbd}{builder}    = $2;
			$an->data->{gathered}{drbd}{build_date} = $3;
			$an->data->{gathered}{drbd}{build_time} = $4;
		}
		else
		{
			# This is just for hash key consistency
			if ($line =~ /^(\d+): cs:(.*?) ro:(.*?)\/(.*?) ds:(.*?)\/(.*?) (.*?) (.*)$/)
			{
				   $minor_number     = $1;
				my $connection_state = $2;
				my $my_role          = $3;
				my $peer_role        = $4;
				my $my_disk_state    = $5;
				my $peer_disk_state  = $6;
				my $drbd_protocol    = $7;
				my $io_flags         = $8;	# See: http://www.drbd.org/users-guide/ch-admin.html#s-io-flags
				   $resource         = $an->data->{gathered}{drbd}{minor_number}{$minor_number}{resource};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
					name1 => "minor_number",     value1 => $minor_number, 
					name2 => "connection_state", value2 => $connection_state, 
					name3 => "my_role",          value3 => $my_role, 
					name4 => "peer_role",        value4 => $peer_role, 
					name5 => "my_disk_state",    value5 => $my_disk_state, 
					name6 => "peer_disk_state",  value6 => $peer_disk_state, 
					name7 => "drbd_protocol",    value7 => $drbd_protocol, 
					name8 => "io_flags",         value8 => $io_flags, 
					name9 => "resource",         value9 => $resource, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{gathered}{drbd}{resource}{$resource}{minor_number}     = $minor_number;
				$an->data->{gathered}{drbd}{resource}{$resource}{connection_state} = $connection_state;
				$an->data->{gathered}{drbd}{resource}{$resource}{role}{me}         = $my_role;
				$an->data->{gathered}{drbd}{resource}{$resource}{role}{peer}       = $peer_role;
				$an->data->{gathered}{drbd}{resource}{$resource}{disk_state}{me}   = $my_disk_state;
				$an->data->{gathered}{drbd}{resource}{$resource}{disk_state}{peer} = $peer_disk_state;
				$an->data->{gathered}{drbd}{resource}{$resource}{drbd_protocol}    = $drbd_protocol;
				$an->data->{gathered}{drbd}{resource}{$resource}{io_flags}         = $io_flags;
			}
			elsif ($line =~ /ns:(.*?) nr:(.*?) dw:(.*?) dr:(.*?) al:(.*?) bm:(.*?) lo:(.*?) pe:(.*?) ua:(.*?) ap:(.*?) ep:(.*?) wo:(.*?) oos:(.*)$/)
			{
				# Details: http://www.drbd.org/users-guide/ch-admin.html#s-performance-indicators
				my $network_sent            = $1;	# KiB send
				my $network_received        = $2;	# KiB received
				my $disk_write              = $3;	# KiB wrote
				my $disk_read               = $4;	# KiB read
				my $activity_log_updates    = $5;	# Number of updates of the activity log area of the meta data.
				my $bitmap_updates          = $6;	# Number of updates of the bitmap area of the meta data.
				my $local_count             = $7;	# Number of open requests to the local I/O sub-system issued by DRBD.
				my $pending_requests        = $8;	# Number of requests sent to the partner, but that have not yet been answered by the latter.
				my $unacknowledged_requests = $9;	# Number of requests received by the partner via the network connection, but that have not yet been answered.
				my $app_pending_requests    = $10;	# Number of block I/O requests forwarded to DRBD, but not yet answered by DRBD.
				my $epoch_objects           = $11;	# Number of epoch objects. Usually 1. Might increase under I/O load when using either the barrier or the none write ordering method.
				my $write_order             = $12;	# Currently used write ordering method: b(barrier), f(flush), d(drain) or n(none).
				my $out_of_sync             = $13;	# KiB that are out of sync
				if    ($write_order eq "b") { $write_order = "barrier"; }
				elsif ($write_order eq "f") { $write_order = "flush"; }
				elsif ($write_order eq "d") { $write_order = "drain"; }
				elsif ($write_order eq "n") { $write_order = "none"; }
				
				$an->data->{gathered}{drbd}{resource}{$resource}{network_sent}            = $an->Readable->hr_to_bytes({size => $network_sent, type => "KiB" })." Bytes";
				$an->data->{gathered}{drbd}{resource}{$resource}{network_received}        = $an->Readable->hr_to_bytes({size => $network_received, type => "KiB" })." Bytes";
				$an->data->{gathered}{drbd}{resource}{$resource}{disk_write}              = $an->Readable->hr_to_bytes({size => $disk_write, type => "KiB" })." Bytes";
				$an->data->{gathered}{drbd}{resource}{$resource}{disk_read}               = $an->Readable->hr_to_bytes({size => $disk_read, type => "KiB" })." Bytes";
				$an->data->{gathered}{drbd}{resource}{$resource}{activity_log_updates}    = $activity_log_updates;
				$an->data->{gathered}{drbd}{resource}{$resource}{bitmap_updates}          = $bitmap_updates;
				$an->data->{gathered}{drbd}{resource}{$resource}{local_count}             = $local_count;
				$an->data->{gathered}{drbd}{resource}{$resource}{pending_requests}        = $pending_requests;
				$an->data->{gathered}{drbd}{resource}{$resource}{unacknowledged_requests} = $unacknowledged_requests;
				$an->data->{gathered}{drbd}{resource}{$resource}{app_pending_requests}    = $app_pending_requests;
				$an->data->{gathered}{drbd}{resource}{$resource}{epoch_objects}           = $epoch_objects;
				$an->data->{gathered}{drbd}{resource}{$resource}{write_order}             = $write_order;
				$an->data->{gathered}{drbd}{resource}{$resource}{out_of_sync}             = $an->Readable->hr_to_bytes({size => $out_of_sync, type => "KiB" })." Bytes";
			}
			else
			{
				# The resync lines aren't consistent, so I pull out data one piece at a time.
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line,
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /sync'ed: (.*?)%/)
				{
					my $percent_synced = $1;
					$an->data->{gathered}{drbd}{resource}{$resource}{syncing} = 1;
					$an->data->{gathered}{drbd}{resource}{$resource}{synced}  = $percent_synced." %";
				}
				if ($line =~ /\((\d+)\/(\d+)\)M/)
				{
					# The 'M' is 'Mibibyte'
					my $left_to_sync  = $1;
					my $total_to_sync = $2;
					
					$an->data->{gathered}{drbd}{resource}{$resource}{left_to_sync}  = $an->Readable->hr_to_bytes({size => $left_to_sync, type => "MiB" })." Bytes";
					$an->data->{gathered}{drbd}{resource}{$resource}{total_to_sync} = $an->Readable->hr_to_bytes({size => $total_to_sync, type => "MiB" })." Bytes";
				}
				if ($line =~ /finish: (\d+):(\d+):(\d+)/)
				{
					my $hours   = $1;
					my $minutes = $2;
					my $seconds = $3;
					$an->data->{gathered}{drbd}{resource}{$resource}{eta_to_sync} = (($hours * 3600) + ($minutes * 60) + $seconds)." Seconds";
				}
				if ($line =~ /speed: (.*?) \((.*?)\)/)
				{
					my $current_speed =  $1;
					my $average_speed =  $2;
					   $current_speed =~ s/,//g;
					   $average_speed =~ s/,//g;
					$an->data->{gathered}{drbd}{resource}{$resource}{current_speed} = $an->Readable->hr_to_bytes({size => $current_speed, type => "KiB" })." Bytes";
					$an->data->{gathered}{drbd}{resource}{$resource}{average_speed} = $an->Readable->hr_to_bytes({size => $average_speed, type => "KiB" })." Bytes";
				}
				if ($line =~ /want: (.*?) K/)
				{
					# The 'want' line is only calculated on the sync target
					my $want_speed =  $1;
					   $want_speed =~ s/,//g;
					$an->data->{gathered}{drbd}{resource}{$resource}{want_speed} = $an->Readable->hr_to_bytes({size => $want_speed, type => "KiB" })." Bytes";
				}
			}
		}
	}
	close $file_handle;
	
	return(0);
}

# This gathers data from drbdadm XML dump
sub gather_drbdadm
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_drbdadm" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $xml_data   = "";
	my $shell_call = $an->data->{path}{drbdadm}." dump-xml";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$xml_data .= "$line\n";
	}
	close $file_handle;
	
	# Now parse with XML::Simple.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "xml_data", value1 => $xml_data,
	}, file => $THIS_FILE, line => __LINE__});
	if ($xml_data)
	{
		my $xml  = XML::Simple->new();
		my $data = $xml->XMLin($xml_data, KeyAttr => {node => 'name'}, ForceArray => 1);
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "data", value1 => $data,
		}, file => $THIS_FILE, line => __LINE__});
		
		foreach my $a (keys %{$data})
		{
			if ($a eq "common")
			{
				$an->data->{gathered}{drbd}{protocol} = defined $data->{common}->[0]->{protocol} ? $data->{common}->[0]->{protocol} : "";
				foreach my $b (@{$data->{common}->[0]->{section}})
				{
					my $name = $b->{name};
					if ($name eq "handlers")
					{
						$an->data->{gathered}{drbd}{fence}{handler}{name} = defined $b->{option}->[0]->{name}  ? $b->{option}->[0]->{name}  : "";
						$an->data->{gathered}{drbd}{fence}{handler}{path} = defined $b->{option}->[0]->{value} ? $b->{option}->[0]->{value} : "";
					}
					elsif ($name eq "disk")
					{
						$an->data->{gathered}{drbd}{fence}{policy} = defined $b->{option}->[0]->{value} ? $b->{option}->[0]->{value} : "";
					}
					elsif ($name eq "syncer")
					{
						$an->data->{gathered}{drbd}{syncer}{rate} = defined $b->{option}->[0]->{value} ? $b->{option}->[0]->{value} : "";
					}
					elsif ($name eq "startup")
					{
						foreach my $c (@{$b->{option}})
						{
							my $name  = $c->{name};
							my $value = defined $c->{value} ? $c->{value} : "";
							$an->data->{gathered}{drbd}{startup}{$name} = $value;
						}
					}
					elsif ($name eq "net")
					{
						foreach my $c (@{$b->{option}})
						{
							my $name  = $c->{name};
							my $value = defined $c->{value} ? $c->{value} : "";
							$an->data->{gathered}{drbd}{net}{$name} = $value;
							
							if ($name =~ /timeout/)
							{
								$an->data->{gathered}{drbd}{net}{$name} .= " ms";
							}
						}
					}
					elsif ($name eq "options")
					{
						foreach my $c (@{$b->{option}})
						{
							my $name  = $c->{name};
							my $value = defined $c->{value} ? $c->{value} : "";
							$an->data->{gathered}{drbd}{options}{$name} = $value;
						}
					}
				}
			}
			elsif ($a eq "resource")
			{
				foreach my $b (@{$data->{resource}})
				{
					my $resource = $b->{name};
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "resource", value1 => $resource, 
					}, file => $THIS_FILE, line => __LINE__});
					foreach my $c (@{$b->{host}})
					{
						my $hostname       = $c->{name};
						my $ip_type        = defined $c->{address}->[0]->{family}                ? $c->{address}->[0]->{family}                : "";
						my $ip_address     = defined $c->{address}->[0]->{content}               ? $c->{address}->[0]->{content}               : "";
						my $tcp_port       = defined $c->{address}->[0]->{port}                  ? $c->{address}->[0]->{port}                  : "";
						my $metadisk       = defined $c->{volume}->[0]->{'meta-disk'}->[0]       ? $c->{volume}->[0]->{'meta-disk'}->[0]       : "";
						my $minor_number   = defined $c->{volume}->[0]->{device}->[0]->{minor}   ? $c->{volume}->[0]->{device}->[0]->{minor}   : "";
						### TODO: Why are these the same?
						my $drbd_device    = defined $c->{volume}->[0]->{device}->[0]->{content} ? $c->{volume}->[0]->{device}->[0]->{content} : "";
						my $backing_device = defined $c->{volume}->[0]->{device}->[0]->{content} ? $c->{volume}->[0]->{device}->[0]->{content} : "";
						
						# This is used for locating a resource by its minor number
						$an->data->{gathered}{drbd}{minor_number}{$minor_number}{resource} = $resource;
						
						# This is where the data itself is stored.
						$an->data->{gathered}{drbd}{resource}{$resource}{metadisk}         = $metadisk;
						$an->data->{gathered}{drbd}{resource}{$resource}{minor_number}     = $minor_number;
						$an->data->{gathered}{drbd}{resource}{$resource}{drbd_device}      = $drbd_device;
						$an->data->{gathered}{drbd}{resource}{$resource}{backing_device}   = $backing_device;
						$an->data->{gathered}{drbd}{resource}{$resource}{connection_state} = "";
						$an->data->{gathered}{drbd}{resource}{$resource}{role}{me}         = "";
						$an->data->{gathered}{drbd}{resource}{$resource}{role}{peer}       = "";
						$an->data->{gathered}{drbd}{resource}{$resource}{disk_state}{me}   = "";
						$an->data->{gathered}{drbd}{resource}{$resource}{disk_state}{peer} = "";
						
						# These entries are per-host.
						$an->data->{gathered}{drbd}{resource}{$resource}{hostname}{$hostname}{ip_address} = $ip_address;
						$an->data->{gathered}{drbd}{resource}{$resource}{hostname}{$hostname}{ip_type}    = $ip_type;
						$an->data->{gathered}{drbd}{resource}{$resource}{hostname}{$hostname}{tcp_port}   = $tcp_port;
					}
					foreach my $c (@{$b->{section}})
					{
						my $name = $c->{name};
						if ($name eq "disk")
						{
							foreach my $d (@{$c->{options}})
							{
								my $name  = $d->{name};
								my $value = $d->{value};
								$an->data->{gathered}{drbd}{res_file}{$resource}{disk}{$name} = $value;
							}
						}
					}
				}
			}
		}
	}
	
	return(0);
}

# Gather information on the daemons.
sub gather_daemons
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_daemons" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->data->{gathered}{sys}{enable_poweroff} = 1;
	$an->data->{gathered}{sys}{enable_withdraw} = 0;
	foreach my $daemon ("cman", "rgmanager", "drbd", "clvmd", "gfs2", "libvirtd")
	{
		$an->data->{gathered}{daemon}{$daemon}{status}    = "unknown";
		$an->data->{gathered}{daemon}{$daemon}{exit_code} = "";
	}
	
	# A few calls where changed from init.d status calls to speed things up
	my $shell_call = "
".$an->data->{path}{initd}."/rgmanager status; ".$an->data->{path}{echo}." striker:rgmanager:\$?; 
".$an->data->{path}{initd}."/corosync status; ".$an->data->{path}{echo}." striker:cman:\$?; 
".$an->data->{path}{initd}."/drbd status; ".$an->data->{path}{echo}." striker:drbd:\$?; 
if [ -e '".$an->data->{path}{proc_drbd}."' ]; 
then 
    ".$an->data->{path}{echo}." striker:drbd:0; 
else 
    ".$an->data->{path}{echo}." striker:drbd:3; 
fi;
if \$(".$an->data->{path}{'grep'}." -q gfs2 ".$an->data->{path}{proc_mounts}."); 
then 
    ".$an->data->{path}{echo}." striker:gfs2:0; 
else 
    ".$an->data->{path}{echo}." striker:gfs2:3; 
fi;
if [ -e '".$an->data->{path}{libvirtd_pid}."' ]; 
then 
    PID=\$(".$an->data->{path}{libvirtd_pid}."); 
    if [ -d \"/proc/\$PID\" ]; 
    then 
        ".$an->data->{path}{echo}." striker:libvirtd:0; 
    else 
        ".$an->data->{path}{echo}." striker:libvirtd:2; 
    fi; 
else 
    ".$an->data->{path}{echo}." striker:libvirtd:0; 
fi;
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		next if $line !~ /^striker:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my ($daemon, $exit_code) = ($line =~ /^.*?:(.*?):(.*?)$/);
		   $exit_code            = "" if not defined $exit_code;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "daemon",    value1 => $daemon,
			name2 => "exit_code", value2 => $exit_code,
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($exit_code eq "0")
		{
			# Running
			$an->data->{gathered}{daemon}{$daemon}{status} = "running";
			$an->data->{gathered}{sys}{enable_poweroff}         = 0;
		}
		elsif ($exit_code eq "3")
		{
			# Stopped
			$an->data->{gathered}{daemon}{$daemon}{status} = "stopped";
		}
		
		$an->data->{gathered}{daemon}{$daemon}{exit_code} = $exit_code;
	}
	close $file_handle;
	
	# If cman is running, enable withdrawl. If not, enable shut down.
	if ($an->data->{gathered}{daemon}{cman}{exit_code} eq "0")
	{
		$an->data->{gathered}{sys}{enable_withdraw} = 1;
	}
	else
	{
		# If something went wrong, one of the storage resources might still be running.
		if (($an->data->{gathered}{daemon}{rgmanager}{exit_code} eq "0") or
		    ($an->data->{gathered}{daemon}{drbd}{exit_code}      eq "0") or
		    ($an->data->{gathered}{daemon}{clvmd}{exit_code}     eq "0") or
		    ($an->data->{gathered}{daemon}{gfs2}{exit_code}      eq "0"))
		{
			# This can happen if the user loads the page (or it auto-loads) while the storage is 
			# coming online.
		}
		else
		{
			# Ready to power off the node.
			$an->data->{gathered}{sys}{enable_poweroff} = 1;
		}
	}
	
	return(0);
}

# This gathers information from the node's /etc/hosts file (so that we can report on the hosts and associated
# IPs this machine cares about).
sub gather_hosts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_hosts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{cat}." ".$an->data->{path}{etc_hosts};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/#.*$//;
		   $line =~ s/\s+$//;
		next if not $line;
		next if $line =~ /^127.0.0.1\s/;
		next if $line =~ /^::1\s/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		
		my $this_ip     = "";
		my $these_hosts = "";
		if ($line =~ /^(\d+\.\d+\.\d+\.\d+)\s+(.*)/)
		{
			$this_ip     = $1;
			$these_hosts = $2;
			foreach my $this_host (split/ /, $these_hosts)
			{
				next if not $this_host;
				$an->data->{gathered}{hosts}{by_name}{$this_host} = $this_ip;
				if (not exists $an->data->{gathered}{hosts}{by_ip}{$this_ip})
				{
					$an->data->{gathered}{hosts}{by_ip}{$this_ip} = "";
				}
				$an->data->{gathered}{hosts}{by_ip}{$this_ip} .= "$this_host ";
			}
		}
	}
	close $file_handle;
	
	# Sort and cleanup the host name lists.
	foreach my $this_ip (sort {$a cmp $b} keys %{$an->data->{gathered}{hosts}{by_ip}})
	{
		my $sorted = "";
		my @names  = split/ /, $an->data->{gathered}{hosts}{by_ip}{$this_ip};
		foreach my $host (sort {$a cmp $b} @names)
		{
			$sorted .= $host." ";
		}
		$sorted =~ s/^\s+//;
		$sorted =~ s/\s+$//;
		$an->data->{gathered}{hosts}{by_ip}{$this_ip} = $sorted;
	}
	
	return(0);
}

# This gets data from cluster.conf, if it exists.
sub gather_bonds
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_bonds" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read the bond file names
	my $files      = [];
	my $shell_call = $an->data->{path}{ls}." ".$an->data->{path}{proc_bonding};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		push @{$files}, $line;
	}
	close $file_handle;
	
	# Read each actual bond file now.
	foreach my $bond (sort {$a cmp $b} @{$files})
	{
		my $full_path =  $an->data->{path}{proc_bonding}."/".$bond;
		   $full_path =~ s/\/\//\//g;
		
		# Read in the bond.
		my $bond_data  = "";
		my $skip_bond  = 1;
		my $shell_call = $full_path;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$bond_data .= $line."\n";
			
			# If I have an interface, I will parse this bond. Note that 'bond0' always seems to 
			# exist, without interfaces, if other bonds exist.
			if ($line =~ /^Slave Interface:/i)
			{
				$skip_bond = 0;
			}
		}
		close $file_handle;
		
		# Parse?
		if (not $skip_bond)
		{
			$an->data->{gathered}{bonds}{$bond}{bonding_mode}         = "";
			$an->data->{gathered}{bonds}{$bond}{primary_interface}    = "";
			$an->data->{gathered}{bonds}{$bond}{reselect_policy}      = "";
			$an->data->{gathered}{bonds}{$bond}{active_interface}     = "";
			$an->data->{gathered}{bonds}{$bond}{mii_status}           = "";
			$an->data->{gathered}{bonds}{$bond}{mii_polling_interval} = "";
			$an->data->{gathered}{bonds}{$bond}{up_delay}             = "";
			$an->data->{gathered}{bonds}{$bond}{down_delay}           = "";
			
			my $interface = "";
			
			foreach my $line (split/\n/, $bond_data)
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "bond", value1 => $bond, 
					name2 => "line", value2 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if (not $line)
				{
					$interface = "";
					next;
				}
				
				if ($line =~ /^Slave Interface: (.*)$/)
				{
					$interface = $1;
					
					# Preset some values
					$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{mii_status}         = "";
					$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{speed}              = "";
					$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{duplex}             = "";
					$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{link_failure_count} = "";
					$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{real_mac_address}   = "";
					$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{queue_id}           = "";
					next;
				}
				
				if ($interface)
				{
					# Processing an interface
					if ($line =~ /MII Status: (.*)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{mii_status} = $1;
					}
					elsif ($line =~ /Speed: (.*)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{speed} = $1;
					}
					elsif ($line =~ /Duplex: (.*)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{duplex} = $1;
					}
					elsif ($line =~ /Link Failure Count: (\d+)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{link_failure_count} = $1;
					}
					elsif ($line =~ /Permanent HW addr: (.*)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{real_mac_address} = $1;
					}
					elsif ($line =~ /Slave queue ID: (\d+)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{interface}{$interface}{queue_id} = $1;
					}
				}
				else
				{
					# Processing the main bond info.
					if ($line =~ /Bonding Mode: .*? \((.*)\)/)
					{
						$an->data->{gathered}{bonds}{$bond}{bonding_mode} = $1;
					}
					elsif ($line =~ /Primary Slave: (.*)/)
					{
						my $slave    = $1;
						my $reselect = "n/a";
						
						if ($slave =~ /^(.*?) \(primary_reselect (.*)\)/)
						{
							$slave    = $1;
							$reselect = $2;
						}
						$an->data->{gathered}{bonds}{$bond}{primary_interface} = $slave;
						$an->data->{gathered}{bonds}{$bond}{reselect_policy}   = $reselect;
					}
					elsif ($line =~ /Currently Active Slave: (.*)/)
					{
						$an->data->{gathered}{bonds}{$bond}{active_interface} = $1;
					}
					elsif ($line =~ /MII Status: (.*)$/)
					{
						$an->data->{gathered}{bonds}{$bond}{mii_status} = $1;
					}
					elsif ($line =~ /MII Polling Interval \(ms\): (\d+)$/)
					{
						my $interval = $1;
						$an->data->{gathered}{bonds}{$bond}{mii_polling_interval} = $interval." ms";
					}
					elsif ($line =~ /Up Delay \(ms\): (\d+)$/)
					{
						my $interval = $1;
						$an->data->{gathered}{bonds}{$bond}{up_delay} = $interval." ms";
					}
					elsif ($line =~ /Down Delay \(ms\): (\d+)$/)
					{
						my $interval = $1;
						$an->data->{gathered}{bonds}{$bond}{down_delay} = $interval." ms";
					}
				}
			}
		}
	}
	
	return(0);
}

# This gets data from cluster.conf, if it exists.
sub gather_cluster_conf
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_cluster_conf" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	return if not -e $an->data->{path}{cluster_conf};
	
	my $in_node                 = "";
	my $in_fence                = 0;
	my $in_method               = "";
	my $device_count            = 0;
	my $in_fence_device         = 0;
	my $this_host_name          = "";
	my $this_node               = "";
	my $method_counter          = 0;
	
	### TODO: Parse this with XML::Simple.
	my $shell_call = $an->data->{path}{cluster_conf};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /<cluster .*?name="(.*?)"/)
		{
			$an->data->{gathered}{anvil}{name} = $1;
		}
		
		# If I didn't get the hostname from clustat, try to find it here.
		if ($line =~ /<clusternode.*?name="(.*?)"/)
		{
			   $this_host_name  =  $1;
			my $short_host_name =  $this_host_name;
			   $short_host_name =~ s/\..*$//;
			   
			# Is this us?
			if (($this_host_name eq $an->data->{gathered}{hostname}{me}) or ($short_host_name eq $an->data->{gathered}{hostname}{me}))
			{
				# This is me.
				$this_node = "me";
			}
			else
			{
				# Must be my peer
				$an->data->{gathered}{hostname}{peer} = $this_host_name;
				$this_node = "peer";
			}
			
			# Mark that I am in a node child element.
			$in_node = $this_host_name;
		}
		if ($line =~ /<\/clusternode>/)
		{
			# Record my fence findings.
			$in_node        = "";
			$this_node      = "";
			$method_counter = 0;
		}
		
		if (($in_node) && ($line =~ /<fence>/))
		{
			$in_fence = 1;
		}
		if ($line =~ /<\/fence>/)
		{
			$in_fence = 0;
		}
		if (($in_fence) && ($line =~ /<method.*name="(.*?)"/))
		{
			# The method counter ensures ordered use of the fence devices.
			$in_method = "$method_counter:$1";
			$method_counter++;
		}
		if ($line =~ /<\/method>/)
		{
			$in_method    = "";
			$device_count = 0;
		}
		if (($in_method) && ($line =~ /<device\s/))
		{
			my $name            = $line =~ /name="(.*?)"/          ? $1 : "";
			my $port            = $line =~ /port="(.*?)"/          ? $1 : "";
			my $action          = $line =~ /action="(.*?)"/        ? $1 : "";
			my $address         = $line =~ /ipaddr="(.*?)"/        ? $1 : "";
			my $login           = $line =~ /login="(.*?)"/         ? $1 : "";
			my $password        = $line =~ /passwd="(.*?)"/        ? $1 : "";
			my $password_script = $line =~ /passwd_script="(.*?)"/ ? $1 : "";
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}            = $name;
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}            = $port;
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}          = $action;
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{address}         = $address;
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{login}           = $login;
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{password}        = $password;
			$an->data->{gathered}{'cluster.conf'}{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{password_script} = $password_script;
			$device_count++;
		}
		
		# Parse out the fence device details.
		if ($line =~ /<fencedevices>/)
		{
			$in_fence_device = 1;
		}
		if ($line =~ /<\/fencedevices>/)
		{
			$in_fence_device = 0;
		}
		
		# This could be duplicated, but I don't care as cluster.conf has to be the same on both 
		# nodes, anyway.
		if ($in_fence_device)
		{
			my $name            = $line =~ /name="(.*?)"/          ? $1 : "";
			my $agent           = $line =~ /agent="(.*?)"/         ? $1 : "";
			my $action          = $line =~ /action="(.*?)"/        ? $1 : "";
			my $address         = $line =~ /ipaddr="(.*?)"/        ? $1 : "";
			my $login           = $line =~ /login="(.*?)"/         ? $1 : "";
			my $password        = $line =~ /passwd="(.*?)"/        ? $1 : "";
			my $password_script = $line =~ /passwd_script="(.*?)"/ ? $1 : "";
			
			# If the password has a single-quote, ricci changes it to &apos;. We need to change it back.
			$password =~ s/&apos;/'/g;
			
			$an->data->{gathered}{'cluster.conf'}{fence}{$name}{agent}           = $agent;
			$an->data->{gathered}{'cluster.conf'}{fence}{$name}{action}          = $action;
			$an->data->{gathered}{'cluster.conf'}{fence}{$name}{address}         = $address;
			$an->data->{gathered}{'cluster.conf'}{fence}{$name}{login}           = $login;
			$an->data->{gathered}{'cluster.conf'}{fence}{$name}{password}        = $password;
			$an->data->{gathered}{'cluster.conf'}{fence}{$name}{password_script} = $password_script;
		}
		
		# Find servers.
		if ($line =~ /<vm.*?name="(.*?)"/)
		{
			my $server     = $1;
			my $server_key = $server;
			my $definition = ($line =~ /path="(.*?)"/)[0].$server.".xml";
			my $domain     = ($line =~ /domain="(.*?)"/)[0];
			
			# I need to set the host to 'none' to avoid triggering the error caused by seeing and
			# foo.xml server definition outside of here.
			$an->data->{gathered}{'cluster.conf'}{server}{$server_key}{definition_file} = $definition;
			$an->data->{gathered}{'cluster.conf'}{server}{$server_key}{failover_domain} = $domain;
			$an->data->{gathered}{'cluster.conf'}{server}{$server_key}{host}            = "none" if not $an->data->{server}{$server_key}{host};
		}
	}
	close $file_handle;
	
	return(0);
}

# This gathers data from 'clustat'
sub gather_clustat
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_clustat" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	return if not -e $an->data->{path}{cluster_conf};
	
	# Setup some variables.
	my $in_member  = 0;
	my $in_service = 0;
	my $line_num   = 0;
	
	# Default is 'unknown'
	$an->data->{gathered}{clustat}{name}{me}        = "unknown";
	$an->data->{gathered}{clustat}{name}{peer}      = "unknown";
	$an->data->{gathered}{clustat}{cman}{me}        = 0;
	$an->data->{gathered}{clustat}{cman}{peer}      = 0;
	$an->data->{gathered}{clustat}{rgmanager}{me}   = 0;
	$an->data->{gathered}{clustat}{rgmanager}{peer} = 0;
	$an->data->{gathered}{clustat}{enable_join}     = 0;
	$an->data->{gathered}{clustat}{hung}            = 0;
	
	my $xml_data   = "";
	my $timeout    = 5;
	my $shell_call = $an->data->{path}{timeout}." $timeout ".$an->data->{path}{clustat}." -x; ".$an->data->{path}{echo}." clustat:\$?";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});

		if ($line =~ /clustat:(\d+)/)
		{
			### TODO: If this is 124, make sure sane null values are set because timeout fired.
			my $return_code = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "return_code", value1 => $return_code,
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($return_code eq "124")
			{
				# Timeout fired, clustat is hung
				$an->data->{gathered}{clustat}{hung} = 1;
			}
			next;
		}
		if ($line =~ /Could not connect to CMAN/i)
		{
			# CMAN isn't running.
			$an->data->{gathered}{clustat}{enable_join} = 1;
			next;
		}
		$xml_data .= $line."\n";
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "xml_data", value1 => $xml_data,
	}, file => $THIS_FILE, line => __LINE__});
	if ($xml_data)
	{
		my $xml     = XML::Simple->new();
		my $clustat = $xml->XMLin($xml_data, KeyAttr => {node => 'name'}, ForceArray => 1);
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "clustat", value1 => $clustat,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record the cluster name and current version
		$an->data->{gathered}{clustat}{cluster}{version} = $clustat->{cluster}->[0]->{generation};
		$an->data->{gathered}{clustat}{cluster}{name}    = $clustat->{cluster}->[0]->{name};
		
		# Dig out the node details
		foreach my $this_node (sort {$a cmp $b} keys %{$clustat->{nodes}->[0]->{node}})
		{
			my $is_local     = $clustat->{nodes}->[0]->{node}{$this_node}{'local'};
			my $rgmanager_up = $clustat->{nodes}->[0]->{node}{$this_node}{rgmanager};
			my $cman_up      = $clustat->{nodes}->[0]->{node}{$this_node}{'state'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "this_node",    value1 => $this_node,
				name2 => "is_local",     value2 => $is_local,
				name3 => "rgmanager_up", value3 => $rgmanager_up,
				name4 => "cman_up",      value4 => $cman_up,
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($is_local)
			{
				# It's moi!
				$an->data->{gathered}{clustat}{name}{me}      = $this_node;
				$an->data->{gathered}{clustat}{cman}{me}      = $cman_up;
				$an->data->{gathered}{clustat}{rgmanager}{me} = $rgmanager_up;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "gathered::clustat::name::me",      value1 => $an->data->{gathered}{clustat}{name}{me},
					name2 => "gathered::clustat::cman::me",      value2 => $an->data->{gathered}{clustat}{cman}{me},
					name3 => "gathered::clustat::rgmanager::me", value3 => $an->data->{gathered}{clustat}{rgmanager}{me},
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# C'est le peer.
				$an->data->{gathered}{clustat}{name}{peer}      = $this_node;
				$an->data->{gathered}{clustat}{cman}{peer}      = $cman_up;
				$an->data->{gathered}{clustat}{rgmanager}{peer} = $rgmanager_up;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "gathered::clustat::name::peer",      value1 => $an->data->{gathered}{clustat}{name}{peer},
					name2 => "gathered::clustat::cman::peer",      value2 => $an->data->{gathered}{clustat}{cman}{peer},
					name3 => "gathered::clustat::rgmanager::peer", value3 => $an->data->{gathered}{clustat}{rgmanager}{peer},
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Dig out the service (group) details
		foreach my $hash_ref (@{$clustat->{groups}->[0]->{group}})
		{
			my $service_name =  $hash_ref->{name};
			my $is_server    =  $service_name =~ /^vm:/ ? 1 : 0;
			   $service_name =~ s/^.*?://;
			my $host         =  $hash_ref->{owner};
			my $state        =  $hash_ref->{state_str};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "is_server",    value1 => $is_server, 
				name2 => "service_name", value2 => $service_name, 
				name3 => "host",         value3 => $host, 
				name4 => "state",        value4 => $state, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Clean up the state
			if (($state eq "disabled") or ($state eq "stopped"))
			{
				# Set host to 'none'.
				$host = "none";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "host", value1 => $host,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($state eq "failed")
			{
				# It is possible the server is still running. We don't know...
				$host = "unknown";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "host", value1 => $host,
				}, file => $THIS_FILE, line => __LINE__});
			}
			if (not $host)
			{
				$host = "none";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "host", value1 => $host,
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Record the data... Server or service?
			if ($is_server)
			{
				# Server
				$an->data->{gathered}{clustat}{server}{$service_name}{host}    = $host;
				$an->data->{gathered}{clustat}{server}{$service_name}{'state'} = $state;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "gathered::clustat::server::${service_name}::host",  value1 => $an->data->{gathered}{clustat}{server}{$service_name}{host}, 
					name2 => "gathered::clustat::server::${service_name}::state", value2 => $an->data->{gathered}{clustat}{server}{$service_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Service
				$an->data->{gathered}{clustat}{service}{$service_name}{host}    = $host;
				$an->data->{gathered}{clustat}{service}{$service_name}{'state'} = $state;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "gathered::clustat::service::${service_name}::host",  value1 => $an->data->{gathered}{clustat}{service}{$service_name}{host}, 
					name2 => "gathered::clustat::service::${service_name}::state", value2 => $an->data->{gathered}{clustat}{service}{$service_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		### NOTE: There is a lot more data in here that we don't, currently, care about.
		#print "<pre>\n";
		#print Dumper $clustat;
		#print "</pre>\n";
	}
	close $file_handle;
	
	return(0);
}

# This gets my hostname (and will later be used to determine the peer's hostname).
sub gather_hostname
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "gather_hostname" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{hostname};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0022", message_variables => { shell_call => $shell_call, error => $! }, code => 30, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line)
		{
			$an->data->{gathered}{hostname}{me} = $line;
		}
	}
	close $file_handle;
	
	if ($an->data->{gathered}{hostname}{me} eq "unknown")
	{
		print "error = unknown host name\n";
		$an->nice_exit({exit_code => 1});
	}
	
	return(0);
}

# This reports what we've found.
sub report_findings
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "report_findings" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $variable = "";
	foreach my $key (sort {$a cmp $b} keys %{$an->data->{gathered}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "key", value1 => $key, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (ref($an->data->{gathered}{$key}) eq "HASH")
		{
			walk_hash_reference($an, $an->data->{gathered}{$key}, $key);
		}
		else
		{
			# This is a terminal key.
			next if (($an->data->{sys}{hide_empty}) && ($an->data->{gathered}{$key} eq ""));
			print "$key = [".$an->data->{gathered}{$key}."]\n";
		}
	}
	
	return(0);
}

# This walks a hash reference, decending deeper as needed.
sub walk_hash_reference
{
	my ($an, $hash_reference, $variable) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "walk_hash_reference" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "hash_reference", value1 => $hash_reference,  
		name2 => "variable",       value2 => $variable,  
	}, file => $THIS_FILE, line => __LINE__});
	
	foreach my $key (sort {$a cmp $b} keys %{$hash_reference})
	{
		my $new_variable = $variable."::".$key;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "key",          value1 => $key, 
			name2 => "new_variable", value2 => $new_variable, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (ref($hash_reference->{$key}) eq "HASH")
		{
			walk_hash_reference($an, $hash_reference->{$key}, $new_variable);
		}
		else
		{
			# This is a terminal key.
			next if (($an->data->{sys}{hide_empty}) && ($hash_reference->{$key} eq ""));
			# For now, we hide the XML data. We may present it later.
			next if (($new_variable =~ /^server::/) && ($new_variable =~ /::definition::/));
			print "$new_variable = [".$hash_reference->{$key}."]\n";
		}
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "ars_message_0001"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
