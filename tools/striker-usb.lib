#!/usr/bin/perl
#
# This library is used by striker-usb-insert and an-usr-remove udev scripts.

use strict;
use warnings;
use File::Path qw(make_path);
use Net::SSH2;

my $THIS_FILE = "striker-usb.lib";

# This sets up default values in the $conf hash reference.
sub inititialize_configuration
{
	# nothing read in.
	my $conf = {
		devices	=>	{},
		path	=>	{
			blkid			=>	"/sbin/blkid",
			cryptsetup		=>	"/sbin/cryptsetup",
			df			=>	"/bin/df",
			dmsetup			=>	"/sbin/dmsetup",
			echo			=>	"/bin/echo",
			'grep'			=>	"/bin/grep",
			ls			=>	"/bin/ls",
			'mkdir'			=>	"/bin/mkdir",
			mkfs			=>	"/sbin/mkfs",
			mount			=>	"/bin/mount",
			striker_conf		=>	"/etc/striker/striker.conf",
			tail			=>	"/usr/bin/tail",
			umount			=>	"/bin/umount",
		},
		sys	=>	{
			partition_seen		=>	0,
			remote			=>	"",
		},
		syslog	=>	[],
	};
	
	return($conf);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $file, $line_number, $message) = @_;
	
	# Print the message to the screen.
	print "$file $line_number: $message\n";
	
	# We split on new-lines so that multi-line message render better in
	# syslog.
	my $is_debug = $message =~ /\[ Debug \]/ ? 1 : 0;
	foreach my $line (split/\n/, $message)
	{
		next if not $line;
		if (($is_debug) && ($line !~ /\[ Debug \]/))
		{
			$line = "[ Debug ]   $line";
		}
		$line =~ s/\t/    /g;
		open my $filehandle, '-|', "logger", "-t", $file, "$line_number: $line" or die "Failed to call: [logger -t $THIS_FILE $line]. Error: $!\n";
		while (<$filehandle>)
		{
			print $_;
		}
		close $filehandle;
	}
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	my $fh = IO::Handle->new();
	my $sc = "$conf->{path}{striker_conf}";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		next if $line !~ /=/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		_make_hash_reference($conf, $var, $val);
	}
	$fh->close();
	
	return(0);
}

# Read the last 100 lines of /var/log/messages looking for which USB device was
# plugged in or removed.
sub read_syslog
{
	my ($conf) = @_;
	
	# I'm interested in the last 24 lines, but this is safer in case
	# something is being noisy.
	my $sc = "$conf->{path}{tail} -n 100 /var/log/messages";
	open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
	while (<$filehandle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, $THIS_FILE, __LINE__, "line: [$line]");
		next if $line !~ /kernel:/;
		if ($line =~ /New USB device found/)
		{
			# Old logs, clear what I've read so far.
			#logger($conf, $THIS_FILE, __LINE__, "I see a message in syslog about a new USB device, clearing anything seen before.");
			$conf->{syslog} = [];
			push @{$conf->{syslog}}, $line;
			next;
		}
		else
		{
			push @{$conf->{syslog}}, $line;
		}
	}
	close $filehandle;
	
	return(0);
}

# This calls the target machine and runs a command.
sub remote_call
{
	my ($conf, $parameters) = @_;
	
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - parameters->{password}: [$parameters->{password}], sys::root_password: [$conf->{sys}{root_password}]");
	my $remote     = $parameters->{remote}           ? $parameters->{remote}   : $conf->{sys}{remote};
	my $port       = $parameters->{port}             ? $parameters->{port}     : $conf->{sys}{ssh_port};
	my $user       = $parameters->{user}             ? $parameters->{user}     : "root";
	my $password   = $parameters->{password}         ? $parameters->{password} : $conf->{sys}{password};
	my $ssh_fh     = $parameters->{ssh_fh}           ? $parameters->{ssh_fh}   : "";
	my $close      = defined $parameters->{'close'}  ? $parameters->{'close'}  : 1;
	my $shell_call = $parameters->{shell_call};
	logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote: [$remote], port: [$port], user: [$user], password: [---], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]");
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote: [$remote], port: [$port], user: [$user], password: [$password], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]");
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote: [$remote], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]");
	
	# Break out the port, if needed.
	my $state;
	my $error;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - remote: [$remote]");
	if ($remote =~ /^(.*):(\d+)$/)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - >> remote: [$remote], port: [$port]");
		$remote = $1;
		$port   = $2;
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - << remote: [$remote], port: [$port]");
		if (($port < 0) || ($port > 65536))
		{
			# Variables for 'message_0373'.
			logger($conf, $THIS_FILE, __LINE__, "[ Error ] - The TCP port: [$port] is out of range. It must be between 1 and 65536. The default is '22'.");
			logger($conf, $THIS_FILE, __LINE__, "[ Error ]   The error was hit calling: [$shell_call]");
			exit(8);
		}
	}
	
	# These will be merged into a single 'output' array before returning.
	my $stdout_output = [];
	my $stderr_output = [];
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - ssh_fh: [$ssh_fh]");
	if ($ssh_fh !~ /^Net::SSH2/)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Opening an SSH connection to: [$user\@$remote:$port]");
		$ssh_fh = Net::SSH2->new();
		if (not $ssh_fh->connect($remote, $port, Timeout => 10))
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - error: [$@]");
			if ($@ =~ /Bad hostname/)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to the host: [$remote]");
				logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Error was: [$@]");
				exit(9);
			}
			elsif ($@ =~ /Connection refused/)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to the host: [$remote]");
				logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Error was: [$@]");
				exit(10);
			}
			elsif ($@ =~ /No route to host/)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to the host: [$remote]");
				logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Error was: [$@]");
				exit(11);
			}
			elsif ($@ =~ /timeout/)
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to the host: [$remote]");
				logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Error was: [$@]");
				exit(12);
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to the host: [$remote]");
				logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Error was: [$@]");
				exit(13);
			}
		}
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - error: [$error], ssh_fh: [$ssh_fh]");
		if (not $error)
		{
			#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - user: [$user], password: [$password]");
			if (not $ssh_fh->auth_password($user, $password)) 
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Error ] - Failed to connect to the host: [$remote]");
				logger($conf, $THIS_FILE, __LINE__, "[ Error ]   Please check that the password provides is the correct password for 'root' on the target machine.");
				exit(14);
			}
			else
			{
				logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - SSH session opened to: [$remote].");
			}
			$conf->{node}{$remote}{ssh_fh} = $ssh_fh;
		}
	}
	
	### Special thanks to Rafael Kitover (rkitover@gmail.com), maintainer
	### of Net::SSH2, for helping me sort out the polling and data
	### collection in this section.
	#
	# Open a channel and make the call.
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - error: [$error], ssh_fh: [$ssh_fh]");
	if (($ssh_fh =~ /^Net::SSH2/) && (not $error))
	{
		# We need to open a channel every time for 'exec' calls. We
		# want to keep blocking off, but we need to enable it for the
		# channel() call.
		$ssh_fh->blocking(1);
		my $channel = $ssh_fh->channel();
		$ssh_fh->blocking(0);
		
		# Make the shell call
		if (not $channel)
		{
			$error  = "Failed to establish channel to remote: [$remote] for shell call: [$shell_call]\n";
			$ssh_fh = "";
		}
		else
		{
			logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - channel: [$channel], shell_call: [$shell_call]");
			$channel->exec("$shell_call");
			#"/etc/ssh/ssh_config",
			# This keeps the connection open when the remote side is slow
			# to return data, like in '/etc/init.d/rgmanager stop'.
			my @poll = {
				handle => $channel,
				events => [qw/in err/],
			};
			
			# We'll store the STDOUT and STDERR data here.
			my $stdout = "";
			my $stderr = "";
			
			# Not collect the data.
			while(1)
			{
				$ssh_fh->poll(250, \@poll);
				
				# Read in anything from STDOUT
				while($channel->read(my $chunk, 80))
				{
					$stdout .= $chunk;
				}
				while ($stdout =~ s/^(.*)\n//)
				{
					my $line = $1;
					#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - STDOUT: [$line].");
					push @{$stdout_output}, $line;
				}
				
				# Read in anything from STDERR
				while($channel->read(my $chunk, 80, 1))
				{
					$stderr .= $chunk;
				}
				while ($stderr =~ s/^(.*)\n//)
				{
					my $line = $1;
					#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - STDERR: [$line].");
					push @{$stderr_output}, $line;
				}
				
				# Exit when we get the end-of-file.
				last if $channel->eof;
			}
			if ($stdout)
			{
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] -stdout: [$stdout]. ");
				push @{$stdout_output}, $stdout;
			}
			if ($stderr)
			{
				#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - stderr: [$stderr].");
				push @{$stderr_output}, $stderr;
			}
		}
	}
	
	# Merge the STDOUT and STDERR
	my $output = [];
	
	foreach my $line (@{$stderr_output}, @{$stdout_output})
	{
		#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Merge; line: [$line]");
		push @{$output}, $line;
	}
	
	# Close the connection if requested.
	if ($close)
	{
		logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - Disconnecting from: [$remote]");
		$ssh_fh->disconnect();
		
		# For good measure, blank both variables.
		$conf->{remote}{$remote}{ssh_fh} = "";
		$ssh_fh                          = "";
	}
	
	$error = "" if not defined $error;
	#logger($conf, $THIS_FILE, __LINE__, "[ Debug ] - error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]");
	return($error, $ssh_fh, $output);
}

###############################################################################
# Sssh, there are private functions                                           #
###############################################################################

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

1;
