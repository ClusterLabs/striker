#!/usr/bin/perl
#
# This library is used by striker-usb-insert and an-usr-remove udev scripts.

use strict;
use warnings;
use File::Path qw(make_path);
use Net::SSH2;

my $THIS_FILE = "striker-usb.lib";

# This sets up default values in the $conf hash reference.
sub inititialize_configuration
{
	# nothing read in.
	my $conf = {
		devices	=>	{},
		path	=>	{
			'striker-usb_conf'	=>	"/etc/striker/striker-usb.conf",
			blkid			=>	"/sbin/blkid",
			df			=>	"/bin/df",
			ls			=>	"/bin/ls",
			'mkdir'			=>	"/bin/mkdir",
			mount			=>	"/bin/mount",
			tail			=>	"/usr/bin/tail",
			umount			=>	"/bin/umount",
		},
		sys	=>	{
			remote			=>	"",
		},
		syslog	=>	[],
	};
	
	return($conf);
}

# Write entries to syslog and STDOUT.
sub logger
{
	my ($conf, $line_number, $message) = @_;
	
	print "$line_number: $message\n";
	open my $filehandle, '-|', "logger", "-t", $THIS_FILE , "$line_number: $message" or die "Failed to call: [logger -t $THIS_FILE $message]. Error: $!\n";
	while (<$filehandle>)
	{
		print $_;
	}
	close $filehandle;
	
	return(0);
}

# This reads in the configuration file.
sub read_configuration
{
	my ($conf) = @_;
	
	my $fh = IO::Handle->new();
	my $sc = "$conf->{path}{'striker-usb_conf'}";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		next if $line !~ /=/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		_make_hash_reference($conf, $var, $val);
	}
	$fh->close();
	
	return(0);
}

# Read the last 100 lines of /var/log/messages looking for which USB device was
# plugged in or removed.
sub read_syslog
{
	my ($conf) = @_;
	
	# I'm interested in the last 24 lines, but this is safer in case
	# something is being noisy.
	my $sc = "$conf->{path}{tail} -n 100 /var/log/messages";
	open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
	while (<$filehandle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, __LINE__, "line: [$line]");
		next if $line !~ /kernel:/;
		if ($line =~ /New USB device found/)
		{
			# Old logs, clear what I've read so far.
			#logger($conf, __LINE__, "I see a message in syslog about a new USB device, clearing anything seen before.");
			$conf->{syslog} = [];
			push @{$conf->{syslog}}, $line;
			next;
		}
		else
		{
			push @{$conf->{syslog}}, $line;
		}
	}
	close $filehandle;
	
	return(0);
}

# This calls the target machine and runs a command.
sub remote_call
{
	my ($conf, $parameters) = @_;
	
	#print "[ Debug ] ".__LINE__."; parameters->{password}: [$parameters->{password}], sys::root_password: [$conf->{sys}{root_password}]\n";
	my $remote     = $parameters->{remote}           ? $parameters->{remote}   : $conf->{sys}{remote};
	my $port       = $parameters->{port}             ? $parameters->{port}     : $conf->{sys}{ssh_port};
	my $user       = $parameters->{user}             ? $parameters->{user}     : "root";
	my $password   = $parameters->{password}         ? $parameters->{password} : $conf->{sys}{password};
	my $ssh_fh     = $parameters->{ssh_fh}           ? $parameters->{ssh_fh}   : "";
	my $close      = defined $parameters->{'close'}  ? $parameters->{'close'}  : 1;
	my $shell_call = $parameters->{shell_call};
	#print "[ Debug ] ".__LINE__."; remote: [$remote], port: [$port], user: [$user], password: [$password], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]\n";
	#print "[ Debug ] ".__LINE__."; remote: [$remote], ssh_fh: [$ssh_fh], close: [$close], shell_call: [$shell_call]\n";
	
	# Break out the port, if needed.
	my $state;
	my $error;
	#print "[ Debug ] ".__LINE__."; remote: [$remote]\n";
	if ($remote =~ /^(.*):(\d+)$/)
	{
		#print "[ Debug ] ".__LINE__."; >> remote: [$remote], port: [$port]\n";
		$remote = $1;
		$port   = $2;
		#print "[ Debug ] ".__LINE__."; << remote: [$remote], port: [$port]\n";
		if (($port < 0) || ($port > 65536))
		{
			# Variables for 'message_0373'.
			print "[ Error ] ".__LINE__."; - The TCP port: [$port] is out of range. It must be between 1 and 65536. The default is '22'.\n";
			print "[ Error ] ".__LINE__.";   The error was hit calling: [$shell_call]\n";
			exit(8);
		}
	}
	
	# These will be merged into a single 'output' array before returning.
	my $stdout_output = [];
	my $stderr_output = [];
	#print "[ Debug ] ".__LINE__."; ssh_fh: [$ssh_fh]\n";
	if ($ssh_fh !~ /^Net::SSH2/)
	{
		#print "[ Debug ] ".__LINE__."; Opening an SSH connection to: [$user\@$remote:$port].\n";
		$ssh_fh = Net::SSH2->new();
		if (not $ssh_fh->connect($remote, $port, Timeout => 10))
		{
			print "[ Debug ] ".__LINE__."; error: [$@]\n";
			if ($@ =~ /Bad hostname/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(9);
			}
			elsif ($@ =~ /Connection refused/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(10);
			}
			elsif ($@ =~ /No route to host/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(11);
			}
			elsif ($@ =~ /timeout/)
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(12);
			}
			else
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Error was: [$@]\n";
				exit(13);
			}
		}
		#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh]\n";
		if (not $error)
		{
			#print "[ Debug ] ".__LINE__."; user: [$user], password: [$password]\n";
			if (not $ssh_fh->auth_password($user, $password)) 
			{
				print "[ Debug ] ".__LINE__."; - Failed to connect to the host: [$remote]\n";
				print "[ Debug ] ".__LINE__.";   Please check that the password provides is the correct password for 'root' on the target machine.\n";
				exit(14);
			}
			else
			{
				#print "[ Debug ] ".__LINE__."; SSH session opened to: [$remote].\n";
			}
			$conf->{node}{$remote}{ssh_fh} = $ssh_fh;
		}
	}
	
	### Special thanks to Rafael Kitover (rkitover@gmail.com), maintainer
	### of Net::SSH2, for helping me sort out the polling and data
	### collection in this section.
	#
	# Open a channel and make the call.
	#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh]\n";
	if (($ssh_fh =~ /^Net::SSH2/) && (not $error))
	{
		# We need to open a channel every time for 'exec' calls. We
		# want to keep blocking off, but we need to enable it for the
		# channel() call.
		$ssh_fh->blocking(1);
		my $channel = $ssh_fh->channel();
		$ssh_fh->blocking(0);
		
		# Make the shell call
		if (not $channel)
		{
			$error  = "Failed to establish channel to remote: [$remote] for shell call: [$shell_call]\n";
			$ssh_fh = "";
		}
		else
		{
			#print "[ Debug ] ".__LINE__."; channel: [$channel], shell_call: [$shell_call]\n";
			$channel->exec("$shell_call");
			#"/etc/ssh/ssh_config",
			# This keeps the connection open when the remote side is slow
			# to return data, like in '/etc/init.d/rgmanager stop'.
			my @poll = {
				handle => $channel,
				events => [qw/in err/],
			};
			
			# We'll store the STDOUT and STDERR data here.
			my $stdout = "";
			my $stderr = "";
			
			# Not collect the data.
			while(1)
			{
				$ssh_fh->poll(250, \@poll);
				
				# Read in anything from STDOUT
				while($channel->read(my $chunk, 80))
				{
					$stdout .= $chunk;
				}
				while ($stdout =~ s/^(.*)\n//)
				{
					my $line = $1;
					#print "[ Debug ] ".__LINE__."; STDOUT: [$line].\n";
					push @{$stdout_output}, $line;
				}
				
				# Read in anything from STDERR
				while($channel->read(my $chunk, 80, 1))
				{
					$stderr .= $chunk;
				}
				while ($stderr =~ s/^(.*)\n//)
				{
					my $line = $1;
					#print "[ Debug ] ".__LINE__."; STDERR: [$line].\n";
					push @{$stderr_output}, $line;
				}
				
				# Exit when we get the end-of-file.
				last if $channel->eof;
			}
			if ($stdout)
			{
				#print "[ Debug ] ".__LINE__."; stdout: [$stdout].\n";
				push @{$stdout_output}, $stdout;
			}
			if ($stderr)
			{
				#print "[ Debug ] ".__LINE__."; stderr: [$stderr].\n";
				push @{$stderr_output}, $stderr;
			}
		}
	}
	
	# Merge the STDOUT and STDERR
	my $output = [];
	
	foreach my $line (@{$stderr_output}, @{$stdout_output})
	{
		#print "[ Debug ] ".__LINE__."; Merge; line: [$line]\n";
		push @{$output}, $line;
	}
	
	# Close the connection if requested.
	if ($close)
	{
		#print "[ Debug ] ".__LINE__."; Disconnecting from: [$remote]\n";
		$ssh_fh->disconnect();
		
		# For good measure, blank both variables.
		$conf->{remote}{$remote}{ssh_fh} = "";
		$ssh_fh                      = "";
	}
	
	$error = "" if not defined $error;
	#print "[ Debug ] ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n";
	return($error, $ssh_fh, $output);
}

###############################################################################
# Sssh, there are private functions                                           #
###############################################################################

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

1;
