#!/usr/bin/perl
# 
# This takes a stock RHEL or CentOS 6.x ISO as the source for generating a Anvil! install ISO. 
# 
# This DOES NOT rely on AN::Tools perl modules as most users will not have them installed when they run this.
# For the same reason, translations are not (yet) supported.
# 
# 
# It was created to avoid legal concerns regarding redistributing modified CentOS or RHEL ISOs. Please use it
# with this spirit in mind and do not make available the resulting ISOs for general download unless you get
# written permission from Alteeve's Niche! and either Red Hat or CentOS, depending on the generated ISO.
# 
# (c) Alteeve's Niche! Inc, 2016 - https://alteeve.ca
# 
# This program is released under the GPL v2+
# 
# Return Codes
# 0  = Successful run
# 1  = Source ISO(s) not found
# 2  = Source(es( not mounted and 'isoinfo' and/or 'iso-read' not installed.
# 3  = Source ISO(s) have unrecognized mds5 sums.
# 4  = No source ISO given
# 5  = Failed to copy a file to Packages/ but the shell call itself didn't fail.
# 6  = Failed to clone Striker from github.
# 7  = Failed to download an RPM from an-repo.
# 8  = User rejected the creation of the working directory.
# 

use strict;
use warnings;
use IO::Handle;
use Data::Dumper;

my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	        $running_directory =~ s/^\./$ENV{PWD}/;
}

my $conf = {
	# Executable programs. We will search for these in PATH if not pre-defined (start with '/...').
	executable	=>	{
		createrepo	=>	"createrepo",
		cp		=>	"cp",
		curl		=>	"curl",
		git		=>	"git",
		isoinfo		=>	"isoinfo",
		'iso-read'	=>	"iso-read",
		md5sum		=>	"md5sum",
		mkisofs		=>	"mkisofs",
		mount		=>	"mount",
	},
	# Paths to files and directories
	path		=>	{
		# This details files to be copied out of git to a directory in the source.
		git		=>	{
			# This is where we find the root of the ISO data from the git checkout under 
			# 'path::source_path'.
			root		=>	"striker/ISO",
			# These are the subdirectory names we'll used under 'path::git::root' depending on
			# the OS being build on.
			centos		=>	"CentOS",
			rhel		=>	"RHEL",
			suffix		=>	"6/Anvil",
			
		},
		# Directories and files we download, copy or create will be placed under this directory, 
		# which itself will be appended to the user's home directory.
		working_dir	=>	"anvil",
		# This will be the root of the ISO. The 'working_dir' above will hold other temporary files
		# like things we need to download.
		source_path	=>	"source",
		# These diretories are needed for the ISO and will be made under 'source_path' as needed.
		iso		=>	{
			kickstart	=>	"ks",
			striker		=>	"striker",	# striker-master will be created by git
			packages	=>	"Packages",
			fence		=>	"Tools/fence",
			fujitsu		=>	"Tools/Fujitsu",
			avago		=>	"Tools/Avago",
			git_iso		=>	"ISO",
			# These keys are appended to the 'path::'git::<os>' path. The 'target' is where the 
			# files in these directories should be copied to. The 'target' will be appended to
			# 'path::source_path'.
			git_copy	=>	{
				isolinux	=>	{
					target		=>	"isolinux",
				},
				syslinux	=>	{
					target		=>	"syslinux",
				},
				ks		=>	{
					target		=>	"ks",
				},
			}
		},
	},
	source		=>	{},
	source_packages	=>	{},
	sys		=>	{
		debug		=>	1,
		md5sum		=>	{
			'a2bc9de743bfb0bfe1f14676a46a624b'	=>	"RHEL 6.7, Disk 1",	# v6.7
			'51f90e8ddd2ea199780065eaf75130ad'	=>	"CentOS 6.7, Disk 1",	# v6.7, Disk 1
			'efd54b939787519b350d986329e2c7a3'	=>	"CentOS 6.7, Disk 2",	# v6.7, Disk 2
		},
		# This will be set to 'rhel' or 'centos', depending on the source ISO type.
		os		=>	"",
		source		=>	{
			iso		=>	[],
		},
		use_anvil	=>	0,
		# This is will be set to '1' if the source ISO is not mounted.
		use_isoread	=>	0,
		user		=>	{
			name		=>	$ENV{USER},
			home		=>	$ENV{HOME},
			current_dir	=>	$ENV{PWD},
		},
		# These are the request for permission to download third-party tools.
		third_party	=>	{
			Avago		=>	{
				terms		=>	"https://alteeve.ca/an-repo/el6/Third_Party/Avago/#tc",
				agreed		=>	0,
			},
			Fujitsu		=>	{
				terms		=>	"https://alteeve.ca/an-repo/el6/Third_Party/Fujitsu/#tc",
				agreed		=>	0,
			},
		},
	},
	url		=>	{
		striker		=>	"https://github.com/ClusterLabs/striker.git",
		'an-repo'	=>	"https://alteeve.ca/an-repo/el6/RPMS",
		third_party	=>	"https://alteeve.ca/an-repo/el6/Third_Party",
		# These are non-RPM packages we want to download for the ISO.
		Fujitsu		=>	{
			primecollect	=>	{
				url		=>	"https://alteeve.ca/an-repo/el6/Third_Party/Fujitsu/PrimeCollect.shar",
				mode		=>	0755,
			},
		},
	},
};

get_switches($conf);
$conf->{sys}{debug} = 1 if $conf->{switches}{debug};
if (($conf->{switches}{h})   || 
    ($conf->{switches}{'?'}) ||
    ($conf->{switches}{help}))
{
	print_usage($conf);
	exit(0);
}

# Make sure we know where executables are on this system.
find_executables($conf);

# Ask the user to ACK third party tools
agree_to_terms($conf);

# Possibly useful later
#foreach my $key (sort {$a cmp $b} keys %ENV) { print "$key\t->\t[$ENV{$key}]\n"; } exit;

# Setup our build environment. This creates the directories we'll need for the new ISO, copy over isolinux
# and syslinux, ask the user to download binary files, load our kickstart scripts and splash screens, etc.
setup_build_environment($conf); 

# Genreate an MD5 sum and see if it matches one we know.
validate_source($conf);

# Mount the source, if it isn't already
prep_source($conf);

# If we're still alive, we're ready.
get_package_list($conf);

# Build the list of source files to copy.
build_source($conf);

# Download things we need.
download_striker($conf);

exit(0);

 
#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This checks out the Striker repository, which includes the files we need.
sub download_striker
{
	my ($conf) = @_;
	
	### TODO: Make this version dependent (use a version file at 
	###       'https://alteeve.ca/files/striker_latest.txt').
	# Checkout/update the git repo.
	my $git_directory  = $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{striker}."/.git";
	my $pull_directory = $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{striker};
	print "$THIS_FILE ".__LINE__."; [ Debug ] - git_directory: [$git_directory], pull_directory: [$pull_directory]\n" if $conf->{sys}{debug} >= 2;
	
	# If the git directory exists, 'pull'. Otherwise, clone.
	my $shell_call = "";
	if (-e $git_directory)
	{
		print "- Updating the Striker git repository.\n";
		$shell_call = $conf->{executable}{git}." -C $pull_directory pull";
	}
	else
	{
		print "- Cloning the Striker git repository.\n";
		print "  Please be patient, this might take a minute...\n";
		$shell_call = $conf->{executable}{git}." -C ".$conf->{path}{iso}{source_directory}." clone ".$conf->{url}{striker};
	}
	print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
	open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
	}
	close $file_handle;
	if (-e $git_directory)
	{
		print "- Striker source is ready.\n";
	}
	else
	{
		print "
[ Error ] - Failed to clone the Striker source code! 
[ Error ]   An attempt was made to clone the repository:
[ Error ]   $conf->{url}{striker}
[ Error ] - This should have created the directory:
[ Error ]   $git_directory
[ Error ]   which was not found, meaning the check-out probably failed. Is your
[ Error ]   Internet connection up?
";
		exit(6);
	}
	
	# Download RPMs from our repo.
	download_anrepo_rpms($conf);
	
	# Download non-RPM tools
	download_anrepo_tools($conf);
	
	# Now start copying files into place.
	copy_files_from_git($conf);
	
	
	return(0);
}

# This copies files checked out from git to their directories.
sub copy_files_from_git
{
	my ($conf) = @_;
	
	# I need the OS-specific source.
	my $distro_directory = "";
	if ($conf->{sys}{os} =~ /centos/i)
	{
		$distro_directory = $conf->{path}{git}{centos};
	}
	elsif ($conf->{sys}{os} =~ /rhel/i)
	{
		$distro_directory = $conf->{path}{git}{rhel};
	}
	my $git_iso_source = $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{striker}."/".$conf->{path}{iso}{git_iso}."/".$distro_directory."/".$conf->{path}{git}{suffix};
	print "$THIS_FILE ".__LINE__."; [ Debug ] - git_iso_source: [$git_iso_source]\n" if $conf->{sys}{debug} >= 2;
	
	# isolinux
	foreach my $directory (sort {$a cmp $b} keys %{$conf->{path}{iso}{git_copy}})
	{
		print "$THIS_FILE ".__LINE__."; [ Debug ] - directory: [$directory], path::iso::git_copy::${directory}::target: [$conf->{path}{iso}{git_copy}{$directory}{target}]\n" if $conf->{sys}{debug} >= 2;
		my $source = $git_iso_source."/".$directory;
		my $target = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{git_copy}{$directory}{target});
		   $source =~ s/\/\/+/\//g;
		   #$target =~ s/\/\/+/\//g;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - source: [$source], target: [$target]\n" if $conf->{sys}{debug} >= 2;
		local(*DIR);
		opendir(DIR, $source) or die "Failed to open the directory: [$source], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			my $source_file = $source."/".$file;
			my $target_file = $target."/".$file;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - source_file: [$source_file], target_file: [$target_file]\n" if $conf->{sys}{debug} >= 2;
			copy_file($conf, $source_file, $target_file, 1);
		}
		closedir(DIR);
	}
	
	return(0);
}

# This copies a file from the given ISO file using 'iso-read'
sub isoread_file
{
	my ($conf, $iso, $source, $target) = @_;
	
	print "$THIS_FILE ".__LINE__."; [ Debug ] - iso: [$iso], source: [$source], target: [$target]\n" if $conf->{sys}{debug} >= 2;
	if (-e $target)
	{
		print "- The target file: [$target] exists, no need to copy it.\n" if $conf->{sys}{debug} >= 2;
	}
	else
	{
		my $shell_call = $conf->{executable}{'iso-read'}." --image $iso --extract $source --output-file $target";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
		open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
		}
		close $file_handle;
		if (-e $target)
		{
			print "- The file: [$target] was written successfully.\n" if $conf->{sys}{debug} >= 1;
		}
		else
		{
			print "[ Error ] - Failed to copy: [$source]\n";
			print "[ Error ]   from: [$iso]\n";
			print "[ Error ]   to: [$target]\n";
			print "[ Error ] - No error was reported, but the target file doesn't exist.\n";
			exit(5);
		}
	}
	
	return(0);
}

# This handles copying a file. Fancy, I know.
sub copy_file
{
	my ($conf, $source, $target, $force) = @_;
	
	print "$THIS_FILE ".__LINE__."; [ Debug ] - source: [$source], target: [$target]\n" if $conf->{sys}{debug} >= 2;
	# Delete the target if 'force'd and target exists.
	if (($force) && (-e $target))
	{
		print "- The target file: [$target] exists and the copy is forced, deleting the old file.\n" if $conf->{sys}{debug} >= 2;
		unlink $target or die "[ Error ] - Failed to delete: [$target] to make room for the new file.\n";
	}
	# Copy unless the target exists.
	if (-e $target)
	{
		print "- The target file: [$target] exists, no need to copy it.\n" if $conf->{sys}{debug} >= 2;
	}
	else
	{
		# Copy it.
		print "- Copying the source file: [$source] to: [$target]\n" if $conf->{sys}{debug} >= 2;
		my $shell_call = $conf->{executable}{cp}." -av $source $target";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
		open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
		}
		close $file_handle;
		if (-e $target)
		{
			print "- The file: [$target] was written successfully.\n";
		}
		else
		{
			print "[ Error ] - Failed to copy: [$target]!\n";
			print "[ Error ] - Tried to copy via: [$shell_call]\n";
			print "[ Error ] - No error was reported in the copy operation but the target file doesn't exist.\n";
			exit(5);
		}
	}
	
	return(0);
}

# This asks the user to agree to terms of use for third party applications.
sub agree_to_terms
{
	my ($conf) = @_;
	
	system('clear');
	print "-=] Thank you for using the 'Anvil!' Intelligent Availability platform! [=-\n\n";
	if ($conf->{switches}{'accept-third-part-licenses'})
	{
		print "- Third-party licenses agreed via '--accept-third-part-licenses'.\n";
		$conf->{sys}{third_party}{Fujitsu}{agreed} = 1;
		$conf->{sys}{third_party}{Avago}{agreed}   = 1;
	}
	else
	{
		print "Before we begin, we need to address some important house-keeping.

To simplify and automate as much of the build process as possible, the tool can
download third party tools which add support for some hardware. These tools are
not built, maintained or in any way owned by Alteeve's Niche! and have separate
terms of service and use. 

You will be prompted now to read and accept or deny the terms of service for
each third party vendor. If you decline any, the install will proceed but some
features related to a given vendor may not work. Of course, if you do not have
any hardware related to that vendor, it is safe to decline. In any case, the 
creation of the ISO will proceed.

<press enter to begin>
";
		my $answer = <STDIN>;
		   $answer = "";

		# Fujitsu.
		print "====

If you are using Fujitsu Primergy nodes, and if you agree to Fujitsu's 'Terms 
of use' found here:

$conf->{sys}{third_party}{Fujitsu}{terms}

Support for 'Primecollect' will be added to the ISO. The 'Primecollect' tool is
used to gather information about the hardware when opening a service request.

Do you agree to Fujitsu's 'Terms of Use'? [y/N]
";
		$answer = <STDIN>;
		chomp($answer);
		if ($answer =~ /^y/i)
		{
			print "- Thank you.\n\n";
			$conf->{sys}{third_party}{Fujitsu}{agreed} = 1;
		}
		else
		{
			print "- Noted. Fujitsu support will not be added.\n\n";
		}
		$answer = "";
		sleep 1;

		# Avago.
		print "====

If you are using an Avago (formerly LSI) based RAID controller, and if you 
agree to Avago's 'Download Agreement' found here:

$conf->{sys}{third_party}{Avago}{terms}

Support for managing RAID arrays in Striker and monitoring of the controller
hardware and attached drives will be added to ScanCore. LSI-based controllers
are used by most Tier-1 vendors, like Fujitsu, Dell, IBM/Lenovo as well as most
white-box servers from companies like Intel, Supermicro and so on.

Do you agree to Avago's 'Download Agreement'? [y/N]
";
		$answer = <STDIN>;
		chomp($answer);
		if ($answer =~ /^y/i)
		{
			print "- Thank you.\n\n";
			$conf->{sys}{third_party}{Avago}{agreed} = 1;
		}
		else
		{
			print "- Noted. Avago support will not be added.\n\n";
		}
		$answer = "";
		sleep 1;
		print "====\n";
	}
	
	return(0);
}

# This downloads various (third party) tools needed for the Anvil! that are not RPM packages.
sub download_anrepo_tools
{
	my ($conf) = @_;
	
	# Fujitsu stuff
	print "- Downloading non-RPM third party tools.\n";
	print "$THIS_FILE ".__LINE__."; [ Debug ] - sys::third_party::Fujitsu::agreed: [$conf->{sys}{third_party}{Fujitsu}{agreed}].\n" if $conf->{sys}{debug} >= 2;
	if ($conf->{sys}{third_party}{Fujitsu}{agreed})
	{
		# Primecollect shar
		my $file_name = ($conf->{url}{Fujitsu}{primecollect}{url} =~ /^.*\/(.*)$/)[0];
		my $source    = $conf->{url}{Fujitsu}{primecollect}{url};
		my $target    = $conf->{path}{iso}{iso_fujitsu}."/".$file_name;
		my $mode      = $conf->{url}{Fujitsu}{primecollect}{mode};
		print "$THIS_FILE ".__LINE__."; [ Debug ] - file_name: [$file_name], source: [$source], target: [$target].\n" if $conf->{sys}{debug} >= 2;
		download_file($conf, $source, $target, $mode);
	}
	
	return(0);
}

# This downloads the give file, if it's not already downloaded, and verifies that it is not a curl failure 
# message.
sub download_file
{
	my ($conf, $source, $target, $mode) = @_;
	$mode = "" if not defined $mode;
	
	if (-e $target)
	{
		print "- The file: [$target] is already downloaded.\n" if $conf->{sys}{debug} >= 2;
	}
	else
	{
		print "- Downloading: [$source]\n";
		my $shell_call = $conf->{executable}{curl}." $source > $target";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
		open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
		}
		close $file_handle;
		
		my $file_ok = 0;
		if (-e $target)
		{
			# Downloaded, but is it binary or text? If it's text, make sure it's not a failure 
			# message.
			if (-B $target)
			{
				# Yay!
				$file_ok = 1;
			}
			else
			{
				# If the file is less than 1024 bytes, read it in to make sure it's not a 
				# failure message.
				my $size = (stat($target))[7];
				if ($size < 1024)
				{
					# Read it in.
					my $shell_call = $target;
					print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
					open (my $file_handle, "<$shell_call") or die "\n[ Error ] - Failed to read: [$shell_call]. Received error: $!\n\n";
					while(<$file_handle>)
					{
						chomp;
						my $line = $_;
						print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
						if ($line =~ /Could not resolve host/i)
						{
							# Bad URL
							print "[ Error ] - Failed to download: [$target].\n";
							print "[ Error ]   It appears that the domain name is invalid.\n";
						}
						if ($line =~ /<title>404 Not Found<\/title>/i)
						{
							# File not found.
							print "[ Error ] - Failed to download: [$target].\n";
							print "[ Error ]   It appears that the file was not found on the server.\n";
						}
					}
					close $file_handle;
				}
				else
				{
					# Too big to be a failure, so we're probably good.
					$file_ok = 1;
				}
			}
		}
		if ($file_ok)
		{
			print "  The file: [$target] was downloaded successfully.\n" if $conf->{sys}{debug} >= 1;
		}
		else
		{
			# Sadness.
			if (-e $target)
			{
				# Remove the sadness
				unlink $target or die "[ Error ] - Failed to delete: [$target] (it's a failed download message, not the file).\n";
			}
			exit(7);
		}
	}
	
	# Set the mode, if needed
	if ($mode)
	{
		chmod $mode, $target;
	}
	
	return(0);
}

# This curl's the 'x86_64' and 'noarch' directories in the 'url::an-repo' URL. Then it looks through the RPMs
# in out package list to find matches and downloads them.
sub download_anrepo_rpms
{
	my ($conf) = @_;
	
	# First, get a list of the RPMs available
	print "- Downloading packages from the Alteeve's Niche! repository now.\n";
	foreach my $arch ("x86_64", "noarch")
	{
		my $shell_call = $conf->{executable}{curl}." ".$conf->{url}{'an-repo'}."/$arch/";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
		open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
			if ($line =~ /href="(.*?)">/)
			{
				my $download_package = $1;
				next if $download_package !~ /\.rpm$/;
				my $download_url =  $conf->{url}{'an-repo'}."/$arch/$download_package";
				print "$THIS_FILE ".__LINE__."; [ Debug ] - arch: [$arch], download_package: [$download_package], download_url: [$download_url]\n" if $conf->{sys}{debug} >= 2;
				$conf->{download_packages}{$download_package} = $download_url;
			}
		}
		close $file_handle;
	}
	
	# Match requirements to the available RPMs
	foreach my $package (sort {$a cmp $b} @{$conf->{sys}{packages}{alteeve}})
	{
		my ($file, $arch) = ($package =~ /^(.*)\.(.*?)$/);
		my $found         = 0;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - Looking for the: [$arch] package: [$package] in the source.\n" if $conf->{sys}{debug} >= 2;
		
		foreach my $download_package (sort {$a cmp $b} keys %{$conf->{download_packages}})
		{
			next if $download_package !~ /^\Q$file\E/;
			next if $download_package !~ /\Q$arch\E/;
			print "$THIS_FILE ".__LINE__."; [ Debug ]   - Source file: [$download_package] POSSIBLE match...\n" if $conf->{sys}{debug} >= 2;
			if ($download_package =~ /^\Q$file\E-\d/)
			{
				print "$THIS_FILE ".__LINE__."; [ Debug ]   - Source file: [$download_package] matches!\n" if $conf->{sys}{debug} >= 2;
				$found++;
				$conf->{download}{$package}{url} = $conf->{download_packages}{$download_package};
			}
		}
		
		### It's normal for there to be multiple matches, so we don't fail on too many here.
		# If I didn't finf a match, or if I found too many matches, die.
		die "[ Error ] - Failed to find: [$package] (file: [$file], arch: [$arch])! Is the Internet connection working?\n" if not $found;
	}
	
	# Find the packages in the Third Party repo
	foreach my $vendor (sort {$a cmp $b} keys %{$conf->{sys}{packages}{third_party}})
	{
		print "$THIS_FILE ".__LINE__."; [ Debug ] - vendor: [$vendor], sys::third_party::${vendor}::agreed: [$conf->{sys}{third_party}{$vendor}{agreed}]\n" if $conf->{sys}{debug} >= 2;
		next if not $conf->{sys}{third_party}{$vendor}{agreed};
		my $shell_call =  $conf->{executable}{curl}." ".$conf->{url}{third_party}."/$vendor/";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
		open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
			if ($line =~ /href="(.*?)">/)
			{
				my $download_package = $1;
				next if $download_package !~ /\.rpm$/;
				my $download_url =  $conf->{url}{third_party}."/$vendor/$download_package";
				print "$THIS_FILE ".__LINE__."; [ Debug ] - download_package: [$download_package], download_url: [$download_url]\n" if $conf->{sys}{debug} >= 2;
				$conf->{download_packages}{$download_package} = $download_url;
			}
		}
	}
	
	# Match our requirements to the packages available in the third party repo
	foreach my $vendor (sort {$a cmp $b} keys %{$conf->{sys}{packages}{third_party}})
	{
		print "$THIS_FILE ".__LINE__."; [ Debug ] - vendor: [$vendor], sys::third_party::${vendor}::agreed: [$conf->{sys}{third_party}{$vendor}{agreed}]\n" if $conf->{sys}{debug} >= 2;
		next if not $conf->{sys}{third_party}{$vendor}{agreed};
		foreach my $package (sort {$a cmp $b} @{$conf->{sys}{packages}{third_party}{$vendor}})
		{
			my ($file, $arch) = ($package =~ /^(.*)\.(.*?)$/);
			my $found         = 0;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - Looking for the: [$arch] package: [$package] in the source.\n" if $conf->{sys}{debug} >= 2;
			
			foreach my $download_package (sort {$a cmp $b} keys %{$conf->{download_packages}})
			{
				next if $download_package !~ /^\Q$file\E/;
				next if $download_package !~ /\Q$arch\E/;
				print "$THIS_FILE ".__LINE__."; [ Debug ]   - Source file: [$download_package] POSSIBLE match...\n" if $conf->{sys}{debug} >= 2;
				if ($download_package =~ /^\Q$file\E-\d/)
				{
					print "$THIS_FILE ".__LINE__."; [ Debug ]   - Source file: [$download_package] matches!\n" if $conf->{sys}{debug} >= 2;
					$found++;
					$conf->{download}{$package}{url} = $conf->{download_packages}{$download_package};
				}
			}
			
			### It's normal for there to be multiple matches, so we don't fail on too many here.
			# If I didn't finf a match, or if I found too many matches, die.
			die "[ Error ] - Failed to find: [$package] (file: [$file], arch: [$arch])! Is the Internet connection working?\n" if not $found;
		}
	}
	
	# Download everything
	foreach my $package (sort {$a cmp $b} keys %{$conf->{download}})
	{
		my $package_name = ($conf->{download}{$package}{url} =~ /^.*\/(.*)$/)[0];
		my $package_file = $conf->{path}{iso}{iso_packages}."/".$package_name;
		if (-e $package_file)
		{
			print "- The package: [$package_file] is already downloaded.\n" if $conf->{sys}{debug} >= 2;
		}
		else
		{
			download_file($conf, $conf->{download}{$package}{url}, $package_file);
		}
	}
	
	print "- Done! All Anvil! packages are in place.\n";
	
	return(0);
}

# Setup our build environment. This creates the directories we'll need for the new ISO, copy over isolinux
# and syslinux, ask the user to download binary files, load our kickstart scripts and splash screens, etc.
sub setup_build_environment
{
	my ($conf) = @_;
	
	$conf->{path}{iso}{working_directory} = $conf->{sys}{user}{current_dir}."/".$conf->{path}{working_dir};
	if (-e $conf->{path}{iso}{working_directory})
	{
		print "- The working directory: [$conf->{path}{iso}{working_directory}] already exists.\n";
	}
	else
	{
		print "- The working directory: [$conf->{path}{iso}{working_directory}] doesn't exist.\n";
		print "- Can I create it (and needed subdirectories) now? [Y/n]\n";
		my $answer = <STDIN>;
		chomp($answer);
		if ((not $answer) or ($answer =~ /^y/i))
		{
			print "- Thank you, proceeding now.\n";
			$conf->{path}{iso}{working_directory} = make_directory($conf, $conf->{path}{iso}{working_directory});
		}
		else
		{
			print "- Without a working directory, ISO generation can not proceed. Exiting.\n";
			exit(8);
		}
	}
	
	# Make sure the rest of the directories now exist.
	$conf->{path}{iso}{source_directory} = make_directory($conf, $conf->{path}{iso}{working_directory}."/".$conf->{path}{source_path});
	$conf->{path}{iso}{iso_kickstart}    = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{kickstart});
	$conf->{path}{iso}{iso_packages}     = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{packages});
	$conf->{path}{iso}{iso_striker}      = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{striker});
	$conf->{path}{iso}{iso_fence}        = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{fence});
	
	# These are only created if the user agreed to them
	$conf->{path}{iso}{iso_fujitsu} = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{fujitsu}) if $conf->{sys}{third_party}{Fujitsu}{agreed};
	$conf->{path}{iso}{iso_avago}   = make_directory($conf, $conf->{path}{iso}{source_directory}."/".$conf->{path}{iso}{avago})   if $conf->{sys}{third_party}{Avago}{agreed};
	
	return(0);
}

# This makes a directory similar to 'mkdir -p' at the shell.
sub make_directory
{
	my ($conf, $directory) = @_;
	print "$THIS_FILE ".__LINE__."; [ Debug ] - directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
	
	# If the directory starts with '/', we're building from /. If the directory starts with '~', we're 
	# building from the user's home.
	if ($directory =~ /^~/)
	{
		$directory =~ s/^~/$conf->{sys}{user}{home}/;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
	}
	if ($directory !~ /^\//)
	{
		$directory = $ENV{PWD}."/".$directory;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
	}
	$directory =~ s/\/+/\//g;
	print "$THIS_FILE ".__LINE__."; [ Debug ] - directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
	
	my $current_directory = "";
	foreach my $sub_directory (split/\//, $directory)
	{
		next if not $sub_directory;
		$current_directory .= "/$sub_directory";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - current_directory: [$current_directory]\n" if $conf->{sys}{debug} >= 2;
		
		if (not -e $current_directory)
		{
			print "- Creating the directory: [$current_directory]\n";
			mkdir $current_directory or die "failed to create the directory: [$current_directory]. The error was: $!\n";
		}
	}
	
	print "$THIS_FILE ".__LINE__."; [ Debug ] - current_directory: [$current_directory]\n" if $conf->{sys}{debug} >= 2;
	return($current_directory);
}

# Build the list of source files to copy.
sub build_source
{
	my ($conf) = @_;
	
	print "- Please be patient! 
- We're looking through the source ISO(s) to find which installation packages 
  are needed. This can take a minute.
";
	
	# Build a list of all the packages needed for this OS (common plus distro-specific).
	my $extra_packages = "";
	my $distro_list    = [];
	if ($conf->{sys}{os} =~ /centos/i)
	{
		$extra_packages = "centos";
	}
	elsif ($conf->{sys}{os} =~ /rhel/i)
	{
		$extra_packages = "rhel";
	}
	# Add the common files.
	foreach my $package (sort {$a cmp $b} @{$conf->{sys}{packages}{common}})
	{
		push @{$distro_list}, $package;
	}
	# Now add the distro-specific files
	foreach my $package (sort {$a cmp $b} @{$conf->{sys}{packages}{$extra_packages}})
	{
		push @{$distro_list}, $package;
	}
	
	foreach my $package (sort {$a cmp $b} @{$distro_list})
	{
		my ($file, $arch) = ($package =~ /^(.*)\.(.*?)$/);
		my $found         = 0;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - Looking for the: [$arch] package: [$package] in the source.\n" if $conf->{sys}{debug} >= 2;
		
		foreach my $iso (sort {$a cmp $b} keys %{$conf->{source_packages}})
		{
			print "$THIS_FILE ".__LINE__."; [ Debug ] - ISO: [$iso]\n" if $conf->{sys}{debug} >= 2;
			foreach my $directory (sort {$a cmp $b} keys %{$conf->{source_packages}{$iso}})
			{
				print "$THIS_FILE ".__LINE__."; [ Debug ] - ISO: [$iso], Directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
				foreach my $source_package (sort {$a cmp $b} keys %{$conf->{source_packages}{$iso}{$directory}})
				{
					next if $source_package !~ /^\Q$file\E/;
					next if $source_package !~ /\Q$arch\E/;
					print "$THIS_FILE ".__LINE__."; [ Debug ]   - Source file: [$source_package] POSSIBLE match...\n" if $conf->{sys}{debug} >= 2;
					if ($source_package =~ /^\Q$file\E-\d/)
					{
						print "$THIS_FILE ".__LINE__."; [ Debug ]   - Source file: [$source_package] matches!\n" if $conf->{sys}{debug} >= 2;
						$found++;
						$conf->{copy}{$package} = {
							source    => $iso,
							directory => $directory,
							file      => $source_package,
						};
					}
				}
			}
		}
		
		# If I didn't finf a match, or if I found too many matches, die.
		die "[ Error ] - Failed to find: [$package] (file: [$file], arch: [$arch]) in the source!\n" if not $found;
		die "[ Error ] - The package: [$package] (file: [$file], arch: [$arch]) had multiple matches!\n" if $found > 1;
	}
	
	# Copy!
	print "- Ready to copy files!\n";
	if ($conf->{sys}{debug} >= 1)
	{
		foreach my $package (sort {$a cmp $b} keys %{$conf->{copy}})
		{
			my $iso         = $conf->{copy}{$package}{source};
			my $destination = $conf->{path}{iso}{iso_packages}."/".$conf->{copy}{$package}{file};
			if (-e $destination)
			{
				print "$THIS_FILE ".__LINE__."; [ Debug ]- The package: [$destination] already exists, no need to copy it.\n" if $conf->{sys}{debug} >= 2;
			}
			else
			{
				# Copy it. But how?
				my $shell_call = "";
				if ($conf->{source}{$iso}{mount})
				{
					# copy
					my $source = $conf->{copy}{$package}{directory}."/".$conf->{copy}{$package}{file};
					copy_file($conf, $source, $destination, 0);
				}
				else
				{
					# Use iso-read
					my $extract_file = $conf->{copy}{$package}{directory}."/".$conf->{copy}{$package}{file};
					isoread_file($conf, $iso, $extract_file, $destination);
				}
			}
		}
	}
	print "- Packages copied. Copying auxiliary source files now.\n";
	
	# Now copy the rest of the source files. Note that we'll watch for 'syslinux' and if we don't see it,
	# we'll copy 'isolinux' over.
	my $syslinux_found = 0;
	foreach my $iso (sort {$a cmp $b} keys %{$conf->{source_packages}})
	{
		# We only care about disk 1
		next if $conf->{source}{$iso}{name} !~ /disk 1/i;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - ISO: [$iso] -> [$conf->{source}{$iso}{name}]\n" if $conf->{sys}{debug} >= 2;
		foreach my $directory (sort {$a cmp $b} keys %{$conf->{source_packages}{$iso}})
		{
			# Skip '/Packages'
			next if $directory =~ /\/Packages$/;
			$syslinux_found = 1 if $directory =~ /\/syslinux$/;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
			foreach my $file (sort {$a cmp $b} keys %{$conf->{source_packages}{$iso}{$directory}})
			{
				next if $file eq "TRANS.TBL";
				print "$THIS_FILE ".__LINE__."; [ Debug ] - file: [$directory/$file]\n" if $conf->{sys}{debug} >= 2;
				# To determine the copy target, we first need to strip off the mount point 
				# (if mounted) and append it to the source directory.
				my $destination           = "";
				my $destination_directory = "";
				if ($conf->{source}{$iso}{mount})
				{
					my $destination_sub_directory =  $directory;
					   $destination_sub_directory =~ s/\Q$conf->{source}{$iso}{mount}\E//;
					   $destination               =  $conf->{path}{iso}{source_directory}."/".$destination_sub_directory."/".$file;
					   $destination_directory     =  $conf->{path}{iso}{source_directory}."/".$destination_sub_directory;
				}
				else
				{
					$destination           = $conf->{path}{iso}{source_directory}."/".$directory."/".$file;
					$destination_directory = $conf->{path}{iso}{source_directory}."/".$directory;
				}
				$destination           =~ s/\/+/\//g;
				$destination_directory =~ s/\/+/\//g;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - destination: [$destination], destination_directory: [$destination_directory]\n" if $conf->{sys}{debug} >= 2;
				# Create the destination directory if needed
				$destination_directory = make_directory($conf, $destination_directory);
				
				if (-e $destination)
				{
					print "$THIS_FILE ".__LINE__."; [ Debug ]- The file: [$destination] already exists, no need to copy it.\n" if $conf->{sys}{debug} >= 2;
				}
				else
				{
					# Copy it, but again, how?
					my $shell_call = "";
					
					if ($conf->{source}{$iso}{mount})
					{
						# copy
						my $source     =  $directory."/".$file;
						   $source     =~ s/\/+/\//g;
						copy_file($conf, $source, $destination, 0);
					}
					else
					{
						# Use iso-read
						my $extract_file =  $directory."/".$file;
						   $extract_file =~ s/\/+/\//g;
						isoread_file($conf, $iso, $extract_file, $destination);
					}
				}
			}
		}
	}
	
	print "- Verifying 'syslinux' was created.\n";
	print "$THIS_FILE ".__LINE__."; [ Debug ] - syslinux_found: [$syslinux_found]\n" if $conf->{sys}{debug} >= 2;
	if (not $syslinux_found)
	{
		print "- The 'syslinux' directory was not in the source. Creating it now, if needed.\n";
		my $isolinux_directory = $conf->{path}{iso}{source_directory}."/isolinux";
		my $syslinux_directory = $conf->{path}{iso}{source_directory}."/syslinux";
		print "$THIS_FILE ".__LINE__."; [ Debug ] - isolinux_directory: [$isolinux_directory], syslinux_directory: [$syslinux_directory]\n" if $conf->{sys}{debug} >= 2;
		$syslinux_directory = make_directory($conf, $syslinux_directory);
		
		# Read all the files in isolinux. For each file we find, copy it to syslinux if it doesn't 
		# exist yet. We'll rename anything 'isolinux' to 'syslinux' in the process.
		local(*DIR);
		opendir(DIR, $isolinux_directory) or die "Failed to open the directory: [$isolinux_directory], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			my $destination_file =  $file;
			   $destination_file =~ s/isolinux/syslinux/;
			my $source_path      =  $isolinux_directory."/".$file;
			my $destination_path =  $syslinux_directory."/".$destination_file;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - source_path: [$source_path], destination_path: [$destination_path]\n" if $conf->{sys}{debug} >= 2;
			copy_file($conf, $source_path, $destination_path, 0);
		}
		closedir(DIR);
	}
	
	print "- Auxiliary files now in place, ready to grab Anvil! files.\n";
	
	
	return(0);
}

# This checks to see if the source is mounted or not. If not, it mounts it
sub prep_source
{
	my ($conf) = @_;
	
	# First, are the sources already mounted?
	foreach my $iso (sort {$a cmp $b} @{$conf->{sys}{source}{iso}})
	{
		print "$THIS_FILE ".__LINE__."; [ Debug ] - iso: [$iso]\n" if $conf->{sys}{debug} >= 2;
		$conf->{source}{$iso}{mount}       = "";
		$conf->{source}{$iso}{source_file} = ($iso =~ /^.*\/(.*)$/)[0];
		print "$THIS_FILE ".__LINE__."; [ Debug ] - source::${iso}::source_file: [$conf->{source}{$iso}{source_file}]\n" if $conf->{sys}{debug} >= 2;
		my $shell_call = $conf->{executable}{mount};
		print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
		open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
			
			if ($line =~ /^\/.*?\/\Q$conf->{source}{$iso}{source_file}\E on (.*?) /)
			{
				$conf->{source}{$iso}{mount} = $1;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - source::${iso}::mount: [$conf->{source}{$iso}{mount}]\n" if $conf->{sys}{debug} >= 2;
				print "- The source ISO: [$iso] was found to be mounted at: [$conf->{source}{$iso}{mount}].\n";
			}
		}
		close $file_handle;
		
		# If the source isn't mounted, we'll need to try and read the files out of the ISO directly because
		# 'mount' requires root, and we can't assume the user has that.
		if (not $conf->{source}{$iso}{mount})
		{
			# Not mounted... Do we have the needed tools?
			print "- The source ISO: [$iso] is not mounted. Will read and copy files directly out of the ISO.\n";
			if ((-x $conf->{executable}{isoinfo}) && (-x $conf->{executable}{'iso-read'}))
			{
				# We're good to use this method to get our files.
				print "$THIS_FILE ".__LINE__."; [ Debug ] - 'isoinfo' and 'iso-read' found!\n" if $conf->{sys}{debug} >= 2;
			}
			else
			{
				# Nothing more we can do...
				print "
[ Error ] - The source ISO: [$iso]
[ Error ]   is not mounted and the 'isoinfo' and/or 'iso-read' programs are not
[ Error ]   installed. Please mount the source ISO 'loop-back';
[ Error ]   \$ sudo mkdir /mnt/iso
[ Error ]   \$ sudo mount -o loop $iso /mnt/iso
[ Error ]   or install 'libcdio' and 'genisoimage' (or your OS's version of) 
[ Error ]   and then re-run this program.

	";
				exit(2);
			}
		}
		
		# Now get a list of the source files.
		$conf->{source}{$iso}{files_read}       = 0;
		$conf->{source}{$iso}{directories_read} = 0;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - source::${iso}::mount: [$conf->{source}{$iso}{mount}]\n" if $conf->{sys}{debug} >= 2;
		if (not $conf->{source}{$iso}{mount})
		{
			# We'll neeed to dig the file names out the hard way.
			print "- Reading the contents of the: [$conf->{source}{$iso}{source_file}] ISO now...\n";
			my $files       = 0;
			my $directories = 0;
			my $in_path     = "";
			my $shell_call  = $conf->{executable}{isoinfo}." -lR -i ".$iso;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
			open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				next if not $line;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug} >= 2;
				
				if ($line =~ /Directory listing of (\/.*)?/)
				{
					$in_path = $1;
					$in_path =~ s/\/$// if $in_path ne "/";
					print "$THIS_FILE ".__LINE__."; [ Debug ] - in_path: [$in_path]\n" if $conf->{sys}{debug} >= 2;
					$conf->{source}{$iso}{directories_read}++;
				}
				
				next if not $in_path;
				if ($line =~ /-.*? \d+ \d+ \d+ (\d+) \w+ \d+ \d+ \[.*?\] (.*)$/)
				{
					my $bytes = $1;
					my $file  = $2;
					next if (($file eq ".") or ($file eq ".."));
					die "Failed to parse file name from: [$line]\n" if not $line;
					print "$THIS_FILE ".__LINE__."; [ Debug ] - file: [$file], bytes: [$bytes]\n" if $conf->{sys}{debug} >= 2;
					$conf->{source_packages}{$iso}{$in_path}{$file} = $bytes;
					print "$THIS_FILE ".__LINE__."; [ Debug ] - source_packages::${iso}::${in_path}::${file}: [$conf->{source_packages}{$iso}{$in_path}{$file}]\n" if $conf->{sys}{debug} >= 2;
					$conf->{source}{$iso}{files_read}++;
				}
			}
			close $file_handle;
			print "- Done. Read in: [$conf->{source}{$iso}{files_read}] files across: [$conf->{source}{$iso}{directories_read}] directories.\n";
		}
		else
		{
			# Walk the mount point.
			print "- Reading the contents of the ISO: [$iso] now...\n";
			read_directory($conf, $iso, $conf->{source}{$iso}{mount});
			print "- Done. Read in: [$conf->{source}{$iso}{files_read}] files across: [$conf->{source}{$iso}{directories_read}] directories.\n";
		}
	}
	
	# Get a count of RPMs found in '/Packages'
	my $package_count = 0;
	foreach my $iso (sort {$a cmp $b} keys %{$conf->{source_packages}})
	{
		print "$THIS_FILE ".__LINE__."; [ Debug ] - ISO: [$iso]\n" if $conf->{sys}{debug} >= 2;
		foreach my $directory (sort {$a cmp $b} keys %{$conf->{source_packages}{$iso}})
		{
			print "$THIS_FILE ".__LINE__."; [ Debug ] - ISO: [$iso], Directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
			foreach my $file (sort {$a cmp $b} keys %{$conf->{source_packages}{$iso}{$directory}})
			{
				next if $file !~ /\.rpm$/;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - Source: [$iso]:[$directory]:[$file]\n" if $conf->{sys}{debug} >= 2;
				$package_count++;
			}
		}
	}
	print "- Found: [$package_count] source packages.\n";
	
	return(0);
}

# This reads the files in from the given directory, decending into any subdirectories, and recording the 
# files it finds into the 'sourc_packages::<path>::<file>' hash, where '<path>' has the 'path::source_path'
# stripped off.
sub read_directory
{
	my ($conf, $iso, $directory) = @_;
	$conf->{source}{$iso}{directories_read}++;
	print "$THIS_FILE ".__LINE__."; [ Debug ] - iso: [$iso], directory: [$directory]\n" if $conf->{sys}{debug} >= 2;
	
	my $source_path =  $directory;
	   $source_path =~ s/^$iso//;
	   $source_path =~ s/\/$//;
	   $source_path =  "/$source_path" if $source_path !~ /^\//;
	print "$THIS_FILE ".__LINE__."; [ Debug ] - Reading in the contents of: [$directory], recording as: [$source_path]\n" if $conf->{sys}{debug} >= 2;
	local(*DIR);
	opendir(DIR, $directory) or die "Failed to open the directory: [$directory], error was: $!\n";
	while (my $file = readdir(DIR))
	{
		next if (($file eq ".") or ($file eq ".."));
		my $this_path = $directory."/".$file;
		print "$THIS_FILE ".__LINE__."; [ Debug ] - this_path: [$this_path]\n" if $conf->{sys}{debug} >= 3;
		if (-d $this_path)
		{
			read_directory($conf, $iso, $this_path);
		}
		elsif (-f $this_path)
		{
			# Record the size. (position 7 in the returned array)
			$conf->{source_packages}{$iso}{$source_path}{$file} = (stat($this_path))[7];
			print "$THIS_FILE ".__LINE__."; [ Debug ] - source_packages:${iso}::${source_path}::${file}: [$conf->{source_packages}{$iso}{$source_path}{$file}]\n" if $conf->{sys}{debug} >= 2;
			$conf->{source}{$iso}{files_read}++;
		}
	}
	closedir(DIR);
	
	return(0)
}

# This validates the source ISO. It will exit if problems are found.
sub validate_source
{
	my ($conf) = @_;
	
	print "$THIS_FILE ".__LINE__."; [ Debug ] - switches::source: [$conf->{switches}{source}]\n" if $conf->{sys}{debug} >= 2;
	if ($conf->{switches}{source})
	{
		foreach my $source (split/,/, $conf->{switches}{source})
		{
			print "$THIS_FILE ".__LINE__."; [ Debug ] - source: [$source]\n" if $conf->{sys}{debug} >= 2;
			push @{$conf->{sys}{source}{iso}}, $source;
		}
	}
	else
	{
		print "\n[ Error ] - No source ISO provided!\n";
		print "[ Note ]  - Run './$THIS_FILE -h' for usage.\n\n";
		exit(4);
	}
	
	foreach my $iso (sort {$a cmp $b} @{$conf->{sys}{source}{iso}})
	{
		print "$THIS_FILE ".__LINE__."; [ Debug ] - iso: [$iso]\n" if $conf->{sys}{debug} >= 2;
		if (-e $iso)
		{
			print "$THIS_FILE ".__LINE__."; [ Debug ] - Parsing source: [$iso]\n" if $conf->{sys}{debug} >= 2;
			
			($conf->{source}{$iso}{directory}, $conf->{source}{$iso}{file}) = ($iso =~ /^(.*)\/(.*)$/);
			print "$THIS_FILE ".__LINE__."; [ Debug ] - Source directory: [$conf->{source}{$iso}{directory}], file: [$conf->{source}{$iso}{file}]\n" if $conf->{sys}{debug} >= 2;
		}
		else
		{
			print "\n[ Error ] - Source: [$conf->{switches}{source}] doesn't exist!\n\n";
			exit(1);
		}
		
		### TODO: Remove this; Calc all sums!
		if ($iso eq "/data1/VMs/files/CentOS-6.7-x86_64-bin-DVD1.iso")
		{
			$conf->{source}{$iso}{sum} = "51f90e8ddd2ea199780065eaf75130ad";
		}
		elsif ($iso eq "/data1/VMs/files/CentOS-6.7-x86_64-bin-DVD2.iso")
		{
			$conf->{source}{$iso}{sum} = "efd54b939787519b350d986329e2c7a3";
		}
		else
		{
			print "- Generating md5sum of the source, please wait a moment...\n";
			$conf->{source}{$iso}{sum} = "";
			my $shell_call                = $conf->{executable}{md5sum}." ".$iso;
			print "$THIS_FILE ".__LINE__."; [ Debug ] - shell_call: [$shell_call]\n" if $conf->{sys}{debug} >= 2;
			open (my $file_handle, "$shell_call 2>&1 |") or die "\n[ Error ] - Failed to call: [$shell_call]. Received error: $!\n\n";
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - line: [$line]\n" if $conf->{sys}{debug};
				
				if ($line =~ /^(\S+)\s+$iso/)
				{
					$conf->{source}{$iso}{sum} = $1;
					print "$THIS_FILE ".__LINE__."; [ Debug ] - source::${iso}::sum: [$conf->{source}{$iso}{sum}]\n" if $conf->{sys}{debug} >= 2;
				}
			}
			close $file_handle;
		}
		
		# If we got a sum, make sure it matches an expected one.
		if ($conf->{source}{$iso}{sum})
		{
			foreach my $this_sum (sort {$a cmp $b} keys %{$conf->{sys}{md5sum}})
			{
				print "$THIS_FILE ".__LINE__."; [ Debug ] - source::${iso}::sum: [$conf->{source}{$iso}{sum}]\n" if $conf->{sys}{debug} >= 2;
				print "$THIS_FILE ".__LINE__."; [ Debug ] - this_sum:            [$this_sum]\n" if $conf->{sys}{debug} >= 2;
				if ($conf->{source}{$iso}{sum} eq $this_sum)
				{
					# Match!
					$conf->{sys}{os}            = $conf->{sys}{md5sum}{$this_sum};
					$conf->{source}{$iso}{name} = $conf->{sys}{md5sum}{$this_sum};
					print "- Source identified as: [$conf->{sys}{os}] (sum: [$this_sum])\n" if $conf->{sys}{debug} >= 2;
				}
			}
			
			# Did I find an OS?
			if ($conf->{sys}{os} =~ /rhel/i)
			{
				print "- The source ISO is: [$conf->{sys}{os}].\n";
			}
			elsif ($conf->{sys}{os} =~ /centos/i)
			{
				print "- The source ISO is: [$conf->{sys}{os}].\n";
			}
			else
			{
				print "
[ Error ] - Failed to match the source ISO: [$iso]
[ Error ]   'md5sum': [$conf->{source}{$iso}{sum}] to a known sum.
[ Error ]   It is important to verify the source ISO, so unfortunately, we can not proceed.
";
				exit(3);
			}
		}
	}
	
	if (not $conf->{sys}{os})
	{
		print "\n[ Error ] - Failed to match the source 'md5sum' for: [$conf->{switches}{source}] to a known OS.\n";
		print "[ Error ] - It is important to verify the source ISO, so unfortunately, we can not proceed.\n\n";
		exit(3);
	}
	
	return(0);
}

# This searches the PATH environment variable looking for the location of any executable not pre-defined.
sub find_executables
{
	my ($conf) = @_;
	print "$THIS_FILE ".__LINE__."; [ Debug ] - Searching for executables...\n" if $conf->{sys}{debug} >= 2;
	
	my $ok = 1;
	foreach my $executable (sort {$a cmp $b} keys %{$conf->{executable}})
	{
		next if $conf->{executable}{$executable} =~ /^\//;
		print "$THIS_FILE ".__LINE__."; [ Debug ]   - Program: [$executable]... \n" if $conf->{sys}{debug} >= 2;
		foreach my $path (split/:/, $ENV{'PATH'})
		{
			my $test_path = "$path/$executable";
			if ((-e $test_path) && (-x $test_path))
			{
				# Found it.
				$conf->{executable}{$executable} = $test_path;
				print "$THIS_FILE ".__LINE__."; [ Debug ]     - Found it: [$conf->{executable}{$executable}].\n" if $conf->{sys}{debug} >= 2;
				last;
			}
		}
		
		### NOTE: We don't die on iso-read or isoinfo as they may not be needed.
		# Die if we didn't find it.
		if (($conf->{executable}{$executable} !~ /^\//) && ($executable ne "iso-read") && ($executable ne "isoinfo"))
		{
			$ok = 0;
			print "[ Error ] - Failed to find the: [$executable] program.\n";
		}
	}
	if (not $ok)
	{
		print "
[ Error ] - Some programs needed to build the Anvil! ISO appear to not be 
[ Error ]   installed. Please ensure the following programs are installed:
[ Error ]   'createrepo, iso-read, isoinfo, git and mkisofs'.
[ Error ]   On RPM-based distros, the following command should provide 
[ Error ]   everything:
[ Error ] 
[ Error ] - \$ sudo yum -y install createrepo genisoimage git libcdio 
[ Error ] 
[ Error ] - Note that your distro may use 'dnf' instead of 'yum'. On non-RPM
[ Error ]   based distros, these programs may be provided by different 
[ Error ]   packages. Once these are installed, please run this program again.
[ Error ] - Note that 'iso-read' and 'isoinfo' are not needed if you mount the
[ Error ]   ISO manually. (\$ sudo mount -o loop <iso> <mountpoint>)
";
		exit(1);
	}
	
	return(0);
}

# This is the list of RPMs.
sub get_package_list
{
	my ($conf) = @_;
	
	# These are common to CentOS and RHEL
	$conf->{sys}{packages}{common} = [
		"ConsoleKit-libs.x86_64",
		"ConsoleKit-x11.x86_64",
		"ConsoleKit.x86_64",
		"DeviceKit-power.x86_64",
		"GConf2-gtk.x86_64",
		"GConf2.x86_64",
		"MAKEDEV.x86_64",
		"ORBit2.x86_64",
		"OpenIPMI-libs.x86_64",
		"OpenIPMI.x86_64",
		"PackageKit-device-rebind.x86_64",
		"PackageKit-glib.x86_64",
		"PackageKit-gtk-module.x86_64",
		"PackageKit-yum-plugin.x86_64",
		"PackageKit-yum.x86_64",
		"PackageKit.x86_64",
		"abyssinica-fonts.noarch",
		"acl.x86_64",
		"acpid.x86_64",
		"aic94xx-firmware.noarch",
		"alsa-lib.x86_64",
		"alsa-plugins-pulseaudio.x86_64",
		"alsa-utils.x86_64",
		"apr-util-ldap.x86_64",
		"apr-util.x86_64",
		"apr.x86_64",
		"at-spi.x86_64",
		"atk.x86_64",
		"atmel-firmware.noarch",
		"attr.x86_64",
		"audit-libs-python.x86_64",
		"audit-libs.x86_64",
		"audit.x86_64",
		"augeas-libs.x86_64",
		"authconfig.x86_64",
		"avahi-glib.x86_64",
		"avahi-libs.x86_64",
		"b43-openfwwf.noarch",
		"basesystem.noarch",
		"bash.x86_64",
		"bc.x86_64",
		"bfa-firmware.noarch",
		"bind-libs.x86_64",
		"bind-utils.x86_64",
		"binutils.x86_64",
		"bridge-utils.x86_64",
		"busybox.x86_64",
		"bzip2-libs.x86_64",
		"bzip2.x86_64",
		"ca-certificates.noarch",
		"cairo.x86_64",
		"ccs.x86_64",
		"cdparanoia-libs.x86_64",
		"celt051.x86_64",
		"checkpolicy.x86_64",
		"chkconfig.x86_64",
		"cifs-utils.x86_64",
		"cim-schema.noarch",
		"cjkuni-fonts-common.noarch",
		"cjkuni-uming-fonts.noarch",
		"cloog-ppl.x86_64",
		"cluster-cim.x86_64",
		"clusterlib.x86_64",
		"cman.x86_64",
		"comps-extras.noarch",
		"control-center-extra.x86_64",
		"control-center-filesystem.x86_64",
		"control-center.x86_64",
		"coreutils-libs.x86_64",
		"coreutils.x86_64",
		"corosync.x86_64",
		"corosynclib.x86_64",
		"cpio.x86_64",
		"cpp.x86_64",
		"cracklib-dicts.x86_64",
		"cracklib.x86_64",
		"cronie-anacron.x86_64",
		"cronie.x86_64",
		"crontabs.noarch",
		"cryptsetup-luks-libs.x86_64",
		"cryptsetup-luks.x86_64",
		"cups-libs.x86_64",
		"curl.x86_64",
		"cvs.x86_64",
		"cyrus-sasl-lib.x86_64",
		"cyrus-sasl-md5.x86_64",
		"cyrus-sasl-plain.x86_64",
		"cyrus-sasl.x86_64",
		"dash.x86_64",
		"db4-cxx.x86_64",
		"db4-devel.x86_64",
		"db4-utils.x86_64",
		"db4.x86_64",
		"dbus-glib.x86_64",
		"dbus-libs.x86_64",
		"dbus-python.x86_64",
		"dbus-x11.x86_64",
		"dbus.x86_64",
		"dejavu-fonts-common.noarch",
		"dejavu-sans-fonts.noarch",
		"dejavu-sans-mono-fonts.noarch",
		"dejavu-serif-fonts.noarch",
		"desktop-file-utils.x86_64",
		"device-mapper-event-libs.x86_64",
		"device-mapper-event.x86_64",
		"device-mapper-libs.x86_64",
		"device-mapper-persistent-data.x86_64",
		"device-mapper.x86_64",
		"dhclient.x86_64",
		"dhcp-common.x86_64",
		"dhcp.x86_64",
		"diffutils.x86_64",
		"dmidecode.x86_64",
		"dmz-cursor-themes.noarch",
		"dnsmasq.x86_64",
		"docbook-dtds.noarch",
		"dosfstools.x86_64",
		"dracut-kernel.noarch",
		"dracut.noarch",
		"e2fsprogs-libs.x86_64",
		"e2fsprogs.x86_64",
		"ebtables.x86_64",
		"efibootmgr.x86_64",
		"eggdbus.x86_64",
		"elfutils-libelf.x86_64",
		"elfutils-libs.x86_64",
		"eog.x86_64",
		"ethtool.x86_64",
		"evolution-data-server.x86_64",
		"exempi.x86_64",
		"expat.x86_64",
		"expect.x86_64",
		"fence-agents.x86_64",
		"fence-virt.x86_64",
		"file-libs.x86_64",
		"file.x86_64",
		"filesystem.x86_64",
		"findutils.x86_64",
		"fipscheck-lib.x86_64",
		"fipscheck.x86_64",
		"firefox.x86_64",
		"flac.x86_64",
		"fontconfig.x86_64",
		"fontpackages-filesystem.noarch",
		"fprintd-pam.x86_64",
		"fprintd.x86_64",
		"freeipmi-bmc-watchdog.x86_64",
		"freeipmi-ipmidetectd.x86_64",
		"freeipmi.x86_64",
		"freetype.x86_64",
		"fuse-libs.x86_64",
		"fuse.x86_64",
		"gamin.x86_64",
		"gawk.x86_64",
		"gcc-c++.x86_64",
		"gcc.x86_64",
		"gd.x86_64",
		"gdbm-devel.x86_64",
		"gdbm.x86_64",
		"gdk-pixbuf2.x86_64",
		"gdm-libs.x86_64",
		"gdm-plugin-fingerprint.x86_64",
		"gdm-user-switch-applet.x86_64",
		"gdm.x86_64",
		"gettext.x86_64",
		"gfs2-utils.x86_64",
		"glib-networking.x86_64",
		"glib2.x86_64",
		"glibc-common.x86_64",
		"glibc-devel.x86_64",
		"glibc-headers.x86_64",
		"glibc.i686",
		"glibc.x86_64",
		"glusterfs-api.x86_64",
		"glusterfs-libs.x86_64",
		"glusterfs.x86_64",
		"glx-utils.x86_64",
		"gmp.x86_64",
		"gnome-applets.x86_64",
		"gnome-desktop.x86_64",
		"gnome-disk-utility-libs.x86_64",
		"gnome-doc-utils-stylesheets.noarch",
		"gnome-icon-theme.noarch",
		"gnome-keyring-pam.x86_64",
		"gnome-keyring.x86_64",
		"gnome-media-libs.x86_64",
		"gnome-media.x86_64",
		"gnome-menus.x86_64",
		"gnome-packagekit.x86_64",
		"gnome-panel-libs.x86_64",
		"gnome-panel.x86_64",
		"gnome-power-manager.x86_64",
		"gnome-python2-applet.x86_64",
		"gnome-python2-bonobo.x86_64",
		"gnome-python2-canvas.x86_64",
		"gnome-python2-desktop.x86_64",
		"gnome-python2-extras.x86_64",
		"gnome-python2-gconf.x86_64",
		"gnome-python2-gnome.x86_64",
		"gnome-python2-gnomekeyring.x86_64",
		"gnome-python2-gnomevfs.x86_64",
		"gnome-python2-libegg.x86_64",
		"gnome-python2.x86_64",
		"gnome-screensaver.x86_64",
		"gnome-session-xsession.x86_64",
		"gnome-session.x86_64",
		"gnome-settings-daemon.x86_64",
		"gnome-terminal.x86_64",
		"gnome-themes.noarch",
		"gnome-user-docs.noarch",
		"gnome-utils-libs.x86_64",
		"gnome-utils.x86_64",
		"gnome-vfs2-smb.x86_64",
		"gnome-vfs2.x86_64",
		"gnupg2.x86_64",
		"gnutls-utils.x86_64",
		"gnutls.x86_64",
		"google-crosextra-caladea-fonts.noarch",
		"google-crosextra-carlito-fonts.noarch",
		"gpgme.x86_64",
		"gpm-libs.x86_64",
		"gpm.x86_64",
		"gpxe-roms-qemu.noarch",
		"grep.x86_64",
		"groff.x86_64",
		"grub.x86_64",
		"grubby.x86_64",
		"gstreamer-plugins-base.x86_64",
		"gstreamer-plugins-good.x86_64",
		"gstreamer-tools.x86_64",
		"gstreamer.x86_64",
		"gtk-vnc-python.x86_64",
		"gtk-vnc.x86_64",
		"gtk2-engines.x86_64",
		"gtk2.x86_64",
		"gucharmap.x86_64",
		"gvfs-archive.x86_64",
		"gvfs-fuse.x86_64",
		"gvfs-smb.x86_64",
		"gvfs.x86_64",
		"gzip.x86_64",
		"hal-info.noarch",
		"hal-libs.x86_64",
		"hal.x86_64",
		"hdparm.x86_64",
		"hicolor-icon-theme.noarch",
		"httpd-tools.x86_64",
		"httpd.x86_64",
		"hunspell.x86_64",
		"hwdata.noarch",
		"info.x86_64",
		"initscripts.x86_64",
		"ipmitool.x86_64",
		"iproute.x86_64",
		"iptables-ipv6.x86_64",
		"iptables.x86_64",
		"iputils.x86_64",
		"ipw2100-firmware.noarch",
		"ipw2200-firmware.noarch",
		"irqbalance.x86_64",
		"iscsi-initiator-utils.x86_64",
		"iso-codes.noarch",
		"ivtv-firmware.noarch",
		"iwl100-firmware.noarch",
		"iwl1000-firmware.noarch",
		"iwl3945-firmware.noarch",
		"iwl4965-firmware.noarch",
		"iwl5000-firmware.noarch",
		"iwl5150-firmware.noarch",
		"iwl6000-firmware.noarch",
		"iwl6000g2a-firmware.noarch",
		"iwl6050-firmware.noarch",
		"jasper-libs.x86_64",
		"jomolhari-fonts.noarch",
		"kbd-misc.noarch",
		"kbd.x86_64",
		"kernel-devel.x86_64",
		"kernel-devel.x86_64",
		"kernel-firmware.noarch",
		"kernel-headers.x86_64",
		"kernel.x86_64",
		"kernel.x86_64",
		"kexec-tools.x86_64",
		"keyutils-libs-devel.x86_64",
		"keyutils-libs.x86_64",
		"keyutils.x86_64",
		"khmeros-base-fonts.noarch",
		"khmeros-fonts-common.noarch",
		"kpartx.x86_64",
		"krb5-devel.x86_64",
		"krb5-libs.x86_64",
		"kurdit-unikurd-web-fonts.noarch",
		"lcms-libs.x86_64",
		"less.x86_64",
		"libICE.x86_64",
		"libIDL.x86_64",
		"libSM.x86_64",
		"libX11-common.noarch",
		"libX11.x86_64",
		"libXScrnSaver.x86_64",
		"libXau.x86_64",
		"libXcomposite.x86_64",
		"libXcursor.x86_64",
		"libXdamage.x86_64",
		"libXdmcp.x86_64",
		"libXext.x86_64",
		"libXfixes.x86_64",
		"libXfont.x86_64",
		"libXft.x86_64",
		"libXi.x86_64",
		"libXinerama.x86_64",
		"libXmu.x86_64",
		"libXpm.x86_64",
		"libXrandr.x86_64",
		"libXrender.x86_64",
		"libXres.x86_64",
		"libXt.x86_64",
		"libXtst.x86_64",
		"libXv.x86_64",
		"libXvMC.x86_64",
		"libXxf86dga.x86_64",
		"libXxf86misc.x86_64",
		"libXxf86vm.x86_64",
		"libacl.x86_64",
		"libaio.x86_64",
		"libarchive.x86_64",
		"libart_lgpl.x86_64",
		"libasyncns.x86_64",
		"libatasmart.x86_64",
		"libattr.x86_64",
		"libavc1394.x86_64",
		"libblkid.x86_64",
		"libbonobo.x86_64",
		"libbonoboui.x86_64",
		"libcacard.x86_64",
		"libcanberra-gtk2.x86_64",
		"libcanberra.x86_64",
		"libcap-ng.x86_64",
		"libcap.x86_64",
		"libcdio.x86_64",
		"libcgroup.x86_64",
		"libcom_err-devel.x86_64",
		"libcom_err.x86_64",
		"libcroco.x86_64",
		"libcurl.x86_64",
		"libdmx.x86_64",
		"libdrm.x86_64",
		"libdv.x86_64",
		"libedit.x86_64",
		"liberation-fonts-common.noarch",
		"liberation-mono-fonts.noarch",
		"liberation-sans-fonts.noarch",
		"liberation-serif-fonts.noarch",
		"libertas-usb8388-firmware.noarch",
		"libevent.x86_64",
		"libexif.x86_64",
		"libffi.x86_64",
		"libfontenc.x86_64",
		"libfprint.x86_64",
		"libgail-gnome.x86_64",
		"libgcc.i686",
		"libgcc.x86_64",
		"libgcrypt.x86_64",
		"libgdata.x86_64",
		"libglade2.x86_64",
		"libgnome.x86_64",
		"libgnomecanvas.x86_64",
		"libgnomekbd.x86_64",
		"libgnomeui.x86_64",
		"libgomp.x86_64",
		"libgovirt.x86_64",
		"libgpg-error.x86_64",
		"libgsf.x86_64",
		"libgssglue.x86_64",
		"libgtop2.x86_64",
		"libgudev1.x86_64",
		"libgweather.x86_64",
		"libibverbs.x86_64",
		"libical.x86_64",
		"libidn.x86_64",
		"libiec61883.x86_64",
		"libjpeg-turbo.x86_64",
		"libmcpp.x86_64",
		"libmng.x86_64",
		"libnih.x86_64",
		"libnl.x86_64",
		"libnotify.x86_64",
		"libogg.x86_64",
		"liboil.x86_64",
		"libpcap.x86_64",
		"libpciaccess.x86_64",
		"libpng.x86_64",
		"libproxy-bin.x86_64",
		"libproxy-python.x86_64",
		"libproxy.x86_64",
		"libraw1394.x86_64",
		"librdmacm.x86_64",
		"librsvg2.x86_64",
		"libsamplerate.x86_64",
		"libselinux-devel.x86_64",
		"libselinux-python.x86_64",
		"libselinux-utils.x86_64",
		"libselinux.x86_64",
		"libsemanage-python.x86_64",
		"libsemanage.x86_64",
		"libsepol-devel.x86_64",
		"libsepol.x86_64",
		"libshout.x86_64",
		"libsmbclient.x86_64",
		"libsndfile.x86_64",
		"libsoup.x86_64",
		"libss.x86_64",
		"libssh2.x86_64",
		"libstdc++.x86_64",
		"libtalloc.x86_64",
		"libtasn1.x86_64",
		"libtdb.x86_64",
		"libtevent.x86_64",
		"libthai.x86_64",
		"libtheora.x86_64",
		"libtiff.x86_64",
		"libtirpc.x86_64",
		"libtool-ltdl.x86_64",
		"libudev.x86_64",
		"libusb.x86_64",
		"libusb1.x86_64",
		"libuser.x86_64",
		"libutempter.x86_64",
		"libuuid.x86_64",
		"libv4l.x86_64",
		"libvirt-client.x86_64",
		"libvirt-python.x86_64",
		"libvirt.x86_64",
		"libvisual.x86_64",
		"libvorbis.x86_64",
		"libvpx.x86_64",
		"libwacom-data.noarch",
		"libwacom.x86_64",
		"libwnck.x86_64",
		"libxcb.x86_64",
		"libxkbfile.x86_64",
		"libxklavier.x86_64",
		"libxml2-python.x86_64",
		"libxml2.x86_64",
		"libxslt.x86_64",
		"lklug-fonts.noarch",
		"lm_sensors-libs.x86_64",
		"logrotate.x86_64",
		"lohit-assamese-fonts.noarch",
		"lohit-bengali-fonts.noarch",
		"lohit-devanagari-fonts.noarch",
		"lohit-gujarati-fonts.noarch",
		"lohit-kannada-fonts.noarch",
		"lohit-oriya-fonts.noarch",
		"lohit-punjabi-fonts.noarch",
		"lohit-tamil-fonts.noarch",
		"lohit-telugu-fonts.noarch",
		"lua.x86_64",
		"lvm2-cluster.x86_64",
		"lvm2-libs.x86_64",
		"lvm2.x86_64",
		"lzo.x86_64",
		"lzop.x86_64",
		"m4.x86_64",
		"madan-fonts.noarch",
		"mailcap.noarch",
		"mailx.x86_64",
		"make.x86_64",
		"man.x86_64",
		"mcpp.x86_64",
		"mdadm.x86_64",
		"mesa-dri-drivers.x86_64",
		"mesa-dri-filesystem.x86_64",
		"mesa-dri1-drivers.x86_64",
		"mesa-libEGL.x86_64",
		"mesa-libGL.x86_64",
		"mesa-libGLU.x86_64",
		"mesa-libgbm.x86_64",
		"mesa-private-llvm.x86_64",
		"metacity.x86_64",
		"mingetty.x86_64",
		"mlocate.x86_64",
		"mod_ssl.x86_64",
		"modcluster.x86_64",
		"module-init-tools.x86_64",
		"mozilla-filesystem.x86_64",
		"mpfr.x86_64",
		"mtdev.x86_64",
		"mtools.x86_64",
		"mtr.x86_64",
		"mysql-libs.x86_64",
		"nautilus-extensions.x86_64",
		"nautilus-open-terminal.x86_64",
		"nautilus.x86_64",
		"nc.x86_64",
		"ncurses-base.x86_64",
		"ncurses-libs.x86_64",
		"ncurses.x86_64",
		"net-snmp-libs.x86_64",
		"net-snmp-utils.x86_64",
		"net-snmp.x86_64",
		"net-tools.x86_64",
		"netcf-libs.x86_64",
		"newt-python.x86_64",
		"newt.x86_64",
		"nfs-utils-lib.x86_64",
		"nfs-utils.x86_64",
		"notification-daemon.x86_64",
		"nspr.x86_64",
		"nss-softokn-freebl.i686",
		"nss-softokn-freebl.x86_64",
		"nss-softokn.x86_64",
		"nss-sysinit.x86_64",
		"nss-tools.x86_64",
		"nss-util.x86_64",
		"nss.x86_64",
		"ntp.x86_64",
		"ntpdate.x86_64",
		"numactl.x86_64",
		"numad.x86_64",
		"oddjob.x86_64",
		"openais.x86_64",
		"openaislib.x86_64",
		"openldap.x86_64",
		"openslp.x86_64",
		"openssh-askpass.x86_64",
		"openssh-clients.x86_64",
		"openssh-server.x86_64",
		"openssh.x86_64",
		"openssl-devel.x86_64",
		"openssl.x86_64",
		"p11-kit-trust.x86_64",
		"p11-kit.x86_64",
		"paktype-fonts-common.noarch",
		"paktype-naqsh-fonts.noarch",
		"paktype-tehreer-fonts.noarch",
		"pam.x86_64",
		"pango.x86_64",
		"parted.x86_64",
		"passwd.x86_64",
		"patch.x86_64",
		"pciutils-libs.x86_64",
		"pciutils.x86_64",
		"pcp-conf.x86_64",
		"pcp-libs.x86_64",
		"pcp.x86_64",
		"pcre.x86_64",
		"perl-CGI.x86_64",
		"perl-CPAN.x86_64",
		"perl-Compress-Raw-Zlib.x86_64",
		"perl-Compress-Zlib.x86_64",
		"perl-Crypt-SSLeay.x86_64",
		"perl-DBD-Pg.x86_64",
		"perl-DBI.x86_64",
		"perl-Digest-SHA.x86_64",
		"perl-ExtUtils-MakeMaker.x86_64",
		"perl-ExtUtils-ParseXS.x86_64",
		"perl-HTML-Parser.x86_64",
		"perl-HTML-Tagset.noarch",
		"perl-IO-Compress-Base.x86_64",
		"perl-IO-Compress-Zlib.x86_64",
		"perl-IO-Socket-SSL.noarch",
		"perl-JSON.noarch",
		"perl-Module-Pluggable.x86_64",
		"perl-Net-LibIDN.x86_64",
		"perl-Net-SSLeay.x86_64",
		"perl-Net-Telnet.noarch",
		"perl-PCP-PMDA.x86_64",
		"perl-Pod-Escapes.x86_64",
		"perl-Pod-Simple.x86_64",
		"perl-Sys-Virt.x86_64",
		"perl-TermReadKey.x86_64",
		"perl-Test-Harness.x86_64",
		"perl-Test-Simple.x86_64",
		"perl-Time-HiRes.x86_64",
		"perl-URI.noarch",
		"perl-XML-Parser.x86_64",
		"perl-YAML-Tiny.noarch",
		"perl-devel.x86_64",
		"perl-libs.x86_64",
		"perl-libwww-perl.noarch",
		"perl-version.x86_64",
		"perl.x86_64",
		"pexpect.noarch",
		"phonon-backend-gstreamer.x86_64",
		"pinentry.x86_64",
		"pixman.x86_64",
		"pkgconfig.x86_64",
		"plymouth-core-libs.x86_64",
		"plymouth-gdm-hooks.x86_64",
		"plymouth-graphics-libs.x86_64",
		"plymouth-plugin-label.x86_64",
		"plymouth-plugin-two-step.x86_64",
		"plymouth-scripts.x86_64",
		"plymouth-system-theme.noarch",
		"plymouth-theme-rings.noarch",
		"plymouth-utils.x86_64",
		"plymouth.x86_64",
		"pm-utils.x86_64",
		"policycoreutils-python.x86_64",
		"policycoreutils.x86_64",
		"polkit-desktop-policy.noarch",
		"polkit-gnome.x86_64",
		"polkit.x86_64",
		"popt.x86_64",
		"portreserve.x86_64",
		"postfix.x86_64",
		"ppl.x86_64",
		"procps.x86_64",
		"psmisc.x86_64",
		"pth.x86_64",
		"pulseaudio-gdm-hooks.x86_64",
		"pulseaudio-libs-glib2.x86_64",
		"pulseaudio-libs.x86_64",
		"pulseaudio-module-gconf.x86_64",
		"pulseaudio-module-x11.x86_64",
		"pulseaudio-utils.x86_64",
		"pulseaudio.x86_64",
		"pyOpenSSL.x86_64",
		"pycairo.x86_64",
		"pygobject2.x86_64",
		"pygpgme.x86_64",
		"pygtk2-libglade.x86_64",
		"pygtk2.x86_64",
		"pyorbit.x86_64",
		"python-argparse.noarch",
		"python-iniparse.noarch",
		"python-libs.x86_64",
		"python-pcp.x86_64",
		"python-pycurl.x86_64",
		"python-suds.noarch",
		"python-urlgrabber.noarch",
		"python-virtinst.noarch",
		"python.x86_64",
		"qemu-img.x86_64",
		"qemu-kvm-tools.x86_64",
		"qemu-kvm.x86_64",
		"ql2100-firmware.noarch",
		"ql2200-firmware.noarch",
		"ql23xx-firmware.noarch",
		"ql2400-firmware.noarch",
		"ql2500-firmware.noarch",
		"qt-sqlite.x86_64",
		"qt-x11.x86_64",
		"qt.x86_64",
		"quota.x86_64",
		"radvd.x86_64",
		"rarian-compat.x86_64",
		"rarian.x86_64",
		"rdma.noarch",
		"readline.x86_64",
		"redhat-bookmarks.noarch",
		"redhat-logos.noarch",
		"redhat-menus.noarch",
		"resource-agents.x86_64",
		"rest.x86_64",
		"rgmanager.x86_64",
		"ricci.x86_64",
		"rootfiles.noarch",
		"rpcbind.x86_64",
		"rpm-libs.x86_64",
		"rpm-python.x86_64",
		"rpm.x86_64",
		"rsync.x86_64",
		"rsyslog.x86_64",
		"rt61pci-firmware.noarch",
		"rt73usb-firmware.noarch",
		"rtkit.x86_64",
		"samba-common.x86_64",
		"samba-winbind-clients.x86_64",
		"samba-winbind.x86_64",
		"screen.x86_64",
		"seabios.x86_64",
		"sed.x86_64",
		"selinux-policy-targeted.noarch",
		"selinux-policy.noarch",
		"setools-libs-python.x86_64",
		"setools-libs.x86_64",
		"setup.noarch",
		"sg3_utils-libs.x86_64",
		"sg3_utils.x86_64",
		"sgabios-bin.noarch",
		"sgml-common.noarch",
		"shadow-utils.x86_64",
		"shared-mime-info.x86_64",
		"sil-padauk-fonts.noarch",
		"slang.x86_64",
		"smc-fonts-common.noarch",
		"smc-meera-fonts.noarch",
		"smp_utils.x86_64",
		"snappy.x86_64",
		"sound-theme-freedesktop.noarch",
		"speex.x86_64",
		"spice-glib.x86_64",
		"spice-gtk-python.x86_64",
		"spice-gtk.x86_64",
		"spice-server.x86_64",
		"spice-vdagent.x86_64",
		"sqlite.x86_64",
		"startup-notification.x86_64",
		"stix-fonts.noarch",
		"sudo.x86_64",
		"syslinux-nonlinux.noarch",
		"syslinux.x86_64",
		"sysstat.x86_64",
		"system-config-firewall-base.noarch",
		"system-gnome-theme.noarch",
		"system-icon-theme.noarch",
		"system-setup-keyboard.x86_64",
		"sysvinit-tools.x86_64",
		"taglib.x86_64",
		"tar.x86_64",
		"tcl.x86_64",
		"tcp_wrappers-libs.x86_64",
		"tcp_wrappers.x86_64",
		"telnet.x86_64",
		"tftp-server.x86_64",
		"thai-scalable-fonts-common.noarch",
		"thai-scalable-waree-fonts.noarch",
		"tibetan-machine-uni-fonts.noarch",
		"tog-pegasus-libs.x86_64",
		"tog-pegasus.x86_64",
		"tuned.noarch",
		"tzdata.noarch",
		"udev.x86_64",
		"udisks.x86_64",
		"un-core-dotum-fonts.noarch",
		"un-core-fonts-common.noarch",
		"unique.x86_64",
		"unzip.x86_64",
		"upstart.x86_64",
		"usbredir.x86_64",
		"usermode.x86_64",
		"ustr.x86_64",
		"util-linux-ng.x86_64",
		"vgabios.noarch",
		"vim-common.x86_64",
		"vim-enhanced.x86_64",
		"vim-filesystem.x86_64",
		"vim-minimal.x86_64",
		"vino.x86_64",
		"virt-manager.x86_64",
		"virt-viewer.x86_64",
		"vlgothic-fonts-common.noarch",
		"vlgothic-fonts.noarch",
		"vte.x86_64",
		"wavpack.x86_64",
		"wdaemon.x86_64",
		"wget.x86_64",
		"which.x86_64",
		"wqy-zenhei-fonts.noarch",
		"xcb-util.x86_64",
		"xdg-user-dirs-gtk.x86_64",
		"xdg-user-dirs.x86_64",
		"xinetd.x86_64",
		"xkeyboard-config.noarch",
		"xml-common.noarch",
		"xorg-x11-drivers.x86_64",
		"xorg-x11-drv-acecad.x86_64",
		"xorg-x11-drv-aiptek.x86_64",
		"xorg-x11-drv-apm.x86_64",
		"xorg-x11-drv-ast.x86_64",
		"xorg-x11-drv-ati-firmware.noarch",
		"xorg-x11-drv-ati.x86_64",
		"xorg-x11-drv-cirrus.x86_64",
		"xorg-x11-drv-dummy.x86_64",
		"xorg-x11-drv-elographics.x86_64",
		"xorg-x11-drv-evdev.x86_64",
		"xorg-x11-drv-fbdev.x86_64",
		"xorg-x11-drv-fpit.x86_64",
		"xorg-x11-drv-glint.x86_64",
		"xorg-x11-drv-hyperpen.x86_64",
		"xorg-x11-drv-i128.x86_64",
		"xorg-x11-drv-i740.x86_64",
		"xorg-x11-drv-intel.x86_64",
		"xorg-x11-drv-keyboard.x86_64",
		"xorg-x11-drv-mach64.x86_64",
		"xorg-x11-drv-mga.x86_64",
		"xorg-x11-drv-modesetting.x86_64",
		"xorg-x11-drv-mouse.x86_64",
		"xorg-x11-drv-mutouch.x86_64",
		"xorg-x11-drv-nouveau.x86_64",
		"xorg-x11-drv-nv.x86_64",
		"xorg-x11-drv-openchrome.x86_64",
		"xorg-x11-drv-penmount.x86_64",
		"xorg-x11-drv-qxl.x86_64",
		"xorg-x11-drv-r128.x86_64",
		"xorg-x11-drv-rendition.x86_64",
		"xorg-x11-drv-s3virge.x86_64",
		"xorg-x11-drv-savage.x86_64",
		"xorg-x11-drv-siliconmotion.x86_64",
		"xorg-x11-drv-sis.x86_64",
		"xorg-x11-drv-sisusb.x86_64",
		"xorg-x11-drv-synaptics.x86_64",
		"xorg-x11-drv-tdfx.x86_64",
		"xorg-x11-drv-trident.x86_64",
		"xorg-x11-drv-v4l.x86_64",
		"xorg-x11-drv-vesa.x86_64",
		"xorg-x11-drv-vmmouse.x86_64",
		"xorg-x11-drv-vmware.x86_64",
		"xorg-x11-drv-void.x86_64",
		"xorg-x11-drv-voodoo.x86_64",
		"xorg-x11-drv-wacom.x86_64",
		"xorg-x11-drv-xgi.x86_64",
		"xorg-x11-glamor.x86_64",
		"xorg-x11-server-Xorg.x86_64",
		"xorg-x11-server-common.x86_64",
		"xorg-x11-server-utils.x86_64",
		"xorg-x11-utils.x86_64",
		"xorg-x11-xauth.x86_64",
		"xorg-x11-xinit.x86_64",
		"xorg-x11-xkb-utils.x86_64",
		"xulrunner.x86_64",
		"xvattr.x86_64",
		"xz-libs.x86_64",
		"xz-lzma-compat.x86_64",
		"xz.x86_64",
		"yajl.x86_64",
		"yelp.x86_64",
		"yum-metadata-parser.x86_64",
		"yum.noarch",
		"zd1211-firmware.noarch",
		"zenity.x86_64",
		"zlib-devel.x86_64",
		"zlib.x86_64",
		### On CentOS DVD 2
		"compat-libstdc++-33.i686",
		"libstdc++-devel.i686",
		"libstdc++.i686",
		"mtr-gtk.x86_64",
		"pcp-gui.x86_64",
		"perl-Algorithm-Diff.noarch",
		"perl-Text-Diff.noarch",
		"sharutils.x86_64",
		"syslinux-tftpboot.noarch",
	];
	
	# These are packages specific to one source
	$conf->{sys}{packages}{rhel} = [
		"mtr-gtk.x86_64",					# mtr-gtk-0.75-5.el6.x86_64.rpm
		"pcp-gui.x86_64",					# pcp-gui-3.10.3-3.el6.x86_64.rpm
		"python-gudev.x86_64",					# python-gudev-147.1-4.el6_0.1.x86_64.rpm
		"python-rhsm.x86_64",					# python-rhsm-1.14.3-1.el6.x86_64.rpm
		"redhat-indexhtml.noarch",				# redhat-indexhtml-6-6.el6.noarch.rpm
		"redhat-release-server.x86_64",				# redhat-release-server-6Server-6.7.0.3.el6.x86_64.rpm
		"redhat-support-lib-python.noarch",			# redhat-support-lib-python-0.9.7-3.el6.noarch.rpm
		"redhat-support-tool.noarch",				# redhat-support-tool-0.9.7-4.el6.noarch.rpm
		"rhn-check.noarch",					# rhn-check-1.0.0.1-32.el6.noarch.rpm
		"rhn-client-tools.noarch",				# rhn-client-tools-1.0.0.1-32.el6.noarch.rpm
		"rhn-setup.noarch",					# rhn-setup-1.0.0.1-32.el6.noarch.rpm
		"rhnlib.noarch",					# rhnlib-2.5.22-15.el6.noarch.rpm
		"rhnsd.x86_64",						# rhnsd-4.9.3-2.el6.x86_64.rpm
		"subscription-manager.x86_64",				# subscription-manager-1.14.10-1.el6.x86_64.rpm
		"yum-rhn-plugin.noarch",				# yum-rhn-plugin-0.9.1-58.el6.noarch.rpm
	];
	$conf->{sys}{packages}{centos} = [
		"yum-plugin-fastestmirror.noarch",			# yum-plugin-fastestmirror-1.1.30-30.el6.noarch.rpm
		"centos-indexhtml.noarch",				# centos-indexhtml-6-2.el6.centos.noarch.rpm
		"centos-release.x86_64",				# centos-release-6-7.el6.centos.12.3.x86_64.rpm
	];
	
	# Alteeve-source packages
	$conf->{sys}{packages}{alteeve} = [
		"bash-completion.noarch",
		"drbd84-utils.x86_64",
		"kmod-drbd84.x86_64",
		"ntfs-3g.x86_64",
		"ntfsprogs.x86_64",
		"perl-Net-SSH2.x86_64",
		"perl-XML-Simple.noarch",
		"postgresql95.x86_64",
		"postgresql95-contrib.x86_64",
		"postgresql95-libs.x86_64",
		"postgresql95-plperl.x86_64",
		"postgresql95-server.x86_64",
		"shorewall.noarch",
		"shorewall-core.noarch",
	];
	
	# Binary packages from third parties
	$conf->{sys}{packages}{third_party} = {
		Fujitsu		=>	[
			"SVSystemMonitor.noarch", 
			"ServerViewConnectorService.x86_64", 
			"srv-cimprovider.x86_64", 
			"srvmagt-agents.x86_64", 
			"srvmagt-eecd.x86_64",
			"srvmagt-mods_src.x86_64", 
		],
		Avago		=>	[
			"MegaCli.noarch",
			"storcli.noarch",
		],
	};
	
	return(0);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			elsif (($argument eq "start") or ($argument eq "stop") or ($argument eq "status"))
			{
				$conf->{switches}{$argument} = 1;
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	if ($conf->{sys}{debug} >= 2)
	{
		foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}})
		{
			print "$THIS_FILE ".__LINE__."; [ Debug ] - switches::$variable: [$conf->{switches}{$variable}]\n";
		}
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = "
 -=] Anvil! - Generate ISO

DESCRIPTION

This program will read in a Red Hat Enterprise Linux v6.7 or CentOS v6.7 ISO
and use it to generate an Anvil! install ISO.

This tool is provided as a way to respect the Red Hat and CentOS trademarks 
while providing users with a convenient way to build an Anvil! based on their
preferred distibution.

This tool does NOT alter any of the source RPMs. Instead, it creates a new
'Packages' directory with a subset of the source RPMs needed by the Striker 
dashboard and Anvil! nodes. It also adds additional RPMs as provided by
Alteeve's Niche!.


SWITCHES

--accept-third-part-licenses

	This switch confirms that you have read and agree to the following 
	third party agreements.
	
	Fujitsu:
	- $conf->{sys}{third_party}{Fujitsu}{terms}
	
	Avago:
	- $conf->{sys}{third_party}{Avago}{terms}
	
	With this agreement, support for this hardware will be added to the
	Anvil! ISO.

-h, -?, --help

	Show this dialoge and exit.

--source

	This must be the full path and file name to the source ISO to base the
	Anvil! ISO on. 
	
	NOTE: The source *MUST* be the 'DVD 1' ISO for release 6.7.
	
	If you provide a RHEL ISO, the resulting Anvil! ISO will include RPMs 
	appropriate for registering against Red Hat. Please note that you will
	need to register against Red Hat and entitle the new machines with the
	'Optional' Add-On. The nodes will also need the 'Resilient Storage'
	Add-On as well.
	
	If you provide a CentOS ISO, the RHEL packages will be skipped and 
	CentOS-specific packages will be added.


EXAMPLES

	Build a RHEL-based Anvil! ISO:
	
		./anvil_generate_iso --source ./rhel-server-6.7-x86_64-dvd.iso
	
	Build a CentOS-based Anvil ISO:
	
		./anvil_generate_iso --source ./CentOS-6.7-x86_64-bin-DVD1.iso
	
                  
SUPPORT

https://alteeve.ca/w/Support

                                                              Alteeve's Niche!
";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/${THIS_FILE}.help");

	return(0);
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}
