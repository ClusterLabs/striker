#!/usr/bin/perl

use strict;
use warnings;
use File::Path qw(make_path);
use Net::SSH::Perl;

=pod
rpm -Uvh http://fedora.mirror.nexicom.net/epel/6/x86_64/epel-release-6-8.noarch.rpm
yum -y install perl-Net-SSH-Perl
=cut 

my $THIS_FILE = "an-usb-insert";

my $conf = {
	path	=>	{
		'an-usb_conf'	=>	"/etc/an-usb.conf",
		blkid		=>	"/sbin/blkid",
		ls		=>	"/bin/ls",
		mount		=>	"/bin/mount",
		tail		=>	"/usr/bin/tail",
		umount		=>	"/bin/umount",
	},
	syslog	=>	[],
	devices	=>	{},
};

logger($conf, "AN!USB Insert Script started.");
read_conf($conf);
#logger($conf, "Reading syslog.");
read_syslog($conf);
#logger($conf, "AN!USB Insert Script finished.");

my $this_usb        = "";
my $is_mass_storage = 0;
my $block_device    = "";
my $rule_found      = 0;
foreach my $line (@{$conf->{syslog}})
{
	if ($line =~ /kernel: usb (.*?): New USB device found/)
	{
		$this_usb = $1;
	}
	if ($line =~ /Uniform CD-ROM driver/)
	{
		$block_device = 1;
		last;
	}
	next if not $this_usb;
	$line =~ s/^.*?kernel: //;
	if ($line =~ /SCSI emulation for USB Mass Storage devices/)
	{
		$is_mass_storage = 1;
	}
	next if not $is_mass_storage;
	if ($line =~ /sd(\w+): sd(\w+)\d/)
	{
		my $lhs = $1;
		my $rhs = $2;
		next if (($lhs) && ($lhs ne $rhs));
		$block_device = "sd".$lhs;
	}
	next if not $block_device;
	last;
}
if ($block_device)
{
	$conf->{this_usb} = $this_usb;
	#logger($conf, "USB device: [$this_usb], block device: [$block_device]");
	foreach my $usb (sort {$a cmp $b} keys %{$conf->{usb}})
	{
		if (exists $conf->{usb}{$this_usb})
		{
			   $rule_found   = 1;
			my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
			my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
			my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
			my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
			my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
			my $device       = "/dev/".$block_device;
			#logger($conf, "I will mount filesystems on: [$device] locally as: [$local_mount] and remotely on: [$user\@$host] as: [$remote_mount]");
			last;
		}
	}
	if (not $rule_found)
	{
		logger($conf, "The inserted block device is not using a managed USB port.");
	}
}
else
{
	logger($conf, "The inserted device is not a block device.");
}

if ($rule_found)
{
	my $this_usb     = $conf->{this_usb};
	my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
	my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
	my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
	my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
	my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
	my $device       = "/dev/".$block_device;
	logger($conf, "I will mount the partition on: [$device] locally as: [$local_mount] and remotely on: [$user\@$host] as: [$remote_mount]");
	
	find_file_systems($conf, $device);
	mount_filesystems($conf);
}

sub mount_filesystems
{
	my ($conf) = @_;
	
	### TODO: If I can't make a directory, make an alternative.
	my $i = 0;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{devices}})
	{
		my $this_usb     = $conf->{this_usb};
		my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
		my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
		my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
		my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
		my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
		if ($i)
		{
			$local_mount  .= "-$i";
			$remote_mount .= "-$i";
		}
		logger($conf, "Checking if: [$device ($conf->{devices}{$device}{fs})] is already mounted or not.");
		unmount($conf, $device);
		
		if (not -e $local_mount)
		{
			make_path($local_mount, {
				mode	=>	0777,
			});
			if (not -e $local_mount)
			{
				logger($conf, "Failed to create the local mount directory: [$local_mount]");
				exit(2);
			}
		}
		elsif (not -d $local_mount)
		{
			logger($conf, "There is a file called: [$local_mount], which is where I wanted to create a mount point. Unable to proceed.");
			exit(3);
		}
		$i++;
		
		# Make sure the mount point is empty.
		local(*DIR);
		opendir(DIR, $local_mount) or die "Failed to open the directory: [$local_mount], error was: $!\n";
		while (my $file = readdir(DIR))
		{
			next if (($file eq ".") or ($file eq ".."));
			logger($conf, "Found a file: [$local_mount/$file], the mount point is not empty. Unable to proceed.");
			exit(4);
		}
		
		# Finally, mount the FS.
		my $sc = "$conf->{path}{mount} $device $local_mount";
		open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
		while (<$filehandle>)
		{
			chomp;
			my $line = $_;
		}
		close $filehandle;
		logger($conf, "Successfully mounted: [$device] locally on: [$local_mount].");
		
		# Mount the partition on the target system.
		my ($stdout, $stderr, $exit) = remote_call($conf, "$conf->{path}{ls} -lah $remote_mount");
	}
	
	return(0);
}

sub remote_call
{
	my ($conf, $sc) = @_;
	
	my $this_usb     = $conf->{this_usb};
	my $host         = $conf->{usb}{$this_usb}{sshfs}{host};
	my $user         = $conf->{usb}{$this_usb}{sshfs}{user};
	my $password     = $conf->{usb}{$this_usb}{sshfs}{password};
	my $local_mount  = $conf->{usb}{$this_usb}{local_mount};
	my $remote_mount = $conf->{usb}{$this_usb}{sshfs}{remote_mount};
	
	logger($conf, "Attempting ssh: [$user\@$host] with password: [$password] and call: [$sc]...");
	my $ssh = Net::SSH::Perl->new($host);
	$ssh->login($user, $password);
	$sc = "$conf->{path}{ls} -lah $remote_mount";
	logger($conf, "Calling on: [$host] command: [$sc]...");
	my ($stdout, $stderr, $exit) = $ssh->cmd($sc);
	$stdout = "" if not defined $stdout;
	$stderr = "" if not defined $stderr;
	$exit   = 99 if not defined $exit;
	
	logger($conf, "Received; stdout: [$stdout], stderr: [$stderr], exit code: [$exit]");
	
	return($stdout, $stderr, $exit);
}

sub unmount
{
	my ($conf, $device) = @_;
	
	my $mount_point = get_mount_point($conf, $device);
	if ($mount_point)
	{
		logger($conf, "device: [$device] is mounted on: [$mount_point]. Unmounting.");
		my $sc = "$conf->{path}{umount} $device";
		open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc] Error: $!\n";
		while (<$filehandle>)
		{
			chomp;
			my $line = $_;
		}
		close $filehandle;
		$mount_point = get_mount_point($conf, $device);
		if ($mount_point)
		{
			logger($conf, "Failed to unmount: [$device] from: [$mount_point]");
			exit(1);
		}
		logger($conf, "Device: [$device] unmounted successfully.");
	}
	else
	{
		logger($conf, "device: [$device] is not mounted.");
	}
	
	return(0);
}

sub get_mount_point
{
	my ($conf, $device) = @_;
	
	my $mount_point = "";
	my $sc = "$conf->{path}{mount}";
	open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
	while (<$filehandle>)
	{
		chomp;
		my $line = $_;
		#logger($conf, "line: [$line]");
		if ($line =~ /^$device on (.*?) /)
		{
			$mount_point = $1;
			#logger($conf, "mount_point: [$mount_point]");
		}
	}
	close $filehandle;
	
	return($mount_point);
}

sub find_file_systems
{
	my ($conf, $device) = @_;
	my @filesystems;
	
	my $sc = "$conf->{path}{ls} ${device}*";
	logger($conf, "Calling: [$sc]");
	open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
	while (<$filehandle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, "line: [$line]");
		if (($line eq $device) or ($line =~ /^$device\d+/))
		{
			call_blkid($conf, $line);
		}
	}
	close $filehandle;
		
	return(0);
}

sub call_blkid
{
	my ($conf, $device) = @_;
	
	my $uuid;
	my $fs;
	my $sc = "$conf->{path}{blkid} -c /dev/null $device";
	open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
	while (<$filehandle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, "line: [$line]");
		if ($line =~ /UUID="(.*?)"/)
		{
			$uuid = $1;
		}
		if ($line =~ /TYPE="(.*?)"/)
		{
			$fs = $1;
		}
	}
	close $filehandle;
	
	if ($fs)
	{
		$conf->{devices}{$device}{fs}   = $fs;
		$conf->{devices}{$device}{uuid} = $uuid;
		$conf->{devices}{$device}{path} = $device;
		#logger($conf, "device: [$conf->{devices}{$device}{path}] has a file system of type: [$conf->{devices}{$device}{fs}] with UUID: [$conf->{devices}{$device}{uuid}].");
	}
	else
	{
		#logger($conf, "device: [$device] has no file system.");
	}
	
	return(0);
}

sub read_syslog
{
	my ($conf) = @_;
	
	# I'm interested in the last 24 lines, but this is safer in case
	# something is being noisy.
	my $sc = "$conf->{path}{tail} -n 100 /var/log/messages";
	open (my $filehandle, "$sc 2>&1 |") or die "Failed to call: [$sc]. Error: $!\n";
	while (<$filehandle>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#logger($conf, "line: [$line]");
		next if $line !~ /kernel:/;
		if ($line =~ /New USB device found/)
		{
			# Old logs, clear what I've read so far.
			#logger($conf, "I see a message in syslog about a new USB device, clearing anything seen before.");
			$conf->{syslog} = [];
			push @{$conf->{syslog}}, $line;
			next;
		}
		else
		{
			push @{$conf->{syslog}}, $line;
		}
	}
	close $filehandle;
	
	return(0);
}

sub logger
{
	my ($conf, $message) = @_;
	
	print "$message\n";
	open my $filehandle, '-|', "logger", "-t", $THIS_FILE , "$message" or die "Failed to call: [logger -t $THIS_FILE $message]. Error: $!\n";
	while (<$filehandle>) { print $_; }
	close $filehandle;
	
	return(0);
}

# This reads in the configuration file.
sub read_conf
{
	my ($conf) = @_;
	
	my $fh = IO::Handle->new();
	my $sc = "$conf->{path}{'an-usb_conf'}";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		next if $line !~ /=/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		_make_hash_reference($conf, $var, $val);
	}
	$fh->close();
	
	return(0);
}

###############################################################################
# Sssh, there are private functions                                           #
###############################################################################

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}
