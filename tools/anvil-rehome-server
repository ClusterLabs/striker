#!/usr/bin/perl
# 
# This tool moves a virtual machine from one Anvil! node pair to another. It reaches out to a peer Anvil!, 
# verifies the server isn't running, creates a local LV(s) (if needed), and then use 'dd' over SSH to image
# the source LVs over to the new local LVs. It also copies over the server's XML definition file, updating
# the LV path in the process.
# 
# NOTE: This does NOT remove or otherwise touch the server on the source. When the migration is complete, 
#       test it! If the tests show that the migration succeeded, manually delete the server from the target
# 
# Exit Codes;
# 0  = OK
# 1  = The --server or --target switch wasn't passed.
# 2  = Server not found (or connection to target error)
# 3  = Failed to read (or parse) the server's XML file.
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Data::Dumper;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		'anvil-rehome-server' =>	{
			log_db_transactions	=>	0,
		},
		path		=>	{
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		switches	=>	{
			target			=>	"",	# The host-name or IP address of one of the nodes. It must be a cluster member.
			server			=>	"",	# The name of the server to migrate.
			'new-name'		=>	"",	# This changes the name when it lands here.
		},
		sys		=>	{
			language		=>	"en_CA",
			log_language		=>	"en_CA",
			log_level		=>	2,
			program_name		=>	$program_name,
		},
		dd		=>	{
			block_size		=>	"",
		},
		definition	=>	{
			source_xml		=>	"",
			new_xml			=>	"",
		},
}});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{'anvil-rehome-server'}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Is there a target and server given?
my $proceed = 1;
if (not $an->data->{switches}{target})
{
	$proceed = 0;
	print $an->String->get({key => "arhs_error_0001"})."\n";
}
if (not $an->data->{switches}{server})
{
	$proceed = 0;
	print $an->String->get({key => "arhs_error_0002"})."\n";
}
if (not $proceed)
{
	print $an->String->get({key => "arhs_warning_0001"})."\n";
	$an->nice_exit({exit_code => 1});
}

# Find what anvil the target is in. This also verifies that we have passwordless SSH working.
verify_target_is_ready($an);

### Get the 'bs=' value from the VG's extent size.


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# Find what anvil the target is in. This also verifies that we have passwordless SSH working.
sub verify_target_is_ready
{
	my ($an) = @_;
	
	# First, can i log into the target? 
	check_server($an);
	
	# If we're here, the server was found and it is off.
	print $an->String->get({key => "arhs_message_0002"})."\n";
	
	# Read in the XML definition file
	read_definition_on_target($an);
	
	# Check that we're ready to host this server.
	check_local_system($an);
	
	return(0);
}

# This checks that the local system is ready to take the server.
sub check_local_system
{
	my ($an) = @_;
	
	# Read in our local usage data.
	get_local_resource($an);
	
	# Fist, are we renaming the server?
	$an->data->{new}{server_name}      = $an->data->{switches}{'new-name'} ? $an->data->{switches}{'new-name'} : $an->data->{switches}{server};
	$an->data->{new}{definition}{file} = $an->data->{path}{shared_definitions}."/".$an->data->{new}{server_name}.".xml";
	$an->data->{new}{definition}{xml}  = "";
	
	# If the new server's XML file exists, read it in. We'll create LVs in it that don't already exist.
	if (-e $an->data->{new}{definition}{file})
	{
		# Read the definition and create any missing LVs.
		read_definition_locally($an);
	}
	else
	{
	}
	
	# First; what LVs are needed for this server, and do they exist? if not, is there space for them?
	find_new_lvs($an);
	
	return(0);
}

# This figures out what the new LVs names should be, and checks if they exist. If not, it checks to see if 
# there is enough space to create them.
sub find_new_lvs
{
	my ($an) = @_;
	
	# Loop through each LV from the target's definition and see if there is a match on the loca
	
	return(0);
}

# This uses anvil-report-usage to find out what exists and what resources are free.
sub get_local_resource
{
	my ($an) = @_;
	
	my $usage_xml  = "";
	my $shell_call = $an->data->{path}{'anvil-report-usage'};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		$usage_xml .= $_;
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "usage_xml", value1 => $usage_xml,
	}, file => $THIS_FILE, line => __LINE__});
	my $xml  = XML::Simple->new();
	my $data = $xml->XMLin($usage_xml, ForceArray => 1);
	#print Dumper $data;
	
	# CPU cores?
	my $cores   = $data->{cpu}->[0]->{cores}->[0];
	my $threads = $data->{cpu}->[0]->{threads}->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "cores",   value1 => $cores,
		name2 => "threads", value2 => $threads,
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{'local'}{cpu}{maximum} = $threads > $cores ? $threads : $cores;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "local::cpu::maximum", value1 => $an->data->{'local'}{cpu}{maximum},
	}, file => $THIS_FILE, line => __LINE__});
	
	# RAM?
	$an->data->{'local'}{ram}{available} = $data->{ram}->[0]->{available}->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "local::ram::available", value1 => $an->data->{'local'}{ram}{available}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{ram}{available}}).")",
	}, file => $THIS_FILE, line => __LINE__});
	
	# What VGs do I have?
	foreach my $hash_ref (@{$data->{ 'volume_groups'}->[0]->{'volume_group'}})
	{
		my $name = $hash_ref->{name}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "name", value1 => $name,
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{'local'}{vg}{$name}{size}    = $hash_ref->{size}->[0];
		$an->data->{'local'}{vg}{$name}{free}    = $hash_ref->{size}->[0];
		$an->data->{'local'}{vg}{$name}{pe_size} = $hash_ref->{pe_size}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "local::vg::${name}::size",    value1 => $an->data->{'local'}{vg}{$name}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$name}{size}}).")",
			name2 => "local::vg::${name}::free",    value2 => $an->data->{'local'}{vg}{$name}{free}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$name}{free}}).")",
			name3 => "local::vg::${name}::pe_size", value3 => $an->data->{'local'}{vg}{$name}{pe_size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$name}{pe_size}}).")",
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	foreach my $hash_ref (@{$data->{'logical_volumes'}->[0]->{'logical_volume'}})
	{
		my $name = $hash_ref->{name}->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "name", value1 => $name,
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{'local'}{lv}{$name}{size}  = $hash_ref->{size}->[0];
		$an->data->{'local'}{lv}{$name}{on_vg} = $hash_ref->{on_vg}->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "local::lv::${name}::size",  value1 => $an->data->{'local'}{lv}{$name}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{lv}{$name}{size}}).")",
			name2 => "local::lv::${name}::on_vg", value2 => $an->data->{'local'}{lv}{$name}{on_vg},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Bridges?
	foreach my $bridge (sort {$a cmp $b} @{$data->{bridges}->[0]->{bridge}})
	{
		$an->data->{'local'}{bridge}{$bridge} = 1;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "local::bridge::${bridge}", value1 => $an->data->{'local'}{bridge}{$bridge},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This reads the XML file on the local machine and parses it.
sub read_definition_locally
{
	my ($an) = @_;
	
	my $name = $an->data->{new}{server_name};
	my $xml  = XML::Simple->new();
	my $data = $xml->XMLin($an->data->{new}{definition}{file}, ForceArray => 1);
	
	# Pull out the disks
	foreach my $hash_ref (@{$data->{devices}->[0]->{disk}})
	{
		next if $hash_ref->{device} ne "disk";
		my $source = $hash_ref->{source}->[0]->{dev} ? $hash_ref->{source}->[0]->{dev} : "";
		$an->data->{new}{lv}{$source} = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "new::lv::${source}", value1 => $an->data->{new}{lv}{$source}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Does the source exit? If not, is the VG the same? If so, is there enough space? If so, 
		# create. Otherwise, error out.
		
	}
	
	return(0);
}

# Read in and parse the source XML file.
sub read_definition_on_target
{
	my ($an) = @_;
	
	# Setup some variables.
	my $target = $an->data->{switches}{target};
	my $server = $an->data->{switches}{server};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target", value1 => $target,
		name2 => "server", value2 => $server,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $in_block   = 0;
	my $cores      = 0;
	my $ram        = 0;
	my $disks      = 0;
	my $xml_file   = "/shared/definitions/".$server.".xml";
	my $source_xml = "";
	my $shell_call = $an->data->{path}{ssh}." ".$target." \"cat ".$xml_file."\"";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$source_xml .= $line."\n";
		
		if (($line =~ /<memory unit='(.*?)'>(\d+)<\/memory>/) or ($line =~ /<currentMemory unit='(.*?)'>(\d+)<\/currentMemory>/))
		{
			my $units  = $1;
			my $number = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "units",  value1 => $units, 
				name2 => "number", value2 => $number, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $bytes = $an->Readable->hr_to_bytes({base2 => 1, size => $number, type => $units});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bytes", value1 => $bytes, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($bytes > $ram)
			{
				$ram = $bytes;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "ram", value1 => $ram, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		if ($line =~ /<vcpu placement='static'>(\d+)<\/vcpu>/)
		{
			$cores = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cores", value1 => $cores, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if ($line =~ /<disk type='block'/)
		{
			$in_block = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_block", value1 => $in_block, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if ($in_block)
		{
			if ($line =~ /<\/disk>/)
			{
				$in_block = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "in_block", value1 => $in_block, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			elsif ($line =~ /<source dev='(.*?)'\/>/)
			{
				my $lv = $1;
				my ($vg, $name) = ($lv =~ /\/dev\/(.*?)\/(.*)$/);
				$disks++;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
					name1 => "lv",    value1 => $lv, 
					name2 => "vg",    value2 => $vg, 
					name3 => "name",  value3 => $name, 
					name4 => "disks", value4 => $disks, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{source}{lv}{$name}{source}{path} = $lv;
				$an->data->{source}{lv}{$name}{source}{vg}   = $vg;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "source::lv::${name}::source::path", value1 => $an->data->{source}{lv}{$name}{source}{path}, 
					name2 => "source::lv::${name}::source::vg",   value2 => $an->data->{source}{lv}{$name}{source}{vg}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	close $file_handle;
	
	# Did we read the XML?
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "cores", value1 => $cores, 
		name2 => "ram",   value2 => $ram." (".$an->Readable->bytes_to_hr({'bytes' => $ram}).")", 
		name3 => "disks", value3 => $disks, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $cores) or (not $ram) or (not $disks))
	{
		print $an->String->get({key => "arhs_error_0003", variables => { file => $xml_file, output => $source_xml }})."\n";
		$an->nice_exit({exit_code => 3});
	}
	
	$an->data->{server}{cores} = $cores;
	$an->data->{server}{ram}   = $ram;
	$an->data->{server}{disks} = $disks;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "server::cores", value1 => $an->data->{server}{cores}, 
		name2 => "server::ram",   value2 => $an->data->{server}{ram}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{ram}}).")", 
		name3 => "server::disks", value3 => $an->data->{server}{disks}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the list of LV sizes.
	my $lv_path    = "";
	my $lv_size    = 0;
	   $shell_call = $an->data->{path}{ssh}." ".$target." \"lvdisplay --units b\"";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /LV Path (\/dev\/.*)$/)
		{
			$lv_path = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "lv_path", value1 => $lv_path, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $lv_path;
		
		if ($line =~ /LV Size (\d+) B/)
		{
			$lv_size = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "lv_size", value1 => $lv_size." (".$an->Readable->bytes_to_hr({'bytes' => $lv_size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (not $line)
		{
			if ($lv_size)
			{
				# Is this an LV we care about?
				foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
				{
					# How big is the LV?
					my $this_lv = $an->data->{source}{lv}{$name}{source}{path};
					if ($lv_path eq $this_lv)
					{
						# Found it.
						$an->data->{source}{lv}{$name}{source}{size} = $lv_size;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "source::lv::${name}::source::size", value1 => $an->data->{source}{lv}{$name}{source}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{source}{lv}{$name}{source}{size}}).")", 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
			$lv_path = "";
			$lv_size = 0;
		}
	}
	close $file_handle;
	
	# For each LV, read the parent VG extent size.
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
	{
		# How big is the LV?
		my $this_vg = $an->data->{source}{lv}{$name}{source}{vg};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "this_vg", value1 => $this_vg, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Read the physical extent size?
		if ((not exists $an->data->{source}{vg}{$this_vg}{pe_size}) or (not $an->data->{source}{vg}{$this_vg}{pe_size}))
		{
			# Read in
			my $extent_size = 0;
			my $shell_call  = $an->data->{path}{ssh}." ".$target." \"vgdisplay ".$this_vg." --units b\"";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $an->String->clean_spaces({string => $_});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /PE Size (\d+) B/)
				{
					$an->data->{source}{vg}{$this_vg}{pe_size} = $1;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "source::vg::${this_vg}::pe_size", value1 => $an->data->{source}{vg}{$this_vg}{pe_size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{source}{vg}{$this_vg}{pe_size}}).")",
					}, file => $THIS_FILE, line => __LINE__});
				}
				
			}
			close $file_handle;
			
			if (not $an->data->{source}{vg}{$this_vg}{pe_size})
			{
				# Failed to find the VG's PE size.
				print $an->String->get({key => "arhs_error_0006", variables => { vg => $this_vg }})."\n";
				$an->nice_exit({exit_code => 4});
			}
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "source_xml", value1 => $source_xml, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Summarize.
	print $an->String->get({key => "arhs_message_0003", variables => { 
		ram   => $an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{ram}}),
		cpu   => $an->data->{server}{cores},
		disks => $an->data->{server}{disks},
	}})."\n";
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
	{
		my $logical_volume = $an->data->{source}{lv}{$name}{source}{path};
		my $volume_group   = $an->data->{source}{lv}{$name}{source}{vg};
		my $lv_size        = $an->data->{source}{lv}{$name}{source}{size};
		my $pe_size        = $an->data->{source}{vg}{$volume_group}{pe_size};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "logical_volume", value1 => $logical_volume, 
			name2 => "volume_group",   value2 => $volume_group, 
			name3 => "lv_size",        value3 => $lv_size." (".$an->Readable->bytes_to_hr({'bytes' => $lv_size}).")", 
			name4 => "pe_size",        value4 => $pe_size." (".$an->Readable->bytes_to_hr({'bytes' => $pe_size}).")", 
		}, file => $THIS_FILE, line => __LINE__});
		
		print $an->String->get({key => "arhs_message_0004", variables => { 
			lv    => $logical_volume,
			size  => $an->Readable->bytes_to_hr({'bytes' => $lv_size}),
			block => $an->Readable->bytes_to_hr({'bytes' => $pe_size}),
		}})."\n";
	}
	
	return(0);
}

# This looks to find the server and that it is stopped.
sub check_server
{
	my ($an) = @_;
	
	# Setup some variables.
	my $target = $an->data->{switches}{target};
	my $server = $an->data->{switches}{server};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target", value1 => $target,
		name2 => "server", value2 => $server,
	}, file => $THIS_FILE, line => __LINE__});

	my $found       = 0;
	my $return_code = "";
	my $output      = "";
	my $state       = "";
	my $shell_call  = $an->data->{path}{ssh}." ".$target." \"clustat\" 2>&1";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$output .= $line."\n";
		$line   =  $an->String->clean_spaces({string => $line});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /vm:$server .*? (\w+)$/)
		{
			$found = 1;
			$state = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "found", value1 => $found, 
				name2 => "state", value2 => $state, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	if (not $found)
	{
		print $an->String->get({key => "arhs_error_0003", variables => { output => $output }})."\n";
		$an->nice_exit({exit_code => 2});
	}
	
	if (($state ne "stopped") && ($state ne "disabled"))
	{
		print $an->String->get({key => "arhs_error_0004", variables => { 'state' => $state }})."\n";
		$an->nice_exit({exit_code => 3});
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "arhs_message_0001"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
