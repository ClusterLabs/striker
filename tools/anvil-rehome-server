#!/usr/bin/perl
# 
# This tool moves a virtual machine from one Anvil! node pair to another. It reaches out to a peer Anvil!, 
# verifies the server isn't running, creates a local LV(s) (if needed), and then use 'dd' over SSH to image
# the source LVs over to the new local LVs. It also copies over the server's XML definition file, updating
# the LV path in the process.
# 
# NOTE: This does NOT remove or otherwise touch the server on the source. When the migration is complete, 
#       test it! If the tests show that the migration succeeded, manually delete the server from the target
# 
# Exit Codes;
# 0  = OK
# 1  = The --server or --target switch wasn't passed.
# 2  = Server not found (or connection to target error)
# 3  = Failed to read (or parse) the server's XML file.
# 4  = Failed to find usable VG for incoming LV
# 5  = Exiting on user input.
# 6  = Failed to create an LV.
# 

use strict;
use warnings;
use IO::Handle;
use AN::Tools;
use Data::Dumper;

# Turn off buffering.
$| = 1;

# Strip the 'PATH' variable down so that it doesn't cause problems when called
# via a setuid wrapper.
$ENV{'PATH'} = "/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin";

# Prevent a discrepency between UID/GID and EUID/EGID from throwing an error.
$< = $>;
$( = $);

# Figure out who and where I am.
my $program_name        =  $0;
my $THIS_FILE           =  ($program_name =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($program_name =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $time = time;

my $an = AN::Tools->new({data => {
		'anvil-rehome-server' =>	{
			log_db_transactions	=>	0,
		},
		path		=>	{
			log_file		=>	"/var/log/striker.log",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		switches	=>	{
			target			=>	"",	# The host-name or IP address of one of the nodes. It must be a cluster member.
			server			=>	"",	# The name of the server to migrate.
			'new-name'		=>	"",	# This changes the name when it lands here.
			'y'			=>	"",
			yes			=>	"",
		},
		sys		=>	{
			language		=>	"en_CA",
			log_language		=>	"en_CA",
			log_level		=>	2,
			program_name		=>	$program_name,
		},
		dd		=>	{
			block_size		=>	"",
		},
		definition	=>	{
			source_xml		=>	"",
			new_xml			=>	"",
		},
}});

# Initialize.
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});
$an->Log->level          ($an->data->{sys}{log_level});
$an->Storage->read_conf  ({file => $an->data->{path}{striker_config}});
$an->Storage->read_words ({file => $an->data->{path}{striker_strings}});
$an->Get->switches();
$an->Log->db_transactions(1) if $an->data->{'anvil-rehome-server'}{log_db_transactions};
$an->Readable->base2(1);

if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or 
    ($an->data->{switches}{help}))
{
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Is there a target and server given?
my $proceed = 1;
if (not $an->data->{switches}{target})
{
	$proceed = 0;
	print $an->String->get({key => "arhs_error_0001"})."\n";
}
if (not $an->data->{switches}{server})
{
	$proceed = 0;
	print $an->String->get({key => "arhs_error_0002"})."\n";
}
if (not $proceed)
{
	print $an->String->get({key => "arhs_warning_0001"})."\n";
	$an->nice_exit({exit_code => 1});
}
if ($an->data->{switches}{yes})
{
	$an->data->{switches}{y} = $an->data->{switches}{yes};
}

# Find what anvil the target is in. This also verifies that we have passwordless SSH working.
verify_target_is_ready($an);

# Now run the dd's.
run_dd($an);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This parses the old and new definitions and uses the target devices (vdX) and size to map source LVs to 
# target LVs, crafts the 'dd' calls and then runs them.
sub run_dd
{
	my ($an) = @_;
	
	# Loop through the LVs from the remote
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
	{
		my $from_lv = $an->data->{source}{lv}{$name}{path};
		my $from_vg = $an->data->{source}{lv}{$name}{vg};
		my $size    = $an->data->{source}{lv}{$name}{size};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "name",    value1 => $name, 
			name2 => "from_lv", value2 => $from_lv, 
			name3 => "from_vg", value3 => $from_vg, 
			name4 => "size",    value4 => $size." (".$an->Readable->bytes_to_hr({'bytes' => $size}).")", 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $to_lv      = "";
		my $block_size = "";
		if ((exists $an->data->{image}{$from_lv}) && ($an->data->{image}{$from_lv}{to}))
		{
			$to_lv      = $an->data->{image}{$from_lv}{to};
			$block_size = $an->data->{image}{$from_lv}{bs};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "to_lv",      value1 => $to_lv, 
				name2 => "block_size", value2 => $block_size." (".$an->Readable->bytes_to_hr({'bytes' => $block_size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			get_local_resource($an);
			
			# The LVs exist already, but might have changed names.
			my $new_lv_name = $name;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "new_lv_name", value1 => $new_lv_name, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{new}{server_name})
			{
				my $new_name    =  $an->data->{new}{server_name};
				   $new_name    =~ s/ /_/g;
				my $old_name    =  $an->data->{switches}{server};
				   $new_lv_name =~ s/$old_name/$new_name/;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "new_name",    value1 => $new_name, 
					name2 => "old_name",    value2 => $old_name, 
					name3 => "new_lv_name", value3 => $new_lv_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# What VG is it on?
			my $new_vg = "";
			foreach my $lv (sort {$a cmp $b} keys %{$an->data->{'local'}{lv}})
			{
				next if $lv !~ /\/$new_lv_name$/;
				$new_vg = $an->data->{'local'}{lv}{$lv}{on_vg};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "lv",     value1 => $lv, 
					name2 => "new_vg", value2 => $new_vg, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
				
			my $new_lv = "/dev/".$new_vg."/".$new_lv_name; 
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "new_vg", value1 => $new_vg, 
				name2 => "new_lv", value2 => $new_lv, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Keep track of whick old LVs will be copied to what new LVs.
			$to_lv      = $new_lv;
			$block_size = $an->data->{source}{vg}{$from_vg}{pe_size};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "to_lv",      value1 => $to_lv, 
				name2 => "block_size", value2 => $block_size." (".$an->Readable->bytes_to_hr({'bytes' => $block_size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		my $delay    = 3;
		my $seconds  = ($an->Math->round({number => ((($size / 1024) / 1024) / 100), places => 0}) + $delay);
		my $finished = $an->Readable->time({'time' => $seconds});
		print $an->String->get({key => "arhs_message_0015", variables => {
			from_lv  => $from_lv, 
			size     => $an->Readable->bytes_to_hr({'bytes' => $size}), 
			target   => $an->data->{switches}{target},
			to_lv    => $to_lv, 
			delay    => $delay, 
			finished => $finished,
			seconds  => $an->Readable->comma($seconds),
		}})."\n";
		
		# Give the user time to cancel.
		sleep $delay;
		
		# Start the anvil-watch-dd background process.
		my $shell_call = $an->data->{path}{'anvil-watch-dd'}." &";
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		system ($shell_call);
		
		# We'll use this to track the progress and estimate the time left.
		my $start_time = time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "start_time",  value1 => $start_time,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Now call the dd.
		$shell_call = $an->data->{path}{ssh}." ".$an->data->{switches}{target}." \"".$an->data->{path}{dd}." if=".$from_lv." bs=".$block_size."\" | ".$an->data->{path}{dd}." of=".$to_lv." bs=".$block_size." oflag=dsync";
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^(\d+) bytes /)
			{
				my $bytes_written   = $1;
				my $seconds_elapsed = time - $start_time;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "bytes_written",   value1 => $bytes_written,
					name2 => "seconds_elapsed", value2 => $seconds_elapsed,
				}, file => $THIS_FILE, line => __LINE__});
				
				# We wait until ten seconds have elapsed before we start showing status.
				next if $seconds_elapsed < 2;
				
				# Calculate progress
				my $mib_per_second = $an->Math->round({number => ((($bytes_written / $seconds_elapsed) / 1024) / 1024), places => 1});
				my $say_mps        = $an->String->get({key => "suffix_0018", variables => { number => $mib_per_second }})."\n";
				my $percent        = $an->Math->round({number => (($bytes_written / $size) * 100), places => 2});
				my $seconds_left   = $an->Math->round({number => (($seconds_elapsed / $bytes_written) * ($size - $bytes_written)), places => 0});
				my $say_time_left  = $an->Readable->time({'time' => $seconds_left});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
					name1 => "mib_per_second", value1 => $mib_per_second,
					name2 => "say_mps",        value2 => $say_mps,
					name3 => "percent",        value3 => $percent,
					name4 => "seconds_left",   value4 => $seconds_left,
					name5 => "say_time_left",  value5 => $say_time_left,
				}, file => $THIS_FILE, line => __LINE__});
				
				print $an->String->get({key => "arhs_message_0016", variables => {
					percent   => $percent,
					remaining => $say_time_left, 
					seconds   => $an->Readable->comma($seconds_left),
					speed     => $say_mps, 
					copied    => $an->Readable->bytes_to_hr({'bytes' => $bytes_written}),
					size      => $an->Readable->bytes_to_hr({'bytes' => $size}),
				}})."\n";
			}
		}
		close $file_handle;
	}
	die;
=cut
751+0 records in
751+0 records out
787480576 bytes (787 MB) copied, 5.46186 s, 144 MB/s
=cut

	return(0);
}

# Find what anvil the target is in. This also verifies that we have passwordless SSH working.
sub verify_target_is_ready
{
	my ($an) = @_;
	
	# First, can i log into the target? 
	check_server($an);
	
	# If we're here, the server was found and it is off.
	print $an->String->get({key => "arhs_message_0002"})."\n";
	
	# Read in the XML definition file
	read_definition_on_target($an);
	
	# Check that we're ready to host this server.
	check_local_system($an);
	
	return(0);
}

# This checks that the local system is ready to take the server.
sub check_local_system
{
	my ($an) = @_;
	
	# Read in our local usage data.
	get_local_resource($an);
	
	# Fist, are we renaming the server?
	$an->data->{new}{server_name}      = $an->data->{switches}{'new-name'} ? $an->data->{switches}{'new-name'} : $an->data->{switches}{server};
	$an->data->{new}{definition}{file} = $an->data->{path}{shared_definitions}."/".$an->data->{new}{server_name}.".xml";
	
	# If the new server's XML file exists, read it in. We'll create LVs in it that don't already exist.
	if (-e $an->data->{new}{definition}{file})
	{
		# Read the definition and create any missing LVs.
		read_definition_locally($an);
	}
	else
	{
		# Create the LVs, if needed
		create_lvs($an);
		
		# Write out the new definition
		write_definition($an);
	}
	
	return(0);
}

sub write_definition
{
	my ($an) = @_;
	
	# Walk through the XML we read from the source and modify it.
	my $new_name = $an->data->{new}{server_name};
	my $new_xml  = "";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "new_name", value1 => $new_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	foreach my $line (split/\n/, $an->data->{source}{xml})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => ">> line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /<name>.*?<\/name>/)
		{
			$line =~ s/<name>.*?<\/name>/<name>$new_name<\/name>/;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /<source dev='(.*?)'\/>/)
		{
			my $old_lv = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "old_lv", value1 => $old_lv, 
			}, file => $THIS_FILE, line => __LINE__});
			if ((exists $an->data->{image}{$old_lv}) && ($an->data->{image}{$old_lv}{to}))
			{
				my $new_lv =  $an->data->{image}{$old_lv}{to};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "new_lv", value1 => $new_lv, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$line =~ s/<source dev='$old_lv'\/>/<source dev='$new_lv'\/>/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		if ($line =~ /<source bridge='(.*?)'\/>/)
		{
			my $old_bridge = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "old_bridge", value1 => $old_bridge, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Does the same bridge exist?
			if ((not exists $an->data->{'local'}{bridge}{$old_bridge}) or (not $an->data->{'local'}{bridge}{$old_bridge}))
			{
				### TODO: Make this smarter
				# Nope. Pick a new one.
				my $new_bridge = "";
				foreach my $bridge (sort {$a cmp $b} keys %{$an->data->{'local'}{bridge}})
				{
					next if $bridge !~ /ifn/i;
					$new_bridge = $bridge; 
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "new_bridge", value1 => $new_bridge, 
					}, file => $THIS_FILE, line => __LINE__});
					print $an->String->get({key => "arhs_message_0012", variables => { old_bridge => $old_bridge, new_bridge => $new_bridge }})."\n";
					
					$line =~ s/<source bridge='.*?'\/>/<source bridge='$new_bridge'\/>/;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "<< line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					last;
				}
			}
		}
		$new_xml .= $line."\n";
	}
	
	# Write it out.
	my $shell_call = $an->data->{new}{definition}{file};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
	print $file_handle $new_xml;
	close $file_handle;
	print $an->String->get({key => "arhs_message_0013", variables => { file => $an->data->{new}{definition}{file} }})."\n";
	
	return(0);
}

# This figures out what the new LVs names should be, and checks if they exist. If not, it checks to see if 
# there is enough space to create them.
sub create_lvs
{
	my ($an) = @_;
	
	# Loop through each LV from the target's definition and see if there is a match on the loca
	print $an->String->get({key => "arhs_message_0010"})."\n";
	foreach my $lv_name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
	{
		# How big is the LV?
		my $old_vg   = $an->data->{source}{lv}{$lv_name}{vg};
		my $old_lv   = $an->data->{source}{lv}{$lv_name}{path};
		my $new_size = $an->data->{source}{lv}{$lv_name}{size};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "old_vg",   value1 => $old_vg, 
			name2 => "old_lv",   value2 => $old_lv, 
			name3 => "new_size", value3 => $new_size." (".$an->Readable->bytes_to_hr({'bytes' => $new_size}).")", 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Find the new VG to use.
		my $new_vg = "";
		foreach my $vg_name (sort {$a cmp $b} keys %{$an->data->{'local'}{vg}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "local::vg::${vg_name}::free", value1 => $an->data->{'local'}{vg}{$vg_name}{free}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$vg_name}{free}}).")", 
				name2 => "new_size",                    value2 => $new_size." (".$an->Readable->bytes_to_hr({'bytes' => $new_size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($an->data->{'local'}{vg}{$vg_name}{free} >= $new_size)
			{
				# Found one to use.
				$new_vg = $vg_name;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "new_vg", value1 => $new_vg, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		
		if (not $new_vg)
		{
			# Failed to find a suitable VG for the old LV
			print $an->String->get({key => "arhs_error_0007", variables => { lv => $old_lv }})."\n";
			$an->nice_exit({exit_code => 4});
		}
		
		# Now, what should the new LV be called?
		my $new_lv_name = $lv_name;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "new_lv_name", value1 => $new_lv_name, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($an->data->{new}{server_name})
		{
			my $new_name    =  $an->data->{new}{server_name};
			   $new_name    =~ s/ /_/g;
			my $old_name    =  $an->data->{switches}{server};
			   $new_lv_name =~ s/$old_name/$new_name/;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "new_name",    value1 => $new_name, 
				name2 => "old_name",    value2 => $old_name, 
				name3 => "new_lv_name", value3 => $new_lv_name, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		my $new_lv = "/dev/".$new_vg."/".$new_lv_name; 
		
		# Keep track of whick old LVs will be copied to what new LVs.
		$an->data->{image}{$old_lv}{to} = $new_lv;
		$an->data->{image}{$old_lv}{bs} = $an->data->{source}{vg}{$old_vg}{pe_size};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "image::${old_lv}::to", value1 => $an->data->{image}{$old_lv}{to}, 
			name2 => "image::${old_lv}::bs", value2 => $an->data->{image}{$old_lv}{bs}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{image}{$old_lv}{bs}}).")", 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Does the LV we plan to used exist?
		if ((exists $an->data->{'local'}{lv}{$new_lv}) && ($an->data->{'local'}{lv}{$new_lv}{size}))
		{
			# It does, skip it,
			print $an->String->get({key => "arhs_message_0009", variables => { lv => $new_lv }})."\n";
			next;
		}
		
		my $shell_call = $an->data->{path}{lvcreate}." -L ".$new_size."B -n ".$new_lv_name." ".$new_vg;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "new_lv",     value1 => $new_lv, 
			name2 => "shell_call", value2 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Ask if I can create the LV
		print $an->String->get({key => "arhs_message_0005", variables => { lv => $new_lv }});
		if ($an->data->{switches}{y})
		{
			print "\n".$an->String->get({key => "arhs_message_0006"})."\n";;
		}
		else
		{
			my $answer = <STDIN>;
			chomp($answer);
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "answer", value1 => $answer, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($answer =~ /^n/i)
			{
				# Exit.
				print $an->String->get({key => "arhs_message_0007"})."\n";
				$an->nice_exit({exit_code => 5});
			}
		}

		my $output = "";
		$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			$output .= $_;
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Rescan
		get_local_resource($an);
		
		# Verify the new LV exists
		if ((exists $an->data->{'local'}{lv}{$new_lv}) && ($an->data->{'local'}{lv}{$new_lv}{size}))
		{
			# Made it!
			print $an->String->get({key => "arhs_message_0008"})."\n";
		}
		else
		{
			print $an->String->get({key => "arhs_error_0008", variables => { lv => $new_lv, output => $output }})."\n";
			$an->nice_exit({exit_code => 6});
		}
	}
	print $an->String->get({key => "arhs_message_0011"})."\n";
	
	return(0);
}

# This uses anvil-report-usage to find out what exists and what resources are free.
sub get_local_resource
{
	my ($an) = @_;
	
	my $usage_xml  = "";
	my $shell_call = $an->data->{path}{'anvil-report-usage'};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		$usage_xml .= $_;
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "usage_xml", value1 => $usage_xml,
	}, file => $THIS_FILE, line => __LINE__});
	my $xml  = XML::Simple->new();
	my $data = $xml->XMLin($usage_xml, ForceArray => 1);
	#print Dumper $data;
	
	# CPU cores?
	my $cores   = $data->{cpu}->[0]->{cores}->[0];
	my $threads = $data->{cpu}->[0]->{threads}->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "cores",   value1 => $cores,
		name2 => "threads", value2 => $threads,
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{'local'}{cpu}{maximum} = $threads > $cores ? $threads : $cores;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "local::cpu::maximum", value1 => $an->data->{'local'}{cpu}{maximum},
	}, file => $THIS_FILE, line => __LINE__});
	
	# RAM?
	$an->data->{'local'}{ram}{available} = $data->{ram}->[0]->{available}->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "local::ram::available", value1 => $an->data->{'local'}{ram}{available}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{ram}{available}}).")",
	}, file => $THIS_FILE, line => __LINE__});
	
	# What VGs do I have?
	foreach my $hash_ref (@{$data->{ 'volume_groups'}->[0]->{'volume_group'}})
	{
		my $name = $hash_ref->{name}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "name", value1 => $name,
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{'local'}{vg}{$name}{size}    = $hash_ref->{size}->[0];
		$an->data->{'local'}{vg}{$name}{free}    = $hash_ref->{size}->[0];
		$an->data->{'local'}{vg}{$name}{pe_size} = $hash_ref->{pe_size}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "local::vg::${name}::size",    value1 => $an->data->{'local'}{vg}{$name}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$name}{size}}).")",
			name2 => "local::vg::${name}::free",    value2 => $an->data->{'local'}{vg}{$name}{free}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$name}{free}}).")",
			name3 => "local::vg::${name}::pe_size", value3 => $an->data->{'local'}{vg}{$name}{pe_size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{vg}{$name}{pe_size}}).")",
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	foreach my $hash_ref (@{$data->{'logical_volumes'}->[0]->{'logical_volume'}})
	{
		my $name = $hash_ref->{name}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "name", value1 => $name,
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{'local'}{lv}{$name}{size}  = $hash_ref->{size}->[0];
		$an->data->{'local'}{lv}{$name}{on_vg} = $hash_ref->{on_vg}->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "local::lv::${name}::size",  value1 => $an->data->{'local'}{lv}{$name}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'local'}{lv}{$name}{size}}).")",
			name2 => "local::lv::${name}::on_vg", value2 => $an->data->{'local'}{lv}{$name}{on_vg},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Bridges?
	foreach my $bridge (sort {$a cmp $b} @{$data->{bridges}->[0]->{bridge}})
	{
		$an->data->{'local'}{bridge}{$bridge} = 1;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "local::bridge::${bridge}", value1 => $an->data->{'local'}{bridge}{$bridge},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This reads the XML file on the local machine and parses it.
sub read_definition_locally
{
	my ($an) = @_;
	
	my $name = $an->data->{new}{server_name};
	my $xml  = XML::Simple->new();
	my $data = $xml->XMLin($an->data->{new}{definition}{file}, ForceArray => 1);
	
	# Pull out the disks
	foreach my $hash_ref (@{$data->{devices}->[0]->{disk}})
	{
		next if $hash_ref->{device} ne "disk";
		next if not $hash_ref->{source}->[0]->{dev};
		
		my $source        = $hash_ref->{source}->[0]->{dev};
		my $target_device = $hash_ref->{target}->[0]->{dev};
		
		$an->data->{new}{lv}{$source}{target_device} = $target_device;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "new::lv::${source}::target_device", value1 => $an->data->{new}{lv}{$source}{target_device}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Does the source exit? If not, is the VG the same? If so, is there enough space? If so, 
		# create. Otherwise, error out.
		if ((not exists $an->data->{'local'}{lv}{$source}) or (not $an->data->{'local'}{lv}{$source}{size}))
		{
			# It does not. What VG does it want to use?
			if ($source =~ /\/dev\/(.*?)\/(.*)$/)
			{
				# NOTE: We don't ask permission here because the LVs are defined and need to 
				#       exist. If there's a problem, this will error out and the user will 
				#       have to either manually create the LVs or update the definition file.
				my $vg      = $1;
				my $lv      = $2;
				my $lv_path = "/dev/".$vg."/".$lv;
				my $size    = exists $an->data->{source}{lv}{$lv} ? $an->data->{source}{lv}{$lv}{size} : 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
					name1 => "vg",      value1 => $vg, 
					name2 => "lv",      value2 => $lv, 
					name3 => "lv_path", value3 => $lv_path, 
					name4 => "size",    value4 => $size." (".$an->Readable->bytes_to_hr({'bytes' => $size}).")", 
				}, file => $THIS_FILE, line => __LINE__});
				
				print $an->String->get({key => "arhs_message_0014", variables => { lv => $lv_path, size => $an->Readable->bytes_to_hr({'bytes' => $size}) }})."\n";
				my $shell_call = $an->data->{path}{lvcreate}." -L ".$size."B -n ".$lv." ".$vg;
				my $output = "";
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					$output .= $_;
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line,
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
				
				# Re-read local status and see if the LV exists now.
				get_local_resource($an);
				
				# Verify the new LV exists
				if ((exists $an->data->{'local'}{lv}{$lv_path}) && ($an->data->{'local'}{lv}{$lv_path}{size}))
				{
					# Made it!
					print $an->String->get({key => "arhs_message_0008"})."\n";
				}
				else
				{
					print $an->String->get({key => "arhs_error_0008", variables => { lv => $lv_path, output => $output }})."\n";
					$an->nice_exit({exit_code => 6});
				}
			}
		}
	}
	
	return(0);
}

# Read in and parse the source XML file.
sub read_definition_on_target
{
	my ($an) = @_;
	
	# Setup some variables.
	my $target = $an->data->{switches}{target};
	my $server = $an->data->{switches}{server};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target", value1 => $target,
		name2 => "server", value2 => $server,
	}, file => $THIS_FILE, line => __LINE__});
	
	### TODO: When porting to M3, use XMLin
	my $in_block   = 0;
	my $cores      = 0;
	my $ram        = 0;
	my $disks      = 0;
	my $xml_file   = "/shared/definitions/".$server.".xml";
	my $source_xml = "";
	my $this_lv    = "";
	my $shell_call = $an->data->{path}{ssh}." ".$target." \"cat ".$xml_file."\"";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$source_xml .= $line."\n";
		
		if (($line =~ /<memory unit='(.*?)'>(\d+)<\/memory>/) or ($line =~ /<currentMemory unit='(.*?)'>(\d+)<\/currentMemory>/))
		{
			my $units  = $1;
			my $number = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "units",  value1 => $units, 
				name2 => "number", value2 => $number, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $bytes = $an->Readable->hr_to_bytes({base2 => 1, size => $number, type => $units});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bytes", value1 => $bytes, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($bytes > $ram)
			{
				$ram = $bytes;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "ram", value1 => $ram, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		if ($line =~ /<vcpu placement='static'>(\d+)<\/vcpu>/)
		{
			$cores = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cores", value1 => $cores, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if ($line =~ /<disk type='block'/)
		{
			$in_block = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_block", value1 => $in_block, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if ($in_block)
		{
			if ($line =~ /<\/disk>/)
			{
				$in_block = 0;
				$this_lv  = "";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_block", value1 => $in_block, 
					name2 => "this_lv",  value2 => $this_lv, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			elsif ($line =~ /<source dev='(.*?)'\/>/)
			{
				my $lv_path = $1;
				(my $vg, $this_lv) = ($lv_path =~ /\/dev\/(.*?)\/(.*)$/);
				$disks++;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
					name1 => "lv_path", value1 => $lv_path, 
					name2 => "vg",      value2 => $vg, 
					name3 => "this_lv", value3 => $this_lv, 
					name4 => "disks",   value4 => $disks, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{source}{lv}{$this_lv}{path} = $lv_path;
				$an->data->{source}{lv}{$this_lv}{vg}   = $vg;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "source::lv::${this_lv}::path", value1 => $an->data->{source}{lv}{$this_lv}{path}, 
					name2 => "source::lv::${this_lv}::vg",   value2 => $an->data->{source}{lv}{$this_lv}{vg}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($line =~ /<target dev='(.*?)'/)
			{
				my $target_device = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "target_device", value1 => $target_device, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# This should usually be set by now
				if ($this_lv)
				{
					$an->data->{source}{lv}{$this_lv}{target_device} = $target_device;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "source::lv::${this_lv}::target_device", value1 => $an->data->{source}{lv}{$this_lv}{target_device}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
	}
	close $file_handle;
	
	# Did we read the XML?
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "cores", value1 => $cores, 
		name2 => "ram",   value2 => $ram." (".$an->Readable->bytes_to_hr({'bytes' => $ram}).")", 
		name3 => "disks", value3 => $disks, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not $cores) or (not $ram) or (not $disks))
	{
		print $an->String->get({key => "arhs_error_0003", variables => { file => $xml_file, output => $source_xml }})."\n";
		$an->nice_exit({exit_code => 3});
	}
	
	# Store the XML now.
	$an->data->{source}{xml} = $source_xml;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "source::xml", value1 => $an->data->{source}{xml}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	$an->data->{server}{cores} = $cores;
	$an->data->{server}{ram}   = $ram;
	$an->data->{server}{disks} = $disks;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "server::cores", value1 => $an->data->{server}{cores}, 
		name2 => "server::ram",   value2 => $an->data->{server}{ram}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{ram}}).")", 
		name3 => "server::disks", value3 => $an->data->{server}{disks}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the list of LV sizes.
	my $lv_path    = "";
	my $lv_size    = 0;
	   $shell_call = $an->data->{path}{ssh}." ".$target." \"lvdisplay --units b\"";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $an->String->clean_spaces({string => $_});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /LV Path (\/dev\/.*)$/)
		{
			$lv_path = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "lv_path", value1 => $lv_path, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $lv_path;
		
		if ($line =~ /LV Size (\d+) B/)
		{
			$lv_size = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "lv_size", value1 => $lv_size." (".$an->Readable->bytes_to_hr({'bytes' => $lv_size}).")", 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (not $line)
		{
			if ($lv_size)
			{
				# Is this an LV we care about?
				foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
				{
					# How big is the LV?
					my $this_lv = $an->data->{source}{lv}{$name}{path};
					if ($lv_path eq $this_lv)
					{
						# Found it.
						$an->data->{source}{lv}{$name}{size} = $lv_size;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "source::lv::${name}::size", value1 => $an->data->{source}{lv}{$name}{size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{source}{lv}{$name}{size}}).")", 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
			$lv_path = "";
			$lv_size = 0;
		}
	}
	close $file_handle;
	
	# For each LV, read the parent VG extent size.
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
	{
		# How big is the LV?
		my $this_vg = $an->data->{source}{lv}{$name}{vg};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "this_vg", value1 => $this_vg, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Read the physical extent size?
		if ((not exists $an->data->{source}{vg}{$this_vg}{pe_size}) or (not $an->data->{source}{vg}{$this_vg}{pe_size}))
		{
			# Read in
			my $extent_size = 0;
			my $shell_call  = $an->data->{path}{ssh}." ".$target." \"vgdisplay ".$this_vg." --units b\"";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $an->String->clean_spaces({string => $_});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /PE Size (\d+) B/)
				{
					$an->data->{source}{vg}{$this_vg}{pe_size} = $1;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "source::vg::${this_vg}::pe_size", value1 => $an->data->{source}{vg}{$this_vg}{pe_size}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{source}{vg}{$this_vg}{pe_size}}).")",
					}, file => $THIS_FILE, line => __LINE__});
				}
				
			}
			close $file_handle;
			
			if (not $an->data->{source}{vg}{$this_vg}{pe_size})
			{
				# Failed to find the VG's PE size.
				print $an->String->get({key => "arhs_error_0006", variables => { vg => $this_vg }})."\n";
				$an->nice_exit({exit_code => 4});
			}
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "source_xml", value1 => $source_xml, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Summarize.
	print $an->String->get({key => "arhs_message_0003", variables => { 
		ram   => $an->Readable->bytes_to_hr({'bytes' => $an->data->{server}{ram}}),
		cpu   => $an->data->{server}{cores},
		disks => $an->data->{server}{disks},
	}})."\n";
	foreach my $name (sort {$a cmp $b} keys %{$an->data->{source}{lv}})
	{
		my $logical_volume = $an->data->{source}{lv}{$name}{path};
		my $volume_group   = $an->data->{source}{lv}{$name}{vg};
		my $lv_size        = $an->data->{source}{lv}{$name}{size};
		my $pe_size        = $an->data->{source}{vg}{$volume_group}{pe_size};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "logical_volume", value1 => $logical_volume, 
			name2 => "volume_group",   value2 => $volume_group, 
			name3 => "lv_size",        value3 => $lv_size." (".$an->Readable->bytes_to_hr({'bytes' => $lv_size}).")", 
			name4 => "pe_size",        value4 => $pe_size." (".$an->Readable->bytes_to_hr({'bytes' => $pe_size}).")", 
		}, file => $THIS_FILE, line => __LINE__});
		
		print $an->String->get({key => "arhs_message_0004", variables => { 
			lv    => $logical_volume,
			size  => $an->Readable->bytes_to_hr({'bytes' => $lv_size}),
			block => $an->Readable->bytes_to_hr({'bytes' => $pe_size}),
		}})."\n";
	}
	print "\n";
	
	return(0);
}

# This looks to find the server and that it is stopped.
sub check_server
{
	my ($an) = @_;
	
	# Setup some variables.
	my $target = $an->data->{switches}{target};
	my $server = $an->data->{switches}{server};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target", value1 => $target,
		name2 => "server", value2 => $server,
	}, file => $THIS_FILE, line => __LINE__});

	my $found       = 0;
	my $return_code = "";
	my $output      = "";
	my $state       = "";
	my $shell_call  = $an->data->{path}{ssh}." ".$target." \"clustat\" 2>&1";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call,
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$output .= $line."\n";
		$line   =  $an->String->clean_spaces({string => $line});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /vm:$server .*? (\w+)$/)
		{
			$found = 1;
			$state = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "found", value1 => $found, 
				name2 => "state", value2 => $state, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	if (not $found)
	{
		print $an->String->get({key => "arhs_error_0003", variables => { output => $output }})."\n";
		$an->nice_exit({exit_code => 2});
	}
	
	if (($state ne "stopped") && ($state ne "disabled"))
	{
		print $an->String->get({key => "arhs_error_0004", variables => { 'state' => $state }})."\n";
		$an->nice_exit({exit_code => 3});
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $an->String->get({key => "arhs_message_0001"})."\n";
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
