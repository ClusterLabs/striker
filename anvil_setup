#!/usr/bin/perl
#
# TODO:
# Test VM iface up/down with:
# - virsh domif-setlink an-c06n01 vnet0 down

use strict;
use warnings;
use IO::Handle;

$| = 1;

my $conf = {
	answers			=>	{
		customer_prefix		=>	"xx",
		customer_domain		=>	"example.com",
		cluster_id		=>	"01",
		node_id			=>	"01",
		bcn_ip			=>	"10.20.",
		bcn_netmask		=>	"255.255.0.0",
		sn_ip			=>	"10.10.",
		sn_netmask		=>	"255.255.0.0",
		ifn_ip			=>	"10.255.",
		ifn_netmask		=>	"255.255.0.0",
		ifn_gateway		=>	"10.255.255.254",
		ifn_dg			=>	"yes",
		ifn2_ip			=>	"10.254.",
		ifn2_netmask		=>	"255.255.0.0",
		ifn2_gateway		=>	"10.254.255.254",
		ifn2_dg			=>	"no",
		ipmi_ip			=>	"10.20.",
		ipmi_netmask		=>	"255.255.0.0",
		ipmi_gateway		=>	"",
		ipmi_user		=>	"admin",
		dns1			=>	"8.8.8.8",
		dns2			=>	"8.8.4.4",
		shared_storage		=>	"40",
		storage_pool_1		=>	"0",
		storage_pool_2		=>	"0",
		ntp_server		=>	"tick.redhat.com",
		configure_ups		=>	"yes",
		password		=>	"",
		ups			=>	{
			ups1			=>	{
				name			=>	"",
				address			=>	"10.20.3.",
				snmp_port		=>	161,
				snmp_vendor		=>	"APC_NOTRAP",
				community		=>	"private",
				nisport			=>	"",
				events			=>	"",
				polltime		=>	10,
			},
			ups2			=>	{
				name			=>	"",
				address			=>	"10.20.3.",
				snmp_port		=>	161,
				snmp_vendor		=>	"APC_NOTRAP",
				community		=>	"private",
				nisport			=>	"",
				events			=>	"",
				polltime		=>	10,
			},
		},
		ssh_keys		=>	{
			node1			=>	{
				private			=>	"",
				public			=>	"",
			},
			node2			=>	{
				private			=>	"",
				public			=>	"",
			},
		},
	},
	groups			=>	{
		install			=>	[
			"development",
		],
	},
	apps			=>	{
		install			=>	[
				"acpid", 
				"cman",
				"ccs", 
				"corosync",
				"dmidecode", 
				"fence-agents", 
				"freeipmi",
				"freeipmi-bmc-watchdog",
				"freeipmi-ipmidetectd",
				"gcc", 
				"gd",
				"gfs2-utils",
				"gpm",
				"libvirt",
				"lvm2-cluster",
				"make",
				"man", 
				"mlocate",
				"ntp",
				"OpenIPMI",
				"OpenIPMI-libs",
				"openssh-clients", 
				"openssl-devel", 
				"perl-CGI", 
				"perl-CPAN", 
				"perl-Net-SSLeay", 
				"perl-YAML-Tiny", 
				"python-virtinst",
				"qemu-kvm",
				"qemu-kvm-tools",
				"ricci",
				"rgmanager",
				"rsync",
				"screen",
				"syslinux", 
				"telnet", 
				"vim-enhanced", 
				"virt-viewer",
				"wget",
				"yum-utils",
		],
		remove			=>	[
				"NetworkManager",
		],
		enable			=>	[
				"ipmi",
				"ntpd",
				"ricci",
				"modclusterd",
				"gpm",
		],
		disable			=>	[
				"acpid", 
				"clvmd",
				"cman",
				"drbd",
				"gfs2",
				"ip6tables",
				"iptables",
				"kdump",
				"rgmanager",
		],
		from_http		=>	{
			apcupsd			=>	"https://alteeve.ca/files/apcupsd/apcupsd-latest.el6.x86_64.rpm",
		},
		repos				=>	{
			elrepo				=>	{
				key				=>	"http://elrepo.org/RPM-GPG-KEY-elrepo.org",
				rpm				=>	"http://elrepo.org/elrepo-release-6-4.el6.elrepo.noarch.rpm",
				file				=>	"/etc/yum.repos.d/elrepo.repo",
				install				=>	["drbd83-utils", "kmod-drbd83"],
			},
		},
	},
	commands		=>	{
		'ssh-keygen'		=>	"ssh-keygen -t rsa -N \"\" -b 4095 -f",
		fingerprint		=>	"ssh-keygen -lf",
	},
	files			=>	{
		answers			=>	"anvil_setup.answers",
		install_log		=>	"anvil_setup.log",
		ssh_keys		=>	{
			node1			=>	{
				private			=>	"",
				public			=>	"",
				hostname		=>	"",	# This may seem odd to be here, but it's used in generating ssh's known_hosts and authorized_keys.
				shortname		=>	"",
				contents		=>	{
					private			=>	"",
					public			=>	"",
				},
			},
			node2			=>	{
				private			=>	"",
				public			=>	"",
				hostname		=>	"",
				shortname		=>	"",
				contents		=>	{
					private			=>	"",
					public			=>	"",
				},
			},
			local_key		=>	"/root/.ssh/id_rsa",
			peer_key		=>	"/tmp/peer_id_rsa",
			public_suffix		=>	".pub",
		},
		# known_hosts format is '{ip|hostname} id_rsa $rsa_pub_key'
	},
	nic			=>	{
		count			=>	0,
		ifn_count		=>	1,
	},
	'system'		=>	{
		reboot_required		=>	0,
		skip_network		=>	0,
		skip_ups		=>	0,
		skip_disk		=>	0,
		local_hostname		=>	"",
		local_shortname		=>	"",
		local_key		=>	"",
		peer_key		=>	"",
		peer_hostname		=>	"",
		peer_shortname		=>	"",
		ssh_use_cache_local	=>	1,
		ssh_use_cache_peer	=>	1,
	},
};

record($conf, "\n-=] Anvil! Configuration Tool\n\n");

### TODO: If this is a RHEL box, ask the user to authenticate before
###       proceeding.

# Setup
collect_data($conf);
ask_questions($conf);

# Configure
set_hostname($conf);
install_core_dependencies($conf);
partition_disk($conf);
configure_nics($conf);
configure_ipmi($conf);
write_hosts($conf);
disable_selinux($conf);
setup_ssh($conf);
install_apps($conf);
setup_ntpd($conf);
disable_libvirt_bridge($conf);
install_acpupsd($conf);
modify_daemons($conf);
set_text_boot($conf);
set_password($conf);
write_out_scripts($conf);

my $say_cluster = "$conf->{answers}{customer_prefix}-cluster-$conf->{answers}{cluster_id}";
my $say_vg1     = "$conf->{answers}{customer_prefix}-c$conf->{answers}{node_id}n01_vg0";
my $say_vg2     = "$conf->{answers}{customer_prefix}-c$conf->{answers}{node_id}n02_vg0";
record($conf, "Initial configuration is complete!\n");
record($conf, "Manual tasks remaining;\n\n");
record($conf, " - Manually create the ~/.ssh/authorized_keys file.\n");
record($conf, " - Merge /etc/hosts and add foundation pack devices.\n");
if ($conf->{'system'}{reboot_required})
{
	record ($conf, " - One or more changes require a reboot.\n");
	record ($conf, " - Please reboot your node as soon as possible.\n");
}
record($conf, "modprobe drbd\n");
record($conf, "drbdadm create-md r{0,1}\n");
record($conf, "drbdadm attach r{0,1}\n");
record($conf, "drbdadm connect r{0,1}\n");
record($conf, "On one node only:\n");
record($conf, "drbdadm -- --clear-bitmap new-current-uuid r{0,1}\n");
record($conf, "On both:\n");
record($conf, "drbdadm primary r{0,1}\n");
record($conf, "pvcreate /dev/drbd{0,1}\n");
record($conf, "vgcreate -c y $say_vg1 /dev/drbd0\n");
record($conf, "vgcreate -c y $say_vg2 /dev/drbd1\n");
record($conf, "lvcreate -L 40G -n shared $say_vg1\n");
record($conf, "mkfs.gfs2 -p lock_dlm -j 2 -t $say_cluster:shared /dev/$say_vg1/shared\n");
record($conf, "mkdir /shared\n");
record($conf, "mount /dev/$say_vg1/shared /shared\n");
record($conf, "echo `gfs2_tool sb /dev/$say_vg1/shared uuid | awk '/uuid =/ { print \$4; }' | sed -e \"s/\(.*\)/UUID=\\L\\1\\E \/shared\\t\\tgfs2\\tdefaults,noatime,nodiratime\\t0 0/\"` >> /etc/fstab\n");
record($conf, "/etc/init.d/gfs2 status\n");

###############################################################################
# Functions                                                                   #
###############################################################################

sub write_out_scripts
{
	my ($conf) = @_;
	
	# Write out node #2's stage #1 script.
	#write_out_script_node2_stage1($conf);
	
	#write_out_script_node1_stage2($conf);
	#write_out_script_node2_stage2($conf);
	
	return(0);
}

sub write_out_script_node2_stage1
{
	my ($conf) = @_;
	
	my @node2_stage1 = [];
	
	
	
	return(0);
}

# This handles any exit or die scenario.
sub nice_exit
{
	my ($conf, $exit_code, $message) = @_;
	$exit_code = 99 if not defined $exit_code;
	$message   = "" if not defined $message;
	
	if ($message)
	{
		record($conf, $message);
	}
	exit($exit_code);
}

# This formats the current date and time.
sub get_current_date_time
{
	my ($conf) = @_;
	my $date_and_time = "";
	
	my %time          = ();
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{suffix}   = "";
	
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	my $date          = $time{year}."/".$time{pad_mon}."/".$time{pad_mday};
	my $time          = $time{pad_hour}.":".$time{pad_min}.":".$time{pad_sec};
	   $date_and_time = "$date $time";
	
	return ($date_and_time);
}

# This records messages to the log and prints them to the screen.
sub record
{
	my ($conf, $message) = @_;
	
	# If the log file isn't open yet, open it.
	my $log_fh;
	if (exists $conf->{'system'}{log_fh})
	{
		$log_fh = $conf->{'system'}{log_fh};
	}
	else
	{
		my $log_file = $conf->{files}{install_log};
		   $log_fh   = IO::Handle->new();
		# I can't use "nice_exit" here as a failure would trigger an
		# infinite loop.
		open ($log_fh, ">$log_file") or die "Failed to open the log file: [$log_file], the error was: $!\n";
		$conf->{'system'}{log_fh} = $log_fh;
		print $log_fh "-=] anvil_setup install log started on: [".get_current_date_time($conf)."]\n";
	}
	
	print $log_fh $message;
	print $message;
	
	return(0);
}

sub set_password
{
	my ($conf) = @_;
	
	record($conf, "Setting the password for the 'root' and 'ricci' users.\n");
	if (not $conf->{answers}{password})
	{
		record($conf, " - Skipping. No password specified!\n");
	}
	
	#echo $PASSWORD | passwd --stdin alteeve
	foreach my $user ("root", "ricci")
	{
		record($conf, " - Setting password for: [$user]\n");
		my $sc          = "echo $conf->{answers}{password} | passwd --stdin $user";
		my $fh          = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	record($conf, " - Done!\n");
	
	return(0);
}

sub install_acpupsd
{
	my ($conf) = @_;
	
	# Bail if the user has not asked to setup UPSes.
	return(0) if $conf->{'system'}{skip_ups};
	
	# TODO: Make the apcupsd install component optional.
	record($conf, "Installing and configuring the UPS monitoring application.\n");
	
	# Short names for easier code reading
	my $ups1 = $conf->{answers}{ups}{ups1}{name};
	my $ups2 = $conf->{answers}{ups}{ups2}{name};
	#record($conf, "- ups1: [$ups1], ups2: [$ups2]\n");
	
	# Install the apcupsd RPM if needed.
	record($conf, "Installing 'apcupsd':\n");
	if (-e "/etc/init.d/apcupsd")
	{
		record($conf, " - The 'apcupsd' program has already been installed.\n");
	}
	else
	{
		my $apcupsd_rpm = $conf->{apps}{from_http}{apcupsd};
		my $sc          = "rpm -Uvh $apcupsd_rpm";
		my $fh          = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		if (-e "/etc/init.d/apcupsd")
		{
			record($conf, " - Done.\n");
		}
		else
		{
			record($conf, " - Failed!\n");
			nice_exit($conf, 1, "I was unable to install: [apcupsd] from: [$apcupsd_rpm].\n");
		}
	}
	
	# Make the null script directory.
	record($conf, "Creating the 'null' scripts directory:\n");
	if (-e "/etc/apcupsd/null")
	{
		record($conf, " - The null script directory already exists.\n");
	}
	else
	{
		my $sc          = "mkdir /etc/apcupsd/null";
		my $fh          = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		if (-e "/etc/apcupsd/null")
		{
			record($conf, " - Done.\n");
		}
		else
		{
			record($conf, " - Failed!\n");
			nice_exit($conf, 1, "I was unable to create the: [/etc/apcupsd/null] directory.\n");
		}
	}
	
	record($conf, "Configuring 'apcupsd' and modifying it to support two UPSes:\n");
	if (-e "/etc/apcupsd/apcupsd.conf.anvil")
	{
		record($conf, " - Backup of 'apcupsd.conf' already created.\n");
	}
	else
	{
		my $sc = "cp /etc/apcupsd/apcupsd.conf /etc/apcupsd/apcupsd.conf.anvil";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "Copying the default configuration to the '$ups1' configuration:\n");
	if (-e "/etc/apcupsd/apcupsd.${ups1}.conf")
	{
		record($conf, " - The 'apcupsd.${ups1}.conf' configuration file already created.\n");
	}
	else
	{
		my $sc = "cp /etc/apcupsd/apcupsd.conf /etc/apcupsd/apcupsd.${ups1}.conf";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "Copying the base '${ups1}' configuration to the '${ups2}' configuration:\n");
	if (-e "/etc/apcupsd/apcupsd.${ups2}.conf")
	{
		record($conf, " - The 'apcupsd.${ups2}.conf' configuration file already created.\n");
	}
	else
	{
		my $sc = "cp /etc/apcupsd/apcupsd.${ups1}.conf /etc/apcupsd/apcupsd.${ups2}.conf";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "Backing up the default 'apcupsd' init.d script:\n");
	if (-e "/etc/init.d/apcupsd.anvil")
	{
		record($conf, " - The '/etc/init.d/apcupsd.anvil' backup init.d script was already created.\n");
	}
	else
	{
		my $sc = "cp /etc/init.d/apcupsd /etc/init.d/apcupsd.anvil";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "Configuring UPS confguration files:\n");
	foreach my $ups ("ups1", "ups2")
	{
		my $name          = $conf->{answers}{ups}{$ups}{name};
		my $config_file   = "/etc/apcupsd/apcupsd.${name}.conf";
		my $address       = $conf->{answers}{ups}{$ups}{address};
		my $snmp_port     = $conf->{answers}{ups}{$ups}{snmp_port};
		my $snmp_vendor   = $conf->{answers}{ups}{$ups}{snmp_vendor};
		my $community     = $conf->{answers}{ups}{$ups}{community};
		my $polltime      = $conf->{answers}{ups}{$ups}{polltime};
		my $nisport       = $conf->{answers}{ups}{$ups}{nisport};
		my $events        = $conf->{answers}{ups}{$ups}{events};
		my $device_string = "${address}:${snmp_port}:${snmp_vendor}:${community}";
		#record($conf, " - name: [$name], device_string: [$device_string], polltime: [$polltime], nisport: [$nisport], events: [$events]\n");
		my @lines;
		
		my $sc = "$config_file";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, " - $line\n");
			
			# Strip off the leading # from UPSNAME and then set the
			# name of the UPS. This is done in two steps to make
			# sure this works on re-runs of the script
			#print ">> line: $line\n";
			$line =~ s/^#UPSNAME/UPSNAME/;
			$line =~ s/^UPSNAME.*/UPSNAME $name/;
			
			# Set the UPS type to SNMP and set the connection 
			# details.
			$line =~ s/^UPSTYPE.*/UPSTYPE snmp/;
			$line =~ s/^DEVICE.*/DEVICE $device_string/;
			
			# Setup the poll time. Remove the leading # again.
			$line =~ s/^#POLLTIME/POLLTIME/;
			$line =~ s/^POLLTIME.*/POLLTIME $polltime/;
			
			# Set some static values
			$line =~ s/^BATTERYLEVEL.*/BATTERYLEVEL 5/;
			$line =~ s/^MINUTES.*/MINUTES 0/;
			$line =~ s/^SCRIPTDIR.*/SCRIPTDIR \/etc\/apcupsd\/null/;
			$line =~ s/^PWRFAILDIR.*/PWRFAILDIR \/etc\/apcupsd\/null/;
			$line =~ s/^NOLOGINDIR.*/NOLOGINDIR \/etc\/apcupsd\/null/;
			
			# Set the NIS port
			$line =~ s/^NISPORT.*/NISPORT $nisport/;
			
			# Set the event file
			$line =~ s/^EVENTSFILE.*/EVENTSFILE $events/;
			#print "<< line: $line\n";

			push @lines, "$line\n";
		}
		$fh->close();
		
		# Write the config file back out.
		record($conf, " - Updating ${ups}'s: [$config_file]\n");
		$sc = "$config_file";
		$fh = IO::Handle->new();
		open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
		foreach my $line (@lines)
		{
			print $fh $line;
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "Downloading modified the 'apcupsd' init.d script:\n");
	if (-e "/etc/init.d/apcupsd")
	{
		record($conf, " - Removing the old 'apcupsd' init.d scipt.\n");
		unlink "/etc/init.d/apcupsd" or nice_exit($conf, 1, "Failed to remove: [/etc/init.d/apcupsd], error: $!\n");
		record($conf, " - Done.\n");
	}
	if (not -e "/etc/init.d/apcupsd")
	{
		record($conf, " - Installing the modified 'apcupsd' init.d script.\n");
		my $sc = "wget https://alteeve.ca/files/apcupsd/apcupsd -O /etc/init.d/apcupsd && chmod 755 /etc/init.d/apcupsd";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		record($conf, " - Setting 'apcupsd' to start on boot.\n");
		$sc = "chkconfig apcupsd on";
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		record($conf, " - Starting the 'apcupsd' daemons.\n");
		$sc = "/etc/init.d/apcupsd start";
		record($conf, "/----------\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	else
	{
		record($conf, "[ WARNING ] - Unable to remove the old '/etc/init.d/apcupsd' file!\n");
		record($conf, "[ WARNING ] - Aborting 'apcupsd' init.d configuration!\n");
	}
	
	return(0);
}

sub disable_selinux
{
	my ($conf) = @_;
	
	record($conf, "Disabling SELinux\n");
	if (-e "/etc/selinux/config.anvil")
	{
		record($conf, " - Already disabled, skipping.\n");
		return(0);
	}
	my $sc = "setenforce 0; sed -i.anvil 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/config";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, " - $line\n");
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return (0);
}

sub disable_libvirt_bridge
{
	my ($conf) = @_;
	
	record($conf, "Disabling the libvirtd default bridge\n");
	
	# First see if the bridge is up
	my $up = 0;
	my $sc = "ifconfig -a";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^virbr\d+:/)
		{
			$up = 1;
			last;
		}
	}
	$fh->close();
	
	if ($up)
	{
		record($conf, " - The libvirtd bridge appears to be up, disabling it.\n");
		my $sc = "virsh net-destroy default && virsh net-autostart default --disable && virsh net-undefine default && /etc/init.d/iptables stop";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	else
	{
		record($conf, " - The libvirtd bridge appears to not be up, deleting it.\n");
		my $sc = "cat /dev/null >/etc/libvirt/qemu/networks/default.xml";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	
	record($conf, " - Done.\n");
	
	
	return(0);
}

sub set_text_boot
{
	my ($conf) = @_;
	
	record($conf, "Checking what plymouth theme is active.\n");
	my $current_theme = "";
	my $sc = "plymouth-set-default-theme";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$current_theme = $line;
	}
	$fh->close();
	
	if ($current_theme eq "details")
	{
		record($conf, " - Current plymout boot theme is already: [details].\n - Done.\n");
	}
	else
	{
		record($conf, "Current plymout boot theme is: [$current_theme]. Changing to: [details].\n");
		record($conf, " - This can take a minute, please be patient.\n");
		my $sc = "plymouth-set-default-theme details -R";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, " - $line\n)"
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	return(0);
}

sub modify_daemons
{
	my ($conf) = @_;
	
	# Disable daemons
	record($conf, "Disabling daemons may produce '[FAILED]' errors, these are safe to ingore.\n");
	foreach my $daemon (sort {$a cmp $b} @{$conf->{apps}{disable}})
	{
		next if not $daemon;
		record($conf, "Disabling: [$daemon]\n");
		my $sc = "chkconfig $daemon off && /etc/init.d/$daemon stop";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	# Enable daemons
	foreach my $daemon (sort {$a cmp $b} @{$conf->{apps}{enable}})
	{
		next if not $daemon;
		record($conf, "Enabling: [$daemon].\n");
		my $sc = "chkconfig $daemon on && /etc/init.d/$daemon start";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	return(0);
}

sub setup_ntpd
{
	my ($conf) = @_;
	
	# If the NTP server IP is already in the file, skip.
	record($conf, "This next step will configure the network time server.\n");
	my $ntp_server = $conf->{answers}{ntp_server};
	my $done = 0;
	my $sc = "/etc/ntp.conf";
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /$ntp_server/)
		{
			$done = 1;
			last;
		}
	}
	$fh->close();
	
	if ($done)
	{
		record($conf, " - The NTP server: [$ntp_server] is already in: [/etc/ntpd.conf], skipping.\n");
		return (0);
	}
	
	$sc = "echo \"server $ntp_server\" >> /etc/ntp.conf && echo \"restrict $ntp_server mask 255.255.255.255 nomodify notrap noquery\" >> /etc/ntp.conf";
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "| $line\n");
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub install_apps
{
	my ($conf) = @_;
	
	# Read all currently installed packages.
	read_installed_groups($conf);
	read_installed_rpms($conf);
	
	#foreach my $app (sort {$a cmp $b} keys %{$conf->{installed_apps}}) { record ($conf, "App: [$app], arch: [$conf->{installed_apps}{$app}{arch}]\n"); }
	
	# First, install
	record($conf, "Looking for packages that need to be installed.\n");
	my $apps_install = "";
	foreach my $install_app (sort {$a cmp $b} @{$conf->{apps}{install}})
	{
		# Is the app already installed?
		next if not $install_app;
		#record($conf, "Checking if: [$install_app] is installed.\n");
		if (ref($conf->{installed_apps}{$install_app}) ne "HASH")
		{
			# No, add it.
			record($conf, " - Didn't find the application: [$install_app]\n");
			$apps_install .= "$install_app ";
		}
	}
	
	# Proceed with the install if any packages are not yet installed.
	if ($apps_install)
	{
		record($conf, "Installing missing applications.\n");
		my $sc = "yum -y install $apps_install";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		$apps_install = "";
	}
	else
	{
		record($conf, " - Nothing to install.\n");
	}
	
	# Now install groups if needed.
	record($conf, "Looking for package groups that need to be installed.\n");
	my $groups_install = "";
	foreach my $install_group (sort {$a cmp $b} @{$conf->{groups}{install}})
	{
		next if not $install_group;
		if (not exists $conf->{installed_groups}{$install_group})
		{
			# No, add it.
			record($conf, " - Didn't find the package group: [$install_group]\n");
			$groups_install .= "$install_group ";
		}
	}
	
	# Proceed with the group install if any groups are missing.
	if ($groups_install)
	{
		record($conf, "Installing missing application groups.\n");
		my $sc = "yum -y groupinstall $groups_install";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		$groups_install = "";
	}
	else
	{
		record($conf, " - Nothing to install.\n");
	}
	
	# Now add repos and install their packages.
	foreach my $repo (sort {$a cmp $b} keys %{$conf->{apps}{repos}})
	{
		my $key           = $conf->{apps}{repos}{$repo}{key};
		my $rpm           = $conf->{apps}{repos}{$repo}{rpm};
		my $install_array = $conf->{apps}{repos}{$repo}{install};
		my $file          = $conf->{apps}{repos}{$repo}{file};
		
		record($conf, "Installing the: [$repo] repository key.\n");
		if (-e $file)
		{
			record($conf, " - Already installed, skipping.\n");
			next;
		}
		my $sc = "rpm --import $key";
		record($conf, "Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		record($conf, "Installing the: [$repo] repository RPM.\n");
		$sc = "rpm -Uvh $rpm";
		record($conf, "Calling: [$sc]\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	
		# First, install
		my $install = "";
		foreach my $install_app (sort {$a cmp $b} @{$install_array})
		{
			next if not $install_app;
			$install .= "$install_app ";
		}
		if ($install)
		{
			record($conf, "Installing the: [$repo] repository package(s).\n");
			my $sc = "yum -y install $install";
			record($conf, "Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			record($conf, "/----------\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "| $line\n");
			}
			$fh->close();
			record($conf, "\\----------\n");
			record($conf, " - Done.\n");
		}
	}
	
	# Update the OS
	record($conf, "Updating the operating system.\n");
	my $sc = "yum -y update";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	record($conf, "/----------\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "| $line\n");
		if ($line =~ /kernel/)
		{
			record ($conf, "| Reboot required for this update to take effect.\n");
			$conf->{'system'}{reboot_required} = 1;
		}
	}
	$fh->close();
	record($conf, "\\----------\n");
	record($conf, " - Done.\n");
	
	# Grab the DRBD fence agent.
	if (not -e "/sbin/rhcs_fence")
	{
		record($conf, "Installing the DRBD fence handler\n");
		my $sc = "wget -c https://raw.github.com/digimer/rhcs_fence/master/rhcs_fence -O /sbin/rhcs_fence && chmod 755 /sbin/rhcs_fence && ls -lah /sbin/rhcs_fence";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	### TODO: Update this to edit the default files. Create a downloadable
	###       version with substitution keys.
	# Grab the default DRBD config files
	if (not -e "/etc/drbd.d/global_common.conf.anvil")
	{
		record($conf, "Installing the DRBD initial config files.\n");
		my $sc = "mv /etc/drbd.d/global_common.conf /etc/drbd.d/global_common.conf.anvil && wget -c https://alteeve.ca/files/global_common.conf -O /etc/drbd.d/global_common.conf && wget -c https://alteeve.ca/files/r0.res -O /etc/drbd.d/r0.res";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	# Setup clustered LVM.
	if (not -e "/etc/lvm/lvm.conf.anvil")
	{
		record($conf, "Installing the clustered LVM configuration file.\n");
		my $sc = "mv /etc/lvm/lvm.conf /etc/lvm/lvm.conf.anvil && wget -c https://alteeve.ca/files/lvm.conf -O /etc/lvm/lvm.conf";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	return (0);
}

sub read_installed_rpms
{
	my ($conf) = @_;
	
	record($conf, "Checking which packages are already installed.\n");
	#my $sc = "yum list installed";
	my $sc = "rpm -qa";
	#record($conf, "sc: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "> line: [$line]\n");
# 		next if $line =~ /^\s/;
# 		record($conf, "< line: [$line]\n");
# 		if ($line =~ /^(.*?)\s/)
# 		{
# 			my $rpm  = $1;
# 			record($conf, "> rpm: [$rpm]\n");
# 			next if $rpm !~ /\./;
			my $app = "";
			my $arch = "";
			if ($line =~ /^(.*)\.(.*)/)
			{
				$app  = $1;
				$arch = $2;
			}
			else
			{
				$app  = $line;
				$arch = "noarch";
			}
			$app =~ s/-\d+\.\d+.*$//;
			$app =~ s/\.el6$//;
			#record($conf, "< app: [$app], arch: [$arch]\n");
			
			$conf->{installed_apps}{$app}{arch} = $arch;
# 		}
	}
	$fh->close();
	record($conf, " - Done!\n");
	
	return (0);
}

sub read_installed_groups
{
	my ($conf) = @_;
	
	record($conf, "Checking which groups are already installed.\n");
	my $in_installed = 0;
	my $sc = "yum grouplist -v";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /Installed Groups/)
		{
			$in_installed = 1;
			next;
		}
		if ($in_installed)
		{
			if ($line =~ /Available Groups/)
			{
				$in_installed = 0;
				last;
			}
			elsif ($line =~ /\((.*?)\)/)
			{
				my $group  = $1;
				$conf->{installed_groups}{$group} = 1;
				#record($conf, "Found installed group: [$group]\n");
			}
		}
	}
	$fh->close();
	record($conf, " - Done!\n");
	
	return (0);
}

sub read_answers
{
	my ($conf) = @_;
	
	return if not -e $conf->{files}{answers};
	
	my $private_key = "";
	my $sc = "$conf->{files}{answers}";
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "private key: [$private_key], line: [$line]\n");
		if ($private_key)
		{
			$conf->{answers}{ssh_keys}{$private_key}{private} .= "$line\n";
			if ($line =~ /END RSA PRIVATE KEY/)
			{
				$private_key = "";
			}
			next;
		}
		#record($conf, "answers line: [$line]\n");
		next if not $line;
		next if $line !~ /=/;
		$line         =~ s/^\s+//;
		$line         =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		#record($conf, "var: [$var], val: [$val]\n");
		
		_make_hash_reference($conf, $var, $val);
		
		# Special handling needed for the nodes' private RSA key
		# values.
		if (($var =~ /node1::private$/) && ($val =~ /BEGIN RSA PRIVATE KEY/))
		{
			$private_key = "node1";
			$conf->{answers}{ssh_keys}{$private_key}{private} .= "\n";
		}
		elsif (($var =~ /node2::private$/) && ($val =~ /BEGIN RSA PRIVATE KEY/))
		{
			$private_key = "node2";
			$conf->{answers}{ssh_keys}{$private_key}{private} .= "\n";
		}
	}
	$fh->close();
	
	#use Data::Dumper;
	#print Dumper $conf;
	#die "testing...\n";
	
	return(0);
}

sub write_answers
{
	my ($conf, $hash_ref, $key, $fh, $i) = @_;
	$hash_ref = $conf->{answers} if not defined $hash_ref;
	$key      = "answers"        if not defined $key;
	$i        = 0 if not defined $i;
	
	my $sc = "$conf->{files}{answers}";
	if (not $fh)
	{
		#print "Opening: [$sc]\n";
		$fh = IO::Handle->new();
		open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
	}
	foreach my $var (sort {$a cmp $b} keys %{$hash_ref})
	{
		#print "i: [$i], var: [$var] is HASH? [".ref($hash_ref->{$var})."] ($hash_ref->{$var})\n";
		if (ref($hash_ref->{$var}) eq "HASH")
		{
			my $new_key = "${key}::${var}";
			$i++;
			#print " > Re-entering 'write_answers()' with key: [$new_key]\n";
			write_answers($conf, $hash_ref->{$var}, $new_key, $fh, $i);
			#print " < Returning from 'write_answers();'\n";
			$i--;
		}
		else
		{
			print $fh "${key}::${var} = $hash_ref->{$var}\n";
			#print "cache: [${key}::${var} = $hash_ref->{$var}]\n";
		}
	}
	if ($i == 0)
	{
		#print "Closing: [$sc]\n";
		$fh->close();
	}
	#die "testing...\n";
	
	return(0);
}

sub ask_questions_customer
{
	my ($conf) = @_;
	
	record($conf, "\n-=] Customer and node questions:\n\n");
	
	record($conf, "What is the customer's two or three letter prefix?\n - [$conf->{answers}{customer_prefix}] ");
	my $customer_prefix = <STDIN>;
	chomp($customer_prefix);
	$conf->{answers}{customer_prefix} = $customer_prefix if $customer_prefix;
	write_answers($conf);
	
	record($conf, "What is the customer's domain?\n - [$conf->{answers}{customer_domain}] ");
	my $customer_domain = <STDIN>;
	chomp($customer_domain);
	$conf->{answers}{customer_domain} = $customer_domain if $customer_domain;
	write_answers($conf);
	
	record($conf, "What is the Anvil! sequence ID number?\n - [$conf->{answers}{cluster_id}] ");
	my $cluster_id = <STDIN>;
	chomp($cluster_id);
	if ($cluster_id)
	{
		$cluster_id = sprintf("%02d", $cluster_id);
	}
	$conf->{answers}{cluster_id} = $cluster_id if $cluster_id;
	write_answers($conf);
	
	record($conf, "What is the node's sequence ID number?\n - [$conf->{answers}{node_id}] ");
	my $node_id = <STDIN>;
	chomp($node_id);
	if ($node_id)
	{
		$node_id = sprintf("%02d", $node_id);
	}
	$conf->{answers}{node_id} = $node_id if $node_id;
	write_answers($conf);
	
	record($conf, "*WARNING* - The answer to the next question will be displayed on the screen!\n");
	record($conf, "What password shall I set for 'ricci', 'root' and the IPMI user?\n - [$conf->{answers}{password}] ");
	my $password = <STDIN>;
	chomp($password);
	if ($password)
	{
		$conf->{answers}{password} = $password;
	}
	elsif ($conf->{answers}{password})
	{
		# User is using the same password as before
	}
	else
	{
		$conf->{answers}{password} = "";
		record($conf, "No password specified. Will not set the root or user password.\n");
	}
	write_answers($conf);
	
	# Ask the user what time server they want to use.
	record($conf, "What time server do you want to use?\n - [$conf->{answers}{ntp_server}] ");
	my $ifn2_gateway = <STDIN>;
	chomp($ifn2_gateway);
	$conf->{answers}{ifn2_gateway} = $ifn2_gateway if $ifn2_gateway;
	write_answers($conf);
	
	return(0);
}

sub ask_questions_node_ips
{
	my ($conf) = @_;

# 	$conf->{'system'}{skip_network} = 1;
# 	return(0);
	
	record($conf, "\n-=] Node IP address questions:\n\n");
	
	# If 'vbr2' exists, ask the user if they want to skip the network
	# config.
	if (-e "/etc/sysconfig/network-scripts/ifcfg-vbr2")
	{
		record($conf, "It looks like the network has already been configured.\n");
		record($conf, " - Do you want to re-run the network configuration? [y/N] ");
		my $configure = <STDIN>;
		chomp($configure);
		if ((lc($configure) eq "y") || (lc($configure) eq "yes"))
		{
			record($conf, " - Configuring network...\n");
			$conf->{'system'}{skip_network} = 0;
		}
		else
		{
			record($conf, " - Skipping network config.\n");
			$conf->{'system'}{skip_network} = 1;
		}
		write_answers($conf);
	}
	else
	{
		# Ask if the user wants to configure the network.
		record($conf, "Do you wish to configure networking? [Y/n] ");
		my $configure = <STDIN>;
		chomp($configure);
		if ((lc($configure) eq "n") || (lc($configure) eq "no"))
		{
			record($conf, " - Skipping network config.\n");
			$conf->{'system'}{skip_network} = 1;
		}
		write_answers($conf);
	}
	return (0) if $conf->{'system'}{skip_network};
	
	# IP addresses. If the IPs is only two octals, use the cluster ID to
	# set the third octal.
	my $third_octal  =  $conf->{answers}{cluster_id};
	   $third_octal  =~ s/^0+//;
	   $third_octal  .= "0";
	my $fourth_octal =  $conf->{answers}{node_id};
	   $fourth_octal =~ s/^0+//;
	if ($conf->{answers}{bcn_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{bcn_ip} .= "${third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{ipmi_ip} =~ /^\d+\.\d+\.$/)
	{
		my $this_third_octal = $third_octal + 1;
		$conf->{answers}{ipmi_ip} .= "${this_third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{sn_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{sn_ip} .= "${third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{ifn_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{ifn_ip} .= "${third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{ifn2_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{ifn2_ip} .= "${third_octal}.${fourth_octal}";
	}
	
	# Back-Channel Network
	record($conf, "What IP address would you like to use for the BCN?\n - [$conf->{answers}{bcn_ip}] ");
	my $bcn_ip = <STDIN>;
	chomp($bcn_ip);
	$conf->{answers}{bcn_ip} = $bcn_ip if $bcn_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the BCN?\n - [$conf->{answers}{bcn_netmask}] ");
	my $bcn_netmask = <STDIN>;
	chomp($bcn_netmask);
	$conf->{answers}{bcn_netmask} = $bcn_netmask if $bcn_netmask;
	write_answers($conf);
	
	# Storage Network
	record($conf, "What IP address would you like to use for the SN?\n - [$conf->{answers}{sn_ip}] ");
	my $sn_ip = <STDIN>;
	chomp($sn_ip);
	$conf->{answers}{sn_ip} = $sn_ip if $sn_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the SN?\n - [$conf->{answers}{sn_netmask}] ");
	my $sn_netmask = <STDIN>;
	chomp($sn_netmask);
	$conf->{answers}{sn_netmask} = $sn_netmask if $sn_netmask;
	write_answers($conf);
	
	### TODO: Add "first" to "IFN"
	# Internet-Facing Network
	record($conf, "What IP address would you like to use for the IFN?\n - [$conf->{answers}{ifn_ip}] ");
	my $ifn_ip = <STDIN>;
	chomp($ifn_ip);
	$conf->{answers}{ifn_ip} = $ifn_ip if $ifn_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the IFN?\n - [$conf->{answers}{ifn_netmask}] ");
	my $ifn_netmask = <STDIN>;
	chomp($ifn_netmask);
	$conf->{answers}{ifn_netmask} = $ifn_netmask if $ifn_netmask;
	write_answers($conf);
	
	record($conf, "What gateway would you like to use for the IFN?\n - [$conf->{answers}{ifn_gateway}] ");
	my $ifn_gateway = <STDIN>;
	chomp($ifn_gateway);
	$conf->{answers}{ifn_gateway} = $ifn_gateway if $ifn_gateway;
	write_answers($conf);
	
	record($conf, "Will the IFN be the default gateway?\n - [$conf->{answers}{ifn_dg}] ");
	my $ifn_dg = <STDIN>;
	chomp($ifn_dg);
	$conf->{answers}{ifn_dg} = $ifn_dg if $ifn_dg;
	write_answers($conf);
	
	record($conf, "What will be the first DNS server?\n - [$conf->{answers}{dns1}] ");
	my $dns1 = <STDIN>;
	chomp($dns1);
	$conf->{answers}{dns1} = $dns1 if $dns1;
	write_answers($conf);
	
	record($conf, "What will be the second DNS server?\n - [$conf->{answers}{dns2}] ");
	my $dns2 = <STDIN>;
	chomp($dns2);
	$conf->{answers}{dns2} = $dns2 if $dns2;
	write_answers($conf);
	
	### TODO: More sensibly support a second IFN.
	$conf->{'system'}{two_ifn} = 0;
	if ($conf->{'system'}{two_ifn})
	{
		# Internet-Facing Network B
		record($conf, "What IP address would you like to use for the second IFN?\n - [$conf->{answers}{ifn2_ip}] ");
		my $ifn2_ip = <STDIN>;
		chomp($ifn2_ip);
		$conf->{answers}{ifn2_ip} = $ifn2_ip if $ifn2_ip;
		write_answers($conf);
		
		record($conf, "What subnet mask would you like to use for the second IFN?\n - [$conf->{answers}{ifn2_netmask}] ");
		my $ifn2_netmask = <STDIN>;
		chomp($ifn2_netmask);
		$conf->{answers}{ifn2_netmask} = $ifn2_netmask if $ifn2_netmask;
		write_answers($conf);
		
		record($conf, "What gateway would you like to use for the second IFN?\n - [$conf->{answers}{ifn2_gateway}] ");
		my $ifn2_gateway = <STDIN>;
		chomp($ifn2_gateway);
		$conf->{answers}{ifn2_gateway} = $ifn2_gateway if $ifn2_gateway;
		write_answers($conf);
		
		record($conf, "Will the second IFN be the default gateway?\n - [$conf->{answers}{ifn2_dg}] ");
		my $ifn2_dg = <STDIN>;
		chomp($ifn2_dg);
		$conf->{answers}{ifn2_dg} = $ifn2_dg if $ifn2_dg;
		write_answers($conf);
	}
	
	return (0);
}

sub ask_questions_ipmi
{
	my ($conf) = @_;
	
	record($conf, "\n-=] IPMI BMC questions:\n\n");
	
	$conf->{'system'}{skip_ipmi} = 1; return(0);
	
	# Ask if the user wants to configure IPMI.
	record($conf, "Do you wish to configure the IPMI BMC? [Y/n] ");
	my $configure = <STDIN>;
	chomp($configure);
	if ((lc($configure) eq "n") || (lc($configure) eq "no"))
	{
		record($conf, " - Skipping IPMI config.\n");
		$conf->{'system'}{skip_ipmi} = 1;
	}
	write_answers($conf);
	return (0) if $conf->{'system'}{skip_ipmi};
	
	# IPMI Interface
	record($conf, "What IP address would you like to use for the IPMI BMC?\n - [$conf->{answers}{ipmi_ip}] ");
	my $ipmi_ip = <STDIN>;
	chomp($ipmi_ip);
	$conf->{answers}{ipmi_ip} = $ipmi_ip if $ipmi_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the IPMI BMC?\n - [$conf->{answers}{ipmi_netmask}] ");
	my $ipmi_netmask = <STDIN>;
	chomp($ipmi_netmask);
	$conf->{answers}{ipmi_netmask} = $ipmi_netmask if $ipmi_netmask;
	write_answers($conf);
	
	record($conf, "What gateway would you like to use for the IPMI BMC (leave blank for none)?\n - [$conf->{answers}{ipmi_gateway}] ");
	my $ipmi_gateway = <STDIN>;
	chomp($ipmi_gateway);
	$conf->{answers}{ipmi_gateway} = $ipmi_gateway if $ipmi_gateway;
	write_answers($conf);
	
	record($conf, "What IPMI user shall I set/update the password for (required for fencing)?\n - [$conf->{answers}{ipmi_user}] ");
	my $ipmi_user = <STDIN>;
	chomp($ipmi_user);
	$conf->{answers}{ipmi_user} = $ipmi_user if $ipmi_user;
	write_answers($conf);
	
	return(0);
}

sub ask_questions_misc
{
	my ($conf) = @_;
	
	#record($conf, "\n-=] Miscellaneous node configuration questions:\n\n");
	
	return (0);
}

sub ask_questions_storage
{
	my ($conf) = @_;
	return (0) if $conf->{'system'}{skip_disk};
	
	record($conf, "\n-=] Storage related questions:\n\n");
	
	# TODO: Figure out why it's not using cached values.
	#record($conf, "cached; answers::shared_storage: [$conf->{answers}{shared_storage}], answers::storage_pool_1: [$conf->{answers}{storage_pool_1}], answers::storage_pool_2: [$conf->{answers}{storage_pool_2}]\n");
	### Storage questions.
	if (($conf->{answers}{node_id} eq "1") or ($conf->{answers}{node_id} eq "01"))
	{
		# Tell the user roughly how much free space is available.
		record($conf, "The root device: [$conf->{'system'}{root}{device}] has approximately: [$conf->{'system'}{root}{free_space_gb_rounded} GB] of free space.\n");
		if ($conf->{'system'}{root}{free_space_gb_rounded} > 50)
		{
			# Ask the user how much space they want to assign to /shared
			my $remaining_free_space = $conf->{'system'}{root}{free_space_gb_rounded};
			record($conf, "How much space would you like for the shared storage?\n - [$conf->{answers}{shared_storage}] / $remaining_free_space GB: ");
			my $shared_storage = <STDIN>;
			chomp($shared_storage);
			$conf->{answers}{shared_storage} = $shared_storage if $shared_storage;
			write_answers($conf);
			
			# Subtract the answer and then ask how much space to allocate 
			# to the first VM storage pool.
			$remaining_free_space            -= $conf->{answers}{shared_storage};
			if (not $conf->{answers}{storage_pool_1})
			{
				$conf->{answers}{storage_pool_1} =  $remaining_free_space / 2;
				$conf->{answers}{storage_pool_1} =~ s/\..*//;
			}
			record($conf, "How much space would you like for the servers that will run on node 01?\n - [$conf->{answers}{storage_pool_1}] / $remaining_free_space GB: ");
			my $storage_pool_1 = <STDIN>;
			chomp($storage_pool_1);
			$conf->{answers}{storage_pool_1} = $storage_pool_1 if $storage_pool_1;
			write_answers($conf);
			
			$remaining_free_space            -= $conf->{answers}{storage_pool_1};
			if ($remaining_free_space < 1)
			{
				$conf->{answers}{storage_pool_1} = 0;
				record($conf, "There is no space left for servers on node 02.\n\n");
			}
			else
			{
				$conf->{answers}{storage_pool_2} =  $remaining_free_space;
				$conf->{answers}{storage_pool_2} =~ s/\..*//;
				record($conf, "That leaves: [$conf->{answers}{storage_pool_2} GB] for servers that will run on node 02.\n\n");
			}
		}
		else
		{
			# Can't set it up ourselves...
			record($conf, "-------------------------------------------------------------------------------\n");
			record($conf, "Currently, this installer only supports hardware RAID without LVM. It would\n");
			record($conf, "appear that either their is not enough free space of '/dev/sda' or another\n");
			record($conf, "block device or storage manager is in use. Please configure storage manually\n");
			record($conf, "after this installer has completed.\n");
			record($conf, "-------------------------------------------------------------------------------\n");
		}
	}
	else
	{
		record($conf, "This is the second node in the Anvil!. Please copy the post-install script from\n");
		record($conf, "the first node and run it here in order to configure this node's storage to\n");
		record($conf, "match.\n");
	}
	
	return (0);
}

sub ask_questions_ups
{
	my ($conf) = @_;

# 	$conf->{'system'}{skip_ups} = 1;
# 	return(0);
	
	record($conf, "\n-=] UPS monitoring questions:\n\n");
	
	# APC UPS questions.
	if (-e "/etc/apcupsd/apcupsd.conf.anvil")
	{
		record($conf, " - It appears that UPS monitoring is already configured.\n");
		record($conf, " - Do you want to re-run UPS monitoring configuration? [y/N] ");
		my $config_ups = <STDIN>;
		#my $config_ups = "y";
		chomp($config_ups);
		if ((lc($config_ups) eq "y") or (lc($config_ups) eq "yes"))
		{
			$conf->{'system'}{skip_ups} = 0;
		}
		else
		{
			$conf->{'system'}{skip_ups} = 1;
			record($conf, " - Skipping.\n");
		}
	}
	else
	{
		record($conf, "Would you like to configure UPS monitoring now? [Y/n] ");
		my $config_ups = <STDIN>;
		#my $config_ups = "y";
		chomp($config_ups);
		if ((lc($config_ups) eq "n") or (lc($config_ups) eq "no"))
		{
			$conf->{'system'}{skip_ups} = 1;
			record($conf, " - Skipping APC UPS monitoring setup.\n");
		}
	}
	return(0) if $conf->{'system'}{skip_ups};
	
	foreach my $ups ("ups1", "ups2")
	{
		my $say_ups       =  $ups;
		my $ups_number    =  $ups;
			$say_ups       =~ s/^ups/UPS #0/;
			$ups_number    =~ s/^\D*/0/;
		#print "say_ups: [$say_ups], ups_number: [$ups_number]\n";
		$conf->{answers}{ups}{$ups}{name}    =  $conf->{answers}{customer_prefix}."-u".$ups_number;
		record($conf, "\nQuestions for $say_ups:\n");
		record($conf, " - UPS name: [$conf->{answers}{ups}{$ups}{name}] ");
		my $ups_name = <STDIN>;
		chomp($ups_name);
		$conf->{answers}{ups}{$ups}{name}   = $ups_name if $ups_name;
		$conf->{answers}{ups}{$ups}{events} = "/var/log/apcupsd.".$conf->{answers}{ups}{$ups}{name}.".events";
		write_answers($conf);
		
		# Setup defaults if the default IP (without the fourth
		# octal) is currently in use.
		#record($conf, "answers::ups::${ups}::address: [$conf->{answers}{ups}{$ups}{address}]\n");
		if ($conf->{answers}{ups}{$ups}{address} =~ /\.$/)
		{
			# No final octal, use the UPS's name to
			# determine the last octal.
			my $last_ip_octal = ($conf->{answers}{ups}{$ups}{name} =~ /(\d+)$/)[0];
			#record($conf, ">> last_ip_octal: [$last_ip_octal]\n");
				$last_ip_octal =~ s/^0//g;
			#record($conf, "<< last_ip_octal: [$last_ip_octal]\n");
			$conf->{answers}{ups}{$ups}{address} .= $last_ip_octal;
			$conf->{answers}{ups}{$ups}{nisport} =  "355".$last_ip_octal;
			#record($conf, "address: [$conf->{answers}{ups}{$ups}{address}], nisport: [$conf->{answers}{ups}{$ups}{nisport}]\n");
		}
		
		### TODO: Doesn't use .2
		record($conf, " - UPS IP address: [$conf->{answers}{ups}{$ups}{address}] ");
		my $ups_address = <STDIN>;
		chomp $ups_address;
		$conf->{answers}{ups}{$ups}{address} = $ups_address if $ups_address;
		write_answers($conf);
		
		record($conf, " - Check frequency (in seconds): [$conf->{answers}{ups}{$ups}{polltime}] ");
		my $polltime = <STDIN>;
		chomp $polltime;
		$conf->{answers}{ups}{$ups}{polltime} = $polltime if $polltime;
		write_answers($conf);
		
		record($conf, " - NIS TCP Port: [$conf->{answers}{ups}{$ups}{nisport}] ");
		my $nisport = <STDIN>;
		chomp $nisport;
		$conf->{answers}{ups}{$ups}{nisport} = $nisport if $nisport;
		write_answers($conf);
	}
	
	return (0);
}

sub check_core_dependencies
{
	my ($conf) = @_;
	
	# Check for required networking tools.
	if (not -e "/usr/sbin/brctl")
	{
		# Install the bridge utilities now.
		record($conf, "The bridge utilities are not yet installed. This is needed before the network\n");
		record($conf, "can be configured. It will be installed before the network is reconfigured.\n");
	}
	
	# Check for parted so that we can configure the storage
	if (not -e "/sbin/parted")
	{
		# Install it
		record($conf, "The storage configuration tool 'parted' is not yet installed. It is needed in\n");
		record($conf, "order to prepare the node's replicated storage. It will be installed.\n");
	}
	
	return(0);
}

sub install_core_dependencies
{
	my ($conf) = @_;
	
	if ((not -e "/usr/sbin/brctl") && (not -e "/sbin/parted"))
	{
		record($conf, "Installing 'bridge-utils' and 'parted'.\n");
		my $sc = "yum -y install bridge-utils parted";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		sleep 1;
		my $fatal = 0;
		if (not -e "/usr/sbin/brctl")
		{
			$fatal = 1;
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
		}
		if (not -e "/sbin/parted")
		{
			$fatal = 1;
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
		}
		if ($fatal)
		{
			nice_exit($conf, 1, "[ ERROR ] - Configuration aborted.\n");
		}
	}
	elsif (not -e "/usr/sbin/brctl")
	{
		record($conf, "Installing 'bridge-utils'.\n");
		my $sc = "yum -y install bridge-utils";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		sleep 1;
		if (not -e "/usr/sbin/brctl")
		{
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
			nice_exit($conf, 1, "[ ERROR ] - Configuration aborted.\n");
		}
	}
	elsif (not -e "/sbin/parted")
	{
		record($conf, "Installing 'parted'.\n");
		my $sc = "yum -y install parted";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		sleep 1;
		if (not -e "/sbin/parted")
		{
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
			nice_exit($conf, 1, "[ ERROR ] - Configuration aborted.\n");
		}
	}
	
	return(0);
}

sub ask_questions
{
	my ($conf) = @_;
	read_answers($conf);
	
	system("clear");
	record($conf, "\n##############################################################################\n");
	record($conf, "# NOTE: There is *no* sanity checking of answers yet.                        #\n");
	record($conf, "#       Please answer carefully.                                             #\n");
	record($conf, "##############################################################################\n");
	
	# TODO: Make each one of these it's own section that the user can
	#       independantly verify and, if needed, restart.
	ask_questions_customer($conf);
	
	# Once I know the hostname, I need to sort out if this is node 1 or 2.
	$conf->{answers}{hostname} = "$conf->{answers}{customer_prefix}-c".$conf->{answers}{cluster_id}."n".$conf->{answers}{node_id}.".".$conf->{answers}{customer_domain};
	if ($conf->{answers}{hostname} =~ /01/)
	{
		$conf->{'system'}{this_is_node} = 1;
		$conf->{'system'}{peer_is_node} = 2;
	}
	else
	{
		$conf->{'system'}{this_is_node} = 2;
		$conf->{'system'}{peer_is_node} = 1;
	}
	
	# Back to our regularly scheduled user grilling...
	ask_questions_storage($conf);	# This must follow the customer questions
	ask_questions_ups($conf);	# This must follow the customer questions
	ask_questions_node_ips($conf);	# This must follow the customer questions
	ask_questions_ipmi($conf);
	ask_questions_misc($conf);
	ask_questions_ssh($conf);
	check_core_dependencies($conf);
	
	write_answers($conf);
	record($conf, "\nSummary;\n");
	record($conf, " - Customer prefix:   [$conf->{answers}{customer_prefix}]\n");
	record($conf, " - Customer domain:   [$conf->{answers}{customer_domain}]\n");
	record($conf, " - Anvil! ID:         [$conf->{answers}{cluster_id}]\n");
	record($conf, " - Node ID:           [$conf->{answers}{node_id}]\n");
	record($conf, " - Host Name:         [$conf->{answers}{hostname}]\n");
	if ($conf->{'system'}{skip_network})
	{
		record($conf, " - Network configuration skipped.\n");
	}
	else
	{
		record($conf, " - BCN Network:       [".sprintf("%-15s", $conf->{answers}{bcn_ip})." / $conf->{answers}{bcn_netmask}]\n");
		record($conf, " - IPMI Network:      [".sprintf("%-15s", $conf->{answers}{ipmi_ip})." / $conf->{answers}{ipmi_netmask}]\n");
		record($conf, " - SN Network:        [".sprintf("%-15s", $conf->{answers}{sn_ip})." / $conf->{answers}{sn_netmask}]\n");
		record($conf, " - IFN Network:       [".sprintf("%-15s", $conf->{answers}{ifn_ip})." / $conf->{answers}{ifn_netmask}]\n");
	}
	if ($conf->{'system'}{skip_ipmi})
	{
		record($conf, " - IPMI BMC configuration skipped.\n");
	}
	else
	{
		record($conf, " - IPMI user:         [$conf->{answers}{ipmi_user}]\n");
		record($conf, " - IPMI Network:      [$conf->{answers}{ipmi_ip} / $conf->{answers}{ipmi_netmask}]\n");
		record($conf, " - IPMI Gateway       [$conf->{answers}{ipmi_gateway}]\n");
	}
	
	record($conf, " - /shared Storage:   [$conf->{answers}{shared_storage} GB]\n");
	record($conf, " - Storage Pool 01:   [$conf->{answers}{storage_pool_1} GB]\n");
	record($conf, " - Storage Pool 02:   [$conf->{answers}{storage_pool_2} GB]\n");
	if ($conf->{'system'}{skip_ups})
	{
		record($conf, " - UPS configuration skipped.\n");
	}
	else
	{
		record($conf, " - UPS #1\n");
		record($conf, "   - Name:            [$conf->{answers}{ups}{ups1}{name}]\n");
		record($conf, "   - Address:         [$conf->{answers}{ups}{ups1}{address}]\n");
		record($conf, "   - NIS TCP Port:    [$conf->{answers}{ups}{ups1}{nisport}]\n");
		record($conf, "   - Check frequency: [$conf->{answers}{ups}{ups1}{polltime}] seconds\n");
		record($conf, " - UPS #2\n");
		record($conf, "   - Name:            [$conf->{answers}{ups}{ups2}{name}]\n");
		record($conf, "   - Address:         [$conf->{answers}{ups}{ups2}{address}]\n");
		record($conf, "   - NIS TCP Port:    [$conf->{answers}{ups}{ups2}{nisport}]\n");
		record($conf, "   - Check frequency: [$conf->{answers}{ups}{ups2}{polltime}] seconds\n");
	}
	if ($conf->{'system'}{two_ifn})
	{
		record($conf, " - IFN B Network:   [$conf->{answers}{ifn2_ip} / $conf->{answers}{ifn2_netmask}]\n");
	}
	if (not -e "/usr/sbin/brctl")
	{
		record($conf, " - Bridge utilities will be installed.\n");
	}
	if (not -e "/sbin/parted")
	{
		# Install it
		record($conf, " - Partition manuipulation program will be installed.\n");
	}
	
	record($conf, "\nProceed with setup? [Y/n] ");
	my $proceed = <STDIN>;
	#my $proceed = "y";
	chomp($proceed);
	if ((lc($proceed) eq "n") or (lc($proceed) eq "no"))
	{
		record($conf, "Returning to questions.\n");
		ask_questions($conf);
		return(0);
	}
	else
	{
		record($conf, "Proceeding.\n\n");
	}
	
	return(0);
}

# Ask questions about SSH keys
sub ask_questions_ssh
{
	my ($conf) = @_;

	record($conf, "\n-=] SSH questions (if any)\n\n");
	
	# First thing to do is setup which node is local and which is the peer.
	$conf->{'system'}{local_hostname} = $conf->{answers}{hostname};
	$conf->{'system'}{peer_hostname}  = $conf->{answers}{hostname};
	$conf->{'system'}{local_key}      = "node1";
	$conf->{'system'}{peer_key}       = "node2";
	if ($conf->{'system'}{this_is_node} == 1)
	{
		$conf->{'system'}{peer_hostname}           =~ s/01/02/;
	}
	else
	{
		$conf->{'system'}{peer_hostname}           =~ s/02/01/;
		$conf->{'system'}{local_key}               =  "node2";
		$conf->{'system'}{peer_key}                =  "node1";
	}

	my $local_key = $conf->{'system'}{local_key};
	my $peer_key  = $conf->{'system'}{peer_key};
	$conf->{files}{ssh_keys}{$local_key}{private}   =  $conf->{files}{ssh_keys}{local_key};
	$conf->{files}{ssh_keys}{$local_key}{public}    =  $conf->{files}{ssh_keys}{local_key}.$conf->{files}{ssh_keys}{public_suffix};
	$conf->{files}{ssh_keys}{$local_key}{hostname}  =  $conf->{'system'}{local_hostname};
	$conf->{files}{ssh_keys}{$local_key}{shortname} =  ($conf->{'system'}{local_hostname} =~ /^(.*?)\./)[0];
	$conf->{files}{ssh_keys}{$peer_key}{private}    =  $conf->{files}{ssh_keys}{peer_key};
	$conf->{files}{ssh_keys}{$peer_key}{public}     =  $conf->{files}{ssh_keys}{peer_key}.$conf->{files}{ssh_keys}{public_suffix};
	$conf->{files}{ssh_keys}{$peer_key}{hostname}   =  $conf->{'system'}{peer_hostname};
	$conf->{files}{ssh_keys}{$peer_key}{shortname}  =  ($conf->{'system'}{peer_hostname} =~ /^(.*?)\./)[0];
	
	$conf->{'system'}{local_shortname} = ($conf->{'system'}{local_hostname} =~ /^(.*?)\./)[0];
	$conf->{'system'}{peer_shortname}  = ($conf->{'system'}{peer_hostname}  =~ /^(.*?)\./)[0];
#	record($conf, " - Local hash key: [$local_key], peer hash key: [$peer_key]\n");
# 	record($conf, " - Local hostname: [$conf->{'system'}{local_shortname} ($conf->{'system'}{local_hostname})], peer hostname: [$conf->{'system'}{peer_shortname} ($conf->{'system'}{peer_hostname})]\n");
# 	record($conf, " - Local node: [$conf->{files}{ssh_keys}{$local_key}{shortname} ($conf->{files}{ssh_keys}{$local_key}{hostname})], private key file: [$conf->{files}{ssh_keys}{$local_key}{private}], public key file: [$conf->{files}{ssh_keys}{$local_key}{private}]\n");
# 	record($conf, " - Peer node:  [$conf->{files}{ssh_keys}{$peer_key}{shortname} ($conf->{files}{ssh_keys}{$peer_key}{hostname})], private key file: [$conf->{files}{ssh_keys}{$peer_key}{private}], public key file: [$conf->{files}{ssh_keys}{$peer_key}{private}]\n");
# 	die "testing...\n";

	# Read in keys already on disk.
	record($conf, " - Reading SSH keys from disk, if they exist.\n");
	read_ssh_keys($conf);
	
	# If any of the answer keys are blank but the matching file content has
	# a value, use the file's key as the answer.
	#record($conf, " - local private key on disk:      [$conf->{files}{ssh_keys}{$local_key}{contents}{private}]\n");
	#record($conf, " - local private key from answers: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
	if (($conf->{files}{ssh_keys}{$local_key}{contents}{private}) && (not $conf->{answers}{ssh_keys}{$local_key}{private}))
	{
		#record($conf, ">> answers::ssh_keys::${local_key}::private: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
		$conf->{answers}{ssh_keys}{$local_key}{private} = $conf->{files}{ssh_keys}{$local_key}{contents}{private};
		#record($conf, "<< answers::ssh_keys::${local_key}::private: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
		record($conf, " - Local SSH private key on disk but not in 'answers', adding it.\n");
	}
	#record($conf, " - local public key on disk:       [$conf->{files}{ssh_keys}{$local_key}{contents}{public}]\n");
	#record($conf, " - local public key from answers:  [$conf->{answers}{ssh_keys}{$local_key}{public}]\n");
	if (($conf->{files}{ssh_keys}{$local_key}{contents}{public}) && (not $conf->{answers}{ssh_keys}{$local_key}{public}))
	{
		$conf->{answers}{ssh_keys}{$local_key}{public} = $conf->{files}{ssh_keys}{$local_key}{contents}{public};
		record($conf, " - Local SSH public key on disk but not in 'answers', adding it.\n");
	}
	#record($conf, " - peer private key on disk:        [$conf->{files}{ssh_keys}{$peer_key}{contents}{private}]\n");
	#record($conf, " - peer private key from answers:   [$conf->{answers}{ssh_keys}{$peer_key}{private}]\n");
	if (($conf->{files}{ssh_keys}{$peer_key}{contents}{private}) && (not $conf->{answers}{ssh_keys}{$peer_key}{private}))
	{
		$conf->{answers}{ssh_keys}{$peer_key}{private} = $conf->{files}{ssh_keys}{$peer_key}{contents}{private};
		record($conf, " - Peer SSH private key on disk but not in 'answers', adding it.\n");
	}
	#record($conf, " - peer public key on disk:         [$conf->{files}{ssh_keys}{$peer_key}{contents}{public}]\n");
	#record($conf, " - peer public key from answers:    [$conf->{answers}{ssh_keys}{$peer_key}{public}]\n");
	if (($conf->{files}{ssh_keys}{$peer_key}{contents}{public}) && (not $conf->{answers}{ssh_keys}{$peer_key}{public}))
	{
		$conf->{answers}{ssh_keys}{$peer_key}{public} = $conf->{files}{ssh_keys}{$peer_key}{contents}{public};
		record($conf, " - Peer SSH public key on disk but not in 'answers', adding it.\n");
	}
	
	# If the disk keys exist and either the public or private key is
	# missing, blank the other because we can't/won't use it. Same for the
	# keys from the answers file.
	### Keys from disk
	if ((not $conf->{files}{ssh_keys}{$local_key}{contents}{private}) || (not $conf->{answers}{ssh_keys}{$local_key}{public}))
	{
		$conf->{files}{ssh_keys}{$local_key}{contents}{private} = "";
		$conf->{files}{ssh_keys}{$local_key}{contents}{public}  = "";
	}
	if ((not $conf->{files}{ssh_keys}{$peer_key}{contents}{private}) || (not $conf->{answers}{ssh_keys}{$peer_key}{public}))
	{
		$conf->{files}{ssh_keys}{$peer_key}{contents}{private} = "";
		$conf->{files}{ssh_keys}{$peer_key}{contents}{public}  = "";
	}
	### Keys from answers
	if ((not $conf->{answers}{ssh_keys}{$local_key}{private}) || (not $conf->{answers}{ssh_keys}{$local_key}{public}))
	{
		$conf->{answers}{ssh_keys}{$local_key}{private} = "";
		$conf->{answers}{ssh_keys}{$local_key}{public}  = "";
	}
	if ((not $conf->{answers}{ssh_keys}{$peer_key}{private}) || (not $conf->{answers}{ssh_keys}{$peer_key}{public}))
	{
		$conf->{answers}{ssh_keys}{$peer_key}{private} = "";
		$conf->{answers}{ssh_keys}{$peer_key}{public}  = "";
	}
	
	# From here on, we can assume that if the public key exists, so does
	# the private key. So now, if the key from answers and disks exists and
	# differ, ask the user which to use.
	### Local keys
	record($conf, " - Checking for conflicts between keys from 'answers' and keys on disk.\n");
	record($conf, " - Checking local keys.\n");
	if (($conf->{files}{ssh_keys}{$local_key}{contents}{private}) && ($conf->{answers}{ssh_keys}{$local_key}{private}) &&
	    ($conf->{files}{ssh_keys}{$local_key}{contents}{private} ne $conf->{answers}{ssh_keys}{$local_key}{private}))
	{
		# Two keys exist and they differ.
		record($conf, "The SSH key on disk differs from the one in the \"anvil_setup.answers\" file.");
		record($conf, " - Shall I replace the keys on disk with the one from answers? [Y/n] ");
		my $ssh_use_cache_local = <STDIN>;
		chomp($ssh_use_cache_local);
		if ((lc($ssh_use_cache_local) eq "n") || (lc($ssh_use_cache_local) eq "no"))
		{
			# Replace the answers version with the contents from
			# the disk keys.
			record($conf, " - Replacing local node's keys in \"anvil_setup.answers\" with those from disk.\n");
			#record($conf, ">> answers::ssh_keys::${local_key}::private: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
			$conf->{answers}{ssh_keys}{$local_key}{private} = $conf->{files}{ssh_keys}{$local_key}{contents}{private};
			#record($conf, "<< answers::ssh_keys::${local_key}::private: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
			$conf->{answers}{ssh_keys}{$local_key}{public}  = $conf->{files}{ssh_keys}{$local_key}{contents}{public};
			write_answers($conf);
		}
		else
		{
			# Write out the key files.
			record($conf, " - Replacing local node's keys from disk with those from \"anvil_setup.answers\".\n");
			my $local_private_file = $conf->{files}{ssh_keys}{$local_key}{private};
			my $local_public_file  = $conf->{files}{ssh_keys}{$local_key}{public};
			my $local_private_data = $conf->{files}{ssh_keys}{$local_key}{contents}{private};
			my $local_public_data  = $conf->{files}{ssh_keys}{$local_key}{contents}{public};
			
			# Write the public file
			write_file($conf, $local_private_file, $local_private_data, "root:root", "600");
			write_file($conf, $local_public_file,  $local_public_data,  "root:root", "644");
			
			# Replace the in-memory file contents with the data
			# from the answers file.
			$conf->{files}{ssh_keys}{$local_key}{contents}{private} = $conf->{answers}{ssh_keys}{$local_key}{private};
			$conf->{files}{ssh_keys}{$local_key}{contents}{public}  = $conf->{answers}{ssh_keys}{$local_key}{public};
		}
		record($conf, " - Done.\n");
	}
	### Peer keys
	record($conf, " - Checking peer keys.\n");
	if (($conf->{files}{ssh_keys}{$peer_key}{contents}{private}) && ($conf->{answers}{ssh_keys}{$peer_key}{private}) &&
	    ($conf->{files}{ssh_keys}{$peer_key}{contents}{private} ne $conf->{answers}{ssh_keys}{$peer_key}{private}))
	{
		# Two keys exist and they differ.
		record($conf, "The SSH key for the peer: [$conf->{'system'}{peer_shortname}] on disk differs from the one in the \"anvil_setup.answers\" file.");
		record($conf, " - Shall I replace the peer's keys on disk with the one from answers? [Y/n] ");
		my $ssh_use_cache_local = <STDIN>;
		chomp($ssh_use_cache_local);
		if ((lc($ssh_use_cache_local) eq "n") || (lc($ssh_use_cache_local) eq "no"))
		{
			# Change the "answers" to the keys I read from disk.
			record($conf, " - Replacing peer node's keys in \"anvil_setup.answers\" with those from disk.\n");
			$conf->{answers}{ssh_keys}{$peer_key}{private} = $conf->{files}{ssh_keys}{$peer_key}{contents}{private};
			$conf->{answers}{ssh_keys}{$peer_key}{public}  = $conf->{files}{ssh_keys}{$peer_key}{contents}{public};
			write_answers($conf);
		}
		else
		{
			# Write out the cached keys to the peer files now.
			record($conf, " - Replacing peer node's keys from disk with those from \"anvil_setup.answers\".\n");
			my $peer_private_file = $conf->{files}{ssh_keys}{$peer_key}{private};
			my $peer_public_file  = $conf->{files}{ssh_keys}{$peer_key}{public};
			my $peer_private_data = $conf->{files}{ssh_keys}{$peer_key}{contents}{private};
			my $peer_public_data  = $conf->{files}{ssh_keys}{$peer_key}{contents}{public};
			
			# Write the public file
			write_file($conf, $peer_private_file, $peer_private_data, "root:root", "600");
			write_file($conf, $peer_public_file,  $peer_public_data,  "root:root", "644");
			
			# Replace the in-memory file contents with the data
			# from the answers file.
			$conf->{files}{ssh_keys}{$peer_key}{contents}{private} = $conf->{answers}{ssh_keys}{$peer_key}{private};
			$conf->{files}{ssh_keys}{$peer_key}{contents}{public}  = $conf->{answers}{ssh_keys}{$peer_key}{public};
		}
		record($conf, " - Done.\n");
	}
	#die "testing...\n";
	
	return(0);
}

# Writes out the given file and, if passed, set the owner and mode.
sub write_file
{
	my ($conf, $file, $contents, $owner, $mode) = @_;
	
	use bytes;
	my $size      = legnth($contents);
	my $say_bytes = "bytes";
	if ($size == 1)
	{
		$say_bytes = "byte";
	}
	
	record($conf, "Writing out: [$size] $say_bytes to: [$file]\n");
	my $sc = $file;
	my $fh = IO::Handle->new();
	open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
	print $fh $contents;
	$fh->close();
	record($conf, " - Done.\n");
	
	if ($owner)
	{
		record($conf, " - Setting ownership of: [$file] to: [$owner].\n");
		$sc = "chown $owner $file";
		$fh = IO::Handle->new();
		open ($fh, "$sc 2&>1 |") or nice_exit($conf, 1, "Failed to run: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - output: [$line]\n");
		}
		$fh->close();
		record($conf, " - Done!\n");
	}
	
	if ($mode)
	{
		record($conf, " - Setting mode of: [$file] to: [$mode].\n");
		$sc = "chmod $mode $file";
		$fh = IO::Handle->new();
		open ($fh, "$sc 2&>1 |") or nice_exit($conf, 1, "Failed to own: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - output: [$line]\n");
		}
		$fh->close();
		record($conf, " - Done!\n");
	}
	
	return(0);
}

# This looks on disk for existing SSH keys.
sub read_ssh_keys
{
	my ($conf) = @_;
	
	my $local_key = $conf->{'system'}{local_key};
	my $peer_key  = $conf->{'system'}{peer_key};

	### TODO: Comment out these messages... too noisy.
	# Read in any existing key files.
	record($conf, " - Checking for existing SSH keys.\n");
	if (-e $conf->{files}{ssh_keys}{$local_key}{private})
	{
		record($conf, " - Found local RSA private key: [$conf->{files}{ssh_keys}{$local_key}{private}].\n");
		my $sc = "$conf->{files}{ssh_keys}{$local_key}{private}";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{files}{ssh_keys}{$local_key}{contents}{private} = "";
		while(<$fh>)
		{
			$conf->{files}{ssh_keys}{$local_key}{contents}{private} .= $_;
		}
		$fh->close();
		record($conf, " - Read.\n");
	}
	else
	{
		record($conf, " - Local private key: [$conf->{files}{ssh_keys}{$local_key}{private}] does not exist.\n");
	}
	if (-e $conf->{files}{ssh_keys}{$local_key}{public})
	{
		record($conf, " - Found local RSA public key: [$conf->{files}{ssh_keys}{$local_key}{public}].\n");
		my $sc = "$conf->{files}{ssh_keys}{$local_key}{public}";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{files}{ssh_keys}{$local_key}{contents}{public} = "";
		while(<$fh>)
		{
			$conf->{files}{ssh_keys}{$local_key}{contents}{public} .= $_;
		}
		$fh->close();
		record($conf, " - Read.\n");
	}
	else
	{
		record($conf, " - Local public key: [$conf->{files}{ssh_keys}{$local_key}{public}] does not exist.\n");
	}
	if (-e $conf->{files}{ssh_keys}{$peer_key}{private})
	{
		record($conf, " - Found peer's RSA private key: [$conf->{files}{ssh_keys}{$peer_key}{private}].\n");
		my $sc = "$conf->{files}{ssh_keys}{$peer_key}{private}";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{files}{ssh_keys}{$peer_key}{contents}{private} = "";
		while(<$fh>)
		{
			$conf->{files}{ssh_keys}{$peer_key}{contents}{private} .= $_;
		}
		$fh->close();
		record($conf, " - Read.\n");
	}
	else
	{
		record($conf, " - Peer private key: [$conf->{files}{ssh_keys}{$peer_key}{private}] does not exist.\n");
	}
	if (-e $conf->{files}{ssh_keys}{$peer_key}{public})
	{
		record($conf, " - Found peer's RSA public key: [$conf->{files}{ssh_keys}{$peer_key}{public}].\n");
		my $sc = "$conf->{files}{ssh_keys}{$peer_key}{public}";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{files}{ssh_keys}{$peer_key}{contents}{public} = "";
		while(<$fh>)
		{
			$conf->{files}{ssh_keys}{$peer_key}{contents}{public} .= $_;
		}
		$fh->close();
		record($conf, " - Read.\n");
	}
	else
	{
		record($conf, " - Peer public key: [$conf->{files}{ssh_keys}{$peer_key}{public}] does not exist.\n");
	}
	
	return(0);
}

# This configures the IPMI BMC.
sub configure_ipmi
{
	my ($conf) = @_;
	
	return (0) if $conf->{'system'}{skip_ipmi};
	record($conf, "Configuring the IPMI BMC.\n");
	
	# First up, determine the LAN channel and the user we will update.
	my $ipmi_user = $conf->{answers}{ipmi_user};
	my $channel;
	my $user_id;
	foreach my $this_channel (1..9)
	{
		record($conf, " - Checking LAN channel: [$this_channel]\n");
		my $sc = "ipmitool lan print $this_channel";
		#record($conf, "sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, " - line: [$line]\n");
			next if $channel;
			if ($line =~ /Set in Progress/)
			{
				$channel = $this_channel;
				record($conf, " - Found! Using channel: [$channel]\n");
			}
			elsif ($line =~ /not a LAN channel/)
			{
				record($conf, " - Not found.\n");
				next;
			}
		}
		$fh->close();
		last if $channel;
	}
	
	# Find the requested user ID
	if ($channel)
	{
		record($conf, " - Searching IPMI user list for: [$ipmi_user]\n");
		my $sc = "ipmitool user list $channel";
		#record($conf, "sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, " - line: [$line]\n");
			if ($line =~ /^(\d+)\s+(\w+)\s/)
			{
				my $id   = $1;
				my $name = $2;
				record($conf, " - Checking ID: [$id] and name: [$name]\n");
				if (lc($ipmi_user) eq lc($name))
				{
					$user_id = $id;
					record($conf, " - Match found!\n");
					last;
				}
			}
		}
		$fh->close();
	}
	else
	{
		record($conf, " - Unable to find either the IPMI LAN channel, skipping user search.\n");
	}
	
	my $proceed = 0;
	if (not $channel)
	{
		record($conf, " - Unable to find either the IPMI LAN channel or the user.\n");
		record($conf, "   Did 'ipmid' start properly?\n");
	}
	elsif (not $user_id)
	{
		record($conf, " - The user ID for: [$ipmi_user] was not found. Was the name mis-spelled?\n");
		record($conf, " - Configuring network address only.\n");
		$proceed = 1;
	}
	else
	{
		$proceed = 1;
	}
	
	if (not $proceed)
	{
		record($conf, "IPMI *NOT* configured! Please re-run this tool or configure it manually later.\n");
		return(1);
	}
	
	my $ip = $conf->{answers}{ipmi_ip};
	my $nm = $conf->{answers}{ipmi_netmask};
	my $gw = $conf->{answers}{ipmi_gateway} ? $conf->{answers}{ipmi_gateway} : "";
	my $pw = $conf->{answers}{password}     ? $conf->{answers}{password}     : "";
	
	record($conf, "Setting IPMI network values.\n");
	if (($ip) && ($nm))
	{
		# This should not print anything.
		record($conf, " - Setting IPMI to 'static'.\n");
		my $sc = "ipmitool lan set $channel ipsrc static";
		#record($conf, "sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - line: [$line]\n");
		}
		$fh->close();
		
		record($conf, " - Setting IP: [$ip]\n");
		$sc = "ipmitool lan set $channel ipaddr $ip";
		#record($conf, "sc: [$sc]\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		
		record($conf, " - Setting netmask: [$nm].\n");
		$sc = "ipmitool lan set $channel netmask $nm";
		#record($conf, "sc: [$sc]\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		
		# Set the default gateway if it's been defined.
		if ($gw)
		{
			record($conf, " - Setting default gateway: [$gw].\n");
			my $sc = "ipmitool lan set $channel defgw ipaddr $gw";
			#record($conf, "sc: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			record($conf, "/----------\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "| $line\n");
			}
			$fh->close();
			record($conf, "\\----------\n");
		}
		
		record($conf, "Printing IPMI configuration:\n");
		$sc = "ipmitool lan print $channel";
		#record($conf, "sc: [$sc]\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
	}
	
	# Set the password if the user ID and password are set.
	if (($pw) && ($user_id))
	{
		# No output is expected.
		record($conf, "Setting the user/ID: [$ipmi_user/$user_id]'s password to: [$pw]\n");
		my $sc = "ipmitool user set password $user_id $pw";
		#record($conf, "sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "line: [$line]\n");
		}
		$fh->close();
	}
	
	return(0);
}

# This takes the user's sizes and creates two partitions for later use by DRBD.
sub partition_disk
{
	my ($conf) = @_;
	
	if ($conf->{'system'}{skip_disk})
	{
		record($conf, "Skipping disk partitioning.\n");
		return(0);
	}
	
	# TODO: Make this not try to create the second resource if insufficient
	#       space was left for it.
	my $shared_space = $conf->{answers}{shared_storage};
	my $pool1_space  = $conf->{answers}{storage_pool_1};
	my $pool2_space  = $conf->{answers}{storage_pool_2};
	my $root_device  = $conf->{'system'}{root}{device};
	
	record($conf, "Partitioning: [$root_device]...\n");
	#record($conf, "shared_space: [$shared_space], pool1_space: [$pool1_space], pool2_space: [$pool2_space], root_device: [$root_device]\n");
	
	my $partition1_space = $shared_space + $pool1_space;
	my $partition2_space = $pool2_space;
	#record($conf, "partition1_space: [$partition1_space], partition2_space: [$partition2_space]\n");
	
	# Get the start and end size of the free space.
	$conf->{parted}{free_space_start}      = 0;
	$conf->{parted}{free_space_end}        = 0;
	$conf->{parted}{free_space_total}      = 0;
	if (1)
	{
		# -m == machine parsable, -s == script, don't prompt
		my $sc = "parted -a opt -m -s $root_device \"unit GB print free\"";
		#record($conf, "sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "line: [$line]\n");
			# Often there is a small amount of free space at the
			# start of the disk, so I let this loop and overright 
			# older values on purpose.
			if ($line =~ /1:(.*?):(.*?):(.*?):free;/)
			{
				my $start = $1;
				my $end   = $2;
				my $size  = $3;
				#record($conf, ">> start: [$start], end: [$end], size: [$size]\n");
				# The unit is always GB so I just strip the
				# letters off.
				($conf->{parted}{free_space_start}) = ($start =~ /^(\d+[\.\d]*)/);
				($conf->{parted}{free_space_end})    = ($end   =~ /^(\d+[\.\d]*)/);
				($conf->{parted}{free_space_total})  = ($size  =~ /^(\d+[\.\d]*)/);
				#record($conf, "parted::free_space_start:  [$conf->{parted}{free_space_start}]G\n");
				#record($conf, "parted::free_space_end:    [$conf->{parted}{free_space_end}]G\n");
				#record($conf, "parted::free_space_total:  [$conf->{parted}{free_space_total}]G\n");
			}
		}
		$fh->close();
	}
	
	# Create the extended and logical partitions.
	if (1)
	{
		my $extended_start = $conf->{parted}{free_space_start};
		my $extended_end   = $conf->{parted}{free_space_end};
		my $make_extended  = "parted -a opt -m -s $root_device \"mkpart extended ${extended_start}G ${extended_end}G\"";
		
		my $part1_start   = $conf->{parted}{free_space_start};
		my $part1_end     = $part1_start + $pool1_space + $shared_space;
		# Parted likes to round, so head it off at the past lest the
		# start of the second partition be ahead of the end of the
		# first partition.
		if ($part1_end =~ /\./)
		{
			#record($conf, "> part1_end: [$part1_end]\n");
			$part1_end = int($part1_end + 1);
			#record($conf, "< part1_end: [$part1_end]\n");
		}
		my $make_logical1 = "parted -a opt -m -s $root_device \"mkpart logical ${part1_start}G ${part1_end}G\"";
		
		my $part2_start = $part1_end;
		if ($part1_start =~ /\./)
		{
			# Round it up.
			$part1_start += 1;
			$part1_start =~ s/\..*//;
		}
		my $part2_end     = $conf->{parted}{free_space_end};
		my $make_logical2 = "parted -a opt -m -s $root_device \"mkpart logical ${part2_start}G ${part2_end}G\"";
		#record($conf, "Extended: [$make_extended]\n");
		#record($conf, "Logical1: [$make_logical1]\n");
		#record($conf, "Logical2: [$make_logical2]\n");
		
		record($conf, "Creating extended partition from: [${extended_start} GB] to: [${extended_end} GB]\n");
		record($conf, "Extended: [$make_extended]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$make_extended 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_extended], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "line: [$line]\n");
			if ($line =~ /reboot/)
			{
				record($conf, "Kernel could not read the new partition, a reboot will be required.\n");
				$conf->{'system'}{reboot_required} = 1;
			}
		}
		$fh->close();
		sleep 1;
		
		record($conf, "Creating storage pool 1 from: [${part1_start} GB] to: [${part1_end} GB]\n");
		record($conf, "Logical1: [$make_logical1]\n");
		$fh = IO::Handle->new();
		open ($fh, "$make_logical1 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_logical1], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "line: [$line]\n");
			if ((not $conf->{'system'}{reboot_required}) && ($line =~ /reboot/))
			{
				record($conf, "Kernel could not read the new partition, a reboot will be required.\n");
				$conf->{'system'}{reboot_required} = 1;
			}
		}
		$fh->close();
		sleep 1;
		
		record($conf, "Creating storage pool 2 from: [${part2_start} GB] to: [${part2_end} GB]\n");
		record($conf, "Logical2: [$make_logical2]\n");
		$fh = IO::Handle->new();
		open ($fh, "$make_logical2 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_logical1], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "line: [$line]\n");
			if ((not $conf->{'system'}{reboot_required}) && ($line =~ /reboot/))
			{
				record($conf, "Kernel could not read the new partition, a reboot will be required.\n");
				$conf->{'system'}{reboot_required} = 1;
			}
		}
		$fh->close();
		sleep 1;

# 		record($conf, "New partition layout;\n");
# 		$fh = IO::Handle->new();
# 		open ($fh, "parted -a opt $root_device \"print free\" 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_logical1], error: $!\n");
# 		while(<$fh>)
# 		{
# 			chomp;
# 			my $line = $_;
# 			record($conf, "line: [$line]\n");
# 		}
# 		$fh->close();
	}
	
	return($conf);
}

sub set_hostname
{
	my ($conf) = @_;
	
	# Write the file and then set the active hostname.
	record($conf, "Recording and setting the host name.\n");
	my $file = "/etc/sysconfig/network";
	my $sc = $file;
	my $fh = IO::Handle->new();
	open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
	print $fh "NETWORKING=yes\n";
	print $fh "HOSTNAME=$conf->{answers}{hostname}\n";
	$fh->close();
	
	$sc = "hostname $conf->{answers}{hostname}";
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub write_hosts
{
	my ($conf) = @_;
	
	record($conf, "Writing the hosts file.\n");
	if (not -e "/etc/hosts.an")
	{
		record($conf, " - Backing up the original /etc/hosts as /etc/hosts.an: \n");
		my $sc = "cp /etc/hosts /etc/hosts.an";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, ".");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	my $say_bcn_ip     = $conf->{answers}{bcn_ip};
	my $say_ipmi_ip    = $conf->{answers}{ipmi_ip};
	my $say_sn_ip      = $conf->{answers}{sn_ip};
	my $say_ifn_ip     = $conf->{answers}{ifn_ip};
	my $say_hostname   = $conf->{answers}{hostname};
	my $short_hostname = ($say_hostname =~ /^(.*?)\./)[0];
	
	my $file = "/etc/hosts";
	my $sc = $file;
	my $fh = IO::Handle->new();
	open ($fh, ">>$file") or nice_exit($conf, 1, "Failed to append: [$sc], error: $!\n");
	print $fh "\n";
	print $fh "# Cluster $conf->{answers}{cluster_id}, Node $conf->{answers}{node_id}\n";
	print $fh "$say_bcn_ip\t$short_hostname ${short_hostname}.bcn $say_hostname\n";
	print $fh "$say_ipmi_ip\t${short_hostname}.ipmi\n";
	print $fh "$say_sn_ip\t${short_hostname}.sn\n";
	print $fh "$say_ifn_ip\t${short_hostname}.ifn\n";
	
	print $fh "\n";
	print $fh "### Foundation pack\n";
	# TODO: Switches
	# TODO: PDUs
	
	if (not $conf->{'system'}{skip_ups})
	{
		foreach my $ups (sort {$a cmp $b} keys %{$conf->{answers}{ups}})
		{
			my $say_ip    = $conf->{answers}{ups}{$ups}{address};
			my $say_name  = $conf->{answers}{ups}{$ups}{name};
			my $full_name = $say_name.".".$conf->{answers}{customer_domain};
			print $fh "$say_ip\t$say_name $full_name\n";
		}
	}
	$fh->close();
	
	$sc = "hostname $say_hostname";
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub configure_nics
{
	my ($conf) = @_;
	
	# Bail if the user has not asked to setup networking.
	return(0) if $conf->{'system'}{skip_network};
	
	record($conf, "\n-=] NIC configuration\n\n");
	if ($conf->{'system'}{skip_network})
	{
		record($conf, " - Skipped.\n");
		return(0);
	}
	if ($conf->{nic}{count} > 6)
	{
		$conf->{nic}{ifn_count} = 2;
	}
	if (0)
	{
		foreach my $nic (sort {$a cmp $b} keys %{$conf->{nic}})
		{
			# Skip entries that aren't actually NICs.
			#record($conf, "NIC: [$nic] (".ref($conf->{nic}{$nic}).")\n");
			next if ref($conf->{nic}{$nic}) ne "HASH";
			#record($conf, " - NIC: [$nic]\n");
			my $say_mac = uc($conf->{nic}{$nic}{mac});
			my $say_ip  = $conf->{nic}{$nic}{ip} ? $conf->{nic}{$nic}{ip} : "--";
			my $say_nm  = $conf->{nic}{$nic}{nm} ? $conf->{nic}{$nic}{nm} : "--";
			record($conf, " - nic: [$nic], MAC: [$say_mac], current IP: [$say_ip / $say_nm]\n");
		}
	}
	
	### TODO: If the file exists, ask if the user wants to re-run the
	###       network config. If so, pull down and remove the bonds and
	###       bridges.
	# Here I check for one of the bond files. If I don't see it, I assume
	# the configuration tool has not been run yet, so I will ask the user
	# to un/plug each NIC.
	if (not -e "/etc/sysconfig/network-scripts/ifcfg-bond0")
	{
		# First, re-write all of the network configuration files to
		# the initial format.
		record($conf, "I found: [$conf->{nic}{count}] NICs; IFN Count: [$conf->{nic}{ifn_count}].\n");
		if (backup_ifcfg_files($conf))
		{
			foreach my $nic (sort {$a cmp $b} keys %{$conf->{nic}})
			{
				next if ref($conf->{nic}{$nic}) ne "HASH";
				my $file = "/etc/sysconfig/network-scripts/ifcfg-$nic";
				record($conf, "Re-writing the config for: [$nic]... ");
				my $say_mac = uc($conf->{nic}{$nic}{mac});
				my $say_ip  = $conf->{nic}{$nic}{ip} ? $conf->{nic}{$nic}{ip} : "";
				my $proto = "none";
				if ($say_ip)
				{
					# configure for dhcp.
					$proto = "dhcp";
				}
				my $sc = $file;
				my $fh = IO::Handle->new();
				open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
				print $fh "# Temporary configuration written by the Anvil! configuration tool.\n";
				print $fh "# Original copy stored as: /root/network-scripts.anvil/ifcfg-$nic.\n";
				print $fh "HWADDR=\"$say_mac\"\n";
				print $fh "DEVICE=\"$nic\"\n";
				print $fh "NM_CONTROLLED=\"no\"\n";
				print $fh "ONBOOT=\"yes\"\n";
				print $fh "BOOTPROTO=\"$proto\"\n";
				$fh->close();
				record($conf, " - Done.\n");
			}
		
			# Now restart networking to ensure all NICs are currently up.
			restart_network($conf);
		}
		else
		{
			record($conf, "It looks like the original interface configuration files were backed up and rewritten already. Skipping.\n");
		}
		
		# Read the last line in the syslog file.
		my ($last_line) = read_syslog($conf, "");
		
		record($conf, "It appears that we have not reordered the NICs yet.\n");
		for (my $i = 0; $i < $conf->{nic}{count}; $i++)
		{
			my $current_nic    = "";
			my $desired_nic = "eth$i";
			my $done        = 0;
			record($conf, "Please unplug the interface you wish to make: [$desired_nic]\n");
			while (not $done)
			{
				sleep 1;
				my ($this_last_line) = read_syslog($conf, $last_line);
				#record($conf, "Does: old last line: [$last_line]\n");
				#record($conf, "and: new last line:  [$this_last_line] differ?\n");
				if ($this_last_line ne $last_line)
				{
					#record($conf, "New data, parsing: [".@{$conf->{syslog}{new_lines}}."] new lines.\n");
					# Parse the new lines looking for interface notes.
					foreach my $line (@{$conf->{syslog}{new_lines}})
					{
						#record($conf, "new line: [$line]\n");
						if ($line =~ /\s(\S+?) NIC Link is Down/)
						{
							$current_nic = $1;
							record($conf, " - That appears to be: [$current_nic]. I will move this to: [$desired_nic].\n");
							$conf->{map_nic}{$desired_nic} = $current_nic;
							$done = 1;
						}
					}
					$last_line = $this_last_line;
				}
			}
		}
		
		foreach my $desired_nic (sort {$a cmp $b} keys %{$conf->{map_nic}})
		{
			my $current_nic = $conf->{map_nic}{$desired_nic};
			my $desired_mac = uc($conf->{nic}{$current_nic}{mac});
			record($conf, "Moving interface with MAC: [$desired_mac] from: [$current_nic] to: [$desired_nic]\n");
			$conf->{new_nic}{$desired_nic} = $desired_mac;
		}
		
		# Shut down the network and delete udev file.
		record($conf, "\n##############################################################################\n");
		record($conf, "The next step will take down the network and (likely) change the IP address.\n");
		record($conf, "If you are running this via ssh, be sure to be running in 'screen'. Otherwise,\n");
		record($conf, "this program will die in the middle of modifying the network and likely leave\n");
		record($conf, "you with no remote access at all!\n");
		record($conf, "##############################################################################\n\n");
		record($conf, "Proceed? [y/N] ");
		my $proceed = <STDIN>;
		#my $proceed = "y";
		chomp($proceed);
		if ((lc($proceed) eq "y") or (lc($proceed) eq "yes"))
		{
			record($conf, "Proceeding... ");
			my $sc = "/etc/init.d/network stop && rm -f /etc/udev/rules.d/70-persistent-net.rules";
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
			}
			$fh->close();
			record($conf, " - Done.\n");
		}
		else
		{
			nice_exit($conf, 1, "Aborting. Please restart at your leisure and re-run this program.\n");
		}
		
		foreach my $nic (sort {$a cmp $b} keys %{$conf->{new_nic}})
		{
			my $file = "/etc/sysconfig/network-scripts/ifcfg-$nic";
			record($conf, "Re-writing the config for: [$nic]... ");
			my $say_mac = uc($conf->{new_nic}{$nic});
			my $say_ip  = $conf->{nic}{$nic}{ip} ? $conf->{nic}{$nic}{ip} : "";
			my $proto = "none";
			if ($say_ip)
			{
				# configure for dhcp.
				$proto = "dhcp";
			}
			my $comment = "";
			my $bond    = "";
			if ($conf->{nic}{ifn_count} == 1)
			{
				if ($nic eq "eth0")    { $bond = "bond0"; $comment = "Back-Channel Network - Link 1"; }
				elsif ($nic eq "eth1") { $bond = "bond1"; $comment = "Storage Network - Link 1"; }
				elsif ($nic eq "eth2") { $bond = "bond2"; $comment = "Internet-Facing Network - Link 1"; }
				elsif ($nic eq "eth3") { $bond = "bond0"; $comment = "Back-Channel Network - Link 2"; }
				elsif ($nic eq "eth4") { $bond = "bond1"; $comment = "Storage Network - Link 2"; }
				elsif ($nic eq "eth5") { $bond = "bond2"; $comment = "Internet-Facing Network - Link 2"; }
				else { nice_exit($conf, 1, "Unknown NIC: [$nic]\n"); }
			}
			elsif ($conf->{nic}{ifn_count} == 2)
			{
				if ($nic eq "eth0")    { $bond = "bond0"; $comment = "Back-Channel Network - Link 1"; }
				elsif ($nic eq "eth1") { $bond = "bond1"; $comment = "Storage Network - Link 1"; }
				elsif ($nic eq "eth2") { $bond = "bond2"; $comment = "Internet-Facing Network A - Link 1"; }
				elsif ($nic eq "eth3") { $bond = "bond3"; $comment = "Internet-Facing Network B - Link 1"; }
				elsif ($nic eq "eth4") { $bond = "bond0"; $comment = "Back-Channel Network - Link 2"; }
				elsif ($nic eq "eth5") { $bond = "bond1"; $comment = "Storage Network - Link 2"; }
				elsif ($nic eq "eth6") { $bond = "bond2"; $comment = "Internet-Facing Network A - Link 2"; }
				elsif ($nic eq "eth7") { $bond = "bond3"; $comment = "Internet-Facing Network B - Link 2"; }
				else { nice_exit($conf, 1, "Unknown NIC: [$nic]\n"); }
			}
			else
			{
				nice_exit($conf, 1, "Unknown number of IFNs: [$conf->{nic}{ifn_count}]\n");
			}
			my $sc = $file;
			my $fh = IO::Handle->new();
			open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			print $fh "# $comment\n";
			print $fh "HWADDR=\"$say_mac\"\n";
			print $fh "DEVICE=\"$nic\"\n";
			print $fh "NM_CONTROLLED=\"no\"\n";
			print $fh "ONBOOT=\"yes\"\n";
			print $fh "BOOTPROTO=\"$proto\"\n";
			print $fh "MASTER=\"$bond\"\n";
			print $fh "SLAVE=\"yes\"\n";
			$fh->close();
			record($conf, " - Done.\n");
		}
		
		if ($conf->{nic}{ifn_count} == 1)
		{
			# One bridge, three bonds.
			for (my $i = 0; $i < 3; $i++)
			{
				my $device = "bond".$i;
				my $file   = "/etc/sysconfig/network-scripts/ifcfg-$device";
				record($conf, "Writing the config for: [$device]... ");
				my $sc = $file;
				my $fh = IO::Handle->new();
				open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
				my $primary = "eth0";
				my $comment = "Back-Channel Network - Bond";
				my $bridge  = "";
				my $proto   = "static";
				my $ip      = $conf->{answers}{bcn_ip};
				my $nm      = $conf->{answers}{bcn_netmask};
				if ($i == 1) 
				{
					$primary = "eth1";
					$comment = "Storage Network - Bond";
					$ip      = $conf->{answers}{sn_ip};
					$nm      = $conf->{answers}{sn_netmask};
				}
				elsif ($i == 2)
				{
					$primary = "eth2";
					$comment = "Internet-Facing Network - Bond";
					$ip      = "";
					$nm      = "";
					$proto   = "none";
					$bridge  = "vbr2";
				}
				print $fh "# $comment\n";
				print $fh "DEVICE=\"$device\"\n";
				if ($bridge)
				{
					print $fh "BRIDGE=\"$bridge\"\n";
				}
				print $fh "BOOTPROTO=\"$proto\"\n";
				print $fh "NM_CONTROLLED=\"no\"\n";
				print $fh "ONBOOT=\"yes\"\n";
				print $fh "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=$primary\"\n";
				if (not $bridge)
				{
					print $fh "IPADDR=\"$ip\"\n";
					print $fh "NETMASK=\"$nm\"\n";
				}
				$fh->close();
				record($conf, " - Done.\n");
			}
			
			# Write the bridge.
			my $device = "vbr2";
			my $file   = "/etc/sysconfig/network-scripts/ifcfg-$device";
			record($conf, "Writing the config for: [$device]... ");
			my $sc = $file;
			my $fh = IO::Handle->new();
			open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			print $fh "# Internet-Facing Network - Bridge\n";
			print $fh "DEVICE=\"vbr2\"\n";
			print $fh "TYPE=\"Bridge\"\n";
			print $fh "BOOTPROTO=\"static\"\n";
			print $fh "IPADDR=\"$conf->{answers}{ifn_ip}\"\n";
			print $fh "NETMASK=\"$conf->{answers}{ifn_netmask}\"\n";
			print $fh "GATEWAY=\"$conf->{answers}{ifn_gateway}\"\n";
			print $fh "DNS1=\"$conf->{answers}{dns1}\"\n";
			print $fh "DNS2=\"$conf->{answers}{dns2}\"\n";
			print $fh "DEFROUTE=\"$conf->{answers}{ifn_dg}\"\n";
			$fh->close();
			record($conf, " - Done.\n");
		}
		elsif ($conf->{nic}{ifn_count} == 2)
		{
			# Two bridges, four bonds.
			record($conf, "Two IFNs not yet implemented...\n");
		}
		else
		{
			nice_exit($conf, 1, "Unknown number of IFNs: [$conf->{nic}{ifn_count}]\n");
		}
		
		# Rewrite udev and start the network.
		record($conf, "Note: You may safely ignore any errors like:\n");
		record($conf, " - \"bonding: cannot add bond bondX; already exists\"\n");
		my $sc = "start_udev && /etc/init.d/network start";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "The network should now be configured.\n");
	
	return(0);
}

sub read_syslog
{
	my ($conf, $previous_last_line) = @_;
	my $last_line = "";
	
	my $show_message = 1;
	my $record = 0;
	$conf->{syslog}{new_lines} = [];
	
	my $sc = "/var/log/messages";
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "syslog line: [$line]\n");
		if (not $previous_last_line)
		{
			#record($conf, "No previous last syslog line. Keeping array empty.\n") if $show_message;
			$show_message = 0;
		}
		elsif ($line eq $previous_last_line)
		{
			#record($conf, "Found the last line: [$line], beginning recording.\n");
			$record = 1;
		}
		elsif ($record)
		{
			# I don't want to fill the entire array on first read
			# or else the interface detection code will fire on 
			# every entry.
			push @{$conf->{syslog}{new_lines}}, $line;
		}
		$last_line = $line;
	}
	$fh->close();
	
	#record($conf, "Last syslog line: [$last_line]\n");
	return($last_line);
}

sub restart_network
{
	my ($conf) = @_;
	
	record($conf, "Restarting the network. This may close ssh sessions. Proceed? [y/N] ");
	my $proceed = <STDIN>;
	#my $proceed = "y";
	chomp($proceed);
	if ((lc($proceed) eq "y") or (lc($proceed) eq "yes"))
	{
		record($conf, "Proceeding... ");
	}
	else
	{
		nice_exit($conf, 1, "Aborting. Please restart at your leisure and re-run this program.\n");
	}
	
	# Disable network manager
	my $sc = "chkconfig NetworkManager off && chkconfig network on && /etc/init.d/network restart";
	if (not -e "/etc/init.d/NetworkManager")
	{
		$sc = "chkconfig network on && /etc/init.d/network restart";
	}
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, ".");
	}
	$fh->close();
	sleep 5;	# Give the NICs time to come up
	record($conf, " - Done.\n");
	
	return(0);
}

sub backup_ifcfg_files
{
	my ($conf) = @_;
	
	my $backup_dir = "/root/network-scripts.anvil";
	if (-e "$backup_dir")
	{
		record($conf, "Backup already performed, skipping.\n");
		return(0);
	}
	else
	{
		mkdir "$backup_dir" or warn "Failed to create the directory: [$backup_dir]. The error was: $!\n";
	}
	
	record($conf, "Archiving the current interface configuration files in /root/network-scripts.anvil.\n");
	my $sc = "cp /etc/sysconfig/network-scripts/* /root/network-scripts.anvil";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, ".");
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(1);
}

sub setup_ssh
{
	my ($conf) = @_;
	record($conf, "Configuring the SSH keys.\n");

	my $local_key = $conf->{'system'}{local_key};
	my $peer_key  = $conf->{'system'}{peer_key};
=pod
	$conf->{files}{ssh_keys}{$local_key}{private}   =  $conf->{files}{ssh_keys}{local_key};
	$conf->{files}{ssh_keys}{$local_key}{public}    =  $conf->{files}{ssh_keys}{local_key}.".".$conf->{files}{ssh_keys}{public_suffix};
	$conf->{files}{ssh_keys}{$local_key}{hostname}  =  $conf->{'system'}{local_hostname};
	$conf->{files}{ssh_keys}{$local_key}{shortname} =  ($conf->{'system'}{local_hostname} =~ /^(.*?)\./)[0];
	$conf->{files}{ssh_keys}{$peer_key}{private}    =  $conf->{files}{ssh_keys}{peer_key};
	$conf->{files}{ssh_keys}{$peer_key}{public}     =  $conf->{files}{ssh_keys}{peer_key}.".".$conf->{files}{ssh_keys}{public_suffix};
	$conf->{files}{ssh_keys}{$peer_key}{hostname}   =  $conf->{'system'}{peer_hostname};
	$conf->{files}{ssh_keys}{$peer_key}{shortname}  =  ($conf->{'system'}{peer_hostname} =~ /^(.*?)\./)[0];
	
	$conf->{files}{ssh_keys}{$local_key}{contents}{private}
	$conf->{files}{ssh_keys}{$local_key}{contents}{public}
	$conf->{files}{ssh_keys}{$peer_key}{contents}{private}
	$conf->{files}{ssh_keys}{$peer_key}{contents}{public}
	
	$conf->{answers}{ssh_keys}{$local_key}{private}
	$conf->{answers}{ssh_keys}{$local_key}{public}
	$conf->{answers}{ssh_keys}{$peer_key}{private}
	$conf->{answers}{ssh_keys}{$peer_key}{public}
=cut
	
	# Sort out the hostnames.
	my $local_hostname  = $conf->{files}{ssh_keys}{$local_key}{hostname};
	my $local_shortname = $conf->{files}{ssh_keys}{$local_key}{shortname};
	my $peer_hostname   = $conf->{files}{ssh_keys}{$peer_key}{hostname};
	my $peer_shortname  = $conf->{files}{ssh_keys}{$peer_key}{shortname};
	record($conf, " - This node is: [$local_shortname ($local_hostname)], peer is: [$peer_shortname ($peer_hostname)]\n");
	
	# Makes some keys easier to read.
	# Key contents
	my $local_file_private_key    = $conf->{files}{ssh_keys}{$local_key}{contents}{private};
	my $local_file_public_key     = $conf->{files}{ssh_keys}{$local_key}{contents}{public};
	my $local_answers_private_key = $conf->{answers}{ssh_keys}{$local_key}{private};
	my $local_answers_public_key  = $conf->{answers}{ssh_keys}{$local_key}{public};
	my $peer_file_private_key     = $conf->{files}{ssh_keys}{$peer_key}{contents}{private};
	my $peer_file_public_key      = $conf->{files}{ssh_keys}{$peer_key}{contents}{public};
	my $peer_answers_private_key  = $conf->{answers}{ssh_keys}{$peer_key}{private};
	my $peer_answers_public_key   = $conf->{answers}{ssh_keys}{$peer_key}{public};
	# File names
	my $local_private_file = $conf->{files}{ssh_keys}{$local_key}{private};
	my $local_public_file  = $conf->{files}{ssh_keys}{$local_key}{public};
	my $peer_private_file  = $conf->{files}{ssh_keys}{$peer_key}{private};
	my $peer_public_file   = $conf->{files}{ssh_keys}{$peer_key}{public};
	
	# Setup the local SSH key
	record($conf, "Setting up local SSH keys.\n");
	if (($local_file_private_key) && ($local_file_public_key))
	{
		# Ok, so there are keys on disk. If they match 'answers',
		# nothing needs to be done.
		if (($local_file_private_key eq $local_answers_private_key) &&
		    ($local_file_public_key  eq $local_answers_public_key))
		{
			# Match, nothing to do.
			record($conf, " - Key on disk matches key in 'answers', nothing to do.\n");
		}
		else
		{
			# WTF? 
			record($conf, " - [ WARNING ] - Something went wrong.\n");
			record($conf, "   There are keys in 'answers' that differ from the keys on disk.\n");
			record($conf, "   This should have been resolved during the question stage.\n");
		}
	}
	else
	{
		# If there are no contents, there is no key. If there is an
		# answers key, write it out. Otherwise, generate the SSH key.
		if (($local_answers_private_key) && ($local_file_public_key))
		{
			# Cache exists, using it.
			record($conf, " - Writing out SSH keys using keys from \"anvil_setup.answers\".\n");
			
			# Write the private key
			write_file($conf, $local_private_file, $local_file_private_key, "root:root", "600");
			# Write the public key
			write_file($conf, $local_public_file,  $local_file_public_key,  "root:root", "644");
			record($conf, " - Done.\n");
		}
		else
		{
			# Create a new key
			record($conf, " - Local SSH keys need to be created.\n");
			my $sc = "$conf->{commands}{'ssh-keygen'} $local_private_file";
			#record($conf, " - sc: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			record($conf, "/----------\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "| $line\n");
			}
			$fh->close();
			record($conf, "\\----------\n");
			record($conf, " - Done.\n");
		}
	}
	
	# Setting up peer's SSH keys
	record($conf, "Setting up peer's SSH keys.\n");
	if (($peer_file_private_key) && ($peer_file_public_key))
	{
		# Ok, so there are keys on disk. If they match 'answers',
		# nothing needs to be done.
		if (($peer_file_private_key eq $peer_answers_private_key) &&
		    ($peer_file_public_key  eq $peer_answers_public_key))
		{
			# Match, nothing to do.
			record($conf, " - Key on disk matches key in 'answers', nothing to do.\n");
		}
		else
		{
			# WTF? 
			record($conf, " - [ WARNING ] - Something went wrong.\n");
			record($conf, "   There are keys in 'answers' that differ from the keys on disk.\n");
			record($conf, "   This should have been resolved during the question stage.\n");
		}
	}
	else
	{
		# Generate the peer's keys.
		record($conf, " - Peer's SSH keys need to be created.\n");
		my $sc = "$conf->{commands}{'ssh-keygen'} $peer_private_file";
		#record($conf, " - sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		# The peer's public key generates with this node's hostname.
		# Fix it.
		# Read in the new key;
		record($conf, " - Updating the hostname in the peer's public ssh key.\n");
		$sc = "$conf->{files}{ssh_keys}{$peer_key}{public}";
		$fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{files}{ssh_keys}{$peer_key}{contents}{public} = "";
		while(<$fh>)
		{
			$conf->{files}{ssh_keys}{$peer_key}{contents}{public} .= $_;
		}
		$fh->close();
		
		# Replace the host name
		$conf->{files}{ssh_keys}{$peer_key}{contents}{public} =~ s/$local_shortname/$peer_shortname/;
		
		# Write it back out.
		$sc = "$conf->{files}{ssh_keys}{$peer_key}{public}";
		$fh = IO::Handle->new();
		open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
		print $fh $conf->{files}{ssh_keys}{$peer_key}{contents}{public};
		$fh->close();
		record($conf, " - Read.\n");
	}
	
	# Read in the new keys.
	read_ssh_keys($conf);
	
	# Copy the read keys into answers and then write the update answers file.
	#record($conf, ">> answers::ssh_keys::${local_key}::private: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
	$conf->{answers}{ssh_keys}{$local_key}{private} = $conf->{files}{ssh_keys}{$local_key}{contents}{private};
	#record($conf, "<< answers::ssh_keys::${local_key}::private: [$conf->{answers}{ssh_keys}{$local_key}{private}]\n");
	$conf->{answers}{ssh_keys}{$local_key}{public}  = $conf->{files}{ssh_keys}{$local_key}{contents}{public};
	$conf->{answers}{ssh_keys}{$peer_key}{private}  = $conf->{files}{ssh_keys}{$peer_key}{contents}{private};
	$conf->{answers}{ssh_keys}{$peer_key}{public}   = $conf->{files}{ssh_keys}{$peer_key}{contents}{public};
	write_answers($conf);
	
	# Update /etc/ssh/sshd_config to not require DNS.
	my $sshd_config = "/etc/ssh/sshd_config";
	if (-e "${sshd_config}.anvil")
	{
		record($conf, "SSH daemon configuration update already done, skipping.\n");
	}
	else
	{
		record($conf, "Updating SSH daemon to not lookup IPs of incoming connections.\n");
		record($conf, " - Backing up: [$sshd_config] to: [${sshd_config}.anvil].\n");
		my $sc = "cp $sshd_config ${sshd_config}.anvil";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - output: [$line]\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		record($conf, " - Reading SSH config file: [$sshd_config].\n");
		my @data;
		$sc = "$sshd_config";
		$fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			
			if ($line)
			{
				$line =~ s/^GSSAPIAuthentication yes/#GSSAPIAuthentication yes/;
				$line =~ s/#GSSAPIAuthentication no/GSSAPIAuthentication no/;
				$line =~ s/#UseDNS yes/UseDNS no/;
			}
			
			push @data, "$line\n";
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		record($conf, "Writing updated SSH config file: [$sshd_config].\n");
		$sc = "$sshd_config";
		$fh = IO::Handle->new();
		open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
		foreach my $line (@data)
		{
			print $fh $line;
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		# Reload the ssh daemon
		record($conf, "Restarting the SSH daemon.\n");
		$sc = "/etc/init.d/sshd restart";
		record($conf, "/----------\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	# Finally, write out 'known_hosts'.
	
	
	return(0);
}

sub setup_ssh_keys
{
	my ($conf, $node) = @_;
	
	record($conf, " - Setting up SSH keys for: [$node]\n");
	my $private_file_key = "local_rsa_private";
	my $public_file_key  = "local_rsa_public";
	my $private_data_key = "local_private_key";
	my $public_data_key  = "local_public_key";
	if ($node eq "local")
	{
		record($conf, "Configuring this node's SSH keys.\n");
	}
	else
	{
		record($conf, "Configuring remote node's SSH keys.\n");
		$private_file_key = "peer_rsa_private";
		$public_file_key  = "peer_rsa_public";
		$private_data_key = "peer_private_key";
		$public_data_key  = "peer_public_key";
	}
	if (-e $conf->{files}{$public_file_key})
	{
		record($conf, " - Found an existing key, not generating a new one.\n");
	}
	else
	{
		# Use the key from 'answers' if they exists. Otherwise, generate
		# a new key.
		if (($conf->{'system'}{ssh}{$private_file_key}) && ($conf->{'system'}{ssh}{$public_file_key}))
		{
			record($conf, "Creating SSH public and private key from values in memory\n");
			my $private_key = $conf->{'system'}{ssh}{$private_file_key};
			my $public_key  = $conf->{'system'}{ssh}{$public_file_key};
			
			# Write the public key
			record($conf, " - Writing the public key: [$conf->{files}{$public_file_key}]\n");
			my $sc = "$conf->{files}{$public_file_key}";
			my $fh = IO::Handle->new();
			open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			print $fh $public_key;
			$fh->close();
			record($conf, " - Done!\n");
			
			# Write the private key
			record($conf, " - Writing the private key: [$conf->{files}{$private_file_key}]\n");
			$sc = "$conf->{files}{$private_file_key}";
			$fh = IO::Handle->new();
			open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			print $fh $public_key;
			$fh->close();
			record($conf, " - Done!\n");
			
			# Set the permissions.
			record($conf, " - Setting permissions of key files\n");
			$sc = "chmod 600 $conf->{files}{$private_file_key} && chmod 644 $conf->{files}{$public_file_key}";
			$fh = IO::Handle->new();
			open ($fh, "$sc 2&>1 |") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, " - output: [$line]\n");
			}
			$fh->close();
			record($conf, " - Done!\n");
		}
		else
		{
			# Generating a new RSA key.
			record($conf, "Generating a new RSA key for the root user.\n");
	# 		#my $sc = "ssh-keygen -t rsa -N \"\" -b 4095 -f ~/.ssh/id_rsa";
			my $sc = "$conf->{commands}{'ssh-keygen'} $conf->{files}{$private_file_key}";
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			record($conf, "/----------\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "| $line\n");
			}
			$fh->close();
			record($conf, "\\----------\n");
			record($conf, " - Done.\n");
		}
		
		### TODO: Make the 'read_ssh_keys' selectable and then remove this.
		# Read in this node's public key for later addition to node 2's stage-1 script.
		record($conf, "Reading public key: [$conf->{files}{$public_file_key}].\n");
		my $sc = "$conf->{files}{$public_file_key}";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{'system'}{ssh}{$public_data_key} = "";
		while(<$fh>)
		{
			$conf->{'system'}{ssh}{$public_data_key} .= $_;
		}
		$fh->close();
		record($conf, " - Done.\n");

		record($conf, "Reading private key: [$conf->{files}{$private_file_key}].\n");
		$sc = "$conf->{files}{$private_file_key}";
		$fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		$conf->{'system'}{ssh}{$private_data_key} = "";
		while(<$fh>)
		{
			$conf->{'system'}{ssh}{$private_data_key} .= $_;
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	return(0);
}

sub collect_data
{
	my ($conf) = @_;
	
	# Get the current host name.
	#foreach my $var (sort {$a cmp $b} keys %ENV) { record($conf, "var: [$var] -> [$ENV{$var}]\n"); }
	$conf->{collected}{hostname} = $ENV{HOSTNAME};
	
	# Read the number of NICs.
	get_nic_details($conf);
	
	# Get storage data
	get_storage_details($conf);
	
	return(0);
}

# This collects the storage details.
sub get_storage_details
{
	my ($conf) = @_;
	
	# For now, I only care about the / backing device's free space as that
	# is what AN! uses. Later this should be make more intelligent.
	find_root_device($conf);
	storage_device_details($conf, $conf->{'system'}{root}{device});
	
	return(0);
}

# This takes a block device path and uses 'fdisk' to determine roughly how much
# free space there is left.
sub storage_device_details
{
	my ($conf, $device) = @_;

	my $total_size       = 0;	
	my $sector_size      = 0;
	my $last_used_sector = 0;

	my $fh = IO::Handle->new();
	my $sc = "/sbin/fdisk -luc $device";
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error was: $!\n");
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		#print "line: [$line]\n";
		if ($line =~ /Disk $device:.* (\d+) bytes/)
		{
			$total_size = $1;
		}
		elsif ($line =~ /Sector size \(logical\/physical\): (\d+) bytes \/ (\d+) bytes/)
		{
			$sector_size = $1;
		}
		elsif ($line =~ /^$device(\d+) .*?\d+\s+(\d+)\s+\d+\s/)
		{
			my $partition  = $1;
			my $this_last_sector = $2;
			   $last_used_sector = $this_last_sector if $this_last_sector > $last_used_sector;
			if ($partition == 4)
			{
				# TODO: Read in the existing partitions and 
				# make sure they're recorded in the answers
				# file.
				$conf->{'system'}{skip_disk} = 1;
				record($conf, "The disk has already been partitioned, skipping.\n");
				record($conf, " - If you want to reconfigure storage, use 'fdisk' or 'parted' to delete the\n");
				record($conf, "   logical and extended partitions.\n");
				return(1);
			}
			#record($conf, "This last sector on device: [$device] is: [$this_last_sector (".($this_last_sector * $sector_size).")], last sector value: [$last_used_sector (".($last_used_sector * $sector_size).")]. Read partition: [$partition]\n");
		}
	}
	$fh->close();

	$conf->{'system'}{root}{sector_size}         = $sector_size;
	$conf->{'system'}{root}{total_size}          = $total_size;
	$conf->{'system'}{root}{last_sector}         = $last_used_sector;
	$conf->{'system'}{root}{start_free_space}    = $last_used_sector * $sector_size;

	# parted uses base10, not base2.
	#$conf->{'system'}{root}{total_size_gb}       = $total_size / (1024 ** 3);
	$conf->{'system'}{root}{total_size_gb}       = $total_size / (10 ** 9);
	$conf->{'system'}{root}{total_size_gb}       = 0 if not $conf->{'system'}{root}{total_size_gb};
	#$conf->{'system'}{root}{start_free_space_gb} = $conf->{'system'}{root}{start_free_space} / (1024 ** 3);
	$conf->{'system'}{root}{start_free_space_gb} = $conf->{'system'}{root}{start_free_space} / (10 ** 9);
	$conf->{'system'}{root}{start_free_space_gb} = 0 if not $conf->{'system'}{root}{start_free_space_gb};
	
	# Round down the full size.
	$conf->{'system'}{root}{total_size_gb_rounded} =  $conf->{'system'}{root}{total_size_gb};
	$conf->{'system'}{root}{total_size_gb_rounded} =~ s/\..*+//;

	# Round up the free space.
	if ($conf->{'system'}{root}{start_free_space_gb} =~ /\./)
	{
		$conf->{'system'}{root}{start_free_space_gb_rounded} =  $conf->{'system'}{root}{start_free_space_gb};
		$conf->{'system'}{root}{start_free_space_gb_rounded} +=  1;
		$conf->{'system'}{root}{start_free_space_gb_rounded} =~ s/\..*+//;
	}
	else
	{
		$conf->{'system'}{root}{start_free_space_gb_rounded} = $conf->{'system'}{root}{start_free_space_gb};
	}

	$conf->{'system'}{root}{free_space_gb_rounded} = $conf->{'system'}{root}{total_size_gb_rounded} - $conf->{'system'}{root}{start_free_space_gb_rounded};

	record($conf, "Device: [$device] has: [$conf->{'system'}{root}{free_space_gb_rounded}] GB of free space.\n");
	record($conf, " - Sector size: [$conf->{'system'}{root}{sector_size}]\n");
	record($conf, " - Last Sector: [$conf->{'system'}{root}{last_sector}]\n");
	record($conf, " - Device size:          [$conf->{'system'}{root}{total_size_gb_rounded} GB]\n");
	record($conf, " - Free Space Starts at: [$conf->{'system'}{root}{start_free_space_gb_rounded} GB]\n");
	record($conf, " - Free Space:           [$conf->{'system'}{root}{free_space_gb_rounded} GB]\n");
	
	return(0);
}

# This uses 'df' to determine what the device name is behind the / partition.
sub find_root_device
{
	my ($conf) = @_;
	
	my $root_device = "";

	my $fh = IO::Handle->new();
	my $sc = "/bin/df -hP";
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "line: [$line]\n");
		if ($line =~ /^(.*?)\s.*\s\/$/)
		{
			$root_device =  $1;
			$root_device =~ s/\d+$//;
			#record($conf, "Found root device: [$root_device]\n");
			last;
		}
	}
	$fh->close();
	
	if (not $root_device)
	{
		nice_exit($conf, 1, "Failed to find the root device.\n");
	}
	$conf->{'system'}{root}{device} = $root_device;
	
	return($root_device);
}

sub get_nic_details
{
	my ($conf) = @_;
	
	my $this_nic;
	my $this_mac;
	my $sc = "ifconfig -a";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "line: [$line]\n");

		# New line == new device.
		if (($line eq "") or ($line =~ /^\s+$/))
		{
			$this_nic = "";
			$this_mac = "";
			#record($conf, "clear.\n");
		}

		# EL6-style stuff
		if ($line =~ /^(\S+)\s+.*?HWaddr (.*)/)
		{
			$this_nic = $1;
			$this_mac = $2;
			$this_mac =~ s/\s+$//;
			$conf->{nic}{$this_nic}{mac} = $this_mac;
			$conf->{nic}{count}++;
			#record($conf, "found nic: [$this_nic] -> MAC: [$conf->{nic}{$this_nic}{mac} ($this_mac)]\n");
		}
		elsif ($this_nic)
		{
			#record($conf, "parsing for NIC: [$this_nic]: [$line]\n");
			if ($line =~ /inet addr:(\d+\.\d+\.\d+\.\d+)/)
			{
				$conf->{nic}{$this_nic}{ip} = $1;
				#record($conf, " - IP: [$conf->{nic}{$this_nic}{ip}]\n");
			}
			if ($line =~ /Mask:(\d+\.\d+\.\d+\.\d+)/)
			{
				$conf->{nic}{$this_nic}{nm} = $1;
				#record($conf, " - NM: [$conf->{nic}{$this_nic}{nm}]\n");
			}
		}
	}
	$fh->close();
	
	return(0);
}

###############################################################################
# Sssh, there are private functions                                           #
###############################################################################

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			#record($conf, "answers key: [$key] is a hash reference.\n");
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			#record($conf, "answers recording: [$key]\n");
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}
