#!/usr/bin/perl
#
# TODO:
#  - Add support for updating sshd_config to not do DNS lookup.

use strict;
use warnings;
use IO::Handle;

$| = 1;

my $conf = {
	answers		=>	{
		customer_prefix	=>	"xx",
		customer_domain	=>	"example.com",
		cluster_id	=>	"01",
		node_id		=>	"01",
		bcn_ip		=>	"10.20.",
		bcn_netmask	=>	"255.255.0.0",
		sn_ip		=>	"10.10.",
		sn_netmask	=>	"255.255.0.0",
		ifn_ip		=>	"10.255.",
		ifn_netmask	=>	"255.255.0.0",
		ifn_gateway	=>	"10.255.255.254",
		ifn_dg		=>	"yes",
		ifn2_ip		=>	"10.254.",
		ifn2_netmask	=>	"255.255.0.0",
		ifn2_gateway	=>	"10.254.255.254",
		ifn2_dg		=>	"no",
		ipmi_ip		=>	"10.20.",
		ipmi_netmask	=>	"255.255.0.0",
		dns1		=>	"8.8.8.8",
		dns2		=>	"8.8.4.4",
		shared_storage	=>	"40",
		storage_pool_1	=>	"0",
		storage_pool_2	=>	"0",
		ntp_server	=>	"tick.redhat.com",
		configure_ups	=>	"yes",
		ups		=>	{
			ups1		=>	{
				name		=>	"",
				address		=>	"10.20.30.1",
				snmp_port	=>	161,
				snmp_vendor	=>	"APC_NOTRAP",
				community	=>	"private",
				nisport		=>	"6551",
				events		=>	"",
				polltime	=>	30,
			},
			ups2		=>	{
				name		=>	"",
				address		=>	"10.20.30.2",
				snmp_port	=>	161,
				snmp_vendor	=>	"APC_NOTRAP",
				community	=>	"private",
				nisport		=>	"6552",
				events		=>	"",
				polltime	=>	30,
			},
		},
	},
	groups		=>	{
		install		=>	[
			"development",
		],
	},
	apps		=>	{
		install		=>	[
			"acpid", 
			"cman",
			"ccs", 
			"corosync",
			"dmidecode", 
			"fence-agents", 
			"freeipmi",
			"freeipmi-bmc-watchdog",
			"freeipmi-ipmidetectd",
			"gcc", 
			"gd",
			"gfs2-utils",
			"gpm",
			"libvirt",
			"lvm2-cluster",
			"make",
			"man", 
			"mlocate",
			"ntp",
			"OpenIPMI",
			"OpenIPMI-libs",
			"openssh-clients", 
			"openssl-devel", 
			"perl-CGI", 
			"perl-CPAN", 
			"perl-Net-SSLeay", 
			"perl-YAML-Tiny", 
			"python-virtinst",
			"qemu-kvm",
			"qemu-kvm-tools",
			"ricci",
			"rgmanager",
			"rsync",
			"screen",
			"syslinux", 
			"telnet", 
			"vim-enhanced", 
			"virt-viewer",
			"wget",
			"yum-utils",
		],
		remove		=>	[
			"NetworkManager",
		],
		enable		=>	[
			"ipmi",
			"ntpd",
			"ricci",
			"modclusterd",
			"gpm",
		],
		disable		=>	[
			"acpid", 
			"clvmd",
			"cman",
			"drbd",
			"gfs2",
			"ip6tables",
			"iptables",
			"kdump",
			"NetworkManager",
			"rgmanager",
		],
		from_http	=>	{
			apcupsd		=>	"https://alteeve.ca/files/apcupsd/apcupsd-latest.el6.x86_64.rpm",
		},
		repos		=>	{
			elrepo		=>	{
				key		=>	"http://elrepo.org/RPM-GPG-KEY-elrepo.org",
				rpm		=>	"http://elrepo.org/elrepo-release-6-4.el6.elrepo.noarch.rpm",
				file		=>	"/etc/yum.repos.d/elrepo.repo",
				install		=>	["drbd83-utils", "kmod-drbd83"],
			},
		},
	},
	commands	=>	{
		'ssh-keygen'	=>	"ssh-keygen -t rsa -N \"\" -b 4095 -f ~/.ssh/id_rsa",
	},
	files		=>	{
		answers		=>	"anvil_setup.answers",
		install_log	=>	"anvil_setup.log",
	},
	nic		=>	{
		count		=>	0,
		ifn_count	=>	1,
	},
	'system'	=>	{
		reboot_required	=>	0,
		skip_network	=>	0,
		skip_ups	=>	0,
		skip_disk	=>	0,
	},
};

record($conf, "\n-=] Anvil! Configuration Tool\n\n");

### TODO: If this is a RHEL box, ask the user to authenticate before
###       proceeding.

record($conf, ">\n");
collect_data($conf);
record($conf, "<\n");
ask_questions($conf);
disable_selinux($conf);
setup_ssh($conf);
install_apps($conf);
setup_ntpd($conf);
disable_libvirt_bridge($conf);
install_acpupsd($conf);
modify_daemons($conf);
set_text_boot($conf);
set_password($conf);
write_out_scripts($conf);

my $say_cluster = "$conf->{answers}{customer_prefix}-cluster-$conf->{answers}{cluster_id}";
my $say_vg1     = "$conf->{answers}{customer_prefix}-c$conf->{answers}{node_id}n01_vg0";
my $say_vg2     = "$conf->{answers}{customer_prefix}-c$conf->{answers}{node_id}n02_vg0";
record($conf, "Initial configuration is complete!\n");
record($conf, "Manual tasks remaining;\n\n");
record($conf, " - Manually create the ~/.ssh/authorized_keys file.\n");
record($conf, " - Merge /etc/hosts and add foundation pack devices.\n");
record($conf, " - Create the DRBD partition(s)\n");
record($conf, " - Reboot and run the following commands;\n\n");
record($conf, "modprobe drbd\n");
record($conf, "drbdadm create-md r{0,1}\n");
record($conf, "drbdadm attach r{0,1}\n");
record($conf, "drbdadm connect r{0,1}\n");
record($conf, "On one node only:\n");
record($conf, "drbdadm -- --clear-bitmap new-current-uuid r{0,1}\n");
record($conf, "On both:\n");
record($conf, "drbdadm primary r{0,1}\n");
record($conf, "pvcreate /dev/drbd{0,1}\n");
record($conf, "vgcreate -c y $say_vg1 /dev/drbd0\n");
record($conf, "vgcreate -c y $say_vg2 /dev/drbd1\n");
record($conf, "lvcreate -L 40G -n shared $say_vg1\n");
record($conf, "mkfs.gfs2 -p lock_dlm -j 2 -t $say_cluster:shared /dev/$say_vg1/shared\n");
record($conf, "mkdir /shared\n");
record($conf, "mount /dev/$say_vg1/shared /shared\n");
record($conf, "echo `gfs2_tool sb /dev/$say_vg1/shared uuid | awk '/uuid =/ { print \$4; }' | sed -e \"s/\(.*\)/UUID=\\L\\1\\E \/shared\\t\\tgfs2\\tdefaults,noatime,nodiratime\\t0 0/\"` >> /etc/fstab\n");
record($conf, "/etc/init.d/gfs2 status\n");

###############################################################################
# Functions                                                                   #
###############################################################################

sub write_out_scripts
{
	my ($conf) = @_;
	
	# Write out node #2's stage #1 script.
	
	return(0);
}

# This handles any exit or die scenario.
sub nice_exit
{
	my ($conf, $exit_code, $message) = @_;
	$exit_code = 99 if not define $exit_code;
	$message   = "" if not defined $message;
	
	if ($message)
	{
		record($conf, $message);
	}
	exit($exit_code);
}

# This formats the current date and time.
sub get_current_date_time
{
	my ($conf) = @_;
	my $date_and_time = "";
	
	my %time          = ();
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{suffix}   = "";
	
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	my $date          = $time{year}."/".$time{pad_mon}."/".$time{pad_mday};
	my $time          = $time{pad_hour}.":".$time{pad_min}.":".$time{pad_sec};
	   $date_and_time = "$date $time";
	
	return ($date_and_time);
}

# This records messages to the log and prints them to the screen.
sub record
{
	my ($conf, $message) = @_;
	
	# If the log file isn't open yet, open it.
	my $log_fh;
	if (exists $conf->{'system'}{log_fh})
	{
		$log_fh = $conf->{'system'}{log_fh};
	}
	else
	{
		my $log_file = $conf->{files}{install_log};
		   $log_fh   = IO::Handle->new();
		# I can't use "nice_exit" here as a failure would trigger an
		# infinite loop.
		open ($log_fh, ">$log_file") or die "Failed to open the log file: [$log_file], the error was: $!\n";
		$conf->{'system'}{log_fh} = $log_fh;
		print $log_fh "-=] anvil_setup install log started on: [".get_current_date_time($conf)."]\n";
	}
	
	print $log_fh $message;
	print $message;
	
	return(0);
}

sub set_password
{
	my ($conf) = @_;
	
	record($conf, "Setting the password for the 'root' and 'ricci' users.\n");
	if (not $conf->{answers}{password})
	{
		record($conf, " - Skipping. No password specified!\n");
	}
	
	#echo $PASSWORD | passwd --stdin alteeve
	foreach my $user ("root", "ricci")
	{
		record($conf, " - Setting password for: [$user]\n");
		my $sc          = "echo $conf->{answers}{password} | passwd --stdin $user";
		my $fh          = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	record($conf, " - Done!\n");
	
	return(0);
}

sub install_acpupsd
{
	my ($conf) = @_;
	
	# Bail if the user has not asked to setup UPSes.
	return(0) if $conf->{'system'}{skip_ups};
	
	# TODO: Make the apcupsd install component optional.
	record($conf, "Installing and configuring the UPS monitoring application.\n");
	
	# Short names for easier code reading
	my $ups1 = $conf->{answers}{ups}{ups1}{name};
	my $ups2 = $conf->{answers}{ups}{ups2}{name};
	record($conf, "ups1: [$ups1], ups2: [$ups2]\n");
	
	# Install the apcupsd RPM if needed.
	record($conf, "Installing 'apcupsd':\n");
	if (-e "/etc/init.d/apcupsd")
	{
		record($conf, " - The 'apcupsd' program has already been installed.\n");
	}
	else
	{
		my $apcupsd_rpm = $conf->{apps}{from_http}{apcupsd};
		my $sc          = "rpm -Uvh $apcupsd_rpm";
		my $fh          = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		if (-e "/etc/init.d/apcupsd")
		{
			record($conf, " - Done.\n");
		}
		else
		{
			record($conf, " - Failed!\n");
			nice_exit($conf, 1, "I was unable to install: [apcupsd] from: [$apcupsd_rpm].\n");
		}
	}
	
	# Make the null script directory.
	record($conf, "Creating the 'null' scripts directory:\n");
	if (-e "/etc/apcupsd/null")
	{
		record($conf, " - The null script directory already exists.\n");
	}
	else
	{
		my $apcupsd_rpm = $conf->{apps}{from_http}{apcupsd};
		my $sc          = "rpm -Uvh $apcupsd_rpm";
		my $fh          = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		if (-e "/etc/init.d/apcupsd")
		{
			record($conf, " - Done.\n");
		}
		else
		{
			record($conf, " - Failed!\n");
			nice_exit($conf, 1, "I was unable to install: [apcupsd] from: [$apcupsd_rpm].\n");
		}
	}
	
	record($conf, "Configuring 'apcupsd' and modifying it to support two UPSes:\n");
	if (-e "/etc/apcupsd/apcupsd.conf.anvil")
	{
		record($conf, " - Backup of 'apcupsd.conf' already created.\n");
	}
	else
	{
		my $sc = "cp /etc/apcupsd/apcupsd.conf /etc/apcupsd/apcupsd.conf.anvil";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	
	record($conf, "Copying the default configuration to the '$ups1' configuration:\n");
	if (-e "/etc/apcupsd/apcupsd.${ups1}.conf")
	{
		record($conf, " - The 'apcupsd.${ups1}.conf' configuration file already created.\n");
	}
	else
	{
		my $sc = "cp /etc/apcupsd/apcupsd.conf /etc/apcupsd/apcupsd.${ups1}.conf";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	
	record($conf, "Copying the base '${ups1}' configuration to the '${ups2}' configuration:\n");
	if (-e "/etc/apcupsd/apcupsd.${ups2}.conf")
	{
		record($conf, " - The 'apcupsd.${ups2}.conf' configuration file already created.\n");
	}
	else
	{
		my $sc = "cp /etc/apcupsd/apcupsd.${ups1}.conf /etc/apcupsd/apcupsd.${ups2}.conf";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	
	record($conf, "Backing up the default 'apcupsd' init.d script:\n");
	if (-e "/etc/init.d/apcupsd.anvil")
	{
		record($conf, " - The '/etc/init.d/apcupsd.anvil' backup init.d script was already created.\n");
	}
	else
	{
		my $sc = "/etc/init.d/apcupsd /etc/init.d/apcupsd.anvil";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	
	record($conf, "Configuring UPS #1's confguration file:\n");
	foreach my $ups (sort {$a cmp $b} keys %{$conf->{ups}})
	{
		my $config_file   = "/etc/apcupsd/apcupsd.${ups}.conf";
		my $name          = $conf->{answers}{ups}{$ups}{name};
		my $address       = $conf->{answers}{ups}{$ups}{address};
		my $snmp_port     = $conf->{answers}{ups}{$ups}{snmp_port};
		my $snmp_vendor   = $conf->{answers}{ups}{$ups}{snmp_vendor};
		my $community     = $conf->{answers}{ups}{$ups}{community};
		my $polltime      = $conf->{answers}{ups}{$ups}{polltime};
		my $nisport       = $conf->{answers}{ups}{$ups}{nisport};
		my $events        = $conf->{answers}{ups}{$ups}{events};
		my $device_string = "${address}:${snmp_port}:${snmp_vendor}:${community}";
		record($conf, "config_file: [$config_file], name: [$name], device_string: [$device_string], polltime: [$polltime], nisport: [$nisport], events: [$events]\n");
		my @lines;
		
		my $sc = "$config_file";
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, " - $line\n");
			
			# Strip off the leading # from UPSNAME and then set the
			# name of the UPS. This is done in two steps to make
			# sure this works on re-runs of the script
			$line =~ s/^#UPSNAME/UPSNAME/;
			$line =~ s/^UPSNAME.*/UPSNAME $name/;
			
			# Set the UPS type to SNMP and set the connection 
			# details.
			$line =~ s/^UPSTYPE.*/UPSTYPE snmp/;
			$line =~ s/^DEVICE.*/DEVICE $device_string/;
			
			# Setup the poll time. Remove the leading # again.
			$line =~ s/^#POLLTIME/POLLTIME/;
			$line =~ s/^POLLTIME.*/POLLTIME $polltime/;
			
			# Set some static values
			$line =~ s/^BATTERYLEVEL.*/BATTERYLEVEL 5/;
			$line =~ s/^MINUTES.*/MINUTES 0/;
			$line =~ s/^SCRIPTDIR.*/SCRIPTDIR \/etc\/apcupsd\/null/;
			$line =~ s/^PWRFAILDIR.*/PWRFAILDIR \/etc\/apcupsd\/null/;
			$line =~ s/^NOLOGINDIR.*/NOLOGINDIR \/etc\/apcupsd\/null/;
			
			# Set the NIS port
			$line =~ s/^NISPORT.*/NISPORT $nisport/;
			
			# Set the event file
			$line =~ s/^EVENTSFILE.*/EVENTSFILE $events/;

			push @lines, "$line\n";
		}
		$fh->close();
		
		# Write the config file back out.
		$sc = "$config_file";
		$fh = IO::Handle->new();
		open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
		foreach my $line (@lines)
		{
			print $line;
		}
		$fh->close();
	}
	
	record($conf, "Downloading modified the 'apcupsd' init.d script:\n");
	if (-e "/etc/init.d/apcupsd")
	{
		record($conf, " - Removing the old 'apcupsd' init.d scipt.\n");
		unlink "/etc/init.d/apcupsd" or nice_exit($conf, 1, "Failed to remove: [/etc/init.d/apcupsd], error: $!\n");
	}
	if (not -e "/etc/init.d/apcupsd")
	{
		record($conf, " - Installing the modified 'apcupsd' init.d script.\n");
		my $sc = "wget https://alteeve.ca/files/apcupsd/apcupsd -O /etc/init.d/apcupsd && chmod 755 /etc/init.d/apcupsd";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		record($conf, " - Setting 'apcupsd' to start on boot.\n");
		$sc = "chkconfig apcupsd on";
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		record($conf, " - Starting the 'apcupsd' daemons.\n");
		$sc = "/etc/init.d/apcupsd start";
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	else
	{
		record($conf, "[ WARNING ] - Unable to remove the old '/etc/init.d/apcupsd' file!\n");
		record($conf, "[ WARNING ] - Aborting 'apcupsd' init.d configuration!\n");
	}
	
	return(0);
}

sub disable_selinux
{
	my ($conf) = @_;
	
	record($conf, "Disabling SELinux\n");
	if (-e "/etc/selinux/config.anvil")
	{
		record($conf, " - Already disabled, skipping.\n");
		return(0);
	}
	my $sc = "setenforce 0 && sed -i.anvil 's/SELINUX=.*/SELINUX=disabled/' /etc/selinux/config";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, " - $line\n");
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return (0);
}

sub disable_libvirt_bridge
{
	my ($conf) = @_;
	
	record($conf, "Disabling the libvirtd default bridge\n");
	
	# First see if the bridge is up
	my $up = 0;
	my $sc = "ifconfig -a";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^virbr\d+:/)
		{
			$up = 1;
			last;
		}
	}
	$fh->close();
	
	if ($up)
	{
		record($conf, " - The libvirtd bridge appears to be up, disabling it.\n");
		my $sc = "virsh net-destroy default && virsh net-autostart default --disable && virsh net-undefine default && /etc/init.d/iptables stop";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	else
	{
		record($conf, " - The libvirtd bridge appears to not be up, deleting it.\n");
		my $sc = "cat /dev/null >/etc/libvirt/qemu/networks/default.xml";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
	}
	
	record($conf, " - Done.\n");
	
	
	return(0);
}

sub set_text_boot
{
	my ($conf) = @_;
	
	record($conf, "Configuring the operating system for textual booting.\n");
	record($conf, "This can take a minute, please be patient.\n");
	my $sc = "plymouth-set-default-theme details -R";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, " - $line\n)"
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub modify_daemons
{
	my ($conf) = @_;
	
	# Disable daemons
	foreach my $daemon (sort {$a cmp $b} @{$conf->{apps}{disable}})
	{
		next if not $daemon;
		record($conf, "Disabling: [$daemon]");
		my $sc = "chkconfig $daemon off && /etc/init.d/$daemon stop";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	# Enable daemons
	foreach my $daemon (sort {$a cmp $b} @{$conf->{apps}{enable}})
	{
		next if not $daemon;
		record($conf, "Enabling: [$daemon]");
		my $sc = "chkconfig $daemon on && /etc/init.d/$daemon start";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	return(0);
}

sub setup_ntpd
{
	my ($conf) = @_;
	
	# If the NTP server IP is already in the file, skip.
	record($conf, "This next step will configure the network time server.\n");
	my $ntp_server = $conf->{answers}{ntp_server};
	my $done = 0;
	my $sc = "/etc/ntp.conf";
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /$ntp_server/)
		{
			$done = 1;
			last;
		}
	}
	$fh->close();
	
	if ($done)
	{
		record($conf, " - The NTP server: [$ntp_server] is already in: [/etc/ntpd.conf], skipping.\n");
		return (0);
	}
	
	$sc = "echo \"server $ntp_server\" >> /etc/ntp.conf && echo \"restrict $ntp_server mask 255.255.255.255 nomodify notrap noquery\" >> /etc/ntp.conf";
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "| $line\n");
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub install_apps
{
	my ($conf) = @_;
	
	# Read all currently installed packages.
	read_installed_groups($conf);
	read_installed_rpms($conf);
	
	#foreach my $app (sort {$a cmp $b} keys %{$conf->{installed_apps}}) { record ($conf, "App: [$app], arch: [$conf->{installed_apps}{$app}{arch}]\n"); }
	
	# First, install
	record($conf, "Looking for packages that need to be installed.\n");
	my $apps_install = "";
	foreach my $install_app (sort {$a cmp $b} @{$conf->{apps}{install}})
	{
		# Is the app already installed?
		next if not $install_app;
		#record($conf, "Checking if: [$install_app] is installed.\n");
		if (ref($conf->{installed_apps}{$install_app}) ne "HASH")
		{
			# No, add it.
			record($conf, " - Didn't find the application: [$install_app]\n");
			$apps_install .= "$install_app ";
		}
	}
	
	# Proceed with the install if any packages are not yet installed.
	if ($apps_install)
	{
		record($conf, "Installing missing applications.\n");
		my $sc = "yum -y install $apps_install";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		$apps_install = "";
	}
	else
	{
		record($conf, " - Nothing to install.\n");
	}
	
	# Now install groups if needed.
	record($conf, "Looking for package groups that need to be installed.\n");
	my $groups_install = "";
	foreach my $install_group (sort {$a cmp $b} @{$conf->{groups}{install}})
	{
		next if not $install_group;
		if (not exists $conf->{installed_groups}{$install_group})
		{
			# No, add it.
			record($conf, " - Didn't find the package group: [$install_group]\n");
			$groups_install .= "$install_group ";
		}
	}
	
	# Proceed with the group install if any groups are missing.
	if ($groups_install)
	{
		record($conf, "Installing missing application groups.\n");
		my $sc = "yum -y groupinstall $groups_install";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		$groups_install = "";
	}
	else
	{
		record($conf, " - Nothing to install.\n");
	}
	
	# Now add repos and install their packages.
	foreach my $repo (sort {$a cmp $b} keys %{$conf->{apps}{repos}})
	{
		my $key           = $conf->{apps}{repos}{$repo}{key};
		my $rpm           = $conf->{apps}{repos}{$repo}{rpm};
		my $install_array = $conf->{apps}{repos}{$repo}{install};
		my $file          = $conf->{apps}{repos}{$repo}{file};
		
		record($conf, "Installing the: [$repo] repository key.\n");
		if (-e $file)
		{
			record($conf, " - Already installed, skipping.\n");
			next;
		}
		my $sc = "rpm --import $key";
		record($conf, "Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, " - $line\n");
		}
		$fh->close();
		record($conf, " - Done.\n");
		
		record($conf, "Installing the: [$repo] repository RPM.\n");
		$sc = "rpm -Uvh $rpm";
		record($conf, "Calling: [$sc]\n");
		$fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	
		# First, install
		my $install = "";
		foreach my $install_app (sort {$a cmp $b} @{$install_array})
		{
			next if not $install_app;
			$install .= "$install_app ";
		}
		if ($install)
		{
			record($conf, "Installing the: [$repo] repository package(s).\n");
			my $sc = "yum -y install $install";
			record($conf, "Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			record($conf, "/----------\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "| $line\n");
			}
			$fh->close();
			record($conf, "\\----------\n");
			record($conf, " - Done.\n");
		}
	}
	
	# Update the OS
	record($conf, "Updating the operating system.\n");
	my $sc = "yum -y update";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	record($conf, "/----------\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "| $line\n");
		if ($line =~ /kernel/)
		{
			record ($conf, "| Reboot required for this update to take effect.\n");
			$conf->{'system'}{reboot_required} = 1;
		}
	}
	$fh->close();
	record($conf, "\\----------\n");
	record($conf, " - Done.\n");
	
	# Grab the DRBD fence agent.
	if (not -e "/sbin/rhcs_fence")
	{
		record($conf, "Installing the DRBD fence handler\n");
		my $sc = "wget -c https://raw.github.com/digimer/rhcs_fence/master/rhcs_fence -O /sbin/rhcs_fence && chmod 755 /sbin/rhcs_fence && ls -lah /sbin/rhcs_fence";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	### TODO: Update this to edit the default files. Create a downloadable
	###       version with substitution keys.
	# Grab the default DRBD config files
	if (not -e "/etc/drbd.d/global_common.conf.anvil")
	{
		record($conf, "Installing the DRBD initial config files.\n");
		my $sc = "mv /etc/drbd.d/global_common.conf /etc/drbd.d/global_common.conf.anvil && wget -c https://alteeve.ca/files/global_common.conf -O /etc/drbd.d/global_common.conf && wget -c https://alteeve.ca/files/r0.res -O /etc/drbd.d/r0.res";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	# Setup clustered LVM.
	if (not -e "/etc/lvm/lvm.conf.anvil")
	{
		record($conf, "Installing the clustered LVM configuration file.\n");
		my $sc = "mv /etc/lvm/lvm.conf /etc/lvm/lvm.conf.anvil && wget -c https://alteeve.ca/files/lvm.conf -O /etc/lvm/lvm.conf";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	return (0);
}

sub read_installed_rpms
{
	my ($conf) = @_;
	
	record($conf, "Checking which packages are already installed.\n");
	#my $sc = "yum list installed";
	my $sc = "rpm -qa";
	#record($conf, "sc: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "> line: [$line]\n");
# 		next if $line =~ /^\s/;
# 		record($conf, "< line: [$line]\n");
# 		if ($line =~ /^(.*?)\s/)
# 		{
# 			my $rpm  = $1;
# 			record($conf, "> rpm: [$rpm]\n");
# 			next if $rpm !~ /\./;
			my $app = "";
			my $arch = "";
			if ($line =~ /^(.*)\.(.*)/)
			{
				$app  = $1;
				$arch = $2;
			}
			else
			{
				$app  = $line;
				$arch = "noarch";
			}
			$app =~ s/-\d+\.\d+.*$//;
			$app =~ s/\.el6$//;
			#record($conf, "< app: [$app], arch: [$arch]\n");
			
			$conf->{installed_apps}{$app}{arch} = $arch;
# 		}
	}
	$fh->close();
	
	return (0);
}

sub read_installed_groups
{
	my ($conf) = @_;
	
	record($conf, "Checking which groups are already installed.\n");
	my $in_installed = 0;
	my $sc = "yum grouplist -v";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /Installed Groups/)
		{
			$in_installed = 1;
			next;
		}
		if ($in_installed)
		{
			if ($line =~ /Available Groups/)
			{
				$in_installed = 0;
				last;
			}
			elsif ($line =~ /\((.*?)\)/)
			{
				my $group  = $1;
				$conf->{installed_groups}{$group} = 1;
				#record($conf, "Found installed group: [$group]\n");
			}
		}
	}
	$fh->close();
	
	return (0);
}

sub read_answers
{
	my ($conf) = @_;
	
	return if not -e $conf->{files}{answers};
	
	my $sc = "$conf->{files}{answers}";
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "answers line: [$line]\n");
		next if not $line;
		next if $line !~ /=/;
		$line         =~ s/^\s+//;
		$line         =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		
		_make_hash_reference($conf, $var, $val);
	}
	$fh->close();
	
	return(0);
}

sub write_answers
{
	my ($conf, $hash_ref, $key, $fh, $i) = @_;
	$hash_ref = $conf->{answers} if not defined $hash_ref;
	$key      = "answers"        if not defined $key;
	$i        = 0 if not defined $i;
	
	my $sc = "$conf->{files}{answers}";
	if (not $fh)
	{
		$fh = IO::Handle->new();
		open ($fh, ">$sc") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
	}
	foreach my $var (sort {$a cmp $b} keys %{$hash_ref})
	{
		#print "i: [$i], var: [$var] is HASH? [".ref($hash_ref->{$var})."] ($hash_ref->{$var})\n";
		if (ref($hash_ref->{$var}) eq "HASH")
		{
			my $new_key = "${key}::${var}";
			$i++;
			write_answers($conf, $hash_ref->{$var}, $new_key, $fh, $i);
			$i--;
		}
		else
		{
			print $fh "${key}::${var} = $hash_ref->{$var}\n";
			#print "cache: ${key}::${var} = $hash_ref->{$var}\n";
		}
	}
	if ($i == 0)
	{
		$fh->close();
	}
	
	return(0);
}

sub ask_questions_customer
{
	my ($conf) = @_;
	
	record($conf, "\n-=] Customer and node questions:\n\n");
	
	record($conf, "What is the customer's two or three letter prefix?\n - [$conf->{answers}{customer_prefix}] ");
	my $customer_prefix = <STDIN>;
	chomp($customer_prefix);
	$conf->{answers}{customer_prefix} = $customer_prefix if $customer_prefix;
	write_answers($conf);
	
	record($conf, "What is the customer's domain?\n - [$conf->{answers}{customer_domain}] ");
	my $customer_domain = <STDIN>;
	chomp($customer_domain);
	$conf->{answers}{customer_domain} = $customer_domain if $customer_domain;
	write_answers($conf);
	
	record($conf, "What is the Anvil! sequence ID number?\n - [$conf->{answers}{cluster_id}] ");
	my $cluster_id = <STDIN>;
	chomp($cluster_id);
	if ($cluster_id)
	{
		$cluster_id = sprintf("%02d", $cluster_id);
	}
	$conf->{answers}{cluster_id} = $cluster_id if $cluster_id;
	write_answers($conf);
	
	record($conf, "What is the node's sequence ID number?\n - [$conf->{answers}{node_id}] ");
	my $node_id = <STDIN>;
	chomp($node_id);
	if ($node_id)
	{
		$node_id = sprintf("%02d", $node_id);
	}
	$conf->{answers}{node_id} = $node_id if $node_id;
	write_answers($conf);
	
	record($conf, "*WARNING* - The answer to the next question will be displayed on the screen!\n");
	record($conf, "What password shall I set for 'ricci' and 'root'?\n - [$conf->{answers}{password}] ");
	my $password = <STDIN>;
	chomp($password);
	if ($password)
	{
		$conf->{answers}{password} = $password;
	}
	else
	{
		$conf->{answers}{password} = "";
		record($conf, "No password specified. Will not set the root or user password.\n");
	}
	write_answers($conf);
	
	# Ask the user what time server they want to use.
	record($conf, "What time server do you want to use?\n - [$conf->{answers}{ntp_server}] ");
	my $ifn2_gateway = <STDIN>;
	chomp($ifn2_gateway);
	$conf->{answers}{ifn2_gateway} = $ifn2_gateway if $ifn2_gateway;
	write_answers($conf);
	
	return(0);
}

sub ask_questions_node_ips
{
	my ($conf) = @_;

	$conf->{'system'}{skip_network} = 1;
	return(0);
	
	record($conf, "\n-=] Node IP address questions:\n\n");
	
	# If 'vbr2' exists, ask the user if they want to skip the network
	# config.
	if (-e "/etc/sysconfig/network-scripts/ifcfg-vbr2")
	{
		record($conf, "It looks like the network has already been configured.\n");
		record($conf, " - Do you want to skip the network configuration? [y/N] ");
		my $configure = <STDIN>;
		chomp($configure);
		if ((lc($configure) eq "y") || (lc($configure) eq "yes"))
		{
			record($conf, " - Skipping network config.\n");
			$conf->{'system'}{skip_network} = 1;
		}
		write_answers($conf);
	}
	return (0) if $conf->{'system'}{skip_network};
	
	# Ask if the user wants to configure the network.
	record($conf, "Do you wish to configure networking? [Y/n] ");
	my $configure = <STDIN>;
	chomp($configure);
	if ((lc($configure) eq "n") || (lc($configure) eq "no"))
	{
		record($conf, " - Skipping network config.\n");
		$conf->{'system'}{skip_network} = 1;
	}
	write_answers($conf);
	return (0) if $conf->{'system'}{skip_network};
	
	# IP addresses. If the IPs is only two octals, use the cluster ID to
	# set the third octal.
	my $third_octal  =  $conf->{answers}{cluster_id};
	   $third_octal  =~ s/^0+//;
	   $third_octal  .= "0";
	my $fourth_octal =  $conf->{answers}{node_id};
	   $fourth_octal =~ s/^0+//;
	if ($conf->{answers}{bcn_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{bcn_ip} .= "${third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{ipmi_ip} =~ /^\d+\.\d+\.$/)
	{
		my $this_third_octal = $third_octal + 1;
		$conf->{answers}{ipmi_ip} .= "${this_third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{sn_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{sn_ip} .= "${third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{ifn_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{ifn_ip} .= "${third_octal}.${fourth_octal}";
	}
	if ($conf->{answers}{ifn2_ip} =~ /^\d+\.\d+\.$/)
	{
		$conf->{answers}{ifn2_ip} .= "${third_octal}.${fourth_octal}";
	}
	
	# Back-Channel Network
	record($conf, "What IP address would you like to use for the BCN?\n - [$conf->{answers}{bcn_ip}] ");
	my $bcn_ip = <STDIN>;
	chomp($bcn_ip);
	$conf->{answers}{bcn_ip} = $bcn_ip if $bcn_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the BCN?\n - [$conf->{answers}{bcn_netmask}] ");
	my $bcn_netmask = <STDIN>;
	chomp($bcn_netmask);
	$conf->{answers}{bcn_netmask} = $bcn_netmask if $bcn_netmask;
	write_answers($conf);
	
	# IPMI Interface
	record($conf, "What IP address would you like to use for the IPMI BMC?\n - [$conf->{answers}{ipmi_ip}] ");
	my $ipmi_ip = <STDIN>;
	chomp($ipmi_ip);
	$conf->{answers}{ipmi_ip} = $ipmi_ip if $ipmi_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the IPMI BMC?\n - [$conf->{answers}{ipmi_netmask}] ");
	my $ipmi_netmask = <STDIN>;
	chomp($ipmi_netmask);
	$conf->{answers}{ipmi_netmask} = $ipmi_netmask if $ipmi_netmask;
	write_answers($conf);
	
	# Storage Network
	record($conf, "What IP address would you like to use for the SN?\n - [$conf->{answers}{sn_ip}] ");
	my $sn_ip = <STDIN>;
	chomp($sn_ip);
	$conf->{answers}{sn_ip} = $sn_ip if $sn_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the SN?\n - [$conf->{answers}{sn_netmask}] ");
	my $sn_netmask = <STDIN>;
	chomp($sn_netmask);
	$conf->{answers}{sn_netmask} = $sn_netmask if $sn_netmask;
	write_answers($conf);
	
	### TODO: Add "first" to "IFN"
	# Internet-Facing Network
	record($conf, "What IP address would you like to use for the IFN?\n - [$conf->{answers}{ifn_ip}] ");
	my $ifn_ip = <STDIN>;
	chomp($ifn_ip);
	$conf->{answers}{ifn_ip} = $ifn_ip if $ifn_ip;
	write_answers($conf);
	
	record($conf, "What subnet mask would you like to use for the IFN?\n - [$conf->{answers}{ifn_netmask}] ");
	my $ifn_netmask = <STDIN>;
	chomp($ifn_netmask);
	$conf->{answers}{ifn_netmask} = $ifn_netmask if $ifn_netmask;
	write_answers($conf);
	
	record($conf, "What gateway would you like to use for the IFN?\n - [$conf->{answers}{ifn_gateway}] ");
	my $ifn_gateway = <STDIN>;
	chomp($ifn_gateway);
	$conf->{answers}{ifn_gateway} = $ifn_gateway if $ifn_gateway;
	write_answers($conf);
	
	record($conf, "Will the IFN be the default gateway?\n - [$conf->{answers}{ifn_dg}] ");
	my $ifn_dg = <STDIN>;
	chomp($ifn_dg);
	$conf->{answers}{ifn_dg} = $ifn_dg if $ifn_dg;
	write_answers($conf);
	
	record($conf, "What will be the first DNS server?\n - [$conf->{answers}{dns1}] ");
	my $dns1 = <STDIN>;
	chomp($dns1);
	$conf->{answers}{dns1} = $dns1 if $dns1;
	write_answers($conf);
	
	record($conf, "What will be the second DNS server?\n - [$conf->{answers}{dns2}] ");
	my $dns2 = <STDIN>;
	chomp($dns2);
	$conf->{answers}{dns2} = $dns2 if $dns2;
	write_answers($conf);
	
	### TODO: More sensibly support a second IFN.
	$conf->{'system'}{two_ifn} = 0;
	if ($conf->{'system'}{two_ifn})
	{
		# Internet-Facing Network B
		record($conf, "What IP address would you like to use for the second IFN?\n - [$conf->{answers}{ifn2_ip}] ");
		my $ifn2_ip = <STDIN>;
		chomp($ifn2_ip);
		$conf->{answers}{ifn2_ip} = $ifn2_ip if $ifn2_ip;
		write_answers($conf);
		
		record($conf, "What subnet mask would you like to use for the second IFN?\n - [$conf->{answers}{ifn2_netmask}] ");
		my $ifn2_netmask = <STDIN>;
		chomp($ifn2_netmask);
		$conf->{answers}{ifn2_netmask} = $ifn2_netmask if $ifn2_netmask;
		write_answers($conf);
		
		record($conf, "What gateway would you like to use for the second IFN?\n - [$conf->{answers}{ifn2_gateway}] ");
		my $ifn2_gateway = <STDIN>;
		chomp($ifn2_gateway);
		$conf->{answers}{ifn2_gateway} = $ifn2_gateway if $ifn2_gateway;
		write_answers($conf);
		
		record($conf, "Will the second IFN be the default gateway?\n - [$conf->{answers}{ifn2_dg}] ");
		my $ifn2_dg = <STDIN>;
		chomp($ifn2_dg);
		$conf->{answers}{ifn2_dg} = $ifn2_dg if $ifn2_dg;
		write_answers($conf);
	}
	
	return (0);
}

sub ask_questions_misc
{
	my ($conf) = @_;
	
	#record($conf, "\n-=] Miscellaneous node configuration questions:\n\n");
	
	return (0);
}

sub ask_questions_storage
{
	my ($conf) = @_;
	return (0) if $conf->{'system'}{skip_disk};
	
	record($conf, "\n-=] Storage related questions:\n\n");
	
	# TODO: Figure out why it's not using cached values.
	#record($conf, "cached; answers::shared_storage: [$conf->{answers}{shared_storage}], answers::storage_pool_1: [$conf->{answers}{storage_pool_1}], answers::storage_pool_2: [$conf->{answers}{storage_pool_2}]\n");
	### Storage questions.
	if (($conf->{answers}{node_id} eq "1") or ($conf->{answers}{node_id} eq "01"))
	{
		# Tell the user roughly how much free space is available.
		record($conf, "The root device: [$conf->{'system'}{root}{device}] has approximately: [$conf->{'system'}{root}{free_space_gb_rounded} GB] of free space.\n");
		if ($conf->{'system'}{root}{free_space_gb_rounded} > 50)
		{
			# Ask the user how much space they want to assign to /shared
			my $remaining_free_space = $conf->{'system'}{root}{free_space_gb_rounded};
			record($conf, "How much space would you like for the shared storage?\n - [$conf->{answers}{shared_storage}] / $remaining_free_space GB: ");
			my $shared_storage = <STDIN>;
			chomp($shared_storage);
			$conf->{answers}{shared_storage} = $shared_storage if $shared_storage;
			write_answers($conf);
			
			# Subtract the answer and then ask how much space to allocate 
			# to the first VM storage pool.
			$remaining_free_space            -= $conf->{answers}{shared_storage};
			if (not $conf->{answers}{storage_pool_1})
			{
				$conf->{answers}{storage_pool_1} =  $remaining_free_space / 2;
				$conf->{answers}{storage_pool_1} =~ s/\..*//;
			}
			record($conf, "How much space would you like for the servers that will run on node 01?\n - [$conf->{answers}{storage_pool_1}] / $remaining_free_space GB: ");
			my $storage_pool_1 = <STDIN>;
			chomp($storage_pool_1);
			$conf->{answers}{storage_pool_1} = $storage_pool_1 if $storage_pool_1;
			write_answers($conf);
			
			$remaining_free_space            -= $conf->{answers}{storage_pool_1};
			if ($remaining_free_space < 1)
			{
				$conf->{answers}{storage_pool_1} = 0;
				record($conf, "There is no space left for servers on node 02.\n\n");
			}
			else
			{
				$conf->{answers}{storage_pool_2} =  $remaining_free_space;
				$conf->{answers}{storage_pool_2} =~ s/\..*//;
				record($conf, "That leaves: [$conf->{answers}{storage_pool_2} GB] for servers that will run on node 02.\n\n");
			}
		}
		else
		{
			# Can't set it up ourselves...
			record($conf, "-------------------------------------------------------------------------------\n");
			record($conf, "Currently, this installer only supports hardware RAID without LVM. It would\n");
			record($conf, "appear that either their is not enough free space of '/dev/sda' or another\n");
			record($conf, "block device or storage manager is in use. Please configure storage manually\n");
			record($conf, "after this installer has completed.\n");
			record($conf, "-------------------------------------------------------------------------------\n");
		}
	}
	else
	{
		record($conf, "This is the second node in the Anvil!. Please copy the post-install script from\n");
		record($conf, "the first node and run it here in order to configure this node's storage to\n");
		record($conf, "match.\n");
	}
	
	return (0);
}

sub ask_questions_ups
{
	my ($conf) = @_;

	$conf->{'system'}{skip_ups} = 1;
	return(0);
	
	record($conf, "\n-=] UPS monitoring questions:\n\n");
	
	# APC UPS questions.
	record($conf, "Would you like to configure UPS monitoring now? [Y/n] ");
	my $config_ups = <STDIN>;
	#my $config_ups = "y";
	chomp($config_ups);
	if ((lc($config_ups) eq "n") or (lc($config_ups) eq "no"))
	{
		$conf->{'system'}{skip_ups} = 1;
		record($conf, " - Skipping APC UPS monitoring setup.\n");
	}
	else
	{
		foreach my $ups ("ups1", "ups2")
		{
			my $say_ups       =  $ups;
			my $ups_number    =  $ups;
			   $say_ups       =~ s/^ups/UPS #0/;
			   $ups_number    =~ s/^\D*/0/;
			#print "say_ups: [$say_ups], ups_number: [$ups_number]\n";
			$conf->{answers}{ups}{$ups}{name}    =  $conf->{answers}{customer_prefix}."-u".$ups_number;
			record($conf, "\nQuestions for $say_ups:\n");
			record($conf, " - UPS name: [$conf->{answers}{ups}{$ups}{name}] ");
			my $ups_name = <STDIN>;
			chomp($ups_name);
			$conf->{answers}{ups}{$ups}{name}   = $ups_name if $ups_name;
			$conf->{answers}{ups}{$ups}{events} = "/var/log/apcupsd.".$conf->{answers}{ups}{$ups}{name}.".events";
			write_answers($conf);
			
			# Setup defaults
			my $nis_port      =  $ups;
			my $last_ip_octal =  ($conf->{answers}{ups}{$ups}{name} =~ /^.*(\d+)$/)[0];
			   $nis_port      =~ s/^\D*/655/;
			   $last_ip_octal =~ s/^0//g;
			$conf->{answers}{ups}{$ups}{address} =~ s/\.\d+$/\.$last_ip_octal/;
			$conf->{answers}{ups}{$ups}{nisport} =  $nis_port;
			
			### TODO: Doesn't use .2
			record($conf, " - UPS IP address: [$conf->{answers}{ups}{$ups}{address}] ");
			my $ups_address = <STDIN>;
			chomp $ups_address;
			$conf->{answers}{ups}{$ups}{address} = $ups_address if $ups_address;
			write_answers($conf);
			
			record($conf, " - Check frequency (in seconds): [$conf->{answers}{ups}{$ups}{polltime}] ");
			my $polltime = <STDIN>;
			chomp $polltime;
			$conf->{answers}{ups}{$ups}{polltime} = $polltime if $polltime;
			write_answers($conf);
			
			record($conf, " - NIS TCP Port: [$conf->{answers}{ups}{$ups}{nisport}] ");
			my $nisport = <STDIN>;
			chomp $nisport;
			$conf->{answers}{ups}{$ups}{nisport} = $nisport if $nisport;
			write_answers($conf);
		}
	}
	
	return (0);
}

sub check_core_dependencies
{
	my ($conf) = @_;
	
	# Check for required networking tools.
	if (not -e "/usr/sbin/brctl")
	{
		# Install the bridge utilities now.
		record($conf, "The bridge utilities are not yet installed. This is needed before the network\n");
		record($conf, "can be configured. It will be installed before the network is reconfigured.\n");
	}
	
	# Check for parted so that we can configure the storage
	if (not -e "/sbin/parted")
	{
		# Install it
		record($conf, "The storage configuration tool 'parted' is not yet installed. It is needed in\n");
		record($conf, "order to prepare the node's replicated storage. It will be installed.\n");
	}
	
	return(0);
}

sub install_core_dependencies
{
	my ($conf) = @_;
	
	if ((not -e "/usr/sbin/brctl") && (not -e "/sbin/parted"))
	{
		record($conf, "Installing 'bridge-utils' and 'parted'.\n");
		my $sc = "yum -y install bridge-utils parted";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		sleep 1;
		my $fatal = 0;
		if (not -e "/usr/sbin/brctl")
		{
			$fatal = 1;
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
		}
		if (not -e "/sbin/parted")
		{
			$fatal = 1;
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
		}
		if ($fatal)
		{
			nice_exit($conf, 1, "[ ERROR ] - Configuration aborted.\n");
		}
	}
	elsif (not -e "/usr/sbin/brctl")
	{
		record($conf, "Installing 'bridge-utils'.\n");
		my $sc = "yum -y install bridge-utils";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		sleep 1;
		if (not -e "/usr/sbin/brctl")
		{
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
			nice_exit($conf, 1, "[ ERROR ] - Configuration aborted.\n");
		}
	}
	elsif (not -e "/sbin/parted")
	{
		record($conf, "Installing 'parted'.\n");
		my $sc = "yum -y install parted";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
		
		sleep 1;
		if (not -e "/sbin/parted")
		{
			record($conf, "[ ERROR ] - I was unable to install the 'bridge-utils' package!\n");
			record($conf, "[ ERROR ] - Without it, the network can not be configured.\n");
			record($conf, "[ ERROR ] - Do you have an internet connection?\n");
			record($conf, "[ ERROR ] - If this is a RHEL server, is this system registered with RHN?\n");
			nice_exit($conf, 1, "[ ERROR ] - Configuration aborted.\n");
		}
	}
	
	return(0);
}

sub ask_questions
{
	my ($conf) = @_;
	read_answers($conf);
	
	system("clear");
	record($conf, "\n##############################################################################\n");
	record($conf, "# NOTE: There is *no* sanity checking of answers yet.                        #\n");
	record($conf, "#       Please answer carefully.                                             #\n");
	record($conf, "##############################################################################\n");
	
	# TODO: Make each one of these it's own section that the user can
	#       independantly verify and, if needed, restart.
	ask_questions_customer($conf);
	ask_questions_storage($conf);	# This must follow the customer questions
	ask_questions_ups($conf);	# This must follow the customer questions
	ask_questions_node_ips($conf);	# This must follow the customer questions
	ask_questions_misc($conf);
	check_core_dependencies($conf);
	
	$conf->{answers}{hostname} = "$conf->{answers}{customer_prefix}-c".$conf->{answers}{cluster_id}."n".$conf->{answers}{node_id}.".".$conf->{answers}{customer_domain};;
	write_answers($conf);
	record($conf, "\nSummary;\n");
	record($conf, " - Customer prefix:   [$conf->{answers}{customer_prefix}]\n");
	record($conf, " - Customer domain:   [$conf->{answers}{customer_domain}]\n");
	record($conf, " - Anvil! ID:         [$conf->{answers}{cluster_id}]\n");
	record($conf, " - Node ID:           [$conf->{answers}{node_id}]\n");
	record($conf, " - Host Name:         [$conf->{answers}{hostname}]\n");
	if ($conf->{'system'}{skip_network})
	{
		record($conf, " - Network configuration skipped.\n");
	}
	else
	{
		record($conf, " - BCN Network:       [".sprintf("%-15s", $conf->{answers}{bcn_ip})." / $conf->{answers}{bcn_netmask}]\n");
		record($conf, " - IPMI Network:      [".sprintf("%-15s", $conf->{answers}{ipmi_ip})." / $conf->{answers}{ipmi_netmask}]\n");
		record($conf, " - SN Network:        [".sprintf("%-15s", $conf->{answers}{sn_ip})." / $conf->{answers}{sn_netmask}]\n");
		record($conf, " - IFN Network:       [".sprintf("%-15s", $conf->{answers}{ifn_ip})." / $conf->{answers}{ifn_netmask}]\n");
	}
	record($conf, " - /shared Storage:   [$conf->{answers}{shared_storage} GB]\n");
	record($conf, " - Storage Pool 01:   [$conf->{answers}{storage_pool_1} GB]\n");
	record($conf, " - Storage Pool 02:   [$conf->{answers}{storage_pool_2} GB]\n");
	if ($conf->{'system'}{skip_ups})
	{
		record($conf, " - UPS configuration skipped.\n");
	}
	else
	{
		record($conf, " - UPS #1\n");
		record($conf, "   - Name:            [$conf->{answers}{ups}{ups1}{name}]\n");
		record($conf, "   - Address:         [$conf->{answers}{ups}{ups1}{address}]\n");
		record($conf, "   - NIS TCP Port:    [$conf->{answers}{ups}{ups1}{nisport}]\n");
		record($conf, "   - Check frequency: [$conf->{answers}{ups}{ups1}{polltime}] seconds\n");
		record($conf, " - UPS #2\n");
		record($conf, "   - Name:            [$conf->{answers}{ups}{ups2}{name}]\n");
		record($conf, "   - Address:         [$conf->{answers}{ups}{ups2}{address}]\n");
		record($conf, "   - NIS TCP Port:    [$conf->{answers}{ups}{ups2}{nisport}]\n");
		record($conf, "   - Check frequency: [$conf->{answers}{ups}{ups2}{polltime}] seconds\n");
	}
	if ($conf->{'system'}{two_ifn})
	{
		record($conf, " - IFN B Network:   [$conf->{answers}{ifn2_ip} / $conf->{answers}{ifn2_netmask}]\n");
	}
	if (not -e "/usr/sbin/brctl")
	{
		record($conf, " - Bridge utilities will be installed.\n");
	}
	if (not -e "/sbin/parted")
	{
		# Install it
		record($conf, " - Partition manuipulation program will be installed.\n");
	}
	
	record($conf, "Proceed? [Y/n] ");
	my $proceed = <STDIN>;
	#my $proceed = "y";
	chomp($proceed);
	if ((lc($proceed) eq "n") or (lc($proceed) eq "no"))
	{
		record($conf, "Returning to questions.\n");
		ask_questions($conf);
		return(0);
	}
	else
	{
		record($conf, "Proceeding.\n\n");
	}
	
	set_hostname($conf);
	install_core_dependencies($conf);
	partition_disk($conf);
	configure_nics($conf);
	write_hosts($conf);
	
	record($conf, "The setup is complete!\n");
	if ($conf->{'system'}{reboot_required})
	{
		record ($conf, " - One or more changes require a reboot.\n");
		record ($conf, " - Please reboot your node as soon as possible.\n");
	}
	
	return(0);
}

# This takes the user's sizes and creates two partitions for later use by DRBD.
sub partition_disk
{
	my ($conf) = @_;
	
	if ($conf->{'system'}{skip_disk})
	{
		record($conf, "Skipping disk partitioning.\n");
		return(0);
	}
	
	# TODO: Make this not try to create the second resource if insufficient
	#       space was left for it.
	my $shared_space = $conf->{answers}{shared_storage};
	my $pool1_space  = $conf->{answers}{storage_pool_1};
	my $pool2_space  = $conf->{answers}{storage_pool_2};
	my $root_device  = $conf->{'system'}{root}{device};
	
	record($conf, "Partitioning: [$root_device]...\n");
	#record($conf, "shared_space: [$shared_space], pool1_space: [$pool1_space], pool2_space: [$pool2_space], root_device: [$root_device]\n");
	
	my $partition1_space = $shared_space + $pool1_space;
	my $partition2_space = $pool2_space;
	#record($conf, "partition1_space: [$partition1_space], partition2_space: [$partition2_space]\n");
	
	# Get the start and end size of the free space.
	$conf->{parted}{free_space_start}      = 0;
	$conf->{parted}{free_space_end}        = 0;
	$conf->{parted}{free_space_total}      = 0;
	if (1)
	{
		# -m == machine parsable, -s == script, don't prompt
		my $sc = "parted -a opt -m -s $root_device \"unit GB print free\"";
		#record($conf, "sc: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "line: [$line]\n");
			# Often there is a small amount of free space at the
			# start of the disk, so I let this loop and overright 
			# older values on purpose.
			if ($line =~ /1:(.*?):(.*?):(.*?):free;/)
			{
				my $start = $1;
				my $end   = $2;
				my $size  = $3;
				#record($conf, ">> start: [$start], end: [$end], size: [$size]\n");
				# The unit is always GB so I just strip the
				# letters off.
				($conf->{parted}{free_space_start}) = ($start =~ /^(\d+[\.\d]*)/);
				($conf->{parted}{free_space_end})    = ($end   =~ /^(\d+[\.\d]*)/);
				($conf->{parted}{free_space_total})  = ($size  =~ /^(\d+[\.\d]*)/);
				#record($conf, "parted::free_space_start:  [$conf->{parted}{free_space_start}]G\n");
				#record($conf, "parted::free_space_end:    [$conf->{parted}{free_space_end}]G\n");
				#record($conf, "parted::free_space_total:  [$conf->{parted}{free_space_total}]G\n");
			}
		}
		$fh->close();
	}
	
	# Create the extended and logical partitions.
	if (1)
	{
		my $extended_start = $conf->{parted}{free_space_start};
		my $extended_end   = $conf->{parted}{free_space_end};
		my $make_extended  = "parted -a opt -m -s $root_device \"mkpart extended ${extended_start}G ${extended_end}G\"";
		
		my $part1_start   = $conf->{parted}{free_space_start};
		my $part1_end     = $part1_start + $pool1_space + $shared_space;
		# Parted likes to round, so head it off at the past lest the
		# start of the second partition be ahead of the end of the
		# first partition.
		if ($part1_end =~ /\./)
		{
			#record($conf, "> part1_end: [$part1_end]\n");
			$part1_end = int($part1_end + 1);
			#record($conf, "< part1_end: [$part1_end]\n");
		}
		my $make_logical1 = "parted -a opt -m -s $root_device \"mkpart logical ${part1_start}G ${part1_end}G\"";
		
		my $part2_start = $part1_end;
		if ($part1_start =~ /\./)
		{
			# Round it up.
			$part1_start += 1;
			$part1_start =~ s/\..*//;
		}
		my $part2_end     = $conf->{parted}{free_space_end};
		my $make_logical2 = "parted -a opt -m -s $root_device \"mkpart logical ${part2_start}G ${part2_end}G\"";
		#record($conf, "Extended: [$make_extended]\n");
		#record($conf, "Logical1: [$make_logical1]\n");
		#record($conf, "Logical2: [$make_logical2]\n");
		
		record($conf, "Creating extended partition from: [${extended_start} GB] to: [${extended_end} GB]\n");
		record($conf, "Extended: [$make_extended]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$make_extended 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_extended], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "line: [$line]\n");
			if ($line =~ /reboot/)
			{
				record($conf, "Kernel could not read the new partition, a reboot will be required.\n");
				$conf->{'system'}{reboot_required} = 1;
			}
		}
		$fh->close();
		sleep 1;
		
		record($conf, "Creating storage pool 1 from: [${part1_start} GB] to: [${part1_end} GB]\n");
		record($conf, "Logical1: [$make_logical1]\n");
		$fh = IO::Handle->new();
		open ($fh, "$make_logical1 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_logical1], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "line: [$line]\n");
			if ((not $conf->{'system'}{reboot_required}) && ($line =~ /reboot/))
			{
				record($conf, "Kernel could not read the new partition, a reboot will be required.\n");
				$conf->{'system'}{reboot_required} = 1;
			}
		}
		$fh->close();
		sleep 1;
		
		record($conf, "Creating storage pool 2 from: [${part2_start} GB] to: [${part2_end} GB]\n");
		record($conf, "Logical2: [$make_logical2]\n");
		$fh = IO::Handle->new();
		open ($fh, "$make_logical2 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_logical1], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "line: [$line]\n");
			if ((not $conf->{'system'}{reboot_required}) && ($line =~ /reboot/))
			{
				record($conf, "Kernel could not read the new partition, a reboot will be required.\n");
				$conf->{'system'}{reboot_required} = 1;
			}
		}
		$fh->close();
		sleep 1;

# 		record($conf, "New partition layout;\n");
# 		$fh = IO::Handle->new();
# 		open ($fh, "parted -a opt $root_device \"print free\" 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$make_logical1], error: $!\n");
# 		while(<$fh>)
# 		{
# 			chomp;
# 			my $line = $_;
# 			record($conf, "line: [$line]\n");
# 		}
# 		$fh->close();
	}
	
	return($conf);
}

sub set_hostname
{
	my ($conf) = @_;
	
	# Write the file and then set the active hostname.
	record($conf, "Recording and setting the host name... ");
	my $file = "/etc/sysconfig/network";
	my $sc = $file;
	my $fh = IO::Handle->new();
	open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
	print $fh "NETWORKING=yes\n";
	print $fh "HOSTNAME=$conf->{answers}{hostname}\n";
	$fh->close();
	
	$sc = "hostname $conf->{answers}{hostname}";
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub write_hosts
{
	my ($conf) = @_;
	
	record($conf, "Writing the hosts file... ");
	if (not -e "/etc/hosts.an")
	{
		record($conf, " - Backing up the original /etc/hosts as /etc/hosts.an: \n");
		my $sc = "cp /etc/hosts /etc/hosts.an";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, ".");
		}
		$fh->close();
		record($conf, " Done.\n");
	}
	
	my $say_bcn_ip     = $conf->{answers}{bcn_ip};
	my $say_ipmi_ip    = $conf->{answers}{ipmi_ip};
	my $say_sn_ip      = $conf->{answers}{sn_ip};
	my $say_ifn_ip     = $conf->{answers}{ifn_ip};
	my $say_hostname   = $conf->{answers}{hostname};
	my $short_hostname = ($say_hostname =~ /^(.*?)\./)[0];
	
	my $file = "/etc/hosts";
	my $sc = $file;
	my $fh = IO::Handle->new();
	open ($fh, ">>$file") or nice_exit($conf, 1, "Failed to append: [$sc], error: $!\n");
	print $fh "\n";
	print $fh "# Cluster $conf->{answers}{cluster_id}, Node $conf->{answers}{node_id}\n";
	print $fh "$say_bcn_ip\t$short_hostname ${short_hostname}.bcn $say_hostname\n";
	print $fh "$say_ipmi_ip\t${short_hostname}.ipmi\n";
	print $fh "$say_sn_ip\t${short_hostname}.sn\n";
	print $fh "$say_ifn_ip\t${short_hostname}.ifn\n";
	
	print $fh "\n";
	print $fh "### Foundation pack\n";
	# TODO: Switches
	# TODO: PDUs
	
	if (not $conf->{'system'}{skip_ups})
	{
		foreach my $ups (sort {$a cmp $b} keys %{$conf->{answers}{ups}})
		{
			my $say_ip    = $conf->{answers}{ups}{$ups}{address};
			my $say_name  = $conf->{answers}{ups}{$ups}{name};
			my $full_name = $say_name.".".$conf->{answers}{customer_domain};
			print $fh "$say_ip\t$say_name $full_name\n";
		}
	}
	$fh->close();
	
	$sc = "hostname $say_hostname";
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(0);
}

sub configure_nics
{
	my ($conf) = @_;
	
	# Bail if the user has not asked to setup networking.
	return(0) if $conf->{'system'}{skip_network};
	
	record($conf, "\n-=] NIC configuration\n\n");
	if ($conf->{'system'}{skip_network})
	{
		record($conf, " - Skipped.\n");
		return(0);
	}
	if ($conf->{nic}{count} > 6)
	{
		$conf->{nic}{ifn_count} = 2;
	}
	if (0)
	{
		foreach my $nic (sort {$a cmp $b} keys %{$conf->{nic}})
		{
			# Skip entries that aren't actually NICs.
			#record($conf, "NIC: [$nic] (".ref($conf->{nic}{$nic}).")\n");
			next if ref($conf->{nic}{$nic}) ne "HASH";
			#record($conf, " - NIC: [$nic]\n");
			my $say_mac = uc($conf->{nic}{$nic}{mac});
			my $say_ip  = $conf->{nic}{$nic}{ip} ? $conf->{nic}{$nic}{ip} : "--";
			my $say_nm  = $conf->{nic}{$nic}{nm} ? $conf->{nic}{$nic}{nm} : "--";
			record($conf, " - nic: [$nic], MAC: [$say_mac], current IP: [$say_ip / $say_nm]\n");
		}
	}
	
	### TODO: If the file exists, ask if the user wants to re-run the
	###       network config. If so, pull down and remove the bonds and
	###       bridges.
	# Here I check for one of the bond files. If I don't see it, I assume
	# the configuration tool has not been run yet, so I will ask the user
	# to un/plug each NIC.
	if (not -e "/etc/sysconfig/network-scripts/ifcfg-bond0")
	{
		# First, re-write all of the network configuration files to
		# the initial format.
		record($conf, "I found: [$conf->{nic}{count}] NICs; IFN Count: [$conf->{nic}{ifn_count}].\n");
		if (backup_ifcfg_files($conf))
		{
			foreach my $nic (sort {$a cmp $b} keys %{$conf->{nic}})
			{
				next if ref($conf->{nic}{$nic}) ne "HASH";
				my $file = "/etc/sysconfig/network-scripts/ifcfg-$nic";
				record($conf, "Re-writing the config for: [$nic]... ");
				my $say_mac = uc($conf->{nic}{$nic}{mac});
				my $say_ip  = $conf->{nic}{$nic}{ip} ? $conf->{nic}{$nic}{ip} : "";
				my $proto = "none";
				if ($say_ip)
				{
					# configure for dhcp.
					$proto = "dhcp";
				}
				my $sc = $file;
				my $fh = IO::Handle->new();
				open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
				print $fh "# Temporary configuration written by the Anvil! configuration tool.\n";
				print $fh "# Original copy stored as: /root/network-scripts.anvil/ifcfg-$nic.\n";
				print $fh "HWADDR=\"$say_mac\"\n";
				print $fh "DEVICE=\"$nic\"\n";
				print $fh "NM_CONTROLLED=\"no\"\n";
				print $fh "ONBOOT=\"yes\"\n";
				print $fh "BOOTPROTO=\"$proto\"\n";
				$fh->close();
				record($conf, " - Done.\n");
			}
		
			# Now restart networking to ensure all NICs are currently up.
			restart_network($conf);
		}
		else
		{
			record($conf, "It looks like the original interface configuration files were backed up and rewritten already. Skipping.\n");
		}
		
		# Read the last line in the syslog file.
		my ($last_line) = read_syslog($conf, "");
		
		record($conf, "It appears that we have not reordered the NICs yet.\n");
		for (my $i = 0; $i < $conf->{nic}{count}; $i++)
		{
			my $current_nic    = "";
			my $desired_nic = "eth$i";
			my $done        = 0;
			record($conf, "Please unplug the interface you wish to make: [$desired_nic]\n");
			while (not $done)
			{
				sleep 1;
				my ($this_last_line) = read_syslog($conf, $last_line);
				#record($conf, "Does: old last line: [$last_line]\n");
				#record($conf, "and: new last line:  [$this_last_line] differ?\n");
				if ($this_last_line ne $last_line)
				{
					#record($conf, "New data, parsing: [".@{$conf->{syslog}{new_lines}}."] new lines.\n");
					# Parse the new lines looking for interface notes.
					foreach my $line (@{$conf->{syslog}{new_lines}})
					{
						#record($conf, "new line: [$line]\n");
						if ($line =~ /\s(\S+?) NIC Link is Down/)
						{
							$current_nic = $1;
							record($conf, " - That appears to be: [$current_nic]. I will move this to: [$desired_nic].\n");
							$conf->{map_nic}{$desired_nic} = $current_nic;
							$done = 1;
						}
					}
					$last_line = $this_last_line;
				}
			}
		}
		
		foreach my $desired_nic (sort {$a cmp $b} keys %{$conf->{map_nic}})
		{
			my $current_nic = $conf->{map_nic}{$desired_nic};
			my $desired_mac = uc($conf->{nic}{$current_nic}{mac});
			record($conf, "Moving interface with MAC: [$desired_mac] from: [$current_nic] to: [$desired_nic]\n");
			$conf->{new_nic}{$desired_nic} = $desired_mac;
		}
		
		# Shut down the network and delete udev file.
		record($conf, "\n##############################################################################\n");
		record($conf, "The next step will take down the network and (likely) change the IP address.\n");
		record($conf, "If you are running this via ssh, be sure to be running in 'screen'. Otherwise,\n");
		record($conf, "this program will die in the middle of modifying the network and likely leave\n");
		record($conf, "you with no remote access at all!\n");
		record($conf, "##############################################################################\n\n");
		record($conf, "Proceed? [y/N] ");
		my $proceed = <STDIN>;
		#my $proceed = "y";
		chomp($proceed);
		if ((lc($proceed) eq "y") or (lc($proceed) eq "yes"))
		{
			record($conf, "Proceeding... ");
			my $sc = "/etc/init.d/network stop && rm -f /etc/udev/rules.d/70-persistent-net.rules";
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
			while(<$fh>)
			{
				chomp;
				my $line = $_;
			}
			$fh->close();
			record($conf, " - Done.\n");
		}
		else
		{
			nice_exit($conf, 1, "Aborting. Please restart at your leisure and re-run this program.\n");
		}
		
		foreach my $nic (sort {$a cmp $b} keys %{$conf->{new_nic}})
		{
			my $file = "/etc/sysconfig/network-scripts/ifcfg-$nic";
			record($conf, "Re-writing the config for: [$nic]... ");
			my $say_mac = uc($conf->{new_nic}{$nic});
			my $say_ip  = $conf->{nic}{$nic}{ip} ? $conf->{nic}{$nic}{ip} : "";
			my $proto = "none";
			if ($say_ip)
			{
				# configure for dhcp.
				$proto = "dhcp";
			}
			my $comment = "";
			my $bond    = "";
			if ($conf->{nic}{ifn_count} == 1)
			{
				if ($nic eq "eth0")    { $bond = "bond0"; $comment = "Back-Channel Network - Link 1"; }
				elsif ($nic eq "eth1") { $bond = "bond1"; $comment = "Storage Network - Link 1"; }
				elsif ($nic eq "eth2") { $bond = "bond2"; $comment = "Internet-Facing Network - Link 1"; }
				elsif ($nic eq "eth3") { $bond = "bond0"; $comment = "Back-Channel Network - Link 2"; }
				elsif ($nic eq "eth4") { $bond = "bond1"; $comment = "Storage Network - Link 2"; }
				elsif ($nic eq "eth5") { $bond = "bond2"; $comment = "Internet-Facing Network - Link 2"; }
				else { nice_exit($conf, 1, "Unknown NIC: [$nic]\n"); }
			}
			elsif ($conf->{nic}{ifn_count} == 2)
			{
				if ($nic eq "eth0")    { $bond = "bond0"; $comment = "Back-Channel Network - Link 1"; }
				elsif ($nic eq "eth1") { $bond = "bond1"; $comment = "Storage Network - Link 1"; }
				elsif ($nic eq "eth2") { $bond = "bond2"; $comment = "Internet-Facing Network A - Link 1"; }
				elsif ($nic eq "eth3") { $bond = "bond3"; $comment = "Internet-Facing Network B - Link 1"; }
				elsif ($nic eq "eth4") { $bond = "bond0"; $comment = "Back-Channel Network - Link 2"; }
				elsif ($nic eq "eth5") { $bond = "bond1"; $comment = "Storage Network - Link 2"; }
				elsif ($nic eq "eth6") { $bond = "bond2"; $comment = "Internet-Facing Network A - Link 2"; }
				elsif ($nic eq "eth7") { $bond = "bond3"; $comment = "Internet-Facing Network B - Link 2"; }
				else { nice_exit($conf, 1, "Unknown NIC: [$nic]\n"); }
			}
			else
			{
				nice_exit($conf, 1, "Unknown number of IFNs: [$conf->{nic}{ifn_count}]\n");
			}
			my $sc = $file;
			my $fh = IO::Handle->new();
			open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			print $fh "# $comment\n";
			print $fh "HWADDR=\"$say_mac\"\n";
			print $fh "DEVICE=\"$nic\"\n";
			print $fh "NM_CONTROLLED=\"no\"\n";
			print $fh "ONBOOT=\"yes\"\n";
			print $fh "BOOTPROTO=\"$proto\"\n";
			print $fh "MASTER=\"$bond\"\n";
			print $fh "SLAVE=\"yes\"\n";
			$fh->close();
			record($conf, " - Done.\n");
		}
		
		if ($conf->{nic}{ifn_count} == 1)
		{
			# One bridge, three bonds.
			for (my $i = 0; $i < 3; $i++)
			{
				my $device = "bond".$i;
				my $file   = "/etc/sysconfig/network-scripts/ifcfg-$device";
				record($conf, "Writing the config for: [$device]... ");
				my $sc = $file;
				my $fh = IO::Handle->new();
				open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
				my $primary = "eth0";
				my $comment = "Back-Channel Network - Bond";
				my $bridge  = "";
				my $proto   = "static";
				my $ip      = $conf->{answers}{bcn_ip};
				my $nm      = $conf->{answers}{bcn_netmask};
				if ($i == 1) 
				{
					$primary = "eth1";
					$comment = "Storage Network - Bond";
					$ip      = $conf->{answers}{sn_ip};
					$nm      = $conf->{answers}{sn_netmask};
				}
				elsif ($i == 2)
				{
					$primary = "eth2";
					$comment = "Internet-Facing Network - Bond";
					$ip      = "";
					$nm      = "";
					$proto   = "none";
					$bridge  = "vbr2";
				}
				print $fh "# $comment\n";
				print $fh "DEVICE=\"$device\"\n";
				if ($bridge)
				{
					print $fh "BRIDGE=\"$bridge\"\n";
				}
				print $fh "BOOTPROTO=\"$proto\"\n";
				print $fh "NM_CONTROLLED=\"no\"\n";
				print $fh "ONBOOT=\"yes\"\n";
				print $fh "BONDING_OPTS=\"mode=1 miimon=100 use_carrier=1 updelay=120000 downdelay=0 primary=$primary\"\n";
				if (not $bridge)
				{
					print $fh "IPADDR=\"$ip\"\n";
					print $fh "NETMASK=\"$nm\"\n";
				}
				$fh->close();
				record($conf, " - Done.\n");
			}
			
			# Write the bridge.
			my $device = "vbr2";
			my $file   = "/etc/sysconfig/network-scripts/ifcfg-$device";
			record($conf, "Writing the config for: [$device]... ");
			my $sc = $file;
			my $fh = IO::Handle->new();
			open ($fh, ">$file") or nice_exit($conf, 1, "Failed to write: [$sc], error: $!\n");
			print $fh "# Internet-Facing Network - Bridge\n";
			print $fh "DEVICE=\"vbr2\"\n";
			print $fh "TYPE=\"Bridge\"\n";
			print $fh "BOOTPROTO=\"static\"\n";
			print $fh "IPADDR=\"$conf->{answers}{ifn_ip}\"\n";
			print $fh "NETMASK=\"$conf->{answers}{ifn_netmask}\"\n";
			print $fh "GATEWAY=\"$conf->{answers}{ifn_gateway}\"\n";
			print $fh "DNS1=\"$conf->{answers}{dns1}\"\n";
			print $fh "DNS2=\"$conf->{answers}{dns2}\"\n";
			print $fh "DEFROUTE=\"$conf->{answers}{ifn_dg}\"\n";
			$fh->close();
			record($conf, " - Done.\n");
		}
		elsif ($conf->{nic}{ifn_count} == 2)
		{
			# Two bridges, four bonds.
			record($conf, "Two IFNs not yet implemented...\n");
		}
		else
		{
			nice_exit($conf, 1, "Unknown number of IFNs: [$conf->{nic}{ifn_count}]\n");
		}
		
		# Rewrite udev and start the network.
		record($conf, "Note: You may safely ignore any errors like:\n");
		record($conf, " - \"bonding: cannot add bond bondX; already exists\"\n");
		my $sc = "start_udev && /etc/init.d/network start";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
		}
		$fh->close();
		record($conf, " - Done.\n");
	}
	
	record($conf, "The network should now be configured.\n");
	
	return(0);
}

sub read_syslog
{
	my ($conf, $previous_last_line) = @_;
	my $last_line = "";
	
	my $show_message = 1;
	my $record = 0;
	$conf->{syslog}{new_lines} = [];
	
	my $sc = "/var/log/messages";
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or nice_exit($conf, 1, "Failed to read: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "syslog line: [$line]\n");
		if (not $previous_last_line)
		{
			#record($conf, "No previous last syslog line. Keeping array empty.\n") if $show_message;
			$show_message = 0;
		}
		elsif ($line eq $previous_last_line)
		{
			#record($conf, "Found the last line: [$line], beginning recording.\n");
			$record = 1;
		}
		elsif ($record)
		{
			# I don't want to fill the entire array on first read
			# or else the interface detection code will fire on 
			# every entry.
			push @{$conf->{syslog}{new_lines}}, $line;
		}
		$last_line = $line;
	}
	$fh->close();
	
	#record($conf, "Last syslog line: [$last_line]\n");
	return($last_line);
}

sub restart_network
{
	my ($conf) = @_;
	
	record($conf, "Restarting the network. This may close ssh sessions. Proceed? [y/N] ");
	my $proceed = <STDIN>;
	#my $proceed = "y";
	chomp($proceed);
	if ((lc($proceed) eq "y") or (lc($proceed) eq "yes"))
	{
		record($conf, "Proceeding... ");
	}
	else
	{
		nice_exit($conf, 1, "Aborting. Please restart at your leisure and re-run this program.\n");
	}
	
	# Disable network manager
	my $sc = "chkconfig NetworkManager off && chkconfig network on && /etc/init.d/network restart";
	if (not -e "/etc/init.d/NetworkManager")
	{
		$sc = "chkconfig network on && /etc/init.d/network restart";
	}
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, ".");
	}
	$fh->close();
	sleep 5;	# Give the NICs time to come up
	record($conf, " - Done.\n");
	
	return(0);
}

sub backup_ifcfg_files
{
	my ($conf) = @_;
	
	my $backup_dir = "/root/network-scripts.anvil";
	if (-e "$backup_dir")
	{
		record($conf, "Backup already performed, skipping.\n");
		return(0);
	}
	else
	{
		mkdir "$backup_dir" or warn "Failed to create the directory: [$backup_dir]. The error was: $!\n";
	}
	
	record($conf, "Archiving the current interface configuration files in /root/network-scripts.anvil.\n");
	my $sc = "cp /etc/sysconfig/network-scripts/* /root/network-scripts.anvil";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, ".");
	}
	$fh->close();
	record($conf, " - Done.\n");
	
	return(1);
}

sub setup_ssh
{
	my ($conf) = @_;
	
	record($conf, "Configuring the SSH keys.\n");
	if (-e "/root/.ssh/id_rsa")
	{
		record($conf, " - Found an existing key, not generating a new one.\n");
	}
	else
	{
		# Generating a new RSA key.
		record($conf, "Generating a new RSA key for the root user.\n");
		my $sc = "ssh-keygen -t rsa -N \"\" -b 4095 -f ~/.ssh/id_rsa";
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
		record($conf, "/----------\n");
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "| $line\n");
		}
		$fh->close();
		record($conf, "\\----------\n");
		record($conf, " - Done.\n");
	}
	
	return(0);
}

sub collect_data
{
	my ($conf) = @_;
	
	# Get the current host name.
	#foreach my $var (sort {$a cmp $b} keys %ENV) { record($conf, "var: [$var] -> [$ENV{$var}]\n"); }
	$conf->{collected}{hostname} = $ENV{HOSTNAME};
	
	# Read the number of NICs.
	get_nic_details($conf);
	
	# Get storage data
	get_storage_details($conf);
	
	return(0);
}

# This collects the storage details.
sub get_storage_details
{
	my ($conf) = @_;
	
	# For now, I only care about the / backing device's free space as that
	# is what AN! uses. Later this should be make more intelligent.
	find_root_device($conf);
	storage_device_details($conf, $conf->{'system'}{root}{device});
	
	return(0);
}

# This takes a block device path and uses 'fdisk' to determine roughly how much
# free space there is left.
sub storage_device_details
{
	my ($conf, $device) = @_;

	my $total_size       = 0;	
	my $sector_size      = 0;
	my $last_used_sector = 0;

	my $fh = IO::Handle->new();
	my $sc = "/sbin/fdisk -luc $device";
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error was: $!\n");
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		#print "line: [$line]\n";
		if ($line =~ /Disk $device:.* (\d+) bytes/)
		{
			$total_size = $1;
		}
		elsif ($line =~ /Sector size \(logical\/physical\): (\d+) bytes \/ (\d+) bytes/)
		{
			$sector_size = $1;
		}
		elsif ($line =~ /^$device(\d+) .*?\d+\s+(\d+)\s+\d+\s/)
		{
			my $partition  = $1;
			my $this_last_sector = $2;
			   $last_used_sector = $this_last_sector if $this_last_sector > $last_used_sector;
			if ($partition == 4)
			{
				$conf->{'system'}{skip_disk} = 1;
				record($conf, "The disk has already been partitioned, skipping.\n");
				record($conf, " - If you want to reconfigure storage, use 'fdisk' or 'parted' to delete the logical and extended partitions.\n");
				return(1);
			}
			record($conf, "This last sector on device: [$device] is: [$this_last_sector (".($this_last_sector * $sector_size).")], last sector value: [$last_used_sector (".($last_used_sector * $sector_size).")]. Read partition: [$partition]\n");
		}
	}
	$fh->close();

	$conf->{'system'}{root}{sector_size}         = $sector_size;
	$conf->{'system'}{root}{total_size}          = $total_size;
	$conf->{'system'}{root}{last_sector}         = $last_used_sector;
	$conf->{'system'}{root}{start_free_space}    = $last_used_sector * $sector_size;

	# parted uses base10, not base2.
	#$conf->{'system'}{root}{total_size_gb}       = $total_size / (1024 ** 3);
	$conf->{'system'}{root}{total_size_gb}       = $total_size / (10 ** 9);
	$conf->{'system'}{root}{total_size_gb}       = 0 if not $conf->{'system'}{root}{total_size_gb};
	#$conf->{'system'}{root}{start_free_space_gb} = $conf->{'system'}{root}{start_free_space} / (1024 ** 3);
	$conf->{'system'}{root}{start_free_space_gb} = $conf->{'system'}{root}{start_free_space} / (10 ** 9);
	$conf->{'system'}{root}{start_free_space_gb} = 0 if not $conf->{'system'}{root}{start_free_space_gb};
	
	# Round down the full size.
	$conf->{'system'}{root}{total_size_gb_rounded} =  $conf->{'system'}{root}{total_size_gb};
	$conf->{'system'}{root}{total_size_gb_rounded} =~ s/\..*+//;

	# Round up the free space.
	if ($conf->{'system'}{root}{start_free_space_gb} =~ /\./)
	{
		$conf->{'system'}{root}{start_free_space_gb_rounded} =  $conf->{'system'}{root}{start_free_space_gb};
		$conf->{'system'}{root}{start_free_space_gb_rounded} +=  1;
		$conf->{'system'}{root}{start_free_space_gb_rounded} =~ s/\..*+//;
	}
	else
	{
		$conf->{'system'}{root}{start_free_space_gb_rounded} = $conf->{'system'}{root}{start_free_space_gb};
	}

	$conf->{'system'}{root}{free_space_gb_rounded} = $conf->{'system'}{root}{total_size_gb_rounded} - $conf->{'system'}{root}{start_free_space_gb_rounded};

	record($conf, "Device: [$device] has: [$conf->{'system'}{root}{free_space_gb_rounded}] GB of free space.\n");
	record($conf, " - Sector size: [$conf->{'system'}{root}{sector_size}]\n");
	record($conf, " - Last Sector: [$conf->{'system'}{root}{last_sector}]\n");
	record($conf, " - Device size:          [$conf->{'system'}{root}{total_size_gb_rounded} GB]\n");
	record($conf, " - Free Space Starts at: [$conf->{'system'}{root}{start_free_space_gb_rounded} GB]\n");
	record($conf, " - Free Space:           [$conf->{'system'}{root}{free_space_gb_rounded} GB]\n");
	
	return(0);
}

# This uses 'df' to determine what the device name is behind the / partition.
sub find_root_device
{
	my ($conf) = @_;
	
	my $root_device = "";

	my $fh = IO::Handle->new();
	my $sc = "/bin/df -hP";
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "line: [$line]\n");
		if ($line =~ /^(.*?)\s.*\s\/$/)
		{
			$root_device =  $1;
			$root_device =~ s/\d+$//;
			#record($conf, "Found root device: [$root_device]\n");
			last;
		}
	}
	$fh->close();
	
	if (not $root_device)
	{
		nice_exit($conf, 1, "Failed to find the root device.\n");
	}
	$conf->{'system'}{root}{device} = $root_device;
	
	return($root_device);
}

sub get_nic_details
{
	my ($conf) = @_;
	
	my $this_nic;
	my $this_mac;
	my $sc = "ifconfig -a";
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or nice_exit($conf, 1, "Failed to call: [$sc], error: $!\n");
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		#record($conf, "line: [$line]\n");

		# New line == new device.
		if (($line eq "") or ($line =~ /^\s+$/))
		{
			$this_nic = "";
			$this_mac = "";
			#record($conf, "clear.\n");
		}

		# EL6-style stuff
		if ($line =~ /^(\S+)\s+.*?HWaddr (.*)/)
		{
			$this_nic = $1;
			$this_mac = $2;
			$this_mac =~ s/\s+$//;
			$conf->{nic}{$this_nic}{mac} = $this_mac;
			$conf->{nic}{count}++;
			#record($conf, "found nic: [$this_nic] -> MAC: [$conf->{nic}{$this_nic}{mac} ($this_mac)]\n");
		}
		elsif ($this_nic)
		{
			#record($conf, "parsing for NIC: [$this_nic]: [$line]\n");
			if ($line =~ /inet addr:(\d+\.\d+\.\d+\.\d+)/)
			{
				$conf->{nic}{$this_nic}{ip} = $1;
				#record($conf, " - IP: [$conf->{nic}{$this_nic}{ip}]\n");
			}
			if ($line =~ /Mask:(\d+\.\d+\.\d+\.\d+)/)
			{
				$conf->{nic}{$this_nic}{nm} = $1;
				#record($conf, " - NM: [$conf->{nic}{$this_nic}{nm}]\n");
			}
		}
	}
	$fh->close();
	
	return(0);
}

###############################################################################
# Sssh, there are private functions                                           #
###############################################################################

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			#record($conf, "answers key: [$key] is a hash reference.\n");
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			#record($conf, "answers recording: [$key]\n");
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}
