#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - The referenced network interface seen when the user unplugged a network
#      cable did not (properly) record that interfaces MAC address.
# 2  - The referenced network interface seen when the user unplugged a network
#      cable did not (properly) record that interfaces current device name.
# 3  - 
# 4  - Insufficient number of network interfaces found. This program requires
#      two interfaces to run. Wireless interfaces are not supported.
# 5  - The '$conf->{path}{backups}' value is not set.
# 6  - The '$conf->{path}{backups}' backup directory failed to be created. The
#      failure warning should be displayed immediately prior to this error.
# 7  - backup_file() was called without a specified file to backup.
# 8  - Failed to find the '$conf->{path}{network_configs}' directory. I hope
#      for the user's sake that this is a program problem...
# 9  - There was one or more problems while sanity checking the command line
#      options. The problems will be displayed prior to the exit.
# 10 - No switches passed.
# 11 - Failed to bring up a network interface and network configuration was
#      requested.
# 12 - Failed to install all required packages.
# 13 - OS isn't RHEL based.
# 14 - OS isn't EL6.x
# 15 - Unable to get the apache user's UID.
# 16 - Unable to get the apache user's GID.
# 17 - Installer didn't run as 'root'.
# 
# TODO: Create an init script that deletes anything in the media directory on
#       boot. Can't use /tmp as it's usually too small.

my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

use strict;
use warnings;

# No capes!^H^H^H^Hbuffers!
$| = 1;

my $conf = {
	directories	=>	{
		media		=>	"/var/www/home/media",
	},
	executable	=>	{
		cp		=>	"/bin/cp",
		git		=>	"/usr/bin/git",
		htpasswd	=>	"/usr/bin/htpasswd",
		ifup		=>	"/sbin/ifup",
		ip		=>	"/sbin/ip",
		sed		=>	"/bin/sed",
		su		=>	"/bin/su",
		yum		=>	"/usr/bin/yum",
	},
	packages	=>	{
		# These get set to '1' when their found to be installed.
		to_install	=>	{
			ccs				=>	0, 
			'perl-YAML-Tiny'		=>	0, 
			'cyrus-sasl'			=>	0, 
			'cyrus-sasl-plain'		=>	0, 
			expect				=>	0, 
			'fence-agents'			=>	0, 
			guacd				=>	0, 
			httpd				=>	0, 
			libcdio				=>	0, 
			'libguac-client-rdp'		=>	0,
			'libguac-client-ssh'		=>	0, 
			'libguac-client-vnc'		=>	0, 
			man				=>	0, 
			mlocate				=>	0, 
			mod_ssl				=>	0, 
			'perl-CGI'			=>	0, 
			'perl-CPAN'			=>	0, 
			'perl-Net-SSLeay'		=>	0, 
			'perl-TermReadKey'		=>	0,
			'perl-Test-Simple'		=>	0, 
			'policycoreutils-python'	=>	0, 
			postfix				=>	0, 
			screen				=>	0, 
			syslinux			=>	0, 
			'openssl-devel'			=>	0, 
			tomcat6				=>	0, 
			'vim-common'			=>	0, 
			wget				=>	0, 
		},
		# This is populated by 'get_list_of_installed_packages()' and
		# uses the found package name as the key and sets the value to
		# '1'.
		installed	=>	{},
	},
	path		=>	{
		an_repo		=>	"/etc/yum.repos.d/an.repo",
		apache_config	=>	"/etc/httpd/conf/httpd.conf",
		apache_dir	=>	"/etc/httpd",
		apache_home	=>	"/var/www/home",
		apache_htpasswd	=>	"/var/www/home/htpasswd",
		apache_subdirs	=>	["archive", "cacahe", "media", "status"],
		backups		=>	"/root/anvil",
		network_configs	=>	"/etc/sysconfig/network-scripts",
		os_release	=>	"/etc/redhat-release",
		persistent_net	=>	"/etc/udev/rules.d/70-persistent-net.rules",
	},
	sys		=>	{
		apache_group	=>	"apache",
		apache_user	=>	"apache",
		customer	=>	"Striker Dashboard",
		mail_server	=>	"mail.alteeve.ca:587",
		skip_hostname	=>	0,
		skip_mail	=>	0,
		skip_network	=>	0,
		stable_version	=>	"1.1.4",
		striker_user	=>	"admin",
		striker_pass	=>	"",		# no default password, evar!
		switch_count	=>	0,
		apache_timeout	=>	"60000",	# This will go away with AJAX
	},
	url		=>	{
		auth_noauth	=>	"https://alteeve.ca/files/guacamole-auth-noauth-0.9.2.jar",
		guacamole_war	=>	"https://alteeve.ca/files/guacamole-0.9.2.war",
		striker		=>	"https://github.com/digimer/an-cdb/archive/v#!conf!version!#.tar.gz"
	},
	nics		=>	["bcn-link1", "ifn-link1"],
	network		=>	{
		bcn		=>	{
			ip		=>	"",
			netmask		=>	"",
		},
		ifn		=>	{
			ip		=>	"",
			netmask		=>	"",
			gateway		=>	"",
			dns1		=>	"8.8.8.8",
			dns2		=>	"8.8.4.4",
		},
	},
};

system('clear');
# Credit to Martin Allchin for this ASCII art!
print q`
 ##############################################################################
 #   ___ _       _ _                                    The Anvil! Dashboard  #
 #  / __| |_ _ _(_) |_____ _ _                                 -=] Installer  #
 #  \__ \  _| '_| | / / -_) '_|                                               #
 #  |___/\__|_| |_|_\_\___|_|                                                 #
 #                                               https://alteeve.ca/w/Striker #
 ##############################################################################

`;

# Make sure we're running as 'root'
# $< == real UID, $> == effective UID
if (($< != 0) && ($> != 0))
{
	print "[ Error ] - I am sorry, but this program must be run as the root user.\n\n";
	exit(17);
}

# Make sure we got what we needed from the command line.
get_switches($conf);
if (not $conf->{sys}{switch_count})
{
	print_usage($conf);
	exit(10);
}

if (sanity_check_switches($conf))
{
	exit(9);
}

# Make sure we're on EL6.x
verify_os($conf);

# Go into the loop that asks the user to unplug cables until they are happy 
# with their selection. When it exits, we go to work.
if (not $conf->{sys}{skip_network})
{
	# Make backups, of course.
	backup_original_files($conf);
	
	# Make sure all NICs are up. If any aren't, start them.
	start_all_nics($conf);
	
	until(select_nics($conf))
	{
		sleep 1;
	}
	
	# If we're here, the user has OK'ed the changes.
	reconfigure_network($conf);
}

# Now configure the Striker dashboard.
setup_striker($conf);

# If the user reconfigured the network, tell them they will need to reboot.
if (not $conf->{sys}{skip_network})
{
	print "\n[ Warning ] - You may need to reboot the network if the network interfances\n";
	print "[ Warning ] - were renamed. Simply restarting the network will likely not\n";
	print "[ Warning ] - work.\n\n";
}
print "Installation of Striker is complete!\n";
print "(just kidding, this installer isn't done yet.)\n\n";
exit(0);


###############################################################################
# Here be function!                                                           #
###############################################################################

# This handles the rest of the install (everything except the network).
sub setup_striker
{
	my ($conf) = @_;
	
	print "Beginning configuration and installation processes now.\n\n";
	sleep 2;
	
	# First up, install RPMs to make sure we've got everything we need.
	install_packages($conf);
	
	# Configure apache.
	configure_apache($conf);
	
	return(0);
}

# This handles configuring apache.
sub configure_apache
{
	my ($conf) = @_;
	
	print "Configuring Apache.\n";
	
	# Start by backing things up.
	if (-e "$conf->{path}{backups}/httpd")
	{
		print "- Backup already made, skipping.\n";
	}
	else
	{
		print "- Backing up original files.\n";
		backup_file($conf, $conf->{path}{apache_dir});
	}
	
	# Create the apache user's home directory and sub-directories.
	create_apache_home_directories($conf);
	
	# Create the htpasswd file.
	create_apache_htpasswd($conf);
	
	# Now to start updating.
	print "- Reading in the existing config file and adjusting as needed.\n";
	my $apache_config = "";
	open (my $file_handle, "<", $conf->{path}{apache_config}) or die "Failed to read: [$conf->{path}{apache_config}], the error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		
		# Skip lines from previous htpasswd configs.
		next if $line =~ /^\s+# Password login/;
		next if $line =~ /^\s+AuthType /;
		next if $line =~ /^\s+AuthName /;
		next if $line =~ /^\s+AuthUserFile /;
		next if $line =~ /^\s+Require user /;
		
		### TODO: Set SSL as default and add an option for a user to
		###       load their own certs.
		# Now insert and/or modify things.
		if ($line =~ /<Directory "\/var\/www\/cgi-bin/)
		{
			# Now insert our new authentication lines
			$apache_config .= "$line\n";
			$apache_config .= "    # Password login\n";
			$apache_config .= "    AuthType Basic\n";
			$apache_config .= "    AuthName \"Striker - $conf->{sys}{customer}\"\n";
			$apache_config .= "    AuthUserFile $conf->{path}{apache_htpasswd}\n";
			$apache_config .= "    Require user $conf->{sys}{striker_user}\n";
		}
		elsif ($line =~ /#<\/Proxy>/)
		{
			$apache_config .= "$line\n";
			$apache_config .= "<Location /guacamole/>\n";
			$apache_config .= "    Order allow,deny\n";
			$apache_config .= "    Allow from all\n";
			$apache_config .= "    ProxyPass http://localhost:8080/guacamole/ max=20 flushpackets=on\n";
			$apache_config .= "    ProxyPassReverse http://localhost:8080/guacamole/\n";
			$apache_config .= "</Location>\n";
			$apache_config .= "SetEnvIf Request_URI \"^/guacamole/tunnel\" dontlog\n";
			$apache_config .= "CustomLog /var/log/httpd/guac.log common env=!dontlog\n";
		}
		elsif ($line =~ /^Timeout /)
		{
			$apache_config .= "Timeout $conf->{sys}{apache_timeout}\n";
		}
		else
		{
			$apache_config .= "$line\n";
		}
	}
	close $file_handle;
	
	# Now write it out.
	print "- Done. Writing out the new version.\n";
	open ($file_handle, ">", $conf->{path}{apache_config}) or die "Failed to write: [$conf->{path}{apache_config}], the error was: $!\n";
	print $file_handle $apache_config;
	close $file_handle;
	print "- Done.\n\n";
	
	return(0);
}

# Create the htpasswd file.
sub create_apache_htpasswd
{
	my ($conf) = @_;
	
	print "Setting up Striker's authentication via Apache's htpasswd...\n";
	if (-e $conf->{path}{apache_htpasswd})
	{
		print "- Old: [$conf->{path}{apache_htpasswd}] found, deleting it.\n";
		unlink $conf->{path}{apache_htpasswd} or die "Failed to delete: [$conf->{path}{apache_htpasswd}], error was: $!\n";
	}
	
	print "- Generating: [$conf->{sys}{striker_user}]'s: [$conf->{path}{apache_htpasswd}] password file.\n";
	my $shell_call = "$conf->{executable}{su} apache -c \"$conf->{executable}{htpasswd} -cdb $conf->{path}{apache_htpasswd} $conf->{sys}{striker_user} '$conf->{sys}{striker_pass}'\"";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	print "- Done.\n\n";
	
	return(0);
}

# This creates the apache home directories and sets their permissions.
sub create_apache_home_directories
{
	my ($conf) = @_;
	
	print "- Creating the apache home directories.\n";
	my @dirs;
	push @dirs, $conf->{path}{apache_home};
	if (not -e $conf->{path}{apache_home})
	{
		print "  Creating: [$conf->{path}{apache_home}].\n";
		mkdir $conf->{path}{apache_home} or die "Failed to create the directory: [$conf->{path}{apache_home}], the error was: $!\n";
	}
	else
	{
		print "  Home already exists: [$conf->{path}{apache_home}].\n";
	}
	foreach my $directory (@{$conf->{path}{apache_subdirs}})
	{
		my $full_path = "$conf->{path}{apache_home}/$directory";
		push @dirs, $full_path;
		if (not -e $full_path)
		{
			print "  Creating: [$full_path].\n";
			mkdir $full_path or die "Failed to create the directory: [$full_path], the error was: $!\n";
		}
		else
		{
			print "  Already exists: [$full_path].\n";
		}
	}
	
	print "- Setting ownership to: [$conf->{sys}{apache_user}:$conf->{sys}{apache_group}].\n";
	my $apache_uid = getpwnam($conf->{sys}{apache_user}); 
	my $apache_gid = getgrnam($conf->{sys}{apache_group});
	my $dir_mode   = 0775;
	if (not $apache_uid)
	{
		print "[ Error ] - Unable to get the User ID for the apache user: [$conf->{sys}{apache_user}]\n";
		print "[ Error ] - Did apache actually install properly?\n";
		exit(15);
	}
	if (not $apache_gid)
	{
		print "[ Error ] - Unable to get the Group ID for the apache group: [$conf->{sys}{apache_group}]\n";
		print "[ Error ] - Did apache actually install properly?\n";
		exit(16);
	}
	chown $apache_uid, $apache_gid, @dirs;
	print "- Setting mode to: [".sprintf("%04o", $dir_mode)."].\n";
	chmod $dir_mode, @dirs;
	print "- Done.\n\n";
	
	return(0);
}

# This verifies that this is running on a RHEL 6 (or derivative) OS.
sub verify_os
{
	my ($conf) = @_;
	
	# If the release file doesn't exist, it's most likely not EL.
	print "Checking the operating system to ensure it is compatible.\n";
	if (not -e $conf->{path}{os_release})
	{
		print "[ Error ] - This does not appear to be a RHEL (based) operating system.\n";
		print "[ Error ] - At this time, only RHEL and derivatives version 6.x are supported.\n";
		exit(13);
	}
	
	# Read the release file and dig out the version.
	my $major = -1;
	my $minor = -1;
	print "- We're on a RHEL (based) OS, good. Checking version.\n";
	open (my $file_handle, "<", $conf->{path}{os_release}) or die "Failed to read: [$conf->{path}{os_release}], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /release (\d+)\.(\d+) /)
		{
			$major = $1;
			$minor = $2;
		}
	}
	close $file_handle;
	
	if ($major == 6)
	{
		# We're ok, but warn if minor is < 5
		if ($minor < 5)
		{
			print "[ Warning ] - This OS appears to be a little old, you are on: [$major.$minor].\n";
			print "[ Warning ] - Upgrading to at least version 6.5 is recommended, though not\n";
			print "[ Warning ] - strictly required. If you encounter issues, please update before\n";
			print "[ Warning ] - before filing a bug. Thank you.\n\n";
			sleep 5;
		}
		else
		{
			print "- Looks good! You're on: [$major.$minor]\n\n";
		}
	}
	elsif ($major > 6)
	{
		print "[ Error ] - I am sorry, but EL$major is not yet supported.\n";
		print "[ Error ] - Please use RHEL 6.x or similar.\n";
		exit(14);
	}
	else
	{
		print "[ Error ] - I am sorry, but EL$major is not supported.\n";
		print "[ Error ] - Please use RHEL 6.x or similar.\n";
		exit(14);
	}
	
	return(0);
}

# This looks at the list of installed RPMs, compares them against the list of
# needed RPMs and installs any that are missing.
sub install_packages
{
	my ($conf) = @_;
	
	print "Checking if anything needs to be installed.\n";
	
	# First up, has the 'an-repo' been added?
	configure_an_repo($conf);
	
	# Check for OS updates.
	update_os($conf);
	
	# Get a list of already installed packages.
	get_list_of_installed_packages($conf);
	
	# Install missing packages, if any.
	install_missing_packages($conf);
	
	return(0);
}

# This will compare the list of required packages against the list of installed
# packages and, if any are missing, install them
sub install_missing_packages
{
	my ($conf) = @_;
	
	print "Checking to see if any packages need to be installed.\n";
	my $to_install = "";
	foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{to_install}})
	{
		# Watch for autovivication...
		if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
		{
			$conf->{packages}{to_install}{$package} = 1;
			print "- Package: [$package] already installed.\n";
		}
		else
		{
			print "- Package: [$package] needs to be installed.\n";
			$to_install .= "$package ";
		}
	}
	print "- Done\n\n";
	
	if ($to_install)
	{
		# Install the packages, then verify they actually installed.
		print "Installing missing packages now. Please be patient.\n";
		#print "[ Note ] - Please be patient! It may appear that nothing is happening for a\n";
		#print "[ Note ] - while. This is likely because of how buffering is handled. If you\n";
		#print "[ Note ] - really think nothing is happening, please open a new terminal and\n";
		#print "[ Note ] - look for activity using 'top' or 'ps aux'.\n";
		my $shell_call = "$conf->{executable}{yum} -y install $to_install";
		open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- Output: [$line]\n";
		}
		close $file_handle;
		print "- Done.\n\n";
		
		# Verify that everything is installed.
		print "Verifying that everything is installed now.\n";
		sleep 2;
		get_list_of_installed_packages($conf);
		my $missing = 0;
		foreach my $package (sort {$a cmp $b} keys %{$conf->{packages}{to_install}})
		{
			# Watch for autovivication...
			if ((exists $conf->{packages}{installed}{$package}) && ($conf->{packages}{installed}{$package} == 1))
			{
				$conf->{packages}{to_install}{$package} = 1;
				print "- Package: [$package] installed.\n";
			}
			else
			{
				print "[ Error ] - Package: [$package] failed to install!\n";
				$missing = 1;
			}
		}
		# If anything is missing, fail.
		if ($missing)
		{
			print "[ Error ] - Not all required packages installed properly.\n";
			print "[ Error ] - I am sorry, but this is a fatal error.\n";
			print "[ Error ] - If you are on RHEL, is this machine registered?\n";
			print "[ Error ] - If there was a problem accessing the repos, please check the\n";
			print "[ Error ] - network connection and try again.\n\n";
			exit(12);
		}
		else
		{
			print "- All required packages are now installed.\n";
		}
	}
	
	return(0);
}

# This updates the OS, if needed.
sub update_os
{
	my ($conf) = @_;
	
	print "- Checking for OS updates.\n";
	#print "[ Note ] - Please be patient! It may appear that nothing is happening for a\n";
	#print "[ Note ] - while. This is likely because of how buffering is handled. If you\n";
	#print "[ Note ] - really think nothing is happening, please open a new terminal and\n";
	#print "[ Note ] - look for activity using 'top' or 'ps aux'.\n";
	my $shell_call = "$conf->{executable}{yum} -y update";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "- Output: [$line]\n";
	}
	close $file_handle;
	print "- Done.\n\n";
	
	return(0);
}

# This gets a list of installed packages
sub get_list_of_installed_packages
{
	my ($conf) = @_;
	
	# TODO: Use 'tput cols' to get the user's screen width.
	my $dots = 0;
	print "Getting a list of currently installed packages.\n- ";
	my $shell_call = "$conf->{executable}{yum} list installed";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		next if $line =~ /^Loaded plugins/;
		next if $line =~ /^Loading mirror/;
		next if $line =~ /^ \* /;
		next if $line =~ /^Installed Packages/;
		next if $line =~ /^\s+\@/;
		if ($line =~ /^(.*?)\.(.*?)\s+(.*?)\s+\@/)
		{
			my $package   = $1;
			my $arch      = $2;
			my $version   = $3;
			# NOTE: Someday record the arch and version, but for
			#       now, we don't care.
			$conf->{packages}{installed}{$package} = 1;
			#print "[ Debug ] - Package: [$package]\n";
			if ($dots > 75)
			{
				print "\n- .";
				$dots = 0;
			}
			else
			{
				print ".";
				$dots++;
			}
		}
		elsif ($line =~ /^(.*?)\.(.*?)\s+(.*)/)
		{
			my $package   = $1;
			my $arch      = $2;
			my $version   = $3;
			#print "[ Debug ] - Package: [$package]\n";
			if ($dots > 75)
			{
				print "\n- .";
				$dots = 0;
			}
			else
			{
				print ".";
				$dots++;
			}
		}
	}
	close $file_handle;
	print "\n- Done!\n\n";
	
	return(0);
}

# This installs the AN!Repo if needed.
sub configure_an_repo
{
	my ($conf) = @_;
	
	if (-e $conf->{path}{an_repo})
	{
		print "- The AN!Repo is already installed.\n";
	}
	else
	{
		# Create the repo
		print "- The AN!Repo hasn't been added yet, adding it now.\n";
		open (my $file_handle, ">", $conf->{path}{an_repo}) or die "Failed to write: [$conf->{path}{an_repo}], the error was: $!\n";
		print $file_handle "[an-repo]\n";
		print $file_handle "name=AN! Repo for Anvil! stuff\n";
		print $file_handle "baseurl=https://alteeve.ca/repo/el6/\n";
		print $file_handle "enabled=1\n";
		print $file_handle "gpgcheck=0\n";
		print $file_handle "protect=1\n";
		close $file_handle;
		
		# No clear yum's cache
		print "- Added. Clearing yum's cache.\n";
		my $shell_call = "$conf->{executable}{yum} clean all";
		open ($file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			print "- output: [$line]\n";
		}
		close $file_handle;
		print "- Done!\n\n";
	}
	
	return(0);
}

# This looks at all NICs and 'ifup's any that are down.
sub start_all_nics
{
	my ($conf) = @_;
	
	check_nic_states($conf);
	foreach my $this_iface (sort {$a cmp $b} keys %{$conf->{nic}{by_name}})
	{
		# See if it is up already.
		my $link_state = $conf->{nic}{by_name}{$this_iface}{link_state};
		my $mac        = $conf->{nic}{by_name}{$this_iface}{mac};
		next if $link_state != 2;
		
		# If I am here, the interface is down
		my $nic       = $this_iface;
		my $nic_file = "$conf->{path}{network_configs}/ifcfg-$nic";
		print "The network interface: [$nic] is down. It must be started for the next stage.\n";
		print "- Checking if: [$nic_file] exists.\n";
		if (not -e $nic_file)
		{
			print "  New device, writing a skeleton config file... ";
			my $shell_call = $nic_file;
			open (my $file_handle, '>', "$shell_call") || die "\nFailed to write: [$shell_call], error was: $!\n";
			print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
			print $file_handle "# Temporary configuration file for discovered NIC.\n";
			print $file_handle "HWADDR=\"$mac\"\n" if $mac;
			print $file_handle "DEVICE=\"$nic\"\n";
			print $file_handle "BOOTPROTO=\"none\"\n";
			print $file_handle "NM_CONTROLLED=\"no\"\n";
			close $file_handle;
			print "Done.\n";
		}
		else
		{
			# It exists, edit it if needed.
			print "  Config file exists, changing BOOTPROTO to 'none'.\n";
			my $shell_call = "$conf->{executable}{sed} -i 's/BOOTPROTO=.*/BOOTPROTO=\"none\"/\' $nic_file";
			#print "[ Debug ] - Calling: [$shell_call]\n";
			open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				# TODO: Should this cause the installer to bail?
				# This should not return anything, but just in case...
				chomp;
				my $line = $_;
				print "[ Warning ] - Unexpected output: [$line]\n";
			}
			close $file_handle;
		}
			
		# Now start the nic.
		print "  Attempting to bring up: [$nic]...\n";
		my $shell_call = "$conf->{executable}{ifup} $nic";
		open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			print "[ Note ] - Output: [$line]\n";
		}
		close $file_handle;
		
		# See that it came up.
		print "[ Note ] - Checking to see if it is up now.\n";
		sleep 2;
		my $is_up = 0;
		$shell_call   = "$conf->{executable}{ip} link show $nic";
		open ($file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /UP/)
			{
				$is_up = 1;
				last;
			}
		}
		close $file_handle;
		if ($is_up)
		{
			print "[ OK ] - The interface: [$nic] is now up!\n";
		}
		else
		{
			print "[ Error ] - Unable to bring up the interface: [$nic]!\n";
			print "[ Error ] - Please bring it up manually and try again.\n";
			exit(11);
		}
	}
	
	return(0);
}

# This is a wrapper function that calls the various task-specific functions
# that make the actual changes to the network.
sub reconfigure_network
{
	my ($conf) = @_;
	
	### TODO: Confirm that this is needed, may have to reboot anyway
	# Stop the network.
	#daemon_control($conf, "NetworkManager.service", "stop");
	
	# Write the udev file
	write_udev_persistent_net($conf);
	
	# Remove existing ifcfg-* files and then write the new ones.
	update_network_config_files($conf);
	
	return(0);
}

# This will remove all 'ifcfg-*' (save for 'ifcfg-lo') files and the writes
# the new config files.
sub update_network_config_files
{
	my ($conf) = @_;
	
	# First up, delete the old files.
	print "Deleting old network configuration files:\n"; 
	$conf->{path}{network_configs} =~ s/\/$//g;
	local(*DIRECTORY);
	opendir(DIRECTORY, $conf->{path}{network_configs});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		next if $file eq "ifcfg-lo";
		if ($file =~ /^ifcfg-/)
		{
			my $full_path = "$conf->{path}{network_configs}/$file";
			print "- Deleting file: [$full_path]\n";
			unlink $full_path or die "Unable to delete: [$full_path]. The error was: $!\n";
		}
	}
	print "- Done.\n\n";
	print "Writing new network configuration files.\n";
	
	# Now write out the config files.
	# IFN first
	my $ifn_link1_file = "$conf->{path}{network_configs}/ifcfg-ifn-link1";
	print "- IFN Link 1: [$ifn_link1_file]\n";
	my $shell_call = $ifn_link1_file;
	open (my $file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	print $file_handle "# Internet-Facing Network - Link 1\n";
	print $file_handle "DEVICE=\"ifn-link1\"\n";
	print $file_handle "BOOTPROTO=\"static\"\n";
	print $file_handle "NM_CONTROLLED=\"no\"\n";
	print $file_handle "IPADDR=\"$conf->{network}{ifn}{ip}\"\n";
	print $file_handle "NETMASK=\"$conf->{network}{ifn}{netmask}\"\n";
	print $file_handle "GATEWAY=\"$conf->{network}{ifn}{gateway}\"\n";
	print $file_handle "DNS1=\"$conf->{network}{ifn}{dns1}\"\n";
	print $file_handle "DNS2=\"$conf->{network}{ifn}{dns2}\"\n";
	print $file_handle "DEFROUTE=\"yes\"\n";
	close $file_handle;
	
	# Now the BCN
	my $bcn_link1_file = "$conf->{path}{network_configs}/ifcfg-bcn-link1";
	print "- BCN Link 1: [$bcn_link1_file]\n";
	$shell_call = $bcn_link1_file;
	open ($file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	print $file_handle "# Back-Channel Network - Link 1\n";
	print $file_handle "DEVICE=\"bcn-link1\"\n";
	print $file_handle "BOOTPROTO=\"static\"\n";
	print $file_handle "NM_CONTROLLED=\"no\"\n";
	print $file_handle "IPADDR=\"$conf->{network}{bcn}{ip}\"\n";
	print $file_handle "NETMASK=\"$conf->{network}{bcn}{netmask}\"\n";
	print $file_handle "DEFROUTE=\"no\"\n";
	close $file_handle;
	print "- Done.\n\n";
	
	return(0);
}

# This returns the current date and time in 'YYYY/MM/DD HH:MM:SS' format. It
# always uses 24-hour time and it zero-pads single digits.
sub get_date
{
	my ($conf) = @_;
	my $date = "";
	
	# This doesn't support offsets or other advanced features.
	my %time;
	($time{sec}, $time{min}, $time{hour}, $time{mday}, $time{mon}, $time{year}, $time{wday}, $time{yday}, $time{isdst}) = localtime();
	
	# Increment the month by one.
	$time{mon}++;
	
	# 24h time.
	$time{pad_hour} = sprintf("%02d", $time{hour});
	$time{pad_min}  = sprintf("%02d", $time{min});
	$time{pad_sec}  = sprintf("%02d", $time{sec});
	$time{year}     = ($time{year} + 1900);
	$time{pad_mon}  = sprintf("%02d", $time{mon});
	$time{pad_mday} = sprintf("%02d", $time{mday});
	$time{mon}++;
	
	$date = "$time{year}/$time{pad_mon}/$time{pad_mday} $time{pad_hour}:$time{pad_min}:$time{pad_sec}";
	
	return($date);
}

# This writes out the udev 70-persistent-net.rules file.
sub write_udev_persistent_net
{
	my ($conf) = @_;
	
	my $shell_call = "$conf->{path}{persistent_net}";
	print "Writing the new udev rules file: [$conf->{path}{persistent_net}]\n";
	open (my $file_handle, '>', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	print $file_handle "# Generated by: [$THIS_FILE] on: [".get_date($conf)."].\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic = $nic;
		if    ($nic =~ /^bcn-link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^ifn-link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		my $this_mac = $conf->{nic}{name}{$nic};
		if (not $this_mac)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ] - Desired NIC: [$nic] doesn't have a referenced MAC address!\n";
			print "[ Error ] - Exiting.\n";
			exit(1);
		}
		print $file_handle "# $say_nic\n";
		print $file_handle "SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR{address}==\"$this_mac\", NAME=\"$nic\"\n\n";
	}
	close $file_handle;
	print "- Done.\n\n";
	
	return(0);
}

# This starts or stops the specified systemd service.
sub daemon_control
{
	my ($conf, $service, $task) = @_;
	
	my $message    = "";
# 	my $shell_call = "$conf->{executable}{systemctl} $task $service";
# 	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
# 	while(<$file_handle>)
# 	{
# 		chomp;
# 		my $line = $_;
# 		$message .= "$line\n";
# 		print "- Shell output: [$line]\n";
# 	}
# 	close $file_handle;
	
	return($message);
}

# This backs up the udev (if it exists) and network files before making any
# actual changes to the system.
sub backup_original_files
{
	my ($conf) = @_;
	
	if (not $conf->{path}{backups})
	{
		print "[ Error ] - The backup directory is not defined!\n";
		print "[ Error ] - Unable to safely proceed, exiting.\n";
		exit(5);
	}
	elsif (not -e $conf->{path}{backups})
	{
		print "The backup directory: [$conf->{path}{backups}] doesn't exist, creting it.\n";
		mkdir $conf->{path}{backups} or die warn "[ Warning ] - Failed to create the directory: [$conf->{path}{backups}].\n[ Warning ] - The error was: $!\n";
		if (not -e $conf->{path}{backups})
		{
			print "[ Error ] - The backup directory was not created.\n";
			print "[ Error ] - Unable to safely proceed, exiting.\n";
			exit(6);
		}
		else
		{
			print "- Backup directory successfully created.\n";
		}
	}
	
	# If there is already a backup created, skip it as we're probably being
	# run a second (of thirteenth) time.
	print "Backing up: [$conf->{path}{persistent_net}]\n";
	if (-e "$conf->{path}{backups}/70-persistent-net.rules")
	{
		print "- Previous backup exists, skipping.\n";
	}
	else
	{
		# Backup '70-persistent-net.rules' if it exists.
		if (-e $conf->{path}{persistent_net})
		{
			print "- It exists, backing it up.\n";
			backup_file($conf, $conf->{path}{persistent_net});
		}
		else
		{
			print "- Doesn't exist, skipping.\n";
		}
	}
	
	# Backup the '/etc/sysconfig/network-scripts' directory.
	print "Backing up: [$conf->{path}{network_configs}]\n";
	if (-e "$conf->{path}{backups}/network-scripts")
	{
		print "- Previous backup exists, skipping.\n";
	}
	else
	{
		if (-e $conf->{path}{network_configs})
		{
			# No need to say it exists
			backup_file($conf, $conf->{path}{network_configs});
		}
		else
		{
			# Ok, the user has bigger problems
			print "[ Error ] - The network configuration directory was not found!\n";
			print "[ Error ] - This should not be possible.\n";
			print "[ Error ] - Please check the internal path::network_configs value.\n";
			exit(8);
		}
	}
	
	return(0);
}

# This backups up a file (or directory) to the backups directory. It is
# expected that the existance of the source and backup directories are done.
sub backup_file
{
	my ($conf, $file) = @_;
	
	if (not $file)
	{
		print "[ Error ] - The backup function was called, but no source file was given.\n";
		print "[ Error ] - This is likely a program error, exiting.\n";
		exit(7);
	}
	
	# I want the source, if it is a directory, to not have a trailing
	# slash. Conversly, I want the backup directory to have a trailing
	# slash, if it doesn't have it already.
	$file =~ s/\/$//g;
	$conf->{path}{backups} .= "/" if $conf->{path}{backups} !~ /\/$/;
	
	my $shell_call = "$conf->{executable}{cp} -ab $file $conf->{path}{backups}";
	print "- Copying: [$file] to: [$conf->{path}{backups}]\n";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		print "  Shell output: [$line]\n";
	}
	close $file_handle;
	
	### TODO: Verify the backed up file exists in the backup directory.
	#print "  Done\n";
	
	return(0);
}

# This breaks out the command-line switches and varifies that their values are
# (more or less) sane
sub sanity_check_switches
{
	my ($conf) = @_;
	
	# Something has been set for all values, sanity check them.
	# This will fail out if set to '1' once all sanity checking is done.
	my $bad_value = 0;

	# The network is a little tricker
	if (($conf->{switches}{h}) or ($conf->{switches}{help}) or ($conf->{switches}{'?'}))
	{
		print_usage($conf);
		exit(0);
	}
	if (($conf->{switches}{b}) && ($conf->{switches}{i}))
	{
		# Both defined, sanity check them.
		($bad_value) = sanity_check_network($conf, $bad_value);
	}
	elsif ((not $conf->{switches}{b}) && (not $conf->{switches}{i}))
	{
		print "[ Note ] - No network details given. Skipping Network config!\n";
		$conf->{sys}{skip_network} = 1;
	}
	elsif (not $conf->{switches}{b})
	{
		print "[ Error ] - The IFN settings were given, but not the BCN. I am sorry but both\n";
		print "[ Error ] - or neither network must be defined at this time.\n";
		$bad_value = 1;
	}
	elsif (not $conf->{switches}{i})
	{
		print "[ Error ] - The BCN settings were given, but not the IFN. I am sorry but both\n";
		print "[ Error ] - or neither network must be defined at this time.\n";
		$bad_value = 1;
	}

	# Check the hostname
	if ($conf->{switches}{n})
	{
		### Make sure the hostname is sane.
		# First, any double-dots, leading dots or trailing dots?
		($bad_value) = sanity_check_hostname($conf, $conf->{switches}{n}, 0, $bad_value);
	}
	else
	{
		print "[ Note ] - No hostname given. Will not change it.\n";
		$conf->{sys}{skip_hostname} = 1;
	}
	
	# See if they set an owner name
	if (not $conf->{switches}{c})
	{
		print "[ Note ] - No customer/owner name given, will use: [$conf->{sys}{customer}]\n";
		# TODO: check to see if apache limits the names allowed.
	}
	else
	{
		# TODO: Does this need to be sanitized to prevent injection of
		#       malicious code? If so, how? Escape all quotes?
		$conf->{sys}{customer} = $conf->{switches}{c};
	}
	
	# See if they've asked for a specific version.
	if (not $conf->{switches}{d})
	{
		print "[ Note ] - No specific version requested, will install: [$conf->{sys}{stable_version}]\n";
		# TODO: check to see if the requested version exists
	}
	
	# With mail, both or neither must be provided (XNOR y'all!)
	if (($conf->{switches}{e}) && ($conf->{switches}{m}))
	{
		# Validate the mail domain
		($bad_value) = sanity_check_hostname($conf, $conf->{switches}{m}, 1, $bad_value);
		# TODO: Validate the email local user part. Note that a lot 
		#       more flexibility is allowed here than in the domain, 
		#       including UTF-8. See:
		#       https://en.wikipedia.org/wiki/Email_address#Local_part
	}
	elsif ((not $conf->{switches}{e}) && (not $conf->{switches}{m}))
	{
		print "[ Note ]    - Mail server information not provided.\n";
		print "[ Warning ] - If mail sending was not previously configured, you want encounter\n";
		print "[ Warning ] - problems later!\n";
		$conf->{sys}{skip_mail} = 1;
	}
	elsif (not $conf->{switches}{e})
	{
		print "[ Error ] - A mail server alone can not be specified. Please specify\n";
		print "[ Error ] - credentials to use when logging into: [$conf->{switch}{m}].\n";
		$bad_value = 1;
	}
	elsif (not $conf->{switches}{m})
	{
		print "[ Error ] - Credentials for logging into a mail server were given but the mail\n";
		print "[ Error ] - server address itself was not.\n";
		$bad_value = 1;
	}
	
	# Check to see if either the htpasswd file exists or the user is giving us a user now.
	if ((not -e $conf->{path}{apache_htpasswd}) && (not $conf->{switches}{u}))
	{
		print "[ Error ] - No apache credentials were set, and: [$conf->{path}{apache_htpasswd}]\n";
		print "[ Error ] - doesn't exist. This is required for Striker to work securely.\n";
		$bad_value = 1;
	}
	elsif ($conf->{switches}{u})
	{
		if ($conf->{switches}{u} =~ /^(.*?):(.*)$/)
		{
			$conf->{sys}{striker_user} = $1;
			$conf->{sys}{striker_pass} = $2;
		}
		else
		{
			print "[ Error ] - The Striker user name and password were not specified correctly.\n";
			print "[ Error ] - Please use '-u \"<user>:<password>\".\n";
			$bad_value = 1;
		}
	}
	
	return($bad_value);
}

# This sanity-checks the host name.
sub sanity_check_hostname
{
	my ($conf, $hostname, $port_allowed, $bad_value) = @_;
	
	my $port;
	if ($hostname =~ /(.*?):(\d+)$/)
	{
		$hostname = $1;
		$port     = $2;
		
		if (not $port_allowed)
		{
			print "[ Error ] - A port number was set for: [$hostname]\n";
			print "[ Error ] - but it is not allowed here.\n";
			$bad_value = 1;
		}
		elsif (($port < 1) || ($port > 65535))
		{
			print "[ Error ] - The port number: [$port] is out of range!\n";
			print "[ Error ] - Port numbers must be between 1 and 65535.\n";
			$bad_value = 1;
		}
	}
	
	if ($hostname =~ /\.\./)
	{
		print "[ Error ] - The hostname: [$hostname] has multiple periods!\n";
		$bad_value = 1;
	}
	if ($hostname =~ /^\./)
	{
		print "[ Error ] - The hostname: [$hostname] starts with a period!\n";
		$bad_value = 1;
	}
	if ($hostname =~ /\.$/)
	{
		print "[ Error ] - The hostname: [$hostname] ends with a period!\n";
		$bad_value = 1;
	}
	# Now loop through the hostname's elements and make sure they're sane.
	foreach my $name (split/\./, $hostname)
	{
		if (not $name)
		{
			print "[ Error ] - The hostname: [$hostname] appears to have an empty element!\n";
			print "[ Error ] - This might be a program error.\n";
			$bad_value = 1;
		}
		if (length($name) > 255)
		{
			print "[ Error ] - The hostname: [$hostname]'s section: [$name] is too long!\n";
			$bad_value = 1;
		}
		if ($name =~ /[^0-9a-zA-Z\-]/)
		{
			print "[ Error ] - The hostname: [$hostname]'s section: [$name] contains an illegal character!\n";
			print "[ Error ] - only alpha-numeric and the '-' character are allowed\n";
			$bad_value = 1;
		}
	}
	
	return($bad_value);
}

# This sanity checks the network settings passed by the user.
sub sanity_check_network
{
	my ($conf, $bad_value) = @_;
	
	### Now sanity check passed values
	# First up, the BCN
	if ($conf->{switches}{b} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified BCN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{bcn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified BCN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{bcn}{netmask} = $netmask;
		}
	}
	else
	{
		print "[ Error ] - The specified BCN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}

	# Next is the IFN, which is a little more complicated.
	if ($conf->{switches}{i} =~ /^(.*?)\/(.*)$/)
	{
		my $ip      = $1;
		my $netmask = $2;
		my $gateway = "";
		my $dns1    = "";
		my $dns2    = "";
		
		# The netmask should have ',dg=X' and possibly 'dns[12]=[YZ]',
		# so pull those out.
		#print "$THIS_FILE ".__LINE__."; ip: [$ip], netmask: [$netmask]\n";
		if ($netmask =~ /,dg=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dg=(.*?),/)
			{
				$gateway = $1;
				#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			}
			else
			{
				$gateway = ($netmask =~ /,dg=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			}
		}
		
		# Now the nameservers.
		if ($netmask =~ /,dns1=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dns1=(.*?),/)
			{
				$dns1 = $1;
				#print "$THIS_FILE ".__LINE__."; dns1: [$dns1]\n";
			}
			else
			{
				$dns1 = ($netmask =~ /,dns1=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; dns1: [$dns1]\n";
			}
		}
		if ($netmask =~ /,dns2=/)
		{
			# Good, strip it out.
			if ($netmask =~ /,dns2=(.*?),/)
			{
				$dns2 = $1;
				#print "$THIS_FILE ".__LINE__."; dns2: [$dns2]\n";
			}
			else
			{
				$dns2 = ($netmask =~ /,dns2=(.*)/)[0];
				#print "$THIS_FILE ".__LINE__."; dns2: [$dns2]\n";
			}
		}
		
		# Now delete everything from the netmask after the ','
		$netmask =~ s/,.*$//;
		#print "$THIS_FILE ".__LINE__."; netmask: [$netmask]\n";

		### Verify sanity
		# IP address
		$ip = validate_ip_address($conf, $ip);
		if ($ip eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IFN IP address is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{ifn}{ip} = $ip;
		}
		
		# Netmask
		if ($netmask =~ /^\d{1,2}$/)
		{
			# Convert from CIDR to dotted-decimal
			$netmask = convert_cidr_to_dotted_decimal($conf, $netmask);
		}
		else
		{
			$netmask = validate_ip_address($conf, $netmask);
		}
		if ($netmask eq "#!INVALID!#")
		{
			print "[ Error ] - The specified IFN netmask value is not valid.\n";
			$bad_value = 1;
		}
		else
		{
			$conf->{network}{ifn}{netmask} = $netmask;
		}
		
		# Gateway
		#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
		if ($gateway)
		{
			$gateway = validate_ip_address($conf, $gateway);
			#print "$THIS_FILE ".__LINE__."; gateway: [$gateway]\n";
			if ($gateway eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN gateway value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{gateway} = $gateway;
				#print "$THIS_FILE ".__LINE__."; network::ifn::gateway: [$conf->{network}{ifn}{gateway}]\n";
			}
		}
		else
		{
			print "[ Error ] - The IFN gateway is not specified.\n";
			$bad_value = 1;
		}
		
		# DNS 1 and 2, if defined.
		if ($dns1)
		{
			$dns1 = validate_ip_address($conf, $dns1);
			if ($dns1 eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN dns1 value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{dns1} = $dns1;
			}
		}
		if ($dns2)
		{
			$dns2 = validate_ip_address($conf, $dns2);
			if ($dns2 eq "#!INVALID!#")
			{
				print "[ Error ] - The specified IFN dns2 value is not valid.\n";
				$bad_value = 1;
			}
			else
			{
				$conf->{network}{ifn}{dns2} = $dns2;
			}
		}
	}
	else
	{
		print "[ Error ] - The specified IFN IP address and netmask are malformed.\n";
		$bad_value = 1;
	}
	
	return($bad_value);
}

# This validates a string as being an IPv4 address in dotted-decimal notation.
sub validate_ip_address
{
	my ($conf, $ip) = @_;

	if ($ip =~ /(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/)
	{
		my $first_octal  = $1;
		my $second_octal = $2;
		my $third_octal  = $3;
		my $fourth_octal = $4;
		# First octal has to be >= 1. The rest can be 0.
		if (($first_octal < 1)  || ($first_octal > 255)  ||
		    ($second_octal < 0) || ($second_octal > 255) ||
		    ($third_octal < 0)  || ($third_octal > 255)  ||
		    ($fourth_octal < 0) || ($fourth_octal > 255))
		{
			$ip = "#!INVALID!#";
		}
	}
	else
	{
		# Not even formatted properl.
		$ip = "#!INVALID!#";
	}

	return($ip);
}

# This takes an integer and, if it is a valid CIDR range, returns the 
# dotted-decimal equivalent. If it's not, it returns '#!INVALID!#'.
sub convert_cidr_to_dotted_decimal
{
	my ($conf, $netmask) = @_;
	
	if ($netmask =~ /^\d{1,2}$/)
	{
		# Make sure it's a (useful) CIDR
		if (($netmask >= 1) && ($netmask <= 29))
		{
			# Yes, I know that technically '0' and '30-32' are 
			# valid, but not in our case.
			if    ($netmask == 1)  { $netmask = "128.0.0.0"; }
			elsif ($netmask == 2)  { $netmask = "192.0.0.0"; }
			elsif ($netmask == 3)  { $netmask = "224.0.0.0"; }
			elsif ($netmask == 4)  { $netmask = "240.0.0.0"; }
			elsif ($netmask == 5)  { $netmask = "248.0.0.0"; }
			elsif ($netmask == 6)  { $netmask = "252.0.0.0"; }
			elsif ($netmask == 7)  { $netmask = "254.0.0.0"; }
			elsif ($netmask == 8)  { $netmask = "255.0.0.0"; }
			elsif ($netmask == 9)  { $netmask = "255.128.0.0"; }
			elsif ($netmask == 10) { $netmask = "255.192.0.0"; }
			elsif ($netmask == 11) { $netmask = "255.224.0.0"; }
			elsif ($netmask == 12) { $netmask = "255.240.0.0"; }
			elsif ($netmask == 13) { $netmask = "255.248.0.0"; }
			elsif ($netmask == 14) { $netmask = "255.252.0.0"; }
			elsif ($netmask == 15) { $netmask = "255.254.0.0"; }
			elsif ($netmask == 16) { $netmask = "255.255.0.0"; }
			elsif ($netmask == 17) { $netmask = "255.255.128.0"; }
			elsif ($netmask == 18) { $netmask = "255.255.192.0"; }
			elsif ($netmask == 19) { $netmask = "255.255.224.0"; }
			elsif ($netmask == 20) { $netmask = "255.255.240.0"; }
			elsif ($netmask == 21) { $netmask = "255.255.248.0"; }
			elsif ($netmask == 22) { $netmask = "255.255.252.0"; }
			elsif ($netmask == 23) { $netmask = "255.255.254.0"; }
			elsif ($netmask == 24) { $netmask = "255.255.255.0"; }
			elsif ($netmask == 25) { $netmask = "255.255.255.128"; }
			elsif ($netmask == 26) { $netmask = "255.255.255.192"; }
			elsif ($netmask == 27) { $netmask = "255.255.255.224"; }
			elsif ($netmask == 28) { $netmask = "255.255.255.240"; }
			elsif ($netmask == 29) { $netmask = "255.255.255.248"; }
			else
			{
				# This should never be hit.
				$netmask = "#!INVALID!#";
			}
		}
		else
		{
			$netmask = "#!INVALID!#";
		}
	}
	
	return($netmask);
}

# Print the usage information.
sub print_usage
{
	my ($conf) = @_;
	
	my $help = q|
 -=] Striker installer

DESCRIPTION

This program installs and configures Striker, the Anvil! dashboard, on an
almost minimal EL6 install.


SWITCHES

 -b <ip_address/netmask>
	
	This sets the IP address and subnet to be assigned to the Back-Channel
	Network interface.

 -c <customer/owner>

	This sets the name of the customer/owner of the dashboard. This is used
	by apache at the top of the input box when asking the user for their 
	credentials. If this is not set, "Striker Dashboard" will be used alone.

 -d <version>

	This tells the installer what version of Striker dashboard to install.
	The default is to download the latest stable version. If set to 'git',
	the latest version in github will be installed. You probably don't want
	this unless you're a developer.

 -e <user:password>

	This is the email address user and password to use when logging in to
	the mail server. This information will be recorded in postfix's
	/etc/postfix/relay_password file.

 -h, -?, --help

	Show this dialoge and exit.

 -i <ip_address/netmask>,dg=<ip_address>[,dns1=<ip_address>,dns2=<ip_address>]

	This sets the IP address and subnet to be assigned to the 
	Internet-Facing Network interface. Unlike -b switch, this switch
	requires a default gateway be specified after the IP address via:

	dg=<ip_address>
	
		IPv4 address of the default gateway.

	Optionally, one or two DNS servers may be specified via:
	
	dns1=<ip_address>
	dns2=<ip_address>

		IPv4 addresses of the first and/or secondary DNS server. If
		these are not set, dns1 will default to 8.8.8.8 and dns2 will
		default to 8.8.4.4

 -m <mail server:port>

	This sets the mail server and port to use for sending email. If no port
	is set, 587 will be used. This information will be recorded in
	postfix's /etc/postfix/relay_password file.

 -n <hostname>

	This sets the host name of the Striker dashboard.

 -u <striker user:password>

	This is the user name and password to set for Striker. This will be
	used in apache's htpasswd authentication and will be stored in the
|;
	$help .= "	$conf->{path}{apache_htpasswd} file.\n";
	$help .= q|

Note that all IP addresses must be IPv4 in dotted-decimal notation. The netmask
can be in CIDR or dotted-decimal notation. Do not leave a space between the IP
address and netmask


EXAMPLE

Normal install:

 ./striker-installer -c "Alteeve's Niche\!" \
                  -e "foo@alteeve.ca:secret password" \
                  -m mail.alteeve.ca:587 \
                  -n an-m01.alteeve.ca \
                  -u "admin:secret password" \
                  -b 10.20.4.1/16 \
                  -i 10.255.4.1/16,dg=10.255.255.254,dns1=8.8.8.8,dns2=8.8.4.4

Developer install:

 ./striker-installer -c "Alteeve's Niche\!" \
                  -e "foo@alteeve.ca:secret password" \
                  -m mail.alteeve.ca:587 \
                  -n an-m01.alteeve.ca \
                  -d git \
                  -u "admin:secret password" \
                  -b 10.20.4.1/16 \
                  -i 10.255.4.1/16,dg=10.255.255.254,dns1=8.8.8.8,dns2=8.8.4.4

Install without configuring the network:

 ./striker-installer -c "Alteeve's Niche\!" \
                  -e "foo@alteeve.ca:secret password" \
                  -m mail.alteeve.ca:587 \
                  -n an-m01.alteeve.ca \
                  -u "admin:secret password"

Note: As with any bash call, you must escape '!' characters with '\!'.

                  
SUPPORT

https://alteeve.ca/w/Support

							      Alteeve's Niche!
|;
	open (my $file_handle, ">", "/tmp/striker-installer-help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system("/usr/bin/less /tmp/striker-installer-help");

	return(0);
}

# This collects the command line switches
sub get_switches
{
	my ($conf) = @_;
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$conf->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$conf->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$conf->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$conf->{switches}{$last_argument} = $value;
				}
				else
				{
					$conf->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$conf->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$conf->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($conf->{switches}{raw})
	{
		$conf->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	#foreach my $variable (sort {$a cmp $b} keys %{$conf->{switches}}) { print "Variable: [$variable]\t-> value: [$conf->{switches}{$variable}]\n"; } exit;
	
	return(0);
}

# This asks the user to unplug (and plug back in) NICs to identify which
# physical interface they want to use for a given role.
sub select_nics
{
	my ($conf) = @_;

	print "\n-=] Configuring network to enable access to Anvil! systems.\n\n";
	print "Beginning NIC identification...\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $plug_in_message_printed = 0;
		while (my $down_links = check_nic_states($conf))
		{
			if (not $plug_in_message_printed)
			{
				print "  Please plug in all network cables to proceed.\n";
				$plug_in_message_printed = 1;
			}
			#print "MAC address of down links: [$down_links]\n";
			sleep 1;
		}
		my $say_nic = $nic;
		if    ($nic =~ /^bcn-link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^ifn-link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		print "- Please unplug the interface you want to make:\n";
		print "  [$say_nic]\n";
		my $last_conflict = "";
		while(1)
		{
			my $down_links = check_nic_states($conf);
			if (($down_links) && ($down_links !~ /,/))
			{
				if ($conf->{nic}{mac}{$down_links}{new_name})
				{
					print "  The NIC with MAC address: [$down_links] is already allocated to: [$conf->{nic}{mac}{$down_links}{new_name}]\n" if ($last_conflict ne $down_links);
					$last_conflict = $down_links;
				}
				else
				{
					$conf->{nic}{mac}{$down_links}{new_name} = $nic;
					$conf->{nic}{name}{$nic}                 = $down_links;
					print "  NIC with MAC: [$down_links] will become: [$conf->{nic}{mac}{$down_links}{new_name}]\n";
					print "  (it is currently: [$conf->{nic}{mac}{$down_links}{current_name}])\n";
					last;
				}
			}
			sleep 1;
		}
	}
	my $plug_in_message_printed = 0;
	while (my $down_links = check_nic_states($conf))
	{
		if (not $plug_in_message_printed)
		{
			print "  Please plug in all network cables to proceed.\n";
			$plug_in_message_printed = 1;
		}
		sleep 1;
	}

	my $proceed = 1;
	print "\nHere is what you selected:\n";
	foreach my $nic (@{$conf->{nics}})
	{
		my $say_nic = $nic;
		if    ($nic =~ /^bcn-link(\d)/) { $say_nic = "Back-Channel Network, Link $1" }
		elsif ($nic =~ /^ifn-link(\d)/) { $say_nic = "Internet-Facing Network, Link $1" }
		my $this_mac = $conf->{nic}{name}{$nic};
		if (not $this_mac)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ] - Desired NIC: [$nic] doesn't have a referenced MAC address!\n";
			print "[ Error ] - Exiting.\n";
			exit(1);
		}
		my $current_name = $conf->{nic}{mac}{$this_mac}{current_name};
		if (not $current_name)
		{
			print "[ Error ] - There seems to be a problem.\n";
			print "[ Error ] - Desired NIC: [$nic] doesn't have a referenced interface!\n";
			print "[ Error ] - Exiting.\n";
			exit(2);
		}
		print "- Interface: [".uc($this_mac)."], currently named: [$current_name],\n";
		print "  will be renamed to: [$nic]\n";
		#print "- $say_nic will use the NIC with MAC: [$this_mac] ($current_name -> $nic)\n";
	}
	my $bcn_ip      = $conf->{network}{bcn}{ip};
	my $bcn_netmask = $conf->{network}{bcn}{netmask};
	print "\nThe Back-Channel Network interface will be set to:\n";
	print "- IP:      [$bcn_ip]\n";
	print "- Netmask: [$bcn_netmask]\n\n";
	my $ifn_ip      = $conf->{network}{ifn}{ip};
	my $ifn_netmask = $conf->{network}{ifn}{netmask};
	my $ifn_gateway = $conf->{network}{ifn}{gateway};
	my $ifn_dns1    = $conf->{network}{ifn}{dns1};
	my $ifn_dns2    = $conf->{network}{ifn}{dns2};
	print "The Internet-Facing Network interface will be set to:\n";
	print "- IP:      [$ifn_ip]\n";
	print "- Netmask: [$ifn_netmask]\n";
	print "- Gateway: [$ifn_gateway]\n";
	print "- DNS1:    [$ifn_dns1]\n";
	print "- DNS2:    [$ifn_dns2]\n\n";
	print "Shall I proceed? [Y/n] ";
	my $answer = <STDIN>;
	chomp($answer);
	if (($answer) && (lc($answer) =~ /^n/))
	{
		$proceed = 0;
		print "- Ok, starting over.\n";
		sleep 2;
		system('clear');
	}
	else
	{
		print "- Thank you, I will start to work now.\n\n";
	}

	return($proceed);
}

sub check_nic_states
{
	my ($conf) = @_;
	
	my $unplugged_macs  = "";
	my $this_iface      = "";
	my $this_mac        = "";
	my $this_link_state = "";
	my $shell_call = "$conf->{executable}{ip} addr";
	open (my $file_handle, '-|', "$shell_call") || die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /^\d+: (.*?): <(.*?)>/)
		{
			$this_iface      = $1;
			$this_link_state = $2;
			$this_mac        = "";
			if ($this_link_state =~ /UP/)
			{
				# This will be either BROADCAST or NO-CARRIER
				$this_link_state =~ s/,.*//;
			}
			else
			{
				# The interface has been 'ifdown'ed or was not
				# started on boot.
				$this_link_state = "DOWN";
			}
			next;
		}
		next if not $this_iface;
		next if $this_iface eq "lo";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		if ($line =~ /ether ([0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2}:[0-9a-f]{2})/)
		{
			$this_mac = $1;
			#print "this_mac: [$this_mac]\n";
			if ($this_link_state eq "DOWN")
			{
				$this_link_state = 2;
			}
			else
			{
				$this_link_state = $this_link_state eq "NO-CARRIER" ? 0 : 1;
			}
			$conf->{nic}{mac}{$this_mac}{current_name}     = $this_iface;
			$conf->{nic}{mac}{$this_mac}{link_state}       = $this_link_state;
			$conf->{nic}{by_name}{$this_iface}{link_state} = $this_link_state;
			$conf->{nic}{by_name}{$this_iface}{mac}        = $this_mac;
		}
	}
	close $file_handle;

	my $nic_count = 0;
	foreach my $this_mac (sort {$a cmp $b} keys %{$conf->{nic}{mac}})
	{
		# Somewhere in the loop, an empty '$this_mac' is being created... 
		# (I'm looking at you, autovivication >_>)
		next if not $this_mac;
		$nic_count++ if (($this_iface ne "lo") && ($this_iface !~ /wlan/));
		#print "NIC w/ MAC: [$this_mac]; Link: [$conf->{nic}{mac}{$this_mac}{link_state}], current name: [$conf->{nic}{mac}{$this_mac}{current_name}]\n";
		if ($conf->{nic}{mac}{$this_mac}{link_state} ne "1")
		{
			$unplugged_macs .= "$this_mac,";
		}
	}
	
	# If there are less than two NICs and the user is trying to configure
	# the network, bail.
	if ((not $conf->{sys}{skip_network}) && ($nic_count != 2))
	{
		print "[ Error ] - Found a total of: [$nic_count] NIC(s).\n";
		print "[ Error ] - Two are needed for this program to work.\n";
		print "[ Error ] - Merged networks are not supported by this tool.\n";
		exit(4);
	}

	$unplugged_macs =~ s/,$//;
	#print "  DEBUG: unpluggd_macs: [$unplugged_macs]\n";
	return($unplugged_macs);
}

