#!/usr/bin/perl
#
# AN!CDB - Alteeve's Niche! Cluster Dashboard
# 
# This software is released under the GNU GPL v2+ license.
# 
# No warranty is provided. Do not use this software unless you are willing and
# able to take full liability for it's use. The authors take care to prevent
# unexpected side effects when using this program. However, no software is
# perfect and bugs may exist which could lead to hangs or crashes in the
# program, in your cluster and possibly even data loss.
# 
# If you are concerned about these risks, please stick to command line tools.
# 
# This program is designed to extend clusters built according to this tutorial:
# - https://alteeve.com/w/2-Node_Red_Hat_KVM_Cluster_Tutorial
#
# This program's source code and updates are available on Github:
# - https://github.com/digimer/an-cdb
#
# Author;
# Alteeve's Niche!  -  https://alteeve.com
# Madison Kelly     -  mkelly@alteeve.ca
# 

use strict;
use warnings;
use CGI;
use Encode;
use IO::Handle;
use CGI::Carp "fatalsToBrowser";

# Setup for UTF-8 mode.
binmode STDOUT, ":utf8:";
$ENV{'PERL_UNICODE'}=1;
my $THIS_FILE = "an-cdb.lib";

# This tries to ping a node given it's name. If it doesn't answer, it tries 
# again after adding/subtracting the '.remote' suffix. If that works, it will
# change the node name.
sub ping_node
{
	my ($conf, $node) = @_;
	
	my $exit;
	my $fh = IO::Handle->new;
	my $sc = "$conf->{path}{ping} -c 1 $node; echo ping:\$?";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^ping:(\d+)/)
		{
			$exit = $1;
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; exit: [$exit]\n");
	
	if ($exit)
	{
		my $old_node = $node;
		if ($node =~ /\.remote/)
		{
			$node =~ s/\.remote//;
		}
		else
		{
			$node .= ".remote";
		}
		my $sc = "$conf->{path}{ping} -c 1 $node; echo ping:\$?";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /^ping:(\d+)/)
			{
				$exit = $1;
			}
		}
		$fh->close();
		record($conf, "$THIS_FILE ".__LINE__."; exit: [$exit]\n");
		
		if ($exit)
		{
			record($conf, "$THIS_FILE ".__LINE__."; Unable to ping the node: [$old_node] at alternate name: [$node]\n");
			$node = $old_node;
		}
		else
		{
			record($conf, "$THIS_FILE ".__LINE__."; The node: [$old_node] appears to be available at: [$node], renaming.\n");
		}
	}
	else
	{
		record($conf, "$THIS_FILE ".__LINE__."; The node: [$node] is ping-able.\n");
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; Returning node: [$node].\n");
	return ($node);
}

# This does the actual call out to get the data and parse the returned data.
sub gather_node_details
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in gather_node_details() for node: [$node]\n");
	
	# This will flip true if I see 'start dmidecode' (the first line to
	# return from the client).
	$conf->{node}{$node}{connected}      = 0;
	$conf->{node}{$node}{info}{'state'}  = "<span class=\"highlight_unavailable\">Unknown</span>";
	$conf->{node}{$node}{info}{note}     = "";
	$conf->{node}{$node}{up}             = 0;
	$conf->{node}{$node}{enable_poweron} = 0;
	
	# Check to see if I can ping the nodes as they're named.
	#($node) = ping_node($conf, $node);
	
	# I echo 'start purpose:' before each call so that I know for
	# sure when I am switching between shell calls.
	my $sc =  "$conf->{path}{ssh} -o ConnectTimeout=10 root\@$node \"";
	   $sc .= "echo \\\"start dmidecode:\\\"; dmidecode -t 4,16,17; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start meminfo:\\\"; cat /proc/meminfo; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start drbd-status:\\\"; drbdadm status; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start drbd-res-file:\\\"; cat /etc/drbd.d/r?.res; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start clustat:\\\"; clustat; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start cluster.conf:\\\"; cat /etc/cluster/cluster.conf; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start daemons:\\\"; ";
	   $sc .= "/etc/init.d/rgmanager status; echo an-sve:rgmanager:\\\$?; ";
	   $sc .= "/etc/init.d/cman status; echo an-sve:cman:\\\$?; ";
	   $sc .= "/etc/init.d/drbd status; echo an-sve:drbd:\\\$?; ";
	   $sc .= "/etc/init.d/clvmd status; echo an-sve:clvmd:\\\$?; ";
	   $sc .= "/etc/init.d/gfs2 status; echo an-sve:gfs2:\\\$?; ";
	   $sc .= "/etc/init.d/libvirtd status; echo an-sve:libvirtd:\\\$?; ";
	   $sc .= "echo \\\"lvm-scan start:\\\"; pvscan; vgscan; lvscan; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"lvm-data start:\\\"; ";
	   $sc .= "pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid; ";
	   $sc .= "vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name; ";
	   $sc .= "lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices; ";
	   $sc .= "echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start gfs2:\\\"; cat /etc/fstab | grep gfs2 && df -hP; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start virsh:\\\"; virsh list --all; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start vm defs:\\\"; cat /shared/definitions/*; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond0:\\\"; cat /proc/net/bonding/bond0; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond1:\\\"; cat /proc/net/bonding/bond1; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond2:\\\"; cat /proc/net/bonding/bond2; echo \\\"#!end!#\\\"; ";
	   $sc .= "\"";
	   #$sc = "./data_${node}.txt";
	# These keep track of where I am.
	my $in_dmidecode     = 0;
	my $in_meminfo       = 0;
	my $in_drbd_status   = 0;
	my $in_drbd_res_file = 0;
	my $in_clustat       = 0;
	my $in_cluster_conf  = 0;
	my $in_daemons       = 0;
	my $in_lvm_scan      = 0;
	my $in_lvm_data      = 0;
	my $in_gfs2          = 0;
	my $in_virsh         = 0;
	my $in_vm_defs       = 0;
	my $in_bond          = 0;
	
	# This is used to track the bond I am reading.
	my $bond = "";
	
	# These store the data read.
	my @dmidecode;
	my @meminfo;
	my @drbd_status;
	my @drbd_res_file;
	my @clustat;
	my @cluster_conf;
	my @daemons;
	my @lvm_scan;
	my @lvm_data;
	my @gfs2;
	my @virsh;
	my @vm_defs;
	my @bond;
	
	### NOTE: This is over 1 KiB long and causes some IDEs, like 'kate', to
	### flip the file into read-only mode. Enable only when needed.
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	my $raw;
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	#open ($fh, "<$sc") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		#$raw .= $_;
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
		
		# This catches connectivity problems.
		if ($line =~ /No route to host/i)
		{
			my $local_access = on_same_network($conf, $node);
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">No Access</span>";
			if ($local_access)
			{
				$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. It is on an accessible subnet, so the node is likely off or there is a network problem.";
			}
			else
			{
				$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. The server running AN!CDB is not currently on the same subnet as the node.";
			}
			last;
		}
		elsif ($line =~ /host key verification failed/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Verification Failed!</span>";
			$conf->{node}{$node}{info}{note}    = "SSH host key validation failed.<br />Have you saved <span class=\"fixed_width\">${node}</span>'s fingerprint in <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file?<br />If this is a new issue, the physical node may have changed, requiring the old fingerprint be deleted and the new fingerprint be saved.<br />If the machine has not changed, then this might be a sign of an attempt to intercept your connection to the node.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /could not resolve hostname/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Bad Hostname!</span>";
			$conf->{node}{$node}{info}{note}    = "Could not resolve the hostname: <span class=\"fixed_width\">$node</span>. Have you setup your <span class=\"fixed_width\">/etc/hosts</span> file or DNS server properly?";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /permission denied/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Permission Denied!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. Have you added <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/id_rsa.pub</span> public key to <span class=\"fixed_width\">$node</span>'s <span class=\"fixed_width\">/root/.ssh/authorized_keys</span> file? If so, check <span class=\"fixed_width\">/var/log/secure</span> on <span class=\"fixed_width\">$node</span> for errors.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /connection refused/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Refused!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />Either it is refusing incoming connections or this machine does not have access to the node's subnet.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /Connection timed out/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Timed Out</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The connection timed out.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /Network is unreachable/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Network Unreachable</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The network is not reachable. Is this machine hosting this program on the same subnet?";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /\@\@\@\@/)
		{
			# When the host-key fails to match, a box made
			# of '@@@@' is displayed, and is the entire 
			# first line.
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. It appears that the node has changed! If this node failed and was replaced, be sure to remove the old key from <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file. If the node has not been replaced, then someone might be trying to trick you into logging into it.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		
		# Catch the end of sections
		if ($line =~ /#!end!#/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; end\n");
			$in_dmidecode    = 0;
			$in_meminfo      = 0;
			$in_drbd_status  = 0;
			$in_clustat      = 0;
			$in_cluster_conf = 0;
			$in_daemons      = 0;
			$in_lvm_scan     = 0;
			$in_lvm_data     = 0;
			$in_gfs2         = 0;
			$in_virsh        = 0;
			$in_vm_defs      = 0;
			$in_bond         = 0;
			$bond            = "";
		}
		#if ($line =~ /^start (.*?):/) { record($conf, "$THIS_FILE ".__LINE__."; start: [$line]\n"); }
		
		# Figure out where I am.
		if ($line =~ /^start dmidecode:/)
		{
			$conf->{node}{$node}{connected}     = 1;
			$in_dmidecode                       = 1;
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_good\">Up!</span>";
			next;
		}
		if ($line =~ /^start meminfo:/)       { $in_meminfo       = 1; next; }
		if ($line =~ /^start drbd-status:/)   { $in_drbd_status   = 1; next; }
		if ($line =~ /^start drbd-res-file:/) { $in_drbd_res_file = 1; next; }
		if ($line =~ /^start clustat:/)       { $in_clustat       = 1; next; }
		if ($line =~ /^start cluster.conf:/)  { $in_cluster_conf  = 1; next; }
		if ($line =~ /^start daemons:/)       { $in_daemons       = 1; next; }
		if ($line =~ /^lvm-scan start:/)      { $in_lvm_scan      = 1; next; }
		if ($line =~ /^lvm-data start:/)      { $in_lvm_data      = 1; next; }
		if ($line =~ /^start gfs2:/)          { $in_gfs2          = 1; next; }
		if ($line =~ /^start virsh:/)         { $in_virsh         = 1; next; }
		if ($line =~ /^start vm defs:/)       { $in_vm_defs       = 1; next; }
		if ($line =~ /^start vm defs:/)       { $in_vm_defs       = 1; next; }
		if ($line =~ /^start bond(\d+):/)
		{
			$bond       = $1;
			$in_vm_defs = 1;
			next;
		}
		
		# If I am in a section, push the lines into the
		# appropriate array.
		if ($in_dmidecode)     { push @dmidecode,     $line; }
		if ($in_meminfo)       { push @meminfo,       $line; }
		if ($in_drbd_status)   { push @drbd_status,   $line; }
		if ($in_drbd_res_file) { push @drbd_res_file, $line; }
		if ($in_clustat)       { push @clustat,       $line; }
		if ($in_cluster_conf)  { push @cluster_conf,  $line; }
		if ($in_daemons)       { push @daemons,       $line; }
		if ($in_lvm_scan)      { push @lvm_scan,      $line; }
		if ($in_lvm_data)      { push @lvm_data,      $line; }
		if ($in_gfs2)          { push @gfs2,          $line; }
		if ($in_virsh)         { push @virsh,         $line; }
		if ($in_vm_defs)       { push @vm_defs,       $line; }
		if ($in_bond)
		{
			push @bond, "$bond:$line";
		}
	}
	$fh->close();
	#record($conf, "$THIS_FILE ".__LINE__."; raw $node:\n===========================\n$raw\n===========================\n");
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], connected: [$conf->{node}{$node}{connected}], state: [$conf->{node}{$node}{info}{'state'}], note: [$conf->{node}{$node}{info}{note}]\n");
	if ($conf->{node}{$node}{connected})
	{
		$conf->{'system'}{show_nodes} = 1;
		$conf->{node}{$node}{up}      = 1;
		push @{$conf->{up_nodes}}, $node;
		parse_dmidecode    ($conf, $node, \@dmidecode);
		parse_meminfo      ($conf, $node, \@meminfo);
		parse_drbd_status  ($conf, $node, \@drbd_status);
		parse_drbd_res_file($conf, $node, \@drbd_res_file);
		parse_clustat      ($conf, $node, \@clustat);
		parse_cluster_conf ($conf, $node, \@cluster_conf);
		parse_daemons      ($conf, $node, \@daemons);
		parse_lvm_scan     ($conf, $node, \@lvm_scan);
		parse_lvm_data     ($conf, $node, \@lvm_data);
		parse_gfs2         ($conf, $node, \@gfs2);
		parse_virsh        ($conf, $node, \@virsh);
		parse_vm_defs      ($conf, $node, \@vm_defs);
		parse_bonds        ($conf, $node, \@bond);
		# Some stuff, like setting the system memory, needs some
		# post-scan math.
		post_node_calculations($conf, $node);
	}
	else
	{
		check_if_on($conf, $node);
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
		if ($conf->{node}{$node}{is_on} == 0)
		{
			$conf->{'system'}{show_nodes}         = 1;
			$conf->{node}{$node}{enable_poweron}  = 1;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{enable_fence}    = 0;
			#$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">Powered Off</span>";
			#$conf->{node}{$node}{info}{note}    = "The node <span class=\"fixed_width\">$node</span> is powered down.";
		}
		elsif ($conf->{node}{$node}{is_on} == 1)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 1;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 1;
			# Disable poweroff if I wasn't able to SSH into the
			# node.
			if (not $conf->{node}{$node}{connected})
			{
				$conf->{node}{$node}{enable_poweroff} = 0;
			}
			$conf->{node}{$node}{enable_fence}    = 1;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">No Access</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, but it is reported as being powered on.<br />If you just powered on this system, please wait a moment for it to boot.<br />If you just powered off this node, it might still be shutting down.<br /> Otherwise, the node may have crashed.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		elsif ($conf->{node}{$node}{is_on} == 2)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 0;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">Inaccesible</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />The out of band management interface's address, user name or password may have changed since it was last cached.<br />Please manually check the cluster and update the cluster's fencing information if needed.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		elsif ($conf->{node}{$node}{is_on} == 3)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 0;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">Inaccesible</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />The machine running the dashboard is not on the same subnet as the out of band management, so the node's current state is unknown.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		else
		{
			# Unable to determine node state.
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{enable_fence}    = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">No Access</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />Please check the network connections between this machine and the nodes.<br />If the power feeding the node was cut at the PDUs, fencing the node may restore access.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		
		# If I have confirmed the node is powered off, don't display this.
		#record($conf, "$THIS_FILE ".__LINE__."; enable power on: [$conf->{node}{$node}{enable_poweron}], task: [$conf->{cgi}{task}]\n");
		if ((not $conf->{node}{$node}{enable_poweron}) && (not $conf->{cgi}{task}))
		{
			print "
<table align=\"center\">
	<tr>
		<td>
			$conf->{node}{$node}{info}{'state'}
		</td>
		<td>
			$conf->{node}{$node}{info}{note}
		</td>
	</tr>
</table>
<br />
";
		}
	}
	
	return (0);
}

# This sets all of the daemons to a given state.
sub set_daemons
{
	my ($conf, $node, $state, $class) = @_;
	
	my @daemons = ("cman", "rgmanager", "drbd", "clvmd", "gfs2", "libvirtd");
	foreach my $daemon (@daemons)
	{
		$conf->{node}{$node}{daemon}{$daemon}{status}    = "<span class=\"$class\">$state</span>";
		$conf->{node}{$node}{daemon}{$daemon}{exit_code} = "";
	}
	return(0);
}

# This checks to see if the node's power is on, when possible.
sub check_if_on
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in check_if_on(); node: [$node]\n");
	
	# If the peer is on, use it to check the power.
	my $peer                    = "";
	$conf->{node}{$node}{is_on} = 9;
	#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
	if ($conf->{'system'}{up_nodes} == 1)
	{
		# It has to be the peer of this node.
		$peer = @{$conf->{up_nodes}}[0];
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
	if ($peer)
	{
		# Check the power state using the peer node.
		if (not $conf->{node}{$node}{info}{power_check_command})
		{
			error($conf, "I was asked to check the power staus of: [$node] via it's peer: [$peer], but the power check command is empty.<br />\nThis is likely a program error.\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		my $sc = "$conf->{path}{ssh} root\@$peer \"$conf->{node}{$node}{info}{power_check_command} -o status\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ / On$/i)
			{
				$conf->{node}{$node}{is_on} = 1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
			}
			if ($line =~ / Off$/i)
			{
				$conf->{node}{$node}{is_on} = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
			}
		}
		$fh->close();
	}
	else
	{
		# Read the cache and check the power directly, if possible.
		read_node_cache($conf, $node);
		$conf->{node}{$node}{info}{power_check_command} = "" if not defined $conf->{node}{$node}{info}{power_check_command};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		if ($conf->{node}{$node}{info}{power_check_command})
		{
			# Get the address from the command and see if it's in
			# one of my subnet.
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			my $local_access = on_same_network($conf, $target_host);
			
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], local_access: [$local_access]\n");
			if ($local_access)
			{
				# I can reach it directly
				my $sc = "$conf->{node}{$node}{info}{power_check_command} -o status";
				#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
					if ($line =~ / On$/i)
					{
						$conf->{node}{$node}{is_on} = 1;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
					}
					if ($line =~ / Off$/i)
					{
						$conf->{node}{$node}{is_on} = 0;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
					}
					if ($line =~ / Unknown$/i)
					{
						$conf->{node}{$node}{is_on} = 2;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}] - Failed to get info from IPMI!\n");
					}
				}
				$fh->close();
			}
			else
			{
				# I can't reach it from here.
				#record($conf, "$THIS_FILE ".__LINE__."; This machine is not on the same network out of band management interface: [$target_host] for node: [$node], unable to check power state.\n");
				$conf->{node}{$node}{is_on} = 3;
			}
		}
		else
		{
			# No power-check command
			$conf->{node}{$node}{is_on} = 4;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}] - Unable to find power check command!\n");
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
	if ($conf->{node}{$node}{is_on} == 0)
	{
		# I need to preset the services as stopped because the little
		# hack I have below doesn't echo when a service isn't running.
		$conf->{node}{$node}{enable_poweron} = 1;
		set_daemons($conf, $node, "Offline", "highlight_unavailable");
	}
	
	return(0);
}

# This takes a host name (or IP) and sees if it's reachable from the machine
# running this program.
sub on_same_network
{
	my ($conf, $target_host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in on_same_network(); target host: [$target_host]\n");
	
	my $local_access = 0;
	my $target_ip;
	
	my $sc = "$conf->{path}{gethostip} -d $target_host";
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^(\d+\.\d+\.\d+\.\d+)$/)
		{
			$target_ip = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; target_ip: [$target_ip]\n");
		}
		elsif ($line =~ /Unknown host/i)
		{
			#Failed to resolve
			error($conf, "I was trying to resolve the host name: [$target_host] but was unable to do so. Is this a valid host name? If so, do you have an entry in DNS or in your /etc/hosts file?\n");
		}
		elsif ($line =~ /Usage: gethostip/i)
		{
			#No hostname parsed out.
			error($conf, "I was trying to resolve a host name, but no name was given. This is likely a program error.\n");
		}
	}
	$fh->close();
	
	#record($conf, "$THIS_FILE ".__LINE__."; target_ip: [$target_ip]\n");
	if ($target_ip)
	{
		# Find out my own IP(s) and subnet(s).
		my $in_dev       = "";
		my $this_ip      = "";
		my $this_nm      = "";
		
		my $sc           = "$conf->{path}{ifconfig}";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /^(.*?)\s+Link encap/)
			{
				$in_dev = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; in_dev: [$in_dev]\n");
				next;
			}
			elsif ($line =~ /^(.*?): flags/)
			{
				$in_dev = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; in_dev: [$in_dev]\n");
				next;
			}
			if (not $line)
			{
				# See if this network gives me access 
				# to the power check device.
				my $target_ip_range = $target_ip;
				my $this_ip_range   = $this_ip;
				#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip: [$this_ip]\n");
				if ($this_nm eq "255.255.255.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+$//;
					$this_ip_range   =~ s/.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				if ($this_nm eq "255.255.0.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+.\d+$//;
					$this_ip_range   =~ s/.\d+.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				if ($this_nm eq "255.0.0.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+.\d+.\d+$//;
					$this_ip_range   =~ s/.\d+.\d+.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				if ($this_ip_range eq $target_ip_range)
				{
					# Match! I can reach it directly.
					$local_access = 1;
					#record($conf, "$THIS_FILE ".__LINE__."; local_access: [$local_access]\n");
					last;
				}
				
				$in_dev = "";
				$this_ip = "";
				$this_nm = "";
				next;
			}
			
			if ($in_dev)
			{
				next if $line !~ /inet /;
				if ($line =~ /inet addr:(\d+\.\d+\.\d+\.\d+) /)
				{
					$this_ip = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_ip: [$this_ip]\n");
				}
				elsif ($line =~ /inet (\d+\.\d+\.\d+\.\d+) /)
				{
					$this_ip = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_ip: [$this_ip]\n");
				}
				
				if ($line =~ /Mask:(\d+\.\d+\.\d+\.\d+)/i)
				{
					$this_nm = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_nm: [$this_nm]\n");
				}
				elsif ($line =~ /netmask (\d+\.\d+\.\d+\.\d+) /)
				{
					$this_nm = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_nm: [$this_nm]\n");
				}
			}
		}
		$fh->close();
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; local_access: [$local_access]\n");
	return($local_access);
}

# This records this scan's data to the cache file.
sub write_node_cache
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in write_node_cache(); node: [$node]\n");
	
	# It's a program error to try and write the cache file when the node
	# is down.
	my $cluster    = $conf->{cgi}{cluster};
	my $cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".an-cdb";
	if (($conf->{node}{$node}{info}{host_name}) && ($conf->{node}{$node}{info}{power_check_command}))
	{
		# Write the command to disk so that I can check the power state
		# in the future when both nodes are offline.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		my $fh         = IO::Handle->new();
		#record($conf, "$THIS_FILE ".__LINE__."; writting: [$cache_file]\n");
		open ($fh, "> $cache_file") or error($conf, "Failed to write: [<span class=\"fixed_width\">$cache_file</span>] as UID: [<span class=\"fixed_width\">$<</span>].<br />The error was: <span class=\"fixed_width\">$!</span>\n");
		
		print $fh "host_name = $conf->{node}{$node}{info}{host_name}\n";
		print $fh "power_check_command = $conf->{node}{$node}{info}{power_check_command}\n";
		print $fh "fence_methods = $conf->{node}{$node}{info}{fence_methods}\n";
		
		$fh->close();
	}
	elsif (not -e $cache_file)
	{
		# I've probably never seen the cache file before, so don't
		# error out.
	}
	else
	{
		#error($conf, "I was asked to write the cache file for: [$node], but I didn't have all the cache data.<br />\nI was passed; host name: [$conf->{node}{$node}{info}{host_name}], power check command: [$conf->{node}{$node}{info}{power_check_command}].<br />\nThis is likely a program error.\n");
	}
	
	return(0);
}

# This reads the cached data for this node, if available.
sub read_node_cache
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in read_node_cache(); node: [$node]\n");
	
	# Write the command to disk so that I can check the power state
	# in the future when both nodes are offline.
	my $cluster    = $conf->{cgi}{cluster};
	my $cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".an-cdb";
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster], cache file: [$cache_file]\n");
	if (not -e $cache_file)
	{
		# See if there is a version with or without '<node>.remote'
		if ($node =~ /\.remote/)
		{
			# Strip it off
			$cache_file =~ s/\.remote//;
		}
		else
		{
			# Add the .remote suffix.
			$cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".remote.an-cdb";
		}
	}
	if (-e $cache_file)
	{
		# It exists! Read it.
		my $sc = $cache_file;
		#record($conf, "$THIS_FILE ".__LINE__."; Reading: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or die "Failed to read: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			next if $line !~ /=/;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			#record($conf, "$THIS_FILE ".__LINE__."; var: [$var], val: [$val]\n");
			$conf->{node}{$node}{info}{$var} = $val;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], var: [$var] -> [$conf->{node}{$node}{info}{$var}]\n");
		}
		$fh->close();
	}
	else
	{
		$conf->{node}{$node}{info}{host_name} = $node;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; host name: [$conf->{node}{$node}{info}{host_name}], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
	
	return(0);
}

# This parse bond data
sub parse_bonds
{
	my ($conf, $node, $array) = @_;
	
	
	return (0);
}

# This (tries to) parse the VM definitions files.
sub parse_vm_defs
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_vm_defs() for node: [$node]\n");
	my $this_vm    = "";
	my $in_domain  = 0;
	my $this_array = [];
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		# Find the start of a domain.
		if ($line =~ /<domain/)
		{
			$in_domain = 1;
		}
		
		# Get this name of the current domain
		if ($line =~ /<name>(.*?)<\/name>/)
		{
			$this_vm = $1;
		}
		
		# Push all lines into the current domain array.
		if ($in_domain)
		{
			push @{$this_array}, $line;
		}
		
		# When the end of a domain is found, push the array over to
		# $conf.
		if ($line =~ /<\/domain>/)
		{
			my $vm_key = "vm:$this_vm";
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$this_vm], array: [$this_array], lines: [".@{$this_array}."]\n");
			$conf->{vm}{$vm_key}{xml} = $this_array;
			$in_domain  = 0;
			$this_array = [];
		}
	}
	
	return (0);
}

# Parse the dmidecode data.
sub parse_dmidecode
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_dmidecode() for node: [$node]\n");
	#foreach my $line (@{$array}) { record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n"); }
	
	# Some variables I will need.
	my $in_cpu           = 0;
	my $in_system_ram    = 0;
	my $in_dimm_module   = 0;
	
	# On SMP machines, the CPU socket becomes important. This 
	# tracks which CPU I am looking at.
	my $this_socket      = "";
	
	# Same deal with volume groups.
	my $this_vg          = "";
	
	# RAM is all over the place, so I need to record all the bits
	# in strings and push to the hash when I see a blank line.
	my $dimm_locator     = "";
	my $dimm_bank        = "";
	my $dimm_size        = "";
	my $dimm_type        = "";
	my $dimm_speed       = "";
	my $dimm_form_factor = "";
	
	# This will be set to the values I find on this node.
	$conf->{node}{$node}{hardware}{total_node_cores}   = 0;
	$conf->{node}{$node}{hardware}{total_node_threads} = 0;
	$conf->{node}{$node}{hardware}{total_memory}       = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	
	# These will be set to the lowest available RAM, and CPU core
	# available.
	$conf->{resources}{total_cores}   = 0;
	$conf->{resources}{total_threads} = 0;
	$conf->{resources}{total_ram}     = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; Cluster; total cores: [$conf->{resources}{total_cores}], total threads: [$conf->{resources}{total_threads}], total memory: [$conf->{resources}{total_ram}]\n");
	
	foreach my $line (@{$array})
	{
		if ($line =~ /dmidecode: command not found/)
		{
			die "Unable to read system information on node: [$node]. Is 'dmidecode' installed?";
		}
		
		# Find out what I am looking at.
		if (not $line)
		{
			# Blank lines break sections.
			# If I had been reading DIMM info, push it into
			# the hash.
			if ($in_dimm_module)
			{
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{bank}        = $dimm_bank;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{size}        = $dimm_size;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{type}        = $dimm_type;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{speed}       = $dimm_speed;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{form_factor} = $dimm_form_factor;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], dimm: [$dimm_locator], bank: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{bank}], size: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{size}], type: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{type}], speed: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{speed}], form factor: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{form_factor}]\n");
			}
			$in_cpu         = 0;
			$in_system_ram  = 0;
			$in_dimm_module = 0;
			$this_socket    = "";
			$this_vg        = "";
			next;
		}
		if ($line =~ /Processor Information/)
		{
			$in_cpu         = 1;
			next;
		}
		if ($line =~ /Physical Memory Array/)
		{
			$in_system_ram  = 1;
			next;
		}
		if ($line =~ /Memory Device/)
		{
			$in_dimm_module = 1;
			next;
		}
		if ((not $in_cpu) && (not $in_system_ram) && (not $in_dimm_module))
		{
			next;
		}
		
		# Now pull out data based on where I am.
		if ($in_cpu)
		{
			# The socket is the first line, so I can safely
			# assume that 'this_socket' will be populated
			# after this.
			if ($line =~ /Socket Designation: (.*)/)
			{
				$this_socket = $1;
				next;
			}
			
			# Grab some deets!
			if ($line =~ /Family: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{family}    = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu family: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{family}]\n");
			}
			if ($line =~ /Manufacturer: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{oem}       = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu oem: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{oem}]\n");
			}
			if ($line =~ /Version: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{version}   = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu version: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{version}]\n");
			}
			if ($line =~ /Max Speed: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{max_speed} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu max speed: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{max_speed}]\n");
			}
			if ($line =~ /Status: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{status}    = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu status: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{status}]\n");
			}
			if ($line =~ /Core Count: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores} =  $1;
				$conf->{node}{$node}{hardware}{total_node_cores}         += $conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores};
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], socket cores: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores}], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}]\n");
			}
			if ($line =~ /Thread Count: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads} =  $1;
				$conf->{node}{$node}{hardware}{total_node_threads}         += $conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads};
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], socket threads: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}]\n");
			}
		}
		if ($in_system_ram)
		{
			# Not much in system RAM, but good to know stuff.
			if ($line =~ /Error Correction Type: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{ecc_support} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], RAM ECC: [$conf->{node}{$node}{hardware}{ram}{ecc_support}]\n");
			}
			if ($line =~ /Number Of Devices: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{slots}       = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], RAM slots: [$conf->{node}{$node}{hardware}{ram}{slots}]\n");
			}
			# This needs to be converted to bytes.
			if ($line =~ /Maximum Capacity: (\d+) (.*)$/)
			{
				my $size   = $1;
				my $suffix = $2;
				$conf->{node}{$node}{hardware}{ram}{max_support} = hr_to_bytes($conf, $size, $suffix, 1);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], max. supported RAM: [$conf->{node}{$node}{hardware}{ram}{max_support}]\n");
			}
			if ($line =~ /Maximum Capacity: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{max_support} = $1;
				$conf->{node}{$node}{hardware}{ram}{max_support} = hr_to_bytes($conf, $conf->{node}{$node}{hardware}{ram}{max_support}, "", 1);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], max. supported RAM: [$conf->{node}{$node}{hardware}{ram}{max_support}]\n");
			}
		}
		if ($in_dimm_module)
		{
			if ($line =~ /Locator: (.*)/)      { $dimm_locator     = $1; }
			if ($line =~ /Bank Locator: (.*)/) { $dimm_bank        = $1; }
			if ($line =~ /Type: (.*)/)         { $dimm_type        = $1; }
			if ($line =~ /Speed: (.*)/)        { $dimm_speed       = $1; }
			if ($line =~ /Form Factor: (.*)/)  { $dimm_form_factor = $1; }
			if ($line =~ /Size: (.*)/)
			{
				$dimm_size = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size]\n");
				# If the DIMM couldn't be read, it will
				# show "Unknown". I set this to 0 in 
				# that case.
				if ($dimm_size !~ /^\d/)
				{
					$dimm_size = 0;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size]\n");
				}
				else
				{
					$dimm_size                                   =  hr_to_bytes($conf, $dimm_size, "", 1);
					$conf->{node}{$node}{hardware}{total_memory} += $dimm_size;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
				}
			}
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; Cluster; total cores: [$conf->{resources}{total_cores}], total threads: [$conf->{resources}{total_threads}], total memory: [$conf->{resources}{total_ram}]\n");
	return(0);
}

# Parse the memory information.
sub parse_meminfo
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_meminfo() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /MemTotal:\s+(.*)/)
		{
			$conf->{node}{$node}{hardware}{meminfo}{memtotal} = $1;
			$conf->{node}{$node}{hardware}{meminfo}{memtotal} = hr_to_bytes($conf, $conf->{node}{$node}{hardware}{meminfo}{memtotal}, "", 1);
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], meminfo total memory: [$conf->{node}{$node}{hardware}{meminfo}{memtotal}]\n");
		}
	}
	
	return(0);
}

# Parse the DRBD status.
sub parse_drbd_status
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_drbd_status() for node: [$node]\n");
	my $resources = 0;
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if $line !~ /^<resource /;
		$resources++;
		
		# Make sure I only display "unknown" or the read value.
		my $minor = "--";
		my $res   = "--";
		my $cs    = "--";
		my $ro    = "--";
		my $ds    = "--";
		my $dev   = "--";
		($minor) = ($line =~ /minor="(.*?)"/);
		($res)   = ($line =~ /name="(.*?)"/);
		($cs)    = ($line =~ /cs="(.*?)"/);
		($ro)    = ($line =~ /ro1="(.*?)"/);
		($ds)    = ($line =~ /ds1="(.*?)"/);
		$dev = "/dev/drbd$minor" if $minor =~ /^\d+$/;
		
		# This is the new way of recording.
		$conf->{drbd}{$res}{node}{$node}{minor}            = $minor ? $minor : "--";
		$conf->{drbd}{$res}{node}{$node}{connection_state} = $cs    ? $cs    : "--";
		$conf->{drbd}{$res}{node}{$node}{role}             = $ro    ? $ro    : "--";
		$conf->{drbd}{$res}{node}{$node}{disk_state}       = $ds    ? $ds    : "--";
		$conf->{drbd}{$res}{node}{$node}{device}           = $dev   ? $dev   : "--";
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], New - res: [$res], minor: [$conf->{drbd}{$res}{node}{$node}{minor}], cs: [$conf->{drbd}{$res}{node}{$node}{connection_state}], ro: [$conf->{drbd}{$res}{node}{$node}{role}], ds: [$conf->{drbd}{$res}{node}{$node}{disk_state}], dev: [$conf->{drbd}{$res}{node}{$node}{device}]\n");
	}
	if (not $resources)
	{
		# DRBD isn't running.
		record($conf, "$THIS_FILE ".__LINE__."; DRBD does not appear to be running on node: [$node]\n");
	}
	
	return(0);
}

# This reads the DRBD resource details from the resource definition files.
sub parse_drbd_res_file
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_drbd_res_file() for node: [$node]\n");
	
	my $in_res      = "";
	my $in_on       = "";
	my $this_device = "--";
	
	my $resources = 0;
	foreach my $line (@{$array})
	{
		$line =~ s/#.*//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		if ($line =~ /^resource (.*?) {/)
		{
			$in_res = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res]\n");
			next;
		}
		
		if ($in_res)
		{
			if ($line =~ /on (.*?) {/)
			{
				$in_on = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res], on: [$in_on]\n");
				next;
			}
			if ($in_on)
			{
				# I don't want the closing brace of an 
				# "on ... {" directive closing "in_res" early.
				if ($line eq "}")
				{
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], closing 'on': [$in_on]\n");
					$in_on = "";
					next;
				}
			}
			else
			{
				if ($line eq "}")
				{
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], closing 'res': [$in_res]\n");
					$conf->{node}{$node}{drbd}{res_file}{$in_res}{device}           = $this_device;
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{device}           = $this_device;
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{connection_state} = "--";
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{role}             = "--";
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{disk_state}       = "--";
					
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res], device: [$conf->{node}{$node}{drbd}{res_file}{$in_res}{device}]\n");
					$in_res      = "";
					$this_device = "--";
				}
				if ($line =~ /device\s+(.*?);/)
				{
					$this_device = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], device: [$this_device]\n");
				}
			}
		}
	}
	
	return(0);
}

# Parse the cluster status.
sub parse_clustat
{
	my ($conf, $node, $array) = @_;
	
	# Setup some variables.
	my $in_member  = 0;
	my $in_service = 0;
	my $line_num   = 0;
	
	my $host_name                         = "unknown";
	my $storage_name                      = "unknown";
	my $storage_state                     = "unknown";
	$conf->{node}{$node}{me}{cman}        = 0;
	$conf->{node}{$node}{me}{rgmanager}   = 0;
	$conf->{node}{$node}{peer}{cman}      = 0;
	$conf->{node}{$node}{peer}{rgmanager} = 0;
	$conf->{node}{$node}{enable_join}     = 0;
	$conf->{node}{$node}{get_host_from_cluster_conf} = 0;

	### NOTE: This check seems odd, but I've run intp cases where a node,
	###       otherwise behaving fine, simple returns nothing when cman is
	###       off. Couldn't reproduce on the command line.
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_clustat() for node: [$node]\n");
	my $line_count = @{$array};
	if (not $line_count)
	{
		# CMAN isn't running.
		record($conf, "$THIS_FILE ".__LINE__."; CMAN does not appear to be running on node: [$node] (nothing returned by the 'clustat' call).\n");
		$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
		$conf->{node}{$node}{enable_join}                = 1;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; Will parse: [$line_count] lines.\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Could not connect to CMAN/i)
		{
			# CMAN isn't running.
			record($conf, "$THIS_FILE ".__LINE__."; CMAN does not appear to be running on node: [$node]\n");
			$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
			$conf->{node}{$node}{enable_join}                = 1;
		}
		next if not $line;
		next if $line =~ /^-/;
		
		if ($line =~ /^Member Name/)
		{
			$in_member  = 1;
			$in_service = 0;
			next;
		}
		elsif ($line =~ /^Service Name/)
		{
			$in_member  = 0;
			$in_service = 1;
			next;
		}
		if ($in_member)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /Local/)
			{
				($conf->{node}{$node}{me}{name}, undef, my $services) = (split/ /, $line, 3);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - me: [$conf->{node}{$node}{me}{name}], services: [$services]\n");
				$services =~ s/local//;
				$services =~ s/ //g;
				$services =~ s/,,/,/g;
				$conf->{node}{$node}{me}{cman}      =  1 if $services =~ /Online/;
				$conf->{node}{$node}{me}{rgmanager} =  1 if $services =~ /rgmanager/;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - Me   -> [$conf->{node}{$node}{me}{name}]; cman: [$conf->{node}{$node}{me}{cman}], rgmanager: [$conf->{node}{$node}{me}{rgmanager}]\n");
			}
			else
			{
				($conf->{node}{$node}{peer}{name}, undef, my $services) = split/ /, $line, 3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - peer: [$conf->{node}{$node}{peer}{name}], services: [$services]\n");
				$services =~ s/ //g;
				$services =~ s/,,/,/g;
				$conf->{node}{peer}{cman}      = 1 if $services =~ /Online/;
				$conf->{node}{peer}{rgmanager} = 1 if $services =~ /rgmanager/;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - Peer -> [$conf->{node}{$node}{peer}{name}]; cman: [$conf->{node}{peer}{cman}], rgmanager: [$conf->{node}{peer}{rgmanager}]\n");
			}
		}
		elsif ($in_service)
		{
			if ($line =~ /^vm:/)
			{
				my ($vm, $host, $state) = split/ /, $line, 3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$host], state: [$state]\n");
				if ($state eq "disabled")
				{
					$host = "none";
				}
				
				# If the service is disabled, it will 
				# have '()' which I need to remove.
				$host =~ s/\(//g;
				$host =~ s/\)//g;
				
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$host]\n");
				$host = "none" if not $host;
				$conf->{vm}{$vm}{host}    = $host;
				$conf->{vm}{$vm}{'state'} = $state;
				# TODO: If the state is "failed", call 
				# 'virsh list --all' against both nodes. If the
				# VM is found, try to recover the service.
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$conf->{vm}{$vm}{host}], state: [$conf->{vm}{$vm}{'state'}]\n");
				
				# Pick out who the peer node is.
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host: [$host], me: [$conf->{node}{$node}{me}{name}]\n");
				if ($host eq $conf->{node}{$node}{me}{name})
				{
					$conf->{vm}{$vm}{peer} = $conf->{node}{$node}{peer}{name};
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], peer: [$conf->{vm}{$vm}{peer}]\n");
				}
				else
				{
					$conf->{vm}{$vm}{peer} = $conf->{node}{$node}{me}{name};
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], peer: [$conf->{vm}{$vm}{peer}]\n");
				}
			}
			elsif ($line =~ /^service:(.*?)\s+(.*?)\s+(.*)$/)
			{
				my $name  = $1;
				my $host  = $2;
				my $state = $3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name], host: [$host], state: [$state]\n");
				
				# If the service is disabled, it will 
				# have '()' which I need to remove.
				$host =~ s/\(//g;
				$host =~ s/\)//g;
				
				$conf->{service}{$name}{host}    = $host;
				$conf->{service}{$name}{'state'} = $state;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name], host: [$conf->{service}{$name}{host}], state: [$conf->{service}{$name}{'state'}]\n");
			}
		}
	}
	
	# If this is set, the cluster isn't running.
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
	if (not $conf->{node}{$node}{get_host_from_cluster_conf})
	{
		$host_name = $conf->{node}{$node}{me}{name};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host name: [$host_name]\n");
		foreach my $name (sort {$a cmp $b} keys %{$conf->{service}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name]\n");
			next if $conf->{service}{$name}{host} ne $host_name;
			next if $name !~ /storage/;
			$storage_name  = $name;
			$storage_state = $conf->{service}{$name}{'state'};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - storage name: [$storage_name], storage state: [$storage_state]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host name: [$host_name]\n");
		if ($host_name)
		{
			$conf->{node}{$node}{info}{host_name}            =  $host_name;
			$conf->{node}{$node}{info}{short_host_name}      =  $host_name;
			$conf->{node}{$node}{info}{short_host_name}      =~ s/\..*$//;
			$conf->{node}{$node}{get_host_from_cluster_conf} = 0;
		}
		else
		{
			$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
		$conf->{node}{$node}{info}{storage_name}    = $storage_name;
		$conf->{node}{$node}{info}{storage_state}   = $storage_state;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - host name: [$conf->{node}{$node}{info}{host_name}], short host name: [$conf->{node}{$node}{info}{short_host_name}], storage name: [$conf->{node}{$node}{info}{storage_name}], storage state: [$conf->{node}{$node}{info}{storage_state}]\n");
	}
	
	return(0);
}

# Parse the cluster configuration.
sub parse_cluster_conf
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_cluster_conf(); node: [$node]\n");
	
	my $in_fod          = 0;
	my $current_fod     = "";
	my $in_node         = "";
	my $in_fence        = 0;
	my $in_method       = "";
	my $device_count    = 0;
	my $in_fence_device = 0;
	my $this_host_name  = "";
	my $this_node       = "";
	my $method_counter  = 0;
	
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
		
		# Find failover domains.
		if ($line =~ /<failoverdomain /)
		{
			$current_fod = ($line =~ /name="(.*?)"/)[0];
			#record($conf, "$THIS_FILE ".__LINE__."; current_fod: [$current_fod]\n");
			$in_fod      = 1;
			next;
		}
		if ($line =~ /<\/failoverdomain>/)
		{
			$current_fod = "";
			$in_fod      = 0;
			next;
		}
		if ($in_fod)
		{
			next if $line !~ /failoverdomainnode/;
			my $node     = ($line =~ /name="(.*?)"/)[0];
			my $priority = ($line =~ /priority="(.*?)"/)[0] ? $1 : 0;
			$conf->{failoverdomain}{$current_fod}{priority}{$priority}{node} = $node;
			#record($conf, "$THIS_FILE ".__LINE__."; failover domain: [$current_fod], node: [$conf->{failoverdomain}{$current_fod}{priority}{$priority}{node}], priority: [$priority]\n");
		}
		
		# If I didn't get the hostname from clustat, try to find it here.
		if ($line =~ /<clusternode.*?name="(.*?)"/)
		{
			   $this_host_name  =  $1;
			my $short_host_name =  $this_host_name;
			   $short_host_name =~ s/\..*$//;
			my $short_node_name =  $node;
			   $short_node_name =~ s/\..*$//;
			   
			# If I need to record the host name from cluster.conf,
			# do so here.
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], short host name: [$short_host_name], short node name: [$short_node_name], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
			if ($short_host_name eq $short_node_name)
			{
				# Found it.
				if ($conf->{node}{$node}{get_host_from_cluster_conf})
				{
					$conf->{node}{$node}{info}{host_name}            = $this_host_name;
					$conf->{node}{$node}{info}{short_host_name}      = $short_host_name;
					$conf->{node}{$node}{get_host_from_cluster_conf} = 0;
				}
				$this_node = $node;
			}
			else
			{
				$this_node = get_peer_node($conf, $node);
				if (not $conf->{node}{$this_node}{host_name})
				{
					$conf->{node}{$this_node}{info}{host_name}       = $this_host_name;
					$conf->{node}{$this_node}{info}{short_host_name} = $short_host_name;
				}
			}
			
			# Mark that I am in a node child element.
			$in_node = $node;
		}
		if ($line =~ /<\/clusternode>/)
		{
			# Record my fence findings.
			$in_node        = "";
			$this_node      = "";
			$method_counter = 0;
		}
		
		if (($in_node) && ($line =~ /<fence>/))
		{
			$in_fence = 1;
		}
		if ($line =~ /<\/fence>/)
		{
			$in_fence = 0;
		}
		if (($in_fence) && ($line =~ /<method.*name="(.*?)"/))
		{
			# The method counter ensures ordered use of the fence
			# devices.
			$in_method = "$method_counter:$1";
			$method_counter++;
		}
		if ($line =~ /<\/method>/)
		{
			$in_method    = "";
			$device_count = 0;
		}
		if (($in_method) && ($line =~ /<device\s/))
		{
			my $name   = $line =~ /name="(.*?)"/   ? $1 : "";
			my $port   = $line =~ /port="(.*?)"/   ? $1 : "";
			my $action = $line =~ /action="(.*?)"/ ? $1 : "";
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}   = $name;
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}   = $port;
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action} = $action;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node], method: [$in_method], method count: [$device_count], name: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}], port: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}], action: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}]\n");
			$device_count++;
		}
		
		# Parse out the fence device details.
		if ($line =~ /<fencedevices>/)
		{
			$in_fence_device = 1;
		}
		if ($line =~ /<\/fencedevices>/)
		{
			$in_fence_device = 0;
		}
		# This could be duplicated, but I don't care as cluster.conf
		# has to be the same on both nodes, anyway.
		if ($in_fence_device)
		{
			my $name     = $line =~ /name="(.*?)"/   ? $1 : "";
			my $agent    = $line =~ /agent="(.*?)"/  ? $1 : "";
			my $address  = $line =~ /ipaddr="(.*?)"/ ? $1 : "";
			my $login    = $line =~ /login="(.*?)"/  ? $1 : "";
			my $password = $line =~ /passwd="(.*?)"/ ? $1 : "";
			$conf->{fence}{$name}{agent}    = $agent;
			$conf->{fence}{$name}{address}  = $address;
			$conf->{fence}{$name}{login}    = $login;
			$conf->{fence}{$name}{password} = $password;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], fence name: [$name], agent: [$conf->{fence}{$name}{agent}], address: [$conf->{fence}{$name}{address}], login: [$conf->{fence}{$name}{login}], password: [$conf->{fence}{$name}{password}]\n");
		}
		
		# Find VMs.
		if ($line =~ /<vm.*?name="(.*?)"/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			my $vm     = $1;
			my $vm_key = "vm:$vm";
			my $def    = ($line =~ /path="(.*?)"/)[0].$vm.".xml";
			my $domain = ($line =~ /domain="(.*?)"/)[0];
			# I need to set the host to 'none' to avoid triggering
			# the error caused by seeing and foo.xml VM def outside
			# of here.
			#record($conf, "$THIS_FILE ".__LINE__."; vm_key: [$vm_key], def: [$def], domain: [$domain]\n");
			$conf->{vm}{$vm_key}{definition_file} = $def;
			$conf->{vm}{$vm_key}{failover_domain} = $domain;
			$conf->{vm}{$vm_key}{host}            = "none" if not $conf->{vm}{$vm_key}{host};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm_key: [$vm_key], definition: [$conf->{vm}{$vm_key}{definition_file}], host: [$conf->{vm}{$vm_key}{host}]\n");
		}
	}
	
	# See if I got the fence details for both nodes.
	my $peer = get_peer_node($conf, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
	foreach my $this_node ($node, $peer)
	{
		# This will contain possible fence methods.
		$conf->{node}{$this_node}{info}{fence_methods} = "";
		
		# This will contain the command needed to check the node's
		# power.
		$conf->{node}{$this_node}{info}{power_check_command} = "";
		
		#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node]\n");
		foreach my $in_method (sort {$a cmp $b} keys %{$conf->{node}{$this_node}{fence}{method}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node], method: [$in_method]\n");
			my $fence_command = "$in_method: ";
			foreach my $device_count (sort {$a cmp $b} keys %{$conf->{node}{$this_node}{fence}{method}{$in_method}{device}})
			{
				#$fence_command .= " [$device_count]";
				#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node], method: [$in_method], method count: [$device_count], name: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}], port: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}], action: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}]\n");
				#Find the matching fence device entry.
				foreach my $name (sort {$a cmp $b} keys %{$conf->{fence}})
				{
					if ($name eq $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name})
					{
						my $agent    = $conf->{fence}{$name}{agent};
						my $address  = $conf->{fence}{$name}{address};
						my $login    = $conf->{fence}{$name}{login};
						my $password = $conf->{fence}{$name}{password};
						my $port     = $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port};
						#my $action   = $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action};
						#   $action   = "reboot" if not $action;
						my $command  = "$agent -a $address ";
						   $command .= "-l $login "        if $login;
						   $command .= "-p \"$password\" " if $password;	# quote the password in case it has spaces in it.
						   $command .= "-n $port "         if $port;
						   $command =~ s/ $//;
						$conf->{node}{$this_node}{fence_method}{$in_method}{device}{$device_count}{command} = $command;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node], fence command: [$conf->{node}{$this_node}{fence_method}{$in_method}{device}{$device_count}{command}]\n");
						if ($agent eq "fence_ipmilan")
						{
							$conf->{node}{$this_node}{info}{power_check_command} = $command;
							#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: power check command: [$conf->{node}{$this_node}{info}{power_check_command}]\n");
						}
						$fence_command .= "$command -o #!action!#; ";
					}
				}
			}
			# Record the fence command.
			$fence_command =~ s/ $/. /;
			if ($node eq $this_node)
			{
				$conf->{node}{$node}{info}{fence_methods} .= "$fence_command";
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: fence command: $conf->{node}{$node}{info}{fence_methods}\n");
			}
			else
			{
				$conf->{node}{$peer}{info}{fence_methods} .= "$fence_command";
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: peer: [$peer], fence command: $conf->{node}{$peer}{info}{fence_methods}\n");
			}
		}
		$conf->{node}{$this_node}{info}{fence_methods} =~ s/\s+$//;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], fence command: [$conf->{node}{$node}{info}{fence_methods}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; peer: [$peer], fence command: [$conf->{node}{$peer}{info}{fence_methods}]\n");
	
	# If the host name was set, then I can trust that I had good data.
	if ($conf->{node}{$node}{info}{host_name})
	{
		# Find out if the nodes are powered up or not.
		write_node_cache($conf, $node);
	}
	
	return(0);
}

# This takes a node name and returns the peer node.
sub get_peer_node
{
	my ($conf, $node) = @_;
	my $peer = "";
	
	my $cluster = $conf->{cgi}{cluster};
	foreach my $this_node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		next if $node eq $this_node;
		$peer = $this_node;
		last;
	}
	
	if (not $peer)
	{
		error($conf, "I was asked to find the peer to: [$node], but failed. This is likely a program error.\n");
	}
	
	return($peer);
}

# Parse the daemon statuses.
sub parse_daemons
{
	my ($conf, $node, $array) = @_;
	
	# If all daemons are down, record here that I can shut down
	# this VM. If any are up, enable withdrawl.
	$conf->{node}{$node}{enable_poweroff} = 0;
	$conf->{node}{$node}{enable_withdraw} = 0;
	
	# I need to preset the services as stopped because the little
	# hack I have below doesn't echo when a service isn't running.
	set_daemons($conf, $node, "Stopped", "highlight_bad");
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_daemons() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if $line !~ /^an-sve:/;
		my ($daemon, $exit_code) = ($line =~ /^.*?:(.*?):(.*?)$/);
		$exit_code = "" if not defined $exit_code;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], exit_code: [$exit_code]\n");
		if ($exit_code eq "0")
		{
			$conf->{node}{$node}{daemon}{$daemon}{status} = "<span class=\"highlight_good\">Running</span>";
			$conf->{node}{$node}{enable_poweroff}         = 0;
		}
		$conf->{node}{$node}{daemon}{$daemon}{exit_code} = defined $exit_code ? $exit_code : "";
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], exit code: [$conf->{node}{$node}{daemon}{$daemon}{exit_code}], status: [$conf->{node}{$node}{daemon}{$daemon}{status}]\n");
	}
	
	# If cman is running, enable withdrawl. If not, enable shut down.
	my $cman_exit      = $conf->{node}{$node}{daemon}{cman}{exit_code};
	my $rgmanager_exit = $conf->{node}{$node}{daemon}{rgmanager}{exit_code};
	my $drbd_exit      = $conf->{node}{$node}{daemon}{drbd}{exit_code};
	my $clvmd_exit     = $conf->{node}{$node}{daemon}{clvmd}{exit_code};
	my $gfs2_exit      = $conf->{node}{$node}{daemon}{gfs2}{exit_code};
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], cman_exit:      [$cman_exit]\n");
	if ($cman_exit eq "0")
	{
		$conf->{node}{$node}{enable_withdraw} = 1;
	}
	else
	{
		# If something went wrong, one of the storage resources might still be running.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rgmanager_exit: [$rgmanager_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], drbd_exit:      [$drbd_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], clvmd_exit:     [$clvmd_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], gfs2_exit:      [$gfs2_exit]\n");
		if (($rgmanager_exit eq "0") ||
		($drbd_exit eq "0") ||
		($clvmd_exit eq "0") ||
		($gfs2_exit eq "0"))
		{
			# Uh oh...
			error($conf, "One of more of the storage daemons are running on $node while the cluster itself is down. This is generally the sign of an unclean withdrawl of a node from the cluster! Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.\n"); 
		}
		else
		{
			# Ready to power off the node, if I was actually able
			# to connect to the node.
			if ($conf->{node}{$node}{connected})
			{
				$conf->{node}{$node}{enable_poweroff} = 1;
			}
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], enable poweroff: [$conf->{node}{$node}{enable_poweroff}], enable withdrawl: [$conf->{node}{$node}{enable_withdraw}]\n");
	#foreach my $daemon (@daemons) { record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], status: [$conf->{node}{$node}{daemon}{$daemon}{status}], exit_code: [$conf->{node}{$node}{daemon}{$daemon}{exit_code}]\n"); }
	
	return(0);
}

# Parse the LVM scan output.
sub parse_lvm_scan
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_lvm_scan() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
	}
	
	return(0);
}

# Parse the LVM data.
sub parse_lvm_data
{
	my ($conf, $node, $array) = @_;
	
	my $in_pvs = 0;
	my $in_vgs = 0;
	my $in_lvs = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_lvm_data() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^PV/)
		{
			$in_pvs = 1;
			$in_vgs = 0;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^VG/)
		{
			$in_pvs = 0;
			$in_vgs = 1;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^LV/)
		{
			$in_pvs = 0;
			$in_vgs = 0;
			$in_lvs = 1;
			next;
		}
		
		if ($in_pvs)
		{
			# pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			#   pv_name,  vg_name,     pv_fmt,  pv_attr,     pv_size,     pv_free,   pv_used,     pv_uuid
			my ($this_pv, $used_by_vg, $format, $attributes, $total_size, $free_size, $used_size, $uuid) = (split /#!#/, $line);
			$total_size =~ s/B$//;
			$free_size  =~ s/B$//;
			$used_size  =~ s/B$//;
			#record($conf, "$THIS_FILE ".__LINE__."; PV: [$this_pv], used by VG: [$used_by_vg], format: [$format], attributes: [$attributes], total size: [$total_size], free size: [$free_size], used size: [$used_size], uuid: [$uuid]\n");
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_by_vg} = $used_by_vg;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{attributes} = $attributes;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{total_size} = $total_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{free_size}  = $free_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_size}  = $used_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{uuid}       = $uuid;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], PV: [$this_pv], used by VG: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_by_vg}], attributes: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{attributes}], total size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{total_size}], free size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{free_size}], used size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_size}], uuid: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{uuid}]\n");
		}
		elsif ($in_vgs)
		{
			# vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			#   vg_name,  vg_attr,     vg_extent_size, vg_extent_count, vg_uuid, vg_size,  vg_free_count, vg_free,  pv_name
			my ($this_vg, $attributes, $pe_size,       $total_pe,       $uuid,   $vg_size, $free_pe,      $vg_free, $pv_name) = split /#!#/, $line;
			$pe_size    = "" if not defined $pe_size;
			$vg_size    = "" if not defined $vg_size;
			$vg_free    = "" if not defined $vg_free;
			$attributes = "" if not defined $attributes;
			$pe_size =~ s/B$//;
			$vg_size =~ s/B$//;
			$vg_free =~ s/B$//;
			my $used_pe    = $total_pe - $free_pe if (($total_pe) && ($free_pe));
			my $used_space = $vg_size - $vg_free  if (($vg_size) && ($vg_free));
			#record($conf, "$THIS_FILE ".__LINE__."; VG: [$this_vg], attributes: [$attributes], PE size: [$pe_size], total PE: [$total_pe], uuid: [$uuid], VG size: [$vg_size], used PE: [$used_pe], used space: [$used_space], free PE: [$free_pe], free space: [$vg_free], VG free: [$vg_free], pv_name: [$pv_name]\n");
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{clustered}  = $attributes =~ /c$/ ? 1 : 0;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pe_size}    = $pe_size;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{total_pe}   = $total_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{uuid}       = $uuid;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{size}       = $vg_size;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_pe}    = $used_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_space} = $used_space;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_pe}    = $free_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_space} = $vg_free;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pv_name}    = $pv_name;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VG: [$this_vg], clustered: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{clustered}], pe size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pe_size}], total pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{total_pe}], uuid: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{uuid}], size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{size}], used pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_pe}], used space: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_space}], free pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_pe}], free space: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_space}], PV name: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pv_name}]\n");
		}
		elsif ($in_lvs)
		{
			# lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			my ($lv_name, $on_vg, $attributes, $total_size, $uuid, $path, $devices) = (split /#!#/, $line);
			#record($conf, "$THIS_FILE ".__LINE__."; LV name: [$lv_name], on VG: [$on_vg], attributes: [$attributes], total size: [$total_size], uuid: [$uuid], path: [$path], device(s): [$devices]\n");
			$total_size =~ s/B$//;
			$devices    =~ s/\(\d+\)//g;	# Strip the starting PE number
			$conf->{node}{$node}{lvm}{lv}{$path}{name}       = $lv_name;
			$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}      = $on_vg;
			$conf->{node}{$node}{lvm}{lv}{$path}{active}     = ($attributes =~ /.{4}(.{1})/)[0] eq "a" ? 1 : 0;
			$conf->{node}{$node}{lvm}{lv}{$path}{attributes} = $attributes;
			$conf->{node}{$node}{lvm}{lv}{$path}{total_size} = $total_size;
			$conf->{node}{$node}{lvm}{lv}{$path}{uuid}       = $uuid;
			$conf->{node}{$node}{lvm}{lv}{$path}{on_devices} = $devices;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], path: [$path], name: [$conf->{node}{$node}{lvm}{lv}{$path}{name}], on VG: [$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}], active: [$conf->{node}{$node}{lvm}{lv}{$path}{active}], attribute: [$conf->{node}{$node}{lvm}{lv}{$path}{attributes}], total size: [$conf->{node}{$node}{lvm}{lv}{$path}{total_size}], uuid: [$conf->{node}{$node}{lvm}{lv}{$path}{uuid}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$path}{on_devices}]\n");
		}
	}
	
	return(0);
}

# Parse the virsh data.
sub parse_virsh
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_virsh(), node: [$node]\n");
	
	foreach my $line (@{$array})
	{
		next if $line !~ /^\d/;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		my ($id, $say_vm, $state) = split/ /, $line, 3;
		#record($conf, "$THIS_FILE ".__LINE__."; id: [$id], saw vm: [$say_vm], state: [$state]\n");
		
		my $vm = "vm:$say_vm";
		$conf->{vm}{$vm}{node}{$node}{virsh}{'state'} = $state;
		if ($state eq "paused")
		{
			# This VM is being migrated here, disable withdrawl of
			# this node and migration of this VM.
			$conf->{node}{$node}{enable_withdraw} = 0;
			$conf->{vm}{$vm}{can_migrate}         = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
		}
	}
	
	return(0);
}

# Parse the GFS2 data.
sub parse_gfs2
{
	my ($conf, $node, $array) = @_;
	
	my $in_fs = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_gfs2() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Filesystem/)
		{
			$in_fs = 1;
			next;
		}
		
		if ($in_fs)
		{
			next if $line !~ /^\//;
			my ($device_path, $total_size, $used_space, $free_space, $percent_used, $mount_point) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)$/);
			next if not $mount_point;
			$total_size   = "" if not defined $total_size;
			$used_space   = "" if not defined $used_space;
			$free_space   = "" if not defined $free_space;
			$percent_used = "" if not defined $percent_used;
			next if not exists $conf->{node}{$node}{gfs}{$mount_point};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], device path: [$device_path], total size: [$total_size], used space: [$used_space], free space: [$free_space], percent used: [$percent_used], mount point: [$mount_point]\n");
			$conf->{node}{$node}{gfs}{$mount_point}{device_path}  = $device_path;
			$conf->{node}{$node}{gfs}{$mount_point}{total_size}   = $total_size;
			$conf->{node}{$node}{gfs}{$mount_point}{used_space}   = $used_space;
			$conf->{node}{$node}{gfs}{$mount_point}{free_space}   = $free_space;
			$conf->{node}{$node}{gfs}{$mount_point}{percent_used} = $percent_used;
			$conf->{node}{$node}{gfs}{$mount_point}{mounted}      = 1;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], device path: [$conf->{node}{$node}{gfs}{$mount_point}{device_path}], total size: [$conf->{node}{$node}{gfs}{$mount_point}{total_size}], used space: [$conf->{node}{$node}{gfs}{$mount_point}{used_space}], free space: [$conf->{node}{$node}{gfs}{$mount_point}{free_space}], percent used: [$conf->{node}{$node}{gfs}{$mount_point}{percent_used}], mounted: [$conf->{node}{$node}{gfs}{$mount_point}{mounted}]\n");
		}
		else
		{
			# Read the GFS info.
			next if $line !~ /gfs2/;
			my (undef, $mount_point, $fs) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s/);
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], fs: [$fs]\n");
			$conf->{node}{$node}{gfs}{$mount_point}{device_path}  = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{total_size}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{used_space}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{free_space}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{percent_used} = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{mounted}      = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], device path: [$conf->{node}{$node}{gfs}{$mount_point}{device_path}], total size: [$conf->{node}{$node}{gfs}{$mount_point}{total_size}], used space: [$conf->{node}{$node}{gfs}{$mount_point}{used_space}], free space: [$conf->{node}{$node}{gfs}{$mount_point}{free_space}], percent used: [$conf->{node}{$node}{gfs}{$mount_point}{percent_used}], mounted: [$conf->{node}{$node}{gfs}{$mount_point}{mounted}]\n");
		}
	}
	
	return(0);
}

# This sorts out what needs to happen if 'task' was set.
sub process_task
{
	my ($conf) = @_;
	
	if ($conf->{cgi}{task} eq "withdraw")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			withdraw_node($conf);
		}
		else
		{
			confirm_withdraw_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "join_cluster")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			join_cluster($conf);
		}
		else
		{
			confirm_join_cluster($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "dual_join")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			dual_join($conf);
		}
		else
		{
			confirm_dual_join($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "fence_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			fence_node($conf);
		}
		else
		{
			confirm_fence_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "poweroff_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			poweroff_node($conf);
		}
		else
		{
			confirm_poweroff_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "poweron_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			poweron_node($conf);
		}
		else
		{
			confirm_poweron_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "dual_boot")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			dual_boot($conf);
		}
		else
		{
			confirm_dual_boot($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "start_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			start_vm($conf);
		}
		else
		{
			confirm_start_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "stop_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			stop_vm($conf);
		}
		else
		{
			confirm_stop_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "force_off_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			force_off_vm($conf);
		}
		else
		{
			confirm_force_off_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "delete_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			delete_vm($conf);
		}
		else
		{
			confirm_delete_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "migrate_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			migrate_vm($conf);
		}
		else
		{
			confirm_migrate_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "provision")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			if (verify_vm_config($conf))
			{
				# We're golden
				record($conf, "$THIS_FILE ".__LINE__."; VM verified, creating now.\n");
				provision_vm($conf);
			}
			else
			{
				# Something wasn't sane.
				record($conf, "$THIS_FILE ".__LINE__."; VM verification failed.\n");
				confirm_provision_vm($conf);
			}
		}
		else
		{
			confirm_provision_vm($conf);
		}
	}
	else
	{
		print "<pre>\n";
		foreach my $var (sort {$a cmp $b} keys %{$conf->{cgi}})
		{
			print "var: [$var] -> [$conf->{cgi}{$var}]\n" if $conf->{cgi}{$var};
		}
		print "</pre>";
	}
	
	return(0);
}

# This actually kicks off the VM.
sub provision_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_ready_bold\" colspan=\"2\">
			Creating your new $conf->{new_vm}{name} server now.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good\">
			Starting
		</td>
		<td>
			In just a moment, your new server should begin installing.<br />
			Once it starts, you will be able to see it appear in the <span class=\"code\">virt-manager</span> window under <span class=\"fixed_width\">$conf->{new_vm}{host_node}</span>.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning\">
			Note!
		</td>
		<td>
			<br />
			<i>Please leave this window open until you have rebooted the new server for the first time!</i><br />
			<br />
			The server is in a special state until it is rebooted.<br />
			If you press \"Next\" before then, it may not turn back on properly.<br />
			<br />
			When you click \"Next\", the new server will be added to the cluster.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Beginning
		</td>
		<td>
			<br />
";
	
	# Create the LVs
	my $provision;
	my $i = 0;
	foreach my $vg (keys %{$conf->{new_vm}{vg}})
	{
		if (lc($conf->{new_vm}{vg}{$vg}{lvcreate_size}) eq "all")
		{
			$provision .= "lvremove -f /dev/$vg/$conf->{new_vm}{name}_$i\n";
			$provision .= "lvcreate -l 100\%FREE -n $conf->{new_vm}{name}_$i $vg\n";
		}
		else
		{
			$provision .= "lvremove -f /dev/$vg/$conf->{new_vm}{name}_$i\n";
			$provision .= "lvcreate -L $conf->{new_vm}{vg}{$vg}{lvcreate_size}MB -n $conf->{new_vm}{name}_$i $vg\n";
		}
		$i++;
	}
	
	# Setup the 'virt-install' call.
	$provision .= "virt-install --connect qemu:///system \\\\\n";
	$provision .= "  --name $conf->{new_vm}{name} \\\\\n";
	$provision .= "  --ram $conf->{new_vm}{ram} \\\\\n";
	$provision .= "  --arch x86_64 \\\\\n";
	$provision .= "  --vcpus $conf->{new_vm}{cpu_cores} \\\\\n";
	$provision .= "  --cdrom /shared/files/$conf->{new_vm}{install_iso} \\\\\n";
	$provision .= "  --os-variant $conf->{cgi}{os_variant} \\\\\n";
	if ($conf->{new_vm}{virtio}{nic})
	{
		$provision .= "  --network bridge=vbr2,model=virtio \\\\\n";
	}
	else
	{
		$provision .= "  --network bridge=vbr2,model=e1000 \\\\\n";
	}
	$i = 0;
	foreach my $vg (keys %{$conf->{new_vm}{vg}})
	{
		my $path = "/dev/$vg/$conf->{new_vm}{name}_$i";
		record($conf, "$THIS_FILE ".__LINE__."; LV: [$path], use virtio: [$conf->{new_vm}{virtio}{disk}]\n");
		$provision .= "  --disk path=$path";
		if ($conf->{new_vm}{virtio}{disk})
		{
			$provision .= ",bus=virtio";
		}
		$provision .= " \\\\\n";
	}
	$provision .= "  --vnc\n";
	record($conf, "$THIS_FILE ".__LINE__."; provision:\n$provision\n");
	
	### TODO: Make sure the desired node is up and, if not, use the one
	###       good node.
	
	# Push the provision script into a file.
	my $script = "/shared/provision/$conf->{new_vm}{name}.sh";
	print "\t\t\tWriting provision script to <span class=\"code\">$script</span><br />\n";
	my $fh = IO::Handle->new();
	my $sc = "echo \"$provision\" | $conf->{path}{ssh} root\@$conf->{new_vm}{host_node} \"cat > $script && chmod 755 $script\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		print "\t\t\t<span class=\"code\">$_</span><br />\n";
	}
	$fh->close();
	print "\t\t\tDone.\n";
	print "\t\t\t<br />\n";
	
	print "\t\t\tKicking off the installatio of <span class=\"code\">$conf->{new_vm}{name}</span> now.<br />\n";
	print "\t\t\t<br />\n";
	$fh = IO::Handle->new();
	$sc = "$conf->{path}{ssh} root\@$conf->{new_vm}{host_node} \"$script\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		print "\t\t\t<span class=\"fixed_width\"><span class=\"code\">$_</span></span><br />\n";
	}
	$fh->close();
	print "\t\t\t<br />\n";
	print "\t\t\tDone.\n";
	print "\t\t\t<br />\n";
	print "\t\t\tIf there were no errors, the installation should now have started.<br />\n";
	print "\t\t\tPlease complete the install using <span class=\"code\">virt-manager</span>.<br />\n";
	print "\t\t\tOnce the installation is complete, please return here and click \"Next\".<br />\n";
	print "\t\t\t<br />\n";
	
	print "
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><a href=\"?cluster=$conf->{cgi}{cluster}&task=add_vm&name=$conf->{new_vm}{name}&node=$conf->{new_vm}{host_node}\" class=\"button\">Next</a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This sanity-checks the requested VM config prior to creating the VM itself.
sub verify_vm_config
{
	my ($conf) = @_;
	
	# First, get a current view of the cluster.
	my $proceed = 1;
	scan_cluster($conf);
	read_files_on_shared($conf);
	
	# If we connected, start parsing.
	my $cluster = $conf->{cgi}{cluster};
	my @errors;
	if ($conf->{'system'}{up_nodes})
	{
		# Did the user name the VM?
		if ($conf->{cgi}{name})
		{
			$conf->{cgi}{name} =~ s/^\s+//;
			$conf->{cgi}{name} =~ s/\s+$//;
			if ($conf->{cgi}{name} =~ /\s/)
			{
				push @errors, "Bad Server Name#!#The server name can't have spaces in the name.";
			}
			else
			{
				my $vm = $conf->{cgi}{name};
				if (exists $conf->{vm}{$vm})
				{
					push @errors, "Duplicate Server Name#!#The server name: [<span class=\"code\">$vm</span>] is already in use.";
				}
				else
				{
					$conf->{new_vm}{name} = $vm;
				}
			}
		}
		else
		{
			push @errors, "Missing Server Name#!#All servers need to have a name. This is usally something like <span class=\"code\">vmXX-purpose</span>.";
		}
		
		# Did the user ask for too many cores?
		if ($conf->{cgi}{cpu_cores} =~ /\D/)
		{
			push @errors, "Bad CPU Count#!#Somehow, the number of requested CPUs: [<span class=\"code\">$conf->{cgi}{cpu_cores}</span>] has a non-digit in it. This is probably a program error.";
		}
		elsif ($conf->{cgi}{cpu_cores} > $conf->{resources}{total_threads})
		{
			push @errors, "Not Enough CPUs#!#The cluster reports a maximum of <span class=\"code\">$conf->{resources}{total_threads}</span> CPUs, but it looks like you asked for <span class=\"code\">$conf->{cgi}{cpu_cores}</span>. This is probably a program error.";
		}
		else
		{
			$conf->{new_vm}{cpu_cores} = $conf->{cgi}{cpu_cores};
		}
		
		# Now what about RAM?
		if ($conf->{cgi}{ram} =~ /\D/)
		{
			push @errors, "Bad RAM Size#!#The amount of RAM must only contain digits. It looks like you entered: [<span class=\"code\">$conf->{cgi}{ram}</span>].";
		}
		my $requested_ram = hr_to_bytes($conf, $conf->{cgi}{ram}, $conf->{cgi}{ram_suffix});
		if ($requested_ram > ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram}))
		{
			my $say_free_ram  = bytes_to_hr($conf, ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram}));
			my $say_requested = bytes_to_hr($conf, $requested_ram);
			push @errors, "Not Enough RAM#!#The cluster reports a maximum of <span class=\"code\">$say_free_ram</span> free RAM, but it looks like you asked for <span class=\"code\">$say_free_ram</span>.";
		}
		else
		{
			# RAM is specified as a number of MiB.
			my $say_ram = sprintf("%.0f", ($requested_ram /= (2 ** 20)));
			$conf->{new_vm}{ram} = $say_ram;
		}
		
		# Look at the selected storage. if VGs named for two separate
		# nodes are defined, error.
		$conf->{new_vm}{host_node} = "";
		foreach my $vg (split /,/, $conf->{cgi}{vg_list})
		{
			my $short_vg   = $vg;
			my $short_node = $vg;
			if ($vg =~ /^(.*?)_(vg\d+)$/)
			{
				$short_node = $1;
				$short_vg   = $2;
			}
			my $say_node      = $short_vg;
			my $vg_key        = "vg_$vg";
			my $vg_suffix_key = "vg_suffix_$vg";
			next if not $conf->{cgi}{$vg_key};
			foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
			{
				if ($node =~ /$short_node/)
				{
					$say_node = $node;
					last;
				}
			}
			if (not $conf->{new_vm}{host_node})
			{
				$conf->{new_vm}{host_node} = $say_node;
			}
			elsif ($conf->{new_vm}{host_node} ne $say_node)
			{
				push @errors, "Conflicting Storage#!#It looks like you asked to use storage from both nodes. This is not safe. Please clear one of the node's storage.";
			}
			
			# Make to lvcreate command a MiB value.
			my $lv_size = hr_to_bytes($conf, $conf->{cgi}{$vg_key}, $conf->{cgi}{$vg_suffix_key});
			$lv_size    = sprintf("%.0f", ($lv_size /= (2 ** 20)));
			$conf->{new_vm}{vg}{$vg}{lvcreate_size} = "$lv_size";
		}
		
		# Make sure the user specified an install disc.
		if ($conf->{cgi}{install_iso})
		{
			my $file_name = $conf->{cgi}{install_iso};
			if (exists $conf->{files}{shared}{$file_name})
			{
				$conf->{new_vm}{install_iso} = $conf->{cgi}{install_iso};
			}
			else
			{
				push @errors, "Install Media#!#The installation media you selected seems to have disappeared.";
			}
		}
		else
		{
			push @errors, "Install Media#!#You did not select installation media.";
		}
		
		### TODO: Find a better way to determine this.
		# Look at the OS type to try and determine if 'e1000' or
		# 'virtio' should be used by the network.
		$conf->{new_vm}{virtio}{nic}  = 0;
		$conf->{new_vm}{virtio}{disk} = 0;
		if (($conf->{cgi}{os_variant} =~ /fedora1\d/) || 
		    ($conf->{cgi}{os_variant} =~ /virtio/) || 
		    ($conf->{cgi}{os_variant} =~ /ubuntu/) || 
		    ($conf->{cgi}{os_variant} =~ /sles11/) || 
		    ($conf->{cgi}{os_variant} =~ /rhel5/) || 
		    ($conf->{cgi}{os_variant} =~ /rhel6/))
		{
			$conf->{new_vm}{virtio}{disk} = 1;
			$conf->{new_vm}{virtio}{nic}  = 1;
		}
		
		# Optional driver disk, enables virtio when appropriate
		if ($conf->{cgi}{driver_iso})
		{
			my $file_name = $conf->{cgi}{driver_iso};
			if (exists $conf->{files}{shared}{$file_name})
			{
				$conf->{new_vm}{driver_iso} = $conf->{cgi}{driver_iso};
			}
			else
			{
				push @errors, "Driver Media#!#The driver media you selected seems to have disappeared.";
			}
			
			if (lc($file_name) =~ /virtio/)
			{
				$conf->{new_vm}{virtio}{disk} = 1;
				$conf->{new_vm}{virtio}{nic}  = 1;
			}
		}
		
		# Make sure a valid os-variant was passed.
		if ($conf->{cgi}{os_variant})
		{
			my $match = 0;
			foreach my $os_variant (@{$conf->{'system'}{os_variant}})
			{
				my ($short_name, $desc) = ($os_variant =~ /^(.*?)#!#(.*)$/);
				if ($conf->{cgi}{os_variant} eq $short_name)
				{
					$match = 1;
				}
			}
			if (not $match)
			{
				push @errors, "OS Variant Not Found#!#Somehow, an OS optimization type was specified that is not valid. This is probably a program error.";
			}
		}
		else
		{
			push @errors, "OS Variant#!#No operating system optimization type was specified. This is probably a program error.";
		}
		
		# If there were errors, push the user back to the form.
		if (@errors > 0)
		{
			$proceed = 0;
			print "
<table align=\"center\">
";
			foreach my $error (@errors)
			{
				my ($title, $body) = ($error =~ /^(.*?)#!#(.*)$/);
				print "
	<tr>
		<td class=\"highlight_warning\">
			$title
		</td>
		<td>
			$body
		</td>
	</tr>
"
			}
			print "
</table>
<br />
";
		}
	}
	else
	{
		# Failed to connect to the cluster, errors should already be
		# reported to the user.
	}
	# Check the currently available resources on the cluster.
	
	return ($proceed);
}

# This doesn't so much confirm as it does ask the user how they want to build
# the VM.
sub confirm_provision_vm
{
	my ($conf) = @_;
	
	my ($node) = read_files_on_shared($conf);
	record($conf, "$THIS_FILE ".__LINE__."; read file list from node: [$node]\n");
	return if not $node;
	
	my $cluster = $conf->{cgi}{cluster};
	my $images  = [];
	foreach my $file (sort {$a cmp $b} keys %{$conf->{files}{shared}})
	{
		next if $file !~ /iso$/i;
		push @{$images}, $file;
	}
	my $cpu_cores = [];
	foreach my $core_num (1..$conf->{cgi}{max_cores})
	{
		if ($conf->{cgi}{max_cores} > 9)
		{
			#push @{$cpu_cores}, sprintf("%.2d", $core_num);
			push @{$cpu_cores}, $core_num;
		}
		else
		{
			push @{$cpu_cores}, $core_num;
		}
	}
	$conf->{cgi}{cpu_cores}  = 2 if not $conf->{cgi}{cpu_cores};
	my $select_cpu_cores     = build_select($conf, "cpu_cores", 0, 0, 60, $conf->{cgi}{cpu_cores}, $cpu_cores);
	foreach my $storage (sort {$a cmp $b} split/,/, $conf->{cgi}{max_storage})
	{
		my ($vg, $space)             =  ($storage =~ /^(.*?):(\d+)$/);
		my $say_max_storage          =  bytes_to_hr($conf, $space);
		$say_max_storage             =~ s/\.(\d+)//;
		$conf->{cgi}{vg_list}        .= "$vg,";
		my $vg_key                   =  "vg_$vg";
		my $vg_suffix_key            =  "vg_suffix_$vg";
		$conf->{cgi}{$vg_key}        =  ""    if not $conf->{cgi}{$vg_key};
		$conf->{cgi}{$vg_suffix_key} =  "GiB" if not $conf->{cgi}{$vg_suffix_key};
		my $select_vg_suffix                   =  build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB", "GiB", "TiB"]);
		if ($space < (2 ** 30))
		{
			# Less than a Terabyte
			$select_vg_suffix            = build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB", "GiB"]);
			$conf->{cgi}{$vg_suffix_key} = "GiB" if not $conf->{cgi}{$vg_suffix_key};
		}
		elsif ($space < (2 ** 20))
		{
			# Less than a Gigabyte
			$select_vg_suffix            = build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB"]);
			$conf->{cgi}{$vg_suffix_key} = "MiB" if not $conf->{cgi}{$vg_suffix_key};
		}
		# Devine the node associated with this VG.
		my $short_vg   =  $vg;
		my $short_node =  $vg;
		if ($vg =~ /^(.*?)_(vg\d+)$/)
		{
			$short_node = $1;
			$short_vg   = $2;
		}
		my $say_node =  $short_vg;
		foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
		{
			if ($node =~ /$short_node/)
			{
				$say_node = $node;
				last;
			}
		}
		
		$conf->{vg_selects}{$vg}{space}         = $space;
		$conf->{vg_selects}{$vg}{say_storage}   = $say_max_storage;
		$conf->{vg_selects}{$vg}{select_suffix} = $select_vg_suffix;
		$conf->{vg_selects}{$vg}{say_node}      = $say_node;
		$conf->{vg_selects}{$vg}{short_vg}      = $short_vg;
	}
	my $say_selects;
	my $say_or      = "<span class=\"fixed_width\">- or -</span><br />\n";
	foreach my $vg (sort {$a cmp $b} keys %{$conf->{vg_selects}})
	{
		my $space            =  $conf->{vg_selects}{$vg}{space};
		my $say_max_storage  =  $conf->{vg_selects}{$vg}{say_storage};
		my $select_vg_suffix =  $conf->{vg_selects}{$vg}{select_suffix};
		my $say_node         =  $conf->{vg_selects}{$vg}{say_node};
		$say_node            =~ s/\..*$//;
		my $short_vg         =  $conf->{vg_selects}{$vg}{short_vg};
		my $vg_key           =  "vg_$vg";
		$say_selects         .= "<span class=\"fixed_width\">$say_node</span>, <span class=\"fixed_width\">$short_vg</span> (<span class=\"subtle_text\">$say_max_storage free</span>): <input type=\"text\" name=\"$vg_key\" value=\"$conf->{cgi}{$vg_key}\" style=\"width: 100px\">$select_vg_suffix<br />\n";
		$say_selects         .= "$say_or";
	}
	$say_selects =~ s/$say_or$//m;
	$say_selects .= "<input type=\"hidden\" name=\"vg_list\" value=\"$conf->{cgi}{vg_list}\">\n";
	my $say_max_ram          = bytes_to_hr($conf, $conf->{cgi}{max_ram});
	$conf->{cgi}{ram}        = 2 if not $conf->{cgi}{ram};
	$conf->{cgi}{ram_suffix} = "GiB" if not $conf->{cgi}{ram_suffix};
	my $select_ram_suffix    = build_select($conf, "ram_suffix", 0, 0, 60, $conf->{cgi}{ram_suffix}, ["MiB", "GiB"]);
	$conf->{cgi}{os_variant} = "generic" if not $conf->{cgi}{os_variant};
	my $select_install_iso   = build_select($conf, "install_iso", 1, 1, 300, $conf->{cgi}{install_iso}, $images);
	my $select_driver_iso    = build_select($conf, "driver_iso", 1, 1, 300, $conf->{cgi}{driver_iso}, $images);
	my $select_os_variant    = build_select($conf, "os_variant", 1, 0, 300, $conf->{cgi}{os_variant}, $conf->{'system'}{os_variant});
	
	print "
<table align=\"center\">
	<form method=\"post\">
	<tr>
		<td colspan=\"3\">
			<span class=\"highlight_ready\">Create a new VM on the <b>$conf->{cgi}{cluster}</b> cluster</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_note\"><b>Note</b></span>:
		</td>
		<td colspan=\"2\">
			<br />
			You will need to answer some questions in order to create a new virtual server.<br />
			If you are unsure what a certain question means, please don't hesitate to <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">ask questions</a>.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Server Name</span>:
		</td>
		<td>
			<input type=\"text\" name=\"name\" value=\"$conf->{cgi}{name}\" style=\"width: 300px\">
		</td>
		<td class=\"subtle_text\">
			This can be whatever you want, but it must be unique.<br />
			It's good to keep this short.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning\">
			Careful!
		</td>
		<td colspan=\"2\">
			If a server with this name used to exist, and if it's storage remains, it will be deleted and replaced!<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Optimize for</span>:
		</td>
		<td>
			<!-- Update this list by referencing 'virt-install --os_variant list' and feeding it through 'parse-os_variant.pl'. -->
			$select_os_variant
		</td>
		<td class=\"subtle_text\">
			This fine-tunes the cluster for your operating system.<br />
			If your OS is not listed, choose the one that is the closest match.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Install From</span>:
		</td>
		<td>
			$select_install_iso
		</td>
		<td class=\"subtle_text\">
			You server will boot off of this disc image.<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Driver Disc</span>:
		</td>
		<td>
			$select_driver_iso
		</td>
		<td class=\"subtle_text\">
			This is optional.<br />
			If you need a drivers to install your server,<br />
			please select the appropriate disc here.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Memory (RAM)</span>:
		</td>
		<td>
			(<span class=\"subtle_text\">$say_max_ram free</span>) <input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix
		</td>
		<td class=\"subtle_text\">
			Most servers work well between 2 and 8 GiB.<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Number of CPUs</span>:
		</td>
		<td>
			$select_cpu_cores
		</td>
		<td class=\"subtle_text\">
			Windows servers tend to work best with 2 CPUs.<br />
			Few servers need more than 4 CPUs.<br />
			The cluster uses all CPUs to get the best performance.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Storage Space</span>:
		</td>
		<td>
			$say_selects
		</td>
		<td class=\"subtle_text\">
			Please use only one node.<br />
			Type <span class=\"fixed_width\">all</span> to use the rest of the free space.<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<input type=\"hidden\" name=\"cluster\" value=\"$conf->{cgi}{cluster}\">
			<input type=\"hidden\" name=\"task\" value=\"$conf->{cgi}{task}\">
			<input type=\"hidden\" name=\"max_ram\" value=\"$conf->{cgi}{max_ram}\">
			<input type=\"hidden\" name=\"max_cores\" value=\"$conf->{cgi}{max_cores}\">
			<input type=\"hidden\" name=\"max_storage\" value=\"$conf->{cgi}{max_storage}\">
			<div class=\"align_right\"><input type=\"submit\" name=\"confirm\" value=\"Confirm\" class=\"button\"></div>
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to join both nodes to the cluster.
sub confirm_withdraw_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to withdraw <b>$conf->{cgi}{node_cluster_name}</b> from cluster <b>$conf->{cgi}{cluster}</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Caution!</b></span>
		</td>
		<td>
			<br />
			<span class=\"fixed_width\"><u><b>$conf->{cgi}{node_cluster_name}</b></u></span> will leave the cluster.<br />
			Once complete, it will no longer be able to run or recover any VMs until it rejoins!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to join a node to the cluster.
sub confirm_join_cluster
{
	my ($conf) = @_;

	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to join <b>$conf->{cgi}{node_cluster_name}</b> to cluster <b>$conf->{cgi}{cluster}</b>.</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will attempt to join the node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> to the cluster <span class=\"fixed_width\">$conf->{cgi}{cluster}</span>.<br />
			This is usually a safe action.<br />
			If, for any reason, this node can't connect to it's peer, the peer node could be fenced (forcibly shut off).<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# Confirm that the user wants to join both nodes to the cluster.
sub confirm_dual_join
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to join both nodes to the $conf->{cgi}{cluster} cluster.</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will attempt to join both nodes of the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			This is usually a safe action.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to fence a nodes.
sub confirm_fence_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to forcefully power off cluster node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The cluster node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is about to be <span class=\"highlight_dangerous\">forcibly powered off</span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will effectively press and hold your node's power button until the system is forced to power down.<br >
			Should that fail, the power to the node will be cut completely cut off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Reconsider!</b></span>
		</td>
		<td>
			<br />
			This should be done as a last resort, when all other attempts to gracefully shut down the node have failed.<br />
			<i>Every</i> operating system has a chance of corrupting when it is forcibly powered off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# Confirm that the user wants to power-off a nodes.
sub confirm_poweroff_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power down the physical node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will send a <span class=\"fixed_width\">poweroff</span> command to the <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> node.<br />
			If all is well, this node should gracefully power off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Warning!</b></span>
		</td>
		<td>
			<br />
			If there is a problem with this node, like an incomplete withdrawl from the cluster, it may hang while trying to shut down.<br />
			If this happens, this browser session may time out. If it does, return to the dashboard and call a <span class=\"fixed_width\">fence</span> action against this node.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to boot a nodes.
sub confirm_poweron_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power on the physical node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			An attempt will be made to power on the <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> node.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Careful!</b></span>
		</td>
		<td>
			<br />
			Be aware that if anything blocks this node's ability to talk to it's peer, it will fence the peer node during start up!<br />
			This is by design, as a node can not safely provide clustered services when it's peer is in an unknown state.<br />
			If the peer node is already online and there are not network problems, this node will join the peer safely.<br />
			If the peer node is offline, this node will wait for a while before timing out. Once it times out, the peer node will likely be started.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}

# Confirm that the user wants to boot both nodes.
sub confirm_dual_boot
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power on both nodes!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			An attempt will be made to boot both nodes in the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			Please be patient, it can take a few minutes for the nodes to become accessible.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}
# Confirm that the user wants to start a VM.
sub confirm_start_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to boot up the virtual machine <b>$conf->{cgi}{vm}</b> on <b>$conf->{cgi}{node_cluster_name}</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be booted on cluster node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span>.<br />
			The node was selected because it is either the prefered host or the only host ready to run this VM.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}	

# Confirm that the user wants to stop a VM.
sub confirm_stop_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to shut down the virtual machine <b>$conf->{cgi}{vm}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_warning\"><b>Careful!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span>, running on cluster node <span class=\"fixed_width\">$conf->{cgi}{node}</span>, is about to be shut down.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			If $conf->{cgi}{vm} is not listening to ACPI calls, this attempt to shut down the node will fail!<br />
			Make sure that Linux machines are running <span class=\"code\">acpid</span> and that <b>Windows</b> machines have <b>no pending updates</b>.<br />
			If <span class=\"fixed_width\">$conf->{cgi}{vm}</span> doesn't shut down within <u>60 seconds</u>, it will be <span class=\"highlight_dangerous\"><b>forced off</b></span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Precautions!</b></span>
		</td>
		<td>
			<br />
			Before proceeding, it is <b>strongly advised</b> that you connect to the VM. If there are updates pending, please <b>reboot</b> the VM first.<br />
			This will ensure that VM shuts down cleanly.<br />
			Connect to this VM by using <span class=\"fixed_width\">virt-manager</span> (connecting to <span class=\"fixed_width\">$conf->{cgi}{node}</span>) or by using an RDP or SSH session.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}
# Confirm that the user wants to force-off a VM.
sub confirm_force_off_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to forcefully power off <b>$conf->{cgi}{vm}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span>, running on cluster node <span class=\"fixed_width\">$conf->{cgi}{host}</span>, is about to be <span class=\"highlight_dangerous\">forcibly powered off</span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This action is the same as pulling the power on a normal server!<br />
			The virtual machine will have no chance to react and will be instantly turned off. A moment later, the cluster will restart this VM.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Reconsider!</b></span>
		</td>
		<td>
			<br />
			This should be done as a last resort, when all other attempts to gain control of the VM have failed.<br />
			<i>Every</i> operating system has a chance of corrupting when it is forcibly powered off. <br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to migrate a VM.
sub confirm_delete_vm
{
	my ($conf) = @_;

	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to <span class=\"highlight_dangerous\"><b>delete</b></span> the <b>$conf->{cgi}{vm} server!</b></span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be <span class=\"highlight_dangerous\"><b>destroyed and deleted!</b></span><br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Warning!</b></span>
		</td>
		<td>
			<br />
			<u><b>This is a permanent and unreversable action!</b></u><br />
			The virtual machine, along with all of it's data, will be deleted.<br />
			If the virtual machine is running, it will be stopped via the cluster.<br />
			Once off, it will be removed from the cluster's management.<br />
			Finally, it's definition file will be deleted and it's backing storage will be freed up.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This is effectively the same as reformatting a server's hard drive,<br />
			pulling apart a server and making all of it's resources available for new servers later.<br />
			There is no way to undo this action! Ensure you have backed up any data on the machine before proceeding!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to migrate a VM.
sub confirm_migrate_vm
{
	my ($conf) = @_;
	
	# Calculate roughly how long the migration will take.
	my $migration_time_estimate = $conf->{cgi}{vm_ram} / 1073741824; # Get # of GB.
	$migration_time_estimate *= 10; # ~10s / GB
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to migrate the virtual machine <b><span class=\"fixed_width_button\">$conf->{cgi}{vm}</span></b> to <b><span class=\"fixed_width_button\">$conf->{cgi}{target}</span></b>.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be migrated to cluster node <span class=\"fixed_width\">$conf->{cgi}{target}</span>.<br />
			This VM has ".bytes_to_hr($conf, $conf->{cgi}{vm_ram})." RAM, which will take roughly $migration_time_estimate seconds to migrate.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This boots a VM on a target node.
sub start_vm
{
	my ($conf) = @_;
	
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $vm                = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], node_cluster_name: [$node_cluster_name]\n");
	
	# Make sure the node is still ready to take this VM.
	scan_cluster($conf);
	my $vm_key = "vm:$vm";
	my $ready = check_node_readiness($conf, $vm_key, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], ready: [$ready]\n");
	if ($ready)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Booting $vm on $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -e vm:$vm -m $node_cluster_name\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Booting of $vm on $node_cluster_name failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$node_cluster_name</span> is no longer ready to run <span class=\"fixed_width\">$vm</span>.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This tries to parse lines coming back from a shell call to add highlighting and what-not.
sub parse_text_line
{
	my ($conf, $line) = @_;
	
	# 'Da good ^_^
	$line =~ s/(success)/<span class="highlight_good">$1<\/span>/ig;
	$line =~ s/\[ (ok) \]/[ <span class="highlight_good">$1<\/span> ]/ig;
	
	# Informational.
	$line =~ s/(done)/<span class="highlight_ready">$1<\/span>/ig;
	$line =~ s/(Starting Cluster):/<span class="highlight_ready">$1<\/span>:/ig;
	$line =~ s/(Stopping Cluster):/<span class="highlight_ready">$1<\/span>:/ig;
	#$line =~ s/(disabled)/<span class="highlight_ready">$1<\/span>/ig;
	#$line =~ s/(shutdown)/<span class="highlight_ready">$1<\/span>/ig;
	$line =~ s/(shut down)/<span class="highlight_ready">$1<\/span>/ig;
	
	# 'Da bad. ;_;
	$line =~ s/(failed)/<span class="highlight_bad">$1<\/span>/ig;
	$line =~ s/\[ (failed) \]/[ <span class="highlight_bad">$1<\/span> ]/ig;
	
	return($line);
}

# This migrates a VM to the target node.
sub migrate_vm
{
	my ($conf) = @_;
	
	my $target = $conf->{cgi}{target};
	my $vm     = $conf->{cgi}{vm};
	my $node   = long_host_name_to_node_name($conf, $target);
	record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], target: [$target]\n");
	
	# Make sure the node is still ready to take this VM.
	scan_cluster($conf);
	my $vm_key = "vm:$vm";
	my $ready = check_node_readiness($conf, $vm_key, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], ready: [$ready]\n");
	if ($ready)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Migrating $vm to $target now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -M vm:$vm -m $target\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Migration of $vm to $target aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$target</span> is no longer ready to run <span class=\"fixed_width\">$vm</span>.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This sttempts to shut down a VM on a target node.
sub stop_vm
{
	my ($conf) = @_;
	
	my $node = $conf->{cgi}{node};
	my $vm   = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node]\n");
	
	# This, more than 
	scan_cluster($conf);
	print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Attempting orderly shut down of $vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $say_node = node_name_to_long_host_name($conf, $node);
		my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -d vm:$vm\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$line =~ s/Local machine/$say_node/;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This sttempts to shut down a VM on a target node.
sub join_cluster
{
	my ($conf) = @_;
	
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $proceed           = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in join_cluster(), node: [$node], node_cluster_name: [$node_cluster_name]\n");
	
	# This, more than 
	scan_cluster($conf);
	
	# Proceed only if all of the storage components, cman and rgmanager are
	# off.
	if (($conf->{node}{$node}{daemon}{cman}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{rgmanager}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{drbd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{gfs2}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{libvirtd}{exit_code} ne "0"))
	{
		$proceed = 1;
	}
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_good\"><b>Attempting to join $node_cluster_name to $conf->{cgi}{cluster} now...</b></span><br />
			This can take a while, please be patient!<br />
			This process will complete before the storage service starts. Please give a minute or two for storage to come online.<br />
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman start && /etc/init.d/rgmanager start\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Joining of $node_cluster_name to $conf->{cgi}{cluster} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that <span class=\"fixed_width\">$node_cluster_name</span> is already running <span class=\"fixed_width\">cman</span>, <span class=\"fixed_width\">rgmanager</span>, <span class=\"fixed_width\">drbd</span>, <span class=\"fixed_width\">clvmd</span> or <span class=\"fixed_width\">gfs2</span>.<br />
			If any of these daemons are running, then either the cluster was already started elsewhere or the last attempt to withdraw the cluster failed.<br />
			If you believe that the cluster has failed, please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			Note that <span class=\"fixed_width\">libvirtd</span> is allowed to be running and would not block this action.<br />
			Please go back and see what the current state of the cluster is.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This sttempts to start the cluster stack on both nodes simultaneously.
sub dual_join
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $proceed = 1;
	#record($conf, "$THIS_FILE ".__LINE__."; in dual_join(), cluster: [$cluster]\n");
	
	# This, more than 
	scan_cluster($conf);
	
	# Proceed only if all of the storage components, cman and rgmanager are
	# off.
	my @abort_reason;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		if (($conf->{node}{$node}{daemon}{cman}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{rgmanager}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{drbd}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{clvmd}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{gfs2}{exit_code} eq "0"))
		{
			$proceed = 0;
			push @abort_reason, "It appears that <span class=\"fixed_width\">$node</span> is already running <span class=\"fixed_width\">cman</span>, <span class=\"fixed_width\">rgmanager</span>, <span class=\"fixed_width\">drbd</span>, <span class=\"fixed_width\">clvmd</span> or <span class=\"fixed_width\">gfs2</span>.";
		}
	}
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_good\"><b>Attempting to join both nodes to the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster now...</b></span><br />
			This can take a while, please be patient!<br />
			This process will complete before the storage services start. Please give then minute or two for storage to come online.<br />
		</td>
	</tr>
	<tr>
		<td>
			System call output below:<br />
			<span class=\"highlight_ready_bold\">Note</span>: Output from both nodes will be mixed together.
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		# I need to fork here because the calls won't return until cman
		# either talks to it's peer or fences it.
		my $parent_pid = $$;
		#record($conf, "$THIS_FILE ".__LINE__."; Parent process has PID: [$parent_pid]. Spawning a child process for each node.\n");
		my %pids;
		my $node_count = @{$conf->{clusters}{$cluster}{nodes}};
		foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
		{
			defined(my $pid = fork) or die "Can't fork(), error was: $!\n";
			if ($pid)
			{
				# Parent thread.
				$pids{$pid} = 1;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], Spawned child with PID: [$pid].\n");
			}
			else
			{
				# This is the child thread, so do the call.
				# Note that, without the 'die', we could end
				# up here if the fork() failed.
				my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman start && /etc/init.d/rgmanager start\"";
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; $node; $line\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" align=\"right\">
						$node
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				
				# Kill the child process.
				exit;
			}
		}
		
		# Now loop until both child processes are dead.
		# This helps to catch hung children.
		my $saw_reaped = 0;
		
		# If I am here, then I am the parent process and all the child process have
		# been spawned. I will not enter a while() loop that will exist for however
		# long the %pids hash has data.
		while (%pids)
		{
			# This is a bit of an odd loop that put's the while()
			# at the end. It will cycle once per child-exit event.
			my $pid;
			do
			{
				# 'wait' returns the PID of each child as they
				# exit. Once all children are gone it returns 
				# '-1'.
				$pid = wait;
				if ($pid < 1)
				{
					record($conf, "$THIS_FILE ".__LINE__."; Parent process thinks all children are gone now as wait returned: [$pid]. Exiting loop.\n");
				}
				else
				{
					record($conf, "$THIS_FILE ".__LINE__."; Parent process told that child with PID: [$pid] has exited.\n");
				}
				
				# This deletes the just-exited child process' PID from the
				# %pids hash.
				delete $pids{$pid};
				
				# This counter is a safety mechanism. If I see more PIDs exit
				# than I spawned, something went oddly and I need to bail.
				$saw_reaped++;
				error($conf, "All children should be gone now but it seems the program went into an infinit loop.\n") if $saw_reaped > ($node_count + 1);
			}
			while $pid > 0;	# This re-enters the do() loop for as
					# long as the PID returned by wait()
					# was >0.
		}
		record($conf, "$THIS_FILE ".__LINE__."; All child processes reaped, exiting threaded execution.\n");
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Joining of both nodes to the $conf->{cgi}{cluster} cluster aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
";
		foreach my $reason (@abort_reason)
		{
			print "
			$reason<br />
";
		}
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This forcibly shuts down a VM on a target node. The cluster should restart it
# shortly after.
sub force_off_vm
{
	my ($conf) = @_;
	
	my $node = $conf->{cgi}{node};
	my $vm   = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; in force_off_vm(), vm: [$vm], node: [$node]\n");
	
	# This, more than 
	scan_cluster($conf);
	print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Forcibly shutting down $vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"virsh destroy $vm\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			The cluster will restart this VM in a moment, if this call succeeded.
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This stops the VM, if it's running, edits the cluster.conf to remove the VM's
# entry, pushes the changed cluster out, deletes the VM's definition file and 
# finally deletes the LV.
sub delete_vm
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $say_vm  = $conf->{cgi}{vm};
	my $vm      = "vm:$conf->{cgi}{vm}";
	record($conf, "$THIS_FILE ".__LINE__."; in delete_vm(), vm: [$vm], cluster: [$cluster]\n");
	
	# This, more than 
	scan_cluster($conf);
	my $proceed      = 1;
	my $stop_vm      = 0;
	my $say_host     = "";
	my $host         = "";
	my $abort_reason = "";
	my $node         = $conf->{'system'}{cluster}{node1_name};
	my $node1        = $conf->{'system'}{cluster}{node1_name};
	my $node2        = $conf->{'system'}{cluster}{node2_name};
	# I need both nodes to be running for this.
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} ne "0"))
	{
		$proceed      = 0;
		$abort_reason = "<b>Removal of $say_vm has been aborted!</b><br />\nThis program requires that both nodes be running in order to remove a VM.<br />If this is not possible, manual removal of the VM will be required.\n";
	}
	if (not $conf->{vm}{$vm}{host})
	{
		$proceed      = 0;
		$abort_reason = "<b>Removal of $say_vm has been aborted!</b><br />\nThe program appears to have failed to read the VM's information properly.<br />\nThis is likely a bug in the program.<br />\n";
	}
	elsif ($conf->{vm}{$vm}{host} ne "none")
	{
		$stop_vm  = 1;
		$say_host = $conf->{vm}{$vm}{host};
		$host     = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
	}
	# Get to work!
	print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Begining the process of deleting $say_vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
";
	if ($proceed)
	{
		print "
	<tr>
		<td>
			System call output below:<br />
			Please be patient, this might take a few minutes.<br />
		</td>
	</tr>
";
		# Stop the VM if needed.
		my $stop_exit_code = 1;
		if ($stop_vm)
		{
			print "
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			my $sc = "$conf->{path}{ssh} root\@$host \"$conf->{path}{clusvcadm} -d $vm; echo clusvcadm:\\\$?\"";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				$line =~ s/Local machine/$say_host/;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				if ($line =~ /clusvcadm:(\d+)/)
				{
					$stop_exit_code = $1;
				}
				else
				{
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
			}
			$fh->close();
			print "
			</table>
			<br />
		</td>
	</tr>
";
		}
		my $edit_cluster_conf = 0;
		if ($stop_exit_code)
		{
			# Failed to stop, abort.
			print "
	<tr>
		<td>
			Stopping the $say_vm virtual machine failed. Aborting.
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
			footer($conf);
			exit(1);
		}
		
		# VM has stopped. Delete it from the cluster.
		print "
	<tr>
		<td>
			Stopping the $say_vm virtual machine succeeded.<br />
			Removing it from the cluster now.<br />
		</td>
	</tr>
";
		update_cluster_conf($conf, "remove", $vm, $node);
	}
	else
	{
		print "
	<tr>
		<td>
			$abort_reason
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This adds or removes a VM from the cluster.conf file.
sub update_cluster_conf
{
	my ($conf, $do, $vm, $node) = @_;
	my $say_vm  = ($vm =~ /vm:(.*)/)[0];
	my $success = 1;
	
	# I 'cat' the current cluster.conf, incrementing 'config_version="x"'
	# by one, add or remove the <vm ...> line and then write out the edited
	# version locally. Next I backup the current cluster.conf to 
	# '/shared/archive/vX.cluster.conf', 'rsync' the updated local copy to
	# the target node, 'ccs_config_validate' it and, if all is well, 
	# 'cman_tool version -r' to push out the changes.
	
	# Read in the current cluster.conf.
	
	return($success);
}

# This makes an ssh call to the node and sends a simple 'poweroff' command.
sub poweroff_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed = $conf->{node}{$node}{enable_poweroff};
	record($conf, "$THIS_FILE ".__LINE__."; in poweroff_node(), node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# Stop rgmanager and then check it's status.
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Shutting down $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			This will complete once $node_cluster_name has closed the connection.<br />
			It may take a minute before the node shows as powered off on the dashboard.<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"poweroff && echo \"Power down initiated. Please return to the main page now.\"\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Withdrawl of $conf->{cgi}{node_cluster_name} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is now in use by a VM.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	footer($conf);
	
	return(0);
}

# This uses the local machine to call "power on" against both nodes in the
# cluster.
sub dual_boot
{
	my ($conf) = @_;
	
	my $proceed = 1;
	my $cluster = $conf->{cgi}{cluster};
	my $sc      = "";
	# TODO: Provide an option to boot just one node if one node fails for
	# some reason but the other node is fine.
	scan_cluster($conf);
	my @abort_reasons;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		# Read the cache files.
		read_node_cache($conf, $node);
		if (not $conf->{node}{$node}{info}{power_check_command})
		{
			push @abort_reasons, "I was asked to power on: [$node], but the command to do so was not found in the cache. Manual power up is required.\n";
			$proceed = 0;
		}
		
		# Confirm the node is off still.
		check_if_on($conf, $node);
		record($conf, "$THIS_FILE ".__LINE__."; node::${node}::is_on: [$conf->{node}{$node}{is_on}]\n");
		if ($conf->{node}{$node}{is_on} == 1)
		{
			push @abort_reasons, "I was asked to power on: [$node], but it appears to already be running. Start up aborted.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 2)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I am not able to log into the taget node's out of band management interface: [$target_host].<br />Please check to see if the address, user or password has changed. Unable to continue.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 3)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I am not on the same subnet as it's out of band management interface at: [$target_host].<br />Please restore access to the target subnet. Unable to continue.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 4)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I don't have a recorded method of checking or changing the power state for: [$target_host].<br />Please restore access to the target subnet. Unable to continue.\n";
			$proceed = 0;
		}
		
		# Still alive?
		$sc .= "$conf->{node}{$node}{info}{power_check_command} -o on; ";
	}
	
	# Let's go
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Powering on both nodes in the cluster now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now try to power on both nodes in the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			It may take a few minutes before the dashboard can log into either node.<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				$line = parse_text_line($conf, $line);
				my $message = ($line =~ /^(.*)\[/)[0];
				my $status  = ($line =~ /(\[.*)$/)[0];
				if (not $message)
				{
					$message = $line;
					$status  = "";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
			}
			$fh->close();
			print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Booting both nodes in the $conf->{cgi}{cluster} cluster aborted!</span>
		</td>
	</tr>
";
		foreach my $reason (@abort_reasons)
		{
			print "
	<tr>
		<td>
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
";
		}
		print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This uses the IPMI (or similar) to try and power on the node.
sub poweron_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	record($conf, "$THIS_FILE ".__LINE__."; in poweron_node(), node: [$node]\n");
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	check_if_on($conf, $node);
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
	my $proceed      = 0;
	my $abort_reason = "";
	if ($conf->{node}{$node}{is_on} == 0)
	{
		$proceed = 1;
	}
	elsif ($conf->{node}{$node}{is_on} == 1)
	{
		$abort_reason = "The node $node_cluster_name is already reported as being powered up.";
	}
	elsif ($conf->{node}{$node}{is_on} == 2)
	{
		$abort_reason = "The node ${node_cluster_name}'s out of band management interface is currently unreachable.";
	}
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# It is still off.
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_ready\"><b>Powering on $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now try to power on $node_cluster_name.<br />
			It may take a few minutes before the dashboard can log into it.<br />
		</td>
	</tr>
	<tr>
		<td class=\"fixed_width\">
			<br />
";

		# The node is still off. Now can I call it from it's peer?
		my $peer  = "";
		my $is_on = 2;
		record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
		if ($conf->{'system'}{up_nodes} == 1)
		{
			# It has to be the peer of this node.
			$peer = @{$conf->{up_nodes}}[0];
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
		if ($peer)
		{
			# It's peer is up, use it.
			if (not $conf->{node}{$node}{info}{power_check_command})
			{
				error($conf, "I was asked to power on: [$node] via it's peer: [$peer], but the power command is empty.<br />\nThis is likely a program error.\n");
			}
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
			my $sc = "$conf->{path}{ssh} root\@$peer \"$conf->{node}{$node}{info}{power_check_command} -o on\"";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				print "$line<br />\n";
			}
			$fh->close();
			print "
			<br />
		</td>
	</tr>";
		}
		else
		{
			# Try to boot the node locally.
			if ($conf->{node}{$node}{info}{power_check_command})
			{
				my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], target host: [$target_host], power check command: [$conf->{node}{$node}{info}{power_check_command}].\n");
				my $local_access = on_same_network($conf, $target_host);
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], local access: [$local_access].\n");
				if ($local_access)
				{
					# I can reach it directly
					my $sc = "$conf->{node}{$node}{info}{power_check_command} -o on";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
						print "$line<br />\n";
					}
					$fh->close();
					print "
			<br />
		</td>
	</tr>";
				}
				else
				{
					# I can't reach it from here.
					record($conf, "$THIS_FILE ".__LINE__."; This machine is not on the same network out of band management interface: [$target_host] for node: [$node], unable to check power state.\n");
				}
			}
			else
			{
				# Can't check the power.
				print "
			<br />
		</td>
	</tr>
</table>
<br />
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Powering on of $node_cluster_name failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			I wasn't able to find the command needed to power on $node_cluster_name.<br />
			Either this node has not been seen before or the cache for this node was deleted.<br />
			You can not power on the node from the dashboard at this time.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
";
			}
		}
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Powering on of $node_cluster_name aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			$abort_reason<br />
			<br />
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	footer($conf);
	
	return(0);
}

# This uses the fence methods, as defined in cluster.conf and in the proper
# order, to fence the target node.
sub fence_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $peer              = get_peer_node($conf, $node);
	record($conf, "$THIS_FILE ".__LINE__."; in poweron_node(), node: [$node], peer: [$peer], cluster name: [$node_cluster_name]\n");
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed      = 1;
	my @abort_reason = "";
	
	my $fence_string = "";
	# See if I already have the fence string. If not, load it from cache.
	if ($conf->{node}{$node}{info}{fence_methods})
	{
		$fence_string = $conf->{node}{$node}{info}{fence_methods};
	}
	else
	{
		read_node_cache($conf, $node);
		if ($conf->{node}{$node}{info}{fence_methods})
		{
			$fence_string = $conf->{node}{$node}{info}{fence_methods};
		}
		else
		{
			$proceed      = 0;
			push @abort_reason, "Unable to determine the commands needed to fence $node. One of the nodes need to be accessible or the cache file must exist with the correct command.\n";
		}
	}
	
	# If the peer node is up, use the fence command as compiled by it. 
	# Otherwise, read the cache. If the fence command(s) are still not
	# available, abort.
	if ($proceed)
	{
		if (not $conf->{node}{$peer}{up})
		{
			# See if this machine can reach each '-a ...' fence device
			# address.
			foreach my $address ($fence_string =~ /-a\s(.*?)\s/g)
			{
				if (not on_same_network($conf, $address))
				{
					$proceed = 0;
					push @abort_reason, "Trying to fence $node, but it's peer, $peer, is also offline and the fence device at $address is not accessible from this machine.<br />Unable to proceed with fence action.\n";
				}
			}
		}
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Fencing $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now attempt to fence <span class=\"fixed_width\">$node_cluster_name</span>.<br />
		</td>
	</tr>
";
		# This loops for each method, which may have multiple device 
		# calls. I parse each call into an 'off' and 'on' call. If the
		# 'off' call fails, I go to the next method until there are no
		# methods left. If the 'off' works, I call the 'on' call from
		# the same method to (try to) boot the node back up (or simply
		# unfence it in the case of PDUs and the like).
		my $fence_success   = 0;
		my $unfence_success = 0;
		foreach my $line ($fence_string =~ /\d+:.*?;\./g)
		{
			print "
	<tr>
		<td class=\"fixed_width\">
			<br />
";
			my ($method_num, $method_name, $command) = ($line =~ /(\d+):(.*?): (.*?;)\./);
			my $off_command =  $command;
			my $on_command  =  $command;
			
			# If the peer is up, set the command to run through it.
			if ($conf->{node}{$peer}{up})
			{
				# When called remotely, I need to double-escape
				# the $? to protect it inside the "".
				$off_command =~ s/#!action!#;/off; echo fence:\\\$?;/g;
				$on_command  =~ s/#!action!#;/on;  echo fence:\\\$?;/g;
				$off_command = "$conf->{path}{ssh} root\@$peer \"$off_command\"";
				$on_command  = "$conf->{path}{ssh} root\@$peer \"$on_command\"";
			}
			else
			{
				# When called locally, I only need to escape
				# the $? once.
				$off_command =~ s/#!action!#;/off; echo fence:\$?;/g;
				$on_command  =~ s/#!action!#;/on;  echo fence:\$?;/g;
			}
			my $off_success = 1;
			my $on_success  = 1;
			
			# Make the off attempt.
			my $sc = "$off_command";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				# This is how I get the fence call's exit code.
				if ($line =~ /fence:(\d+)/)
				{
					# Anything but '0' is a failure.
					my $exit = $1;
					if ($exit ne "0")
					{
						$off_success = 0;
					}
				}
				else
				{
					print "$line<br />\n";
				}
			}
			$fh->close();
			print "
			<br />
		</td>
	</tr>
";
			if ($off_success)
			{
				# Fence succeeded!
				record($conf, "$THIS_FILE ".__LINE__."; Fencing using the '$method_name' method succeeded. Proceeding with unfence action.\n");
				print "
	<tr>
		<td>
			Fencing using the <span class=\"fixed_width\">$method_name</span> method succeeded. Proceeding with unfence action.<br />
		</td>
	</tr>
";
				$fence_success = 1;
			}
			else
			{
				# Fence failed!
				record($conf, "$THIS_FILE ".__LINE__."; Fencing using the '$method_name' method failed. Will try next method, if available.\n");
				print "
	<tr>
		<td>
			Fencing using the <span class=\"fixed_width\">$method_name</span> method failed. Will try next method, if available.<br />
		</td>
	</tr>
";
				next;
			}
			
			# If I'm here, I can try the unfence command.
			print "
	<tr>
		<td class=\"fixed_width\">
			<br />
";
			$sc = "$on_command";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			$fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				# This is how I get the fence call's exit code.
				if ($line =~ /fence:(\d+)/)
				{
					# Anything but '0' is a failure.
					my $exit = $1;
					if ($exit ne "0")
					{
						$on_success = 0;
					}
				}
				else
				{
					print "$line<br />\n";
				}
			}
			$fh->close();
			print "
			<br />
		</td>
	</tr>
";
			if ($on_success)
			{
				# Unfence succeeded!
				record($conf, "$THIS_FILE ".__LINE__."; Unfencing using the '$method_name' method succeeded. Fence operation a complete success!\n");
				print "
	<tr>
		<td>
			Unfencing using the <span class=\"fixed_width\">$method_name</span> method succeeded. Fence operation a complete success!<br />
		</td>
	</tr>
";
				$unfence_success = 1;
				last;
			}
			else
			{
				# Unfence failed!
				# This is allowed to go to the next fence method
				# because some servers may hang their IPMI 
				# interface after a fence call, requiring power
				# to be cut in order to reset the BMC. HP, I'm
				# looking at you and your DL1** G7 line...
				record($conf, "$THIS_FILE ".__LINE__."; Unfencing using the '$method_name' method failed. The core fence action was a success, but something went wrong and manual intervention may be required before the node can be returned to service. If another fence method remains, it will now be tried in hopes of assisting recovery.\n");
				print "
	<tr>
		<td>
			Unfencing using the <span class=\"fixed_width\">$method_name</span> method failed.<br />\nThe core fence action was a success, but something went wrong and manual intervention may be required before the node can be returned to service.<br />\nIf another fence method remains, it will now be tried in hopes of assisting recovery.<br />			<br />
		</td>
	</tr>
";
			}
		}
	}
	else
	{
		print "
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Powering on of $node_cluster_name aborted!</span>
		</td>
	</tr>
";
		foreach my $reason (@abort_reason)
		{
			print "
	<tr>
		<td>
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
";
		}
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	footer($conf);
	
	return(0);
}

# This does a final check of the target node then withdraws it from the
# cluster.
sub withdraw_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed = $conf->{node}{$node}{enable_withdraw};
	#record($conf, "$THIS_FILE ".__LINE__."; in withdraw_node(), node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# Stop rgmanager and then check it's status.
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Withdrawing $node_cluster_name from the cluster now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			Stopping the cluster resource manager now...<br />
			<span class=\"highligh_ready_bold\">Please be patient</span>! This can take a minute.
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $rgmanager_stop = 1;
		my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/rgmanager stop\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			if ($line =~ /failed/i)
			{
				$rgmanager_stop = 0;
			}
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
";
		if ($rgmanager_stop)
		{
			print "
	<tr>
		<td>
			Cluster resource manager stopped successfully.<br />
			Stopping the cluster communication layer now...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			my $cman_stop = 1;
			my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman stop\"";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				if ($line =~ /failed/i)
				{
					$cman_stop = 0;
				}
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				$line = parse_text_line($conf, $line);
				my $message = ($line =~ /^(.*)\[/)[0];
				my $status  = ($line =~ /(\[.*)$/)[0];
				if (not $message)
				{
					$message = $line;
					$status  = "";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
			}
			$fh->close();
			print "
			</table>
			<br />
		</td>
	</tr>
";
			if (not $cman_stop)
			{
				# Crap...
			print "
	<tr>
		<td class=\"highlight_bad\">
			Cluster communication layer failed to stop!<br />
		</td>
	</tr>
	<tr>
		<td>
			<b>Was something holding open the cluster storage?</b><br />
			If a shell was logged in and sitting in a shared directory, a failure like this can occur.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Attempting to recover now...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				my $cman_start = 1;
				my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman start\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$cman_start = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				print "
			</table>
			<br />
		</td>
	</tr>
";
				if ($cman_start)
				{
					# Number 5 is alive
					print "
	<tr>
		<td class=\"highlight_ready\">
			Cluster communication layer started successfully!<br />
		</td>
	</tr>
";
					recover_rgmanager($conf, $node);
					
				}
				else
				{
					# Failed, call support.
					print "
	<tr>
		<td class=\"highlight_bad\">
			Unable to start the cluster communication layer!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
		</td>
	</tr>
";
				}
			}
		}
		else
		{
			# Oh shit...
			print "
	<tr>
		<td class=\"highlight_bad\">
			Cluster resource manager failed to stop!<br />
			Was something holding open the cluster storage?<br />
			If a shell was logged in and sitting in a shared directory, a failure like this can occur.<br />
		</td>
	</tr>
";
			recover_rgmanager($conf, $node);
		}
		print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highligh_bad\"><b>Withdrawl of $conf->{cgi}{node_cluster_name} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is now in use by a VM.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	footer($conf);
	
	return(0);
}

# This restarts rgmanager and, if necessary, disables and re-enables the 
# storage service
sub recover_rgmanager
{
	my ($conf, $node) = @_;
	
	print "
	<tr>
		<td>
			Attempting to recover rgmanager and, if necessary, the node's storage service...<br />
		</td>
	</tr>
	<tr>
		<td class=\"fixed_width\">
			<br />
";
	my $rgmanager_start = 1;
	my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/rgmanager start\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		if ($line =~ /failed/i)
		{
			$rgmanager_start = 0;
		}
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		print "$line<br />\n";
	}
	$fh->close();
	print "
			<br />
		</td>
	</tr>
";
	if ($rgmanager_start)
	{
		my $storage_service = $conf->{node}{$node}{info}{storage_name};
		print "
	<tr>
		<td class=\"highlight_good\">
			Cluster resource manager recovered successfully!<br />
		</td>
	</tr>
";
		if ($storage_service)
		{
			print "
	<tr>
		<td>
			Checking the <span class=\"fixed_width\">$storage_service</span> storage service now.<br />
			This requires a rescan of the cluster, please be patient.<br />
		</td>
	</tr>
";
			# I need to sleep for ~ten seconds to give time for
			# 'clustat' to start showing the service section again.
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rescanning the cluster in ten seconds.\n");
			sleep 10;
			check_node_status($conf);
			my $storage_state = $conf->{node}{$node}{info}{storage_state};
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], storage service: [$storage_service], storage state: [$storage_state]\n");
			if ($storage_state =~ /Failed/i) 
			{
				print "
	<tr>
		<td class=\"highlight_bad\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service has failed!<br />
		</td>
	</tr>
	<tr>
		<td>
			The <span class=\"fixed_width_button\">$storage_service</span> storage will now be cycled...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				# NOTE: This will return 'Warning' because of
				# whatever is holding open the storage. This is
				# fine, as the goal is to enable, not stop.
				my $storage_stop = 1;
				my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -d $storage_service\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$storage_stop = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				print "
			</table>
			<br />
		</td>
	</tr>
";
				if ($storage_stop)
				{
					print "
	<tr>
		<td class=\"highlight_ready\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service has been disabled.<br />
		</td>
	</tr>
	<tr>
		<td>
			Attempting to re-enable it now...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				my $storage_start = 1;
				my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -e $storage_service\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$storage_start = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				print "
			</table>
			<br />
		</td>
	</tr>
";
					if ($storage_start)
					{
						print "
	<tr>
		<td class=\"highlight_ready\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage has been restarted.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good\">
			Recovery has completed successfully!<br />
		</td>
	</tr>
	<tr>
		<td>
			Please log into <span class=\"fixed_width_button\">$node</span> and locate what held open the storage service.<br />
			Trying to withdraw from the cluster before this is fixed could cause problems. <br />
			Proceed carefully!<br />
		</td>
	</tr>
";
					}
					else
					{
						print "
	<tr>
		<td class=\"highlight_bad\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service failed to restart!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
		</td>
	</tr>
";
					}
				}
				else
				{
					print "
	<tr>
		<td class=\"highlight_bad\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service failed to disable!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
		</td>
	</tr>
";
				}
			}
			else
			{
				# TODO: Check each individual storage service
				# and restart each if needed.
				print "
	<tr>
		<td class=\"highlight_good\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service appears to be ok!<br />
			Recovery of the storage services appears to be unnecessary.
		</td>
	</tr>
";
			}
		}
		else
		{
			print "
	<tr>
		<td class=\"highlight_bad\">
			Unable to identify the storage service for this node! This is likely a program error.<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td class=\"highlight_bad\">
			Failed to start the <span class=\"fixed_width_button\">rgmanager</span> daemon back up!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
		</td>
	</tr>
";
	}
	
	return(0);
}

# This is a new attempt at an interface
sub display_details2
{
	my ($conf) = @_;
	
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	my $rowspan    = 2;
	my $dual_boot  = (($conf->{node}{$node1}{enable_poweron}) && ($conf->{node}{$node2}{enable_poweron})) ? 1 : 0;
	my $dual_join  = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
	
	print "
<table class=\"hidden_table\" align=\"center\" border=\"0\">
	<tr>
		<td class=\"td_hidden\">
			<table width=\"100%\" border=\"0\">
";
	
	# Node header
	my $node1_class = "highlight_unavailable";
	if (check_node_daemons($conf, $node1))        { $node1_class = "highlight_good"; }
	elsif ($conf->{node}{$node1}{up})             { $node1_class = "highlight_warning"; }
	elsif ($conf->{node}{$node1}{enable_poweron}) { $node1_class = "highlight_ready"; }
	my $node2_class = "highlight_unavailable";
	if (check_node_daemons($conf, $node2))        { $node2_class = "highlight_good"; }
	elsif ($conf->{node}{$node2}{up})             { $node2_class = "highlight_warning"; }
	elsif ($conf->{node}{$node2}{enable_poweron}) { $node2_class = "highlight_ready"; }
	print "
				<tr>
					<td nowrap=\"nowrap\">
						<b>Node</b><br />
						<span class=\"$node1_class\">$node1_long</span>
					</td>
					<td nowrap=\"nowrap\">
						<b>Node</b><br />
						<span class=\"$node2_class\">$node2_long</span>
					</td>
				</tr>
";
	
	# Show the VMs.
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		# Break the name out of the hash key.
		my ($say_vm) = ($vm =~ /^vm:(.*)/);
		my $say_power        =  "<span class=\"highlight_unavailable\">--</span>";
		my $say_reset        =  "<span class=\"highlight_unavailable\">--</span>";
		my $prefered_host    =  find_prefered_host($conf, $vm);
		   $prefered_host    =~ s/\..*$//;
		my $say_migrate      =  "<span class=\"highlight_unavailable\">--</span>";
		# If it's not running, setup the start button.
		my $show_on_host;
		if ($conf->{vm}{$vm}{host})
		{
			$say_power   = "S";
			$say_reset   = "R";
			$say_migrate = "M";
			if ($conf->{vm}{$vm}{host} eq $node1_long)
			{
				$show_on_host = $node1_long;
			}
			elsif ($conf->{vm}{$vm}{host} eq $node2_long)
			{
				$show_on_host = $node2_long;
			}
		}
		else
		{
			$say_power = "Power Up";
			$say_reset = "&nbsp;";
		}
		if ($show_on_host eq $node1_long)
		{
			print "
				<tr>
					<td nowrap=\"nowrap\">
						<span class=\"fixed_width\">$say_vm</span><br />
						$say_reset &nbsp; $say_power &nbsp; $say_migrate ->
					</td>
					<td nowrap=\"nowrap\">
						<span class=\"highlight_unavailable\">--</span>
					</td>
				</tr>
";
		}
		else
		{
			print "
				<tr>
					<td nowrap=\"nowrap\">
						<span class=\"highlight_unavailable\">--</span>
					</td>
					<td nowrap=\"nowrap\">
						<span class=\"fixed_width\">$say_vm</span><br />
						<- $say_migrate &nbsp; $say_power &nbsp; $say_reset
					</td>
				</tr>
";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say vm: [$say_vm]\n");
		
		# Use the node's short name for the buttons.
		my $say_start_target     =  $conf->{vm}{$vm}{boot_target};
		$say_start_target        =~ s/\..*?$//;
		my $start_target_long    = $node1_long =~ /$say_start_target/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		my $start_target_name    = $node1      =~ /$say_start_target/ ? $node1 : $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; say_start_target: [$say_start_target], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}], start_target_long: [$start_target_long]\n");
		
		$prefered_host           =  find_prefered_host($conf, $vm);
		$prefered_host           =~ s/\..*$//;
		if ($conf->{vm}{$vm}{boot_target})
		{
			$prefered_host = "<span class=\"highlight_ready\">$prefered_host</span>";
		}
		else
		{
			my $on_host =  $conf->{vm}{$vm}{host};
			   $on_host =~ s/\..*$//;
			if ($on_host eq $prefered_host)
			{
				$prefered_host = "<span class=\"highlight_good\">$prefered_host</span>";
			}
			else
			{
				$prefered_host = "<span class=\"highlight_warning\">$prefered_host</span>";
			}
		}
		
		my $say_migration_target =  $conf->{vm}{$vm}{migration_target};
		$say_migration_target    =~ s/\..*?$//;
		my $migrate_button = "<span class=\"disabled_button\">Migrate</span>";
		if ($conf->{vm}{$vm}{can_migrate})
		{
			$migrate_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=migrate_vm&target=$conf->{vm}{$vm}{migration_target}&vm_ram=$conf->{vm}{$vm}{details}{ram}\">Migrate to <span class=\"fixed_width_button\">$say_migration_target</span></a>";
		}
		my $host_node        = "$conf->{vm}{$vm}{host}";
		my $stop_button      = "<span class=\"disabled_button\">Shut Down</span>";
		my $force_off_button = "<span class=\"disabled_button\">Force Off</span>";
		if ($conf->{vm}{$vm}{can_stop})
		{
			$host_node        = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host node: [$host_node], vm host: [$conf->{vm}{$vm}{host}]\n");
			$stop_button      = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=stop_vm&vm=$say_vm&node=$host_node\">Orderly Shut Down</a>";
			$force_off_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=force_off_vm&vm=$say_vm&node=$host_node&host=$conf->{vm}{$vm}{host}\" class=\"highlight_dangerous\">Force Off</a>";
		}
		my $start_button     = "<span class=\"disabled_button\">Boot Up</span>";
		if ($conf->{vm}{$vm}{boot_target})
		{
			$start_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=start_vm&vm=$say_vm&node=$start_target_name&node_cluster_name=$start_target_long\">Boot Up</a>";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; start_button:     [$start_button], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}]\n");
		
		# I need both nodes up to delete a VM.
		my $say_delete_button = "<span class=\"disabled_button\">Delete</span>";
		if (($conf->{node}{$node1}{daemon}{cman}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} ne "0"))
		{
			$say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		}
		
		#record($conf, "$THIS_FILE ".__LINE__." > say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		if ($conf->{vm}{$vm}{node1_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node1_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_ready\">Ready</span>";
		}
		if ($conf->{vm}{$vm}{node2_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node2_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_ready\">Ready</span>";
		}
		#record($conf, "$THIS_FILE ".__LINE__." < say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
# 		print "
# 	<tr>
# 		<td>
# 			<span class=\"fixed_width\">$say_vm</span>
# 		</td>
# 		<td>
# 			$conf->{vm}{$vm}{say_node1}
# 		</td>
# 		<td>
# 			$conf->{vm}{$vm}{say_node2}
# 		</td>
# 		<td>
# 			<span class=\"fixed_width\">$prefered_host</span>
# 		</td>
# 		<td>
# 			$start_button
# 		</td>
# 		<td>
# 			$migrate_button
# 		</td>
# 		<td>
# 			$stop_button
# 		</td>
# 		<td>
# 			$force_off_button
# 		</td>
# 		<!-- Disabled in this release
# 		<td>
# 			&nbsp;
# 		</td>
# 		<td>
# 			$say_delete_button
# 		</td>
# 		-->
# 	</tr>
# ";
	}
	
	
	# Figure out which, if any, power buttons (boot, poweroff and fence) to enable.
	
	
	print "
			</table>
		</td>
	</tr>
</table>
<br />
";
	return(0);
}

# This creates the summary page after a cluster has been selected.
sub display_details
{
	my ($conf) = @_;
	
	print "
<table class=\"hidden_table\" align=\"center\" border=\"0\">
	<tr>
		<td class=\"td_hidden\">
";
	# Display the status of each node's daemons
	my $up_nodes = @{$conf->{up_nodes}};
	# TODO: Rework this, I always show nodes now so that the 'fence_...' 
	# calls are available. IE: enable this when the cache exists and the
	# fence command addresses are reachable.
	#record($conf, "$THIS_FILE ".__LINE__."; show nodes: [$conf->{'system'}{show_nodes}], up nodes: [$conf->{'system'}{up_nodes}] ($up_nodes)\n");
#	if ($conf->{'system'}{show_nodes})
	if (1)
	{
		display_node_controls($conf);

		# I don't show below here unless at least one node is up.
		#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}] ($up_nodes)\n");
		if ($conf->{'system'}{up_nodes} > 0)
		{
			# Show the user the current VM states and the control buttons.
			display_vm_state_and_controls($conf);
			
			# Show the state of the daemons.
			display_node_details($conf);
		
			# Show the details about each VM.
			display_vm_details($conf);
			
			# Show the status of each node's GFS2 share(s)
			display_gfs2_details($conf);
		
			# This shows the status of each DRBD resource in the cluster.
			display_drbd_details($conf);
		
			# Show the free resources available for new VMs.
			display_free_resources($conf);
			print "
</table>
<br />
";
		}
		else
		{
			# Was able to confirm the nodes are off.
			print "
<table width=\"100%\">
	<tr>
		<td colspan=\"2\">
			<b>Cluster Offline</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Offline
		</td>
		<td>
			Both cluster nodes appear to be powered off. Cluster details are not available at this time.
		</td>
	</tr>
</table>
<!-- <meta http-equiv=\"refresh\" content=\"30\"> -->
<br />
";
		}
	}
	else
	{
		# No access to the cluster at all.
		print "
<table width=\"100%\">
	<tr>
		<td colspan=\"2\">
			<b>Cluster Offline</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_offline\">
			Offline
		</td>
		<td>
			Unable to connect to either cluster node. Cluster status is not available at this time.
		</td>
	</tr>
</table>
<br />
"
	}
	
	return (0);
}

# This shows the free resources available to be assigned to new VMs.
sub display_free_resources
{
	my ($conf) = @_;
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"12\">
			<b>Available Resources</b>
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<i>CPU Cores</i>
		</td>
		<td colspan=\"3\">
			<i>RAM</i>
		</td>
		<td colspan=\"6\">
			<i>Storage</i>
		</td>
	</tr>
	<tr>
		<td>
			Cores
		</td>
		<td>
			Threads
		</td>
		<td>
			Allocated
		</td>
		<td>
			Total
		</td>
		<td>
			Allocated
		</td>
		<td>
			Available
		</td>
		<td>
			VG
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			PV
		</td>
		<td>
			Size
		</td>
		<td>
			Used
		</td>
		<td>
			Free
		</td>
	</tr>
";	
	
	# I only show one row for CPU and RAM, but usually have two or more
	# VGs. So the first step is to put my VG info into an array.
	my $enough_storage = 0;
	my $available_ram  = 0;
	my $max_cpu_cores  = 0;
	my @vg;
	my @vg_size;
	my @vg_used;
	my @vg_free;
	my @pv_name;
	my $vg_link="";
	foreach my $vg (sort {$a cmp $b} keys %{$conf->{resources}{vg}})
	{
		# If it's not a clustered VG, I don't care about it.
		#record($conf, "$THIS_FILE ".__LINE__."; vg: [$vg], clustered: [$conf->{resources}{vg}{$vg}{clustered}]\n");
		next if not $conf->{resources}{vg}{$vg}{clustered};
		push @vg,      $vg;
		push @vg_size, $conf->{resources}{vg}{$vg}{size};
		push @vg_used, $conf->{resources}{vg}{$vg}{used_space};
		push @vg_free, $conf->{resources}{vg}{$vg}{free_space};
		push @pv_name, $conf->{resources}{vg}{$vg}{pv_name};
		
		# If there is at least a GiB free, mark free storage as
		# sufficient.
		if (not $conf->{'system'}{clvmd_down})
		{
			$enough_storage =  1 if $conf->{resources}{vg}{$vg}{free_space} > 1073741824;
			$vg_link        .= "$vg:$conf->{resources}{vg}{$vg}{free_space},";
		}
	}
	$vg_link =~ s/,$//;
	
	# Count how much RAM and CPU cores have been allocated.
	my $allocated_cores = 0;
	my $allocated_ram   = 0;
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		# I check GFS2 because, without it, I can't read the VM's details.
		if ($conf->{'system'}{gfs2_down})
		{
			$allocated_ram   = "<span class=\"fixed_width\">--</span>";
			$allocated_cores = "<span class=\"fixed_width\">--</span>";
		}
		else
		{
			$allocated_ram   += $conf->{vm}{$vm}{details}{ram};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_ram: [$allocated_ram], vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$allocated_cores += $conf->{vm}{$vm}{details}{cpu_count};
		}
	}
	
	# Always knock off 2GB of RAM for the host OS.
	my $real_total_ram            =  bytes_to_hr($conf, $conf->{resources}{total_ram});
	$conf->{resources}{total_ram} -= $conf->{'system'}{unusable_ram};
	$conf->{resources}{total_ram} =  0 if $conf->{resources}{total_ram} < 0;
	my $free_ram                  =  $conf->{'system'}{gfs2_down}  ? 0    : $conf->{resources}{total_ram} - $allocated_ram;
	my $say_free_ram              =  $conf->{'system'}{gfs2_down}  ? "--" : bytes_to_hr($conf, $free_ram);
	my $say_total_ram             =  bytes_to_hr($conf, $conf->{resources}{total_ram});
	my $say_allocated_ram         =  $conf->{'system'}{gfs2_down}  ? "--" : bytes_to_hr($conf, $allocated_ram);
	my $say_vg_size               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_size[0]);
	my $say_vg_used               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_used[0]);
	my $say_vg_free               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_free[0]);
	my $say_vg                    =  $conf->{'system'}{clvmd_down} ? "--" : $vg[0];
	my $say_pv_name               =  $conf->{'system'}{clvmd_down} ? "--" : $pv_name[0];
	
	# Show the main info.
	print "
	<tr>
		<td>
			$conf->{resources}{total_cores}
		</td>
		<td>
			$conf->{resources}{total_threads}
		</td>
		<td>
			$allocated_cores
		</td>
		<td>
			$real_total_ram ($say_total_ram)
		</td>
		<td>
			$say_allocated_ram
		</td>
		<td>
			$say_free_ram
		</td>
		<td>
			<span class=\"fixed_width\">$say_vg</span>
		</td>
		<td>
			on
		</td>
		<td>
			<span class=\"fixed_width\">$say_pv_name</span>
		</td>
		<td>
			$say_vg_size
		</td>
		<td>
			$say_vg_used
		</td>
		<td>
			$say_vg_free
		</td>
	</tr>
";
	if (@vg > 0)
	{
		for (my $i=1; $i < @vg; $i++)
		{
			my $say_vg_size = bytes_to_hr($conf, $vg_size[$i]);
			my $say_vg_used = bytes_to_hr($conf, $vg_used[$i]);
			my $say_vg_free = bytes_to_hr($conf, $vg_free[$i]);
			my $say_pv_name = $pv_name[$i];
			print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"fixed_width\">$vg[$i]</span>
		</td>
		<td>
			on
		</td>
		<td>
			<span class=\"fixed_width\">$pv_name[$i]</span>
		</td>
		<td>
			$say_vg_size
		</td>
		<td>
			$say_vg_used
		</td>
		<td>
			$say_vg_free
		</td>
	</tr>
";
		}
	}
	
	### NOTE: Disabled in this release.
	# If I found enough free disk space, have at least 1 GiB of free RAM 
	# and both nodes are up, enable the "provision new VM" button.
	my $node1    = $conf->{'system'}{cluster}{node1_name};
	my $node2    = $conf->{'system'}{cluster}{node2_name};
	my $say_link = "<span class=\"disabled_button\">Build a New Server</span>";
	
	record($conf, "$THIS_FILE ".__LINE__."; in enough_storage: [$enough_storage], free_ram: [$free_ram], node1 cman: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], node2 cman: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
	if (($enough_storage) && 
	($free_ram > 1073741824) && 
	($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && 
	($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0"))
	{
		$say_link = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=provision&max_ram=$free_ram&max_cores=$conf->{resources}{total_cores}&max_storage=$vg_link\">Build a New Server</a>";
	}
	print "
	<tr>
		<td colspan=\"12\">
			$say_link
		</td>
	</tr>
";

	return (0);
}

# Simply converts a full domain name back to the node name used in the main hash.
sub long_host_name_to_node_name
{
	my ($conf, $host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in long_host_name_to_node_name(), host: [$host]\n");
	
	my $cluster   = $conf->{cgi}{cluster};
	my $node_name = "";
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster]\n");
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node]\n");
		my $short_host =  $host;
		   $short_host =~ s/\..*$//;
		my $short_node =  $node;
		   $short_node =~ s/\..*$//;
		#record($conf, "$THIS_FILE ".__LINE__."; short_host: [$short_host], short_node: [$short_node]\n");
		if ($short_host eq $short_node)
		{
			$node_name = $node;
			#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
			last;
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
	return ($node_name);
}

# Simply converts a node name to the full domain name.
sub node_name_to_long_host_name
{
	my ($conf, $host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in node_name_to_long_host_name(), host: [$host]\n");
	
	my $node_name = $conf->{node}{$host}{me}{name};

	#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
	return ($node_name);
}

# This just shows the details of the VM (no controls)
sub display_vm_details
{
	my ($conf) = @_;
	
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"6\">
			<b>Virtual Machines - Details</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<i>CPU</i>
		</td>
		<td>
			<i>RAM</i>
		</td>
		<td colspan=\"2\">
			<i>Storage</i>
		</td>
		<td>
			<i>Network</i>
		</td>
	</tr>
";
	
	# Pull up the VM details.
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		
		my $say_vm  = ($vm =~ /^vm:(.*)/)[0];
		my $say_ram = $conf->{'system'}{gfs2_down} ? "<span class=\"fixed_width\">--</span>" : bytes_to_hr($conf, $conf->{vm}{$vm}{details}{ram});
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_ram: [$say_ram], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		
		# Get the LV arrays populated.
		my @lv_path;
		my @lv_size;
		my $host = $conf->{vm}{$vm}{host};
		
		# If the host is "none", read the details from one of the "up"
		# nodes.
		if ($host eq "none")
		{
			# If the first node is running, use it. Otherwise use
			# the second node.
			my $node1_daemons_running = check_node_daemons($conf, $node1);
			my $node2_daemons_running = check_node_daemons($conf, $node2);
			if ($node1_daemons_running)
			{
				$host = $node1;
			}
			elsif ($node2_daemons_running)
			{
				$host = $node2;
			}
		}
		
		my @bridge;
		my @device;
		my @mac;
		my @type;
		my $node         = "--";
		my $say_net_host = ""; # Don't want anything printed when the VM is down
		my $say_host     = "--";
		if ($host)
		{
			$node = long_host_name_to_node_name($conf, $host);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$host], node: [$node]\n");
			
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$host], node: [$node], lv hash on node1: [$conf->{vm}{$vm}{node}{$node1}{lv}], lv hash on node2: [$conf->{vm}{$vm}{node}{$node2}{lv}]\n");
			foreach my $lv (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
			{
				#record ($conf, "$THIS_FILE ".__LINE__."; lv: [$lv], size: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}]\n");
				push @lv_path, $lv;
				push @lv_size, $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size};
			}
			
			# Get the network arrays built.
			foreach my $current_bridge (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{details}{bridge}})
			{
				push @bridge, $current_bridge;
				push @device, $conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device};
				push @mac,    uc($conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac});
				push @type,   $conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type};
			}
			
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
			if ($conf->{vm}{$vm}{host} ne "none")
			{
				$say_host  =  $conf->{vm}{$vm}{host};
				$say_host  =~ s/\..*//;
				$say_net_host = "<span class=\"highlight_detail\">$say_host</span> -> <span class=\"highlight_detail\">$bridge[0]</span> -> <span class=\"highlight_detail\">$device[0]</span> -> ";
			}
		}
		
		# If there is no host, only the device type and MAC address are valid.
		$conf->{vm}{$vm}{details}{cpu_count} = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$lv_path[0]                          = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$lv_size[0]                          = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$type[0]                             = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$mac[0]                              = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$say_vm</span>
		</td>
		<td>
			$conf->{vm}{$vm}{details}{cpu_count}
		</td>
		<td>
			$say_ram
		</td>
		<td>
			<span class=\"fixed_width\">$lv_path[0]</span>
		</td>
		<td>
			$lv_size[0]
		</td>
		<td>
			$say_net_host <span class=\"highlight_detail\">$type[0]</span> / <span class=\"highlight_detail\">$mac[0]</span>
		</td>
	</tr>
";
		my $lv_count   = @lv_path;
		my $nic_count  = @bridge;
		my $loop_count = $lv_count >= $nic_count ? $lv_count : $nic_count;
		if ($loop_count > 0)
		{
			for (my $i=1; $loop_count > $i; $i++)
			{
				my $say_lv_path = $lv_path[$i] ? $lv_path[$i] : "&nbsp;";
				my $say_lv_size = $lv_size[$i] ? $lv_size[$i] : "&nbsp;";
				my $say_network = "&nbsp;";
				if ($bridge[$i])
				{
					my $say_net_host = "";
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
					if ($conf->{vm}{$vm}{host} ne "none")
					{
						my $say_host  =  $conf->{vm}{$vm}{host};
						$say_host  =~ s/\..*//;
						$say_net_host = "<span class=\"highlight_detail\">$say_host</span> -> <span class=\"highlight_detail\">$bridge[$i]</span> -> <span class=\"highlight_detail\">$device[$i]</span> -> ";
					}
					$say_network = "$say_net_host <span class=\"highlight_detail\">$type[$i]</span> / <span class=\"highlight_detail\">$mac[$i]</span>";
				}
				
				print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_lv_path
		</td>
		<td>
			$say_lv_size
		</td>
		<td>
			$say_network
		</td>
	</tr>
";
			}
		}
	}
	
	print "
</table>
<br />
";
	return (0);
}

# This checks the daemons running on a node and returns '1' if all are running.
sub check_node_daemons
{
	my ($conf, $node) = @_;
	if (not $node)
	{
		error($conf, "I was asked to check the daemons for a node, but was not passed a node name. This is likely a program error.\n");
	}
	#record($conf, "$THIS_FILE ".__LINE__."; in check_node_daemons(), node: [$node]\n");
	my $ready = 1;
	
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], cman exit_code:      [$conf->{node}{$node}{daemon}{cman}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rgmanager exit_code: [$conf->{node}{$node}{daemon}{rgmanager}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], drbd exit_code:      [$conf->{node}{$node}{daemon}{drbd}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], clvmd exit_code:     [$conf->{node}{$node}{daemon}{clvmd}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], gfs2 exit_code:      [$conf->{node}{$node}{daemon}{gfs2}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], libvirtd exit_code:  [$conf->{node}{$node}{daemon}{libvirtd}{exit_code}]\n");
	
	if (($conf->{node}{$node}{daemon}{cman}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{rgmanager}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{drbd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{gfs2}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{libvirtd}{exit_code} ne "0"))
	{
		$ready = 0;
	}
	
	return($ready);
}

# This checks a node to see if it's ready to run a given VM.
sub check_node_readiness
{
	my ($conf, $vm, $node) = @_;
	if (not $node)
	{
		error($conf, "I was asked to check the node readiness to run the $vm VM, but was not passed a node name. This is likely a program error.\n");
	}

	#record($conf, "$THIS_FILE ".__LINE__."; in check_node_readiness(); vm: [$vm], node: [$node]\n");
	
	# This will get negated if something isn't ready.
	my $ready = check_node_daemons($conf, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; 1. vm: [$vm], node: [$node], ready: [$ready]\n");
	
	# TODO: Add split-brain detection. If both nodes are 
	# Primary/StandAlone, shut the whole cluster down.
	
	# Make sure the storage is ready.
	if ($ready)
	{
		# Still alive, find out what storage backs this VM and ensure
		# that the LV is 'active' and that the DRBD resource(s) they
		# sit on are Primary and UpToDate.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm]\n");
		read_vm_definition($conf, $node, $vm);
		
		foreach my $lv (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
		{
			# Make sure the LV is active.
			#record($conf, "$THIS_FILE ".__LINE__.";  - vm: [$vm], node: [$node], lv: [$lv]\n");
			#record($conf, "$THIS_FILE ".__LINE__.";    - active:           [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active}]\n");
			if ($conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active})
			{
				# It's active, so now check the backing storage.
				foreach my $res (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}})
				{
					# For easier reading...
					my $cs = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{connection_state};
					my $ro = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{role};
					my $ds = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{disk_state};
					#record($conf, "$THIS_FILE ".__LINE__.";    - res:              [$res]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - connection state: [$cs]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - role:             [$ro]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - disk state:       [$ds]\n");
					
					# I consider a node "ready" if it is UpToDate and Primary.
					if (($ro ne "Primary") || ($ds ne "UpToDate"))
					{
						$ready = 0;
						#record($conf, "$THIS_FILE ".__LINE__."; 2. ready: [$ready]\n");
					}
				}
			}
			else
			{
				# The LV is inactive.
				# TODO: Try to change the LV to active.
				$ready = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; 3. vm: [$vm], node: [$node], ready: [$ready]\n");
			}
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; 4. vm: [$vm], node: [$node], ready: [$ready]\n");
	
	return ($ready);
}

# This reads a VM's definition file and pulls out information about the system.
sub read_vm_definition
{
	my ($conf, $node, $vm) = @_;
	if (not $vm)
	{
		error($conf, "I was asked to look at a VM's definition file, but no VM was specified.", 1);
	}
	my $this_vm = ($vm =~ /vm:(.*)/)[0];
	$conf->{vm}{$vm}{definition_file} = "" if not defined $conf->{vm}{$vm}{definition_file};
	$conf->{vm}{$vm}{xml}             = "" if not defined $conf->{vm}{$vm}{xml};
	record($conf, "$THIS_FILE ".__LINE__."; in read_vm_definition(); VM: [$vm]/[$this_vm], node: [$node], definition: [$conf->{vm}{$vm}{definition_file}], XML array? [".ref($conf->{vm}{$vm}{xml})."]\n");

	# Here I want to parse the VM definition XML. Hopefully it was already
	# read in, but if not, I'll make a specific SSH call to get it.
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], XML: [$conf->{vm}{$vm}{xml}], def: [$conf->{vm}{$vm}{definition_file}]\n");
	if ((not ref($conf->{vm}{$vm}{xml}) eq "ARRAY") && ($conf->{vm}{$vm}{definition_file}))
	{
		my $fh = IO::Handle->new();
		my $sc = "ssh root\@$node \"cat $conf->{vm}{$vm}{definition_file}\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			push @{$conf->{vm}{$vm}{xml}}, $line;
		}
		$fh->close();
	}
	
	my $in_disk      = 0;
	my $in_interface = 0;
	my $current_bridge;
	my $current_device;
	my $current_mac_address;
	my $current_interface_type;
	if (not $conf->{vm}{$vm}{xml})
	{
		record($conf, "$THIS_FILE ".__LINE__."; I was asked to look at: [$vm]'s definition file, it was not read or was not found.");
		return (0);
	}
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		my $line=lc($line); # everything should be lower case already.
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], line: [$line]\n");
		
		# Pull out RAM amount.
		if ($line =~ /<memory>(\d+)<\/memory>/)
		{
			# Record the memory, multiple by 1024 to get bytes.
			$conf->{vm}{$vm}{details}{ram} =  $1;
			$conf->{vm}{$vm}{details}{ram} *= 1024;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		}
		if ($line =~ /<memory unit='(.*?)'>(\d+)<\/memory>/)
		{
			# Record the memory, multiple by 1024 to get bytes.
			my $units                      =  $1;
			my $ram                        =  $2;
			$conf->{vm}{$vm}{details}{ram} = hr_to_bytes($conf, $ram, $units, 1);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		}
		
		# TODO: Support pinned cores.
		# Pull out the CPU details
		if ($line =~ /<vcpu>(\d+)<\/vcpu>/)
		{
			$conf->{vm}{$vm}{details}{cpu_count} = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], cpu count: [$conf->{vm}{$vm}{details}{cpu_count}]\n");
		}
		if ($line =~ /<vcpu placement='(.*?)'>(\d+)<\/vcpu>/)
		{
			my $cpu_type                         = $1;
			$conf->{vm}{$vm}{details}{cpu_count} = $2;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], cpu count: [$conf->{vm}{$vm}{details}{cpu_count}], type: [$cpu_type]\n");
		}
		
		# Pull out network details.
		if (($line =~ /<interface/) && ($line =~ /type='bridge'/))
		{
			$in_interface = 1;
			next;
		}
		elsif ($line =~ /<\/interface/)
		{
			# Record the values I found
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device} = $current_device         ? $current_device         : "unknown";
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac}    = $current_mac_address    ? $current_mac_address    : "unknown";
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type}   = $current_interface_type ? $current_interface_type : "unknown";
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], bride: [$current_bridge], device: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device}], mac: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac}], type: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type}]\n");
			$current_bridge         = "";
			$current_device         = "";
			$current_mac_address    = "";
			$current_interface_type = "";
			$in_interface           = 0;
			next;
		}
		if ($in_interface)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], interface line: [$line]\n");
			if ($line =~ /source bridge='(.*?)'/)
			{
				$current_bridge = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], bridge: [$current_bridge]\n");
			}
			if ($line =~ /mac address='(.*?)'/)
			{
				$current_mac_address = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], mac: [$current_mac_address]\n");
			}
			if ($line =~ /target dev='(.*?)'/)
			{
				$current_device = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], device: [$current_device]\n");
			}
			if ($line =~ /model type='(.*?)'/)
			{
				$current_interface_type = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], type: [$current_interface_type]\n");
			}
		}
		
		# Pull out disk info.
		if (($line =~ /<disk/) && ($line =~ /type='block'/) && ($line =~ /device='disk'/))
		{
			$in_disk=1;
			next;
		}
		elsif ($line =~ /<\/disk/)
		{
			$in_disk=0;
			next;
		}
		if ($in_disk)
		{
			if ($line =~ /source dev='(.*?)'/)
			{
				my $lv=$1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], checking LV: [$lv]\n");
				check_lv($conf, $node, $vm, $lv);
			}
		}
	}
	
	return (0);
}

# This takes a node name and an LV and checks the DRBD resources to see if they
# are Primary and UpToDate.
sub check_lv
{
	my ($conf, $node, $vm, $lv) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VM: [$vm], LV: [$lv]\n");
	
	# If this node is down, just return.
	if ($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0")
	{
		#record($conf, "$THIS_FILE ".__LINE__."; The node: [$node] is down, skipping LV check for: [$lv] for VM: [$vm]\n");
		return(0);
	}
	
	$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active} = $conf->{node}{$node}{lvm}{lv}{$lv}{active};
	$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}   = bytes_to_hr($conf, $conf->{node}{$node}{lvm}{lv}{$lv}{total_size});
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VM: [$vm], LV: [$lv], active: [$conf->{node}{$node}{lvm}{lv}{$lv}{active}], size: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$lv}{on_devices}]\n");
	
	# If there is a comman in the devices, the LV spans multiple devices.
	foreach my $device (split/,/, $conf->{node}{$node}{lvm}{lv}{$lv}{on_devices})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; device: [$device]\n");
		# Find the resource name.
		my $on_res;
		foreach my $res (sort {$a cmp $b} keys %{$conf->{drbd}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; res: [$res]\n");
			my $res_device = $conf->{drbd}{$res}{node}{$node}{device};
			#record($conf, "$THIS_FILE ".__LINE__."; res: [$res], device: [$device], res. device: [$res_device]\n");
			if ($device eq $res_device)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; match! Recording res as: [$res]\n");
				$on_res = $res;
				last;
			}
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], on_res: [$on_res]\n");
		
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{connection_state} = $conf->{drbd}{$on_res}{node}{$node}{connection_state};
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{role}             = $conf->{drbd}{$on_res}{node}{$node}{role};
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{disk_state}       = $conf->{drbd}{$on_res}{node}{$node}{disk_state};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], cs: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{connection_state}]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], ro: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{role}]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], ds: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{disk_state}]\n");
	}
	
	return (0);
}

# Check the status of VMs.
sub check_vms
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	#record($conf, "$THIS_FILE ".__LINE__."; node 1: n[$node1] s[$conf->{node}{$node1}{info}{short_host_name}] l[$conf->{node}{$node1}{info}{host_name}], node 2: n[$node2] s[$conf->{node}{$node2}{info}{short_host_name}] l[$conf->{node}{$node2}{info}{host_name}]\n");
	my $short_node1 = "$conf->{node}{$node1}{info}{short_host_name}";
	my $short_node2 = "$conf->{node}{$node2}{info}{short_host_name}";
	my $long_node1  = "$conf->{node}{$node1}{info}{host_name}";
	my $long_node2  = "$conf->{node}{$node2}{info}{host_name}";
	my $say_node1   = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2   = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		my $say_vm;
		if ($vm =~ /^vm:(.*)/)
		{
			$say_vm = $1;
		}
		else
		{
			error($conf, "I was asked to check on a VM that didn't have the <span class=\"code\">vm:</span> prefix. I got the name: <span class=\"code\">$vm</span>. This is likely a programming error.\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_vm: [$say_vm]\n");
		
		# This will control the buttons.
		$conf->{vm}{$vm}{can_start}        = 0;
		$conf->{vm}{$vm}{can_stop}         = 0;
		$conf->{vm}{$vm}{can_migrate}      = 0;
		$conf->{vm}{$vm}{current_host}     = 0;
		$conf->{vm}{$vm}{migration_target} = "";
		
		# Find out who, if anyone, is running this VM and who *can* run
		# it. 2 == Running, 1 == Can run, 0 == Can't run.
		$conf->{vm}{$vm}{say_node1}        = $conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0" ? "<span class=\"highlight_warning\">Not Ready</span>" : "<span class=\"code\">--</span>";
		$conf->{vm}{$vm}{node1_ready}      = 0;
		$conf->{vm}{$vm}{say_node2}        = $conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0" ? "<span class=\"highlight_warning\">Not Ready</span>" : "<span class=\"code\">--</span>";
		$conf->{vm}{$vm}{node2_ready}      = 0;
		
		# If a VM's XML definition file is found but there is no host,
		# the user probably forgot to define it.
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
		if (not $conf->{vm}{$vm}{host})
		{
			error($conf, "I found a definition for a VM named: [<span class=\"highlight_detail\">$say_vm</span>], but there doesn't seem to be an entry in <span class=\"highlight_detail\">cluster.conf</span> for it.", 0);
			next;
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], current host: [$conf->{vm}{$vm}{host}], node1 / node2 short names: [$short_node1] / [$short_node2]\n");
		if ($conf->{vm}{$vm}{host} =~ /$short_node1/)
		{
			# Even though I know the host is ready, this function
			# loads some data, like LV details, which I will need
			# later.
			check_node_readiness($conf, $vm, $node1);
			$conf->{vm}{$vm}{can_start}     = 0;
			$conf->{vm}{$vm}{can_stop}      = 1;
			$conf->{vm}{$vm}{current_host}  = $node1;
			$conf->{vm}{$vm}{node1_ready}   = 2;
			($conf->{vm}{$vm}{node2_ready}) = check_node_readiness($conf, $vm, $node2);
			if ($conf->{vm}{$vm}{node2_ready})
			{
				$conf->{vm}{$vm}{migration_target} = $long_node2;
				$conf->{vm}{$vm}{can_migrate}      = 1;
			}
			# Disable cluster withdrawl of this node.
			$conf->{node}{$node1}{enable_withdraw} = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1: [$node1], node2 ready: [$conf->{vm}{$vm}{node2_ready}], can migrate: [$conf->{vm}{$vm}{can_migrate}], migration target: [$conf->{vm}{$vm}{migration_target}]\n");
		}
		elsif ($conf->{vm}{$vm}{host} =~ /$short_node2/)
		{
			# Even though I know the host is ready, this function
			# loads some data, like LV details, which I will need
			# later.
			check_node_readiness($conf, $vm, $node2);
			$conf->{vm}{$vm}{can_start}     = 0;
			$conf->{vm}{$vm}{can_stop}      = 1;
			$conf->{vm}{$vm}{current_host}  = $node2;
			($conf->{vm}{$vm}{node1_ready}) = check_node_readiness($conf, $vm, $node1);
			$conf->{vm}{$vm}{node2_ready}   = 2;
			if ($conf->{vm}{$vm}{node1_ready})
			{
				$conf->{vm}{$vm}{migration_target} = $long_node1;
				$conf->{vm}{$vm}{can_migrate}      = 1;
			}
			# Disable withdrawl of this node.
			$conf->{node}{$node2}{enable_withdraw} = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1: [$node1], node2 ready: [$conf->{vm}{$vm}{node2_ready}], can migrate: [$conf->{vm}{$vm}{can_migrate}], migration target: [$conf->{vm}{$vm}{migration_target}]\n");
		}
		else
		{
			$conf->{vm}{$vm}{can_stop}      = 0;
			($conf->{vm}{$vm}{node1_ready}) = check_node_readiness($conf, $vm, $node1);
			($conf->{vm}{$vm}{node2_ready}) = check_node_readiness($conf, $vm, $node2);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1_ready: [$conf->{vm}{$vm}{node1_ready}], node2_ready: [$conf->{vm}{$vm}{node2_ready}]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], current host: [$conf->{vm}{$vm}{current_host}]\n");
		$conf->{vm}{$vm}{boot_target} = "";
		if ($conf->{vm}{$vm}{current_host})
		{
			# This is a bit expensive, but read the VM's running
			# definition.
			my $host   = $conf->{vm}{$vm}{current_host};
			my $say_vm = $vm;
			$say_vm =~ s/^vm://;
			#record($conf, "$THIS_FILE ".__LINE__."; Reading the XML for the VM: [$vm] which is currently running on: [$conf->{vm}{$vm}{current_host}]\n");
			my $fh = IO::Handle->new();
			my $sc = "ssh root\@$host \"virsh dumpxml $say_vm\"";
			#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				push @{$conf->{vm}{$vm}{xml}}, $line;
			}
			$fh->close();
		}
		else
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1_ready: [$conf->{vm}{$vm}{node1_ready}], node2_ready: [$conf->{vm}{$vm}{node2_ready}]\n");
			if (($conf->{vm}{$vm}{node1_ready}) && ($conf->{vm}{$vm}{node2_ready}))
			{
				# I can boot on either node, so choose the 
				# first one in the VM's failover domain.
				$conf->{vm}{$vm}{boot_target} = find_prefered_host($conf, $vm);
				$conf->{vm}{$vm}{can_start}   = 1;
			}
			elsif ($conf->{vm}{$vm}{node1_ready})
			{
				$conf->{vm}{$vm}{boot_target} = $node1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}]\n");
			}
			elsif ($conf->{vm}{$vm}{node2_ready})
			{
				$conf->{vm}{$vm}{boot_target} = $node2;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}]\n");
			}
			else
			{
				$conf->{vm}{$vm}{can_start} = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], can_start: [$conf->{vm}{$vm}{can_start}]\n");
			}
		}
	}
	
	return (0);
}

# This looks through the failover domain for a VM and returns the prefered host.
sub find_prefered_host
{
	my ($conf, $vm) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in find_prefered_host(), vm: [$vm]\n");
	my $prefered_host = "";
	
	my $failover_domain = $conf->{vm}{$vm}{failover_domain};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], failover_domain: [$failover_domain]\n");
	if (not $failover_domain)
	{
		# Not yet defined in the cluster.
		return("--");
	}
	
	# TODO: Check to see if I need to use <=> instead of cmp.
	foreach my $priority (sort {$a cmp $b} keys %{$conf->{failoverdomain}{$failover_domain}{priority}})
	{
		# I only care about the first entry, so I will
		# exit the loop as soon as I analyze it.
		$prefered_host = $conf->{failoverdomain}{$failover_domain}{priority}{$priority}{node};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], prefered host: [$prefered_host]\n");
		last;
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], prefered host: [$prefered_host]\n");
	return ($prefered_host);
}

# This function simply sets a couple variables using the node names as set in
# the $conf hash declaration
sub set_node_names
{
	my ($conf) = @_;
	
	# First pull the names into easier to follow variables.
	my $this_cluster = $conf->{cgi}{cluster};
	$conf->{'system'}{cluster}{node1_name} = $conf->{clusters}{$this_cluster}{nodes}[0];
	$conf->{'system'}{cluster}{node2_name} = $conf->{clusters}{$this_cluster}{nodes}[1];
	#record($conf, "$THIS_FILE ".__LINE__."; this_cluster: [$this_cluster], node1: [$conf->{'system'}{cluster}{node1_name}], node2: [$conf->{'system'}{cluster}{node2_name}]\n");
	
	return (0);
}

# This shows the current state of the VMs as well as the available control
# buttons.
sub display_vm_state_and_controls
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	#record($conf, "$THIS_FILE ".__LINE__."; node1: [$node1], node1_long: [$node1_long]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; node2: [$node2], node2_long: [$node2_long]\n");
	
	print "
<table width=\"100%\">
	<tr>
		<!-- Reset to '10' when enabling VM deletion -->
		<td colspan=\"8\">
			<b>Virtual Machines - Status and Control</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>
		</td>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>
		</td>
		<td>
			Prefered Host
		</td>
		<!-- Reset to '6' when enabling VM deletion -->
		<td colspan=\"4\">
			<i>Controls</i>
		</td>
	</tr>
";

	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		# Break the name out of the hash key.
		my ($say_vm) = ($vm =~ /^vm:(.*)/);
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say vm: [$say_vm]\n");
		
		# Use the node's short name for the buttons.
		my $say_start_target     =  $conf->{vm}{$vm}{boot_target} ? $conf->{vm}{$vm}{boot_target} : "--";
		$say_start_target        =~ s/\..*?$//;
		my $start_target_long    = $node1_long =~ /$say_start_target/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		my $start_target_name    = $node1      =~ /$say_start_target/ ? $node1 : $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; say_start_target: [$say_start_target], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}], start_target_long: [$start_target_long]\n");
		
		my $prefered_host        =  find_prefered_host($conf, $vm);
		$prefered_host           =~ s/\..*$//;
		if ($conf->{vm}{$vm}{boot_target})
		{
			$prefered_host = "<span class=\"highlight_ready\">$prefered_host</span>";
		}
		else
		{
			my $on_host =  $conf->{vm}{$vm}{host};
			   $on_host =~ s/\..*$//;
			if ($on_host eq $prefered_host)
			{
				$prefered_host = "<span class=\"highlight_good\">$prefered_host</span>";
			}
			else
			{
				$prefered_host = "<span class=\"highlight_warning\">$prefered_host</span>";
			}
		}
		
		my $say_migration_target =  $conf->{vm}{$vm}{migration_target};
		$say_migration_target    =~ s/\..*?$//;
		my $migrate_button = "<span class=\"disabled_button\">Migrate</span>";
		if ($conf->{vm}{$vm}{can_migrate})
		{
			$migrate_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=migrate_vm&target=$conf->{vm}{$vm}{migration_target}&vm_ram=$conf->{vm}{$vm}{details}{ram}\">Migrate to <span class=\"fixed_width_button\">$say_migration_target</span></a>";
		}
		my $host_node        = "$conf->{vm}{$vm}{host}";
		my $stop_button      = "<span class=\"disabled_button\">Shut Down</span>";
		my $force_off_button = "<span class=\"disabled_button\">Force Off</span>";
		if ($conf->{vm}{$vm}{can_stop})
		{
			$host_node        = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host node: [$host_node], vm host: [$conf->{vm}{$vm}{host}]\n");
			$stop_button      = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=stop_vm&vm=$say_vm&node=$host_node\">Orderly Shut Down</a>";
			$force_off_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=force_off_vm&vm=$say_vm&node=$host_node&host=$conf->{vm}{$vm}{host}\" class=\"highlight_dangerous\">Force Off</a>";
		}
		my $start_button     = "<span class=\"disabled_button\">Boot Up</span>";
		if ($conf->{vm}{$vm}{boot_target})
		{
			$start_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=start_vm&vm=$say_vm&node=$start_target_name&node_cluster_name=$start_target_long\">Boot Up</a>";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; start_button:     [$start_button], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}]\n");
		
		# I need both nodes up to delete a VM.
		my $say_delete_button = "<span class=\"disabled_button\">Delete</span>";
		if (($conf->{node}{$node1}{daemon}{cman}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} ne "0"))
		{
			$say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		}
		
		#record($conf, "$THIS_FILE ".__LINE__." > say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		if ($conf->{vm}{$vm}{node1_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node1_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_ready\">Ready</span>";
		}
		if ($conf->{vm}{$vm}{node2_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node2_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_ready\">Ready</span>";
		}
		#record($conf, "$THIS_FILE ".__LINE__." < say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$say_vm</span>
		</td>
		<td>
			$conf->{vm}{$vm}{say_node1}
		</td>
		<td>
			$conf->{vm}{$vm}{say_node2}
		</td>
		<td>
			<span class=\"fixed_width\">$prefered_host</span>
		</td>
		<td>
			$start_button
		</td>
		<td>
			$migrate_button
		</td>
		<td>
			$stop_button
		</td>
		<td>
			$force_off_button
		</td>
		<!-- Disabled in this release
		<td>
			&nbsp;
		</td>
		<td>
			$say_delete_button
		</td>
		-->
	</tr>
";
	}
	
	# When enabling the "Start" button, be sure to start on the highest 
	# priority host in the failover domain, when possible.
	
	print "
</table>
<br />
";
	
	return (0);
}

# This shows the status of each DRBD resource in the cluster.
sub display_drbd_details
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $say_node1 = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2 = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"9\">
			<b>DRBD - Replicated Storage</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\">
			<i>Device</i>
		</td>
		<td colspan=\"2\">
			<i>Connection</i>
		</td>
		<td colspan=\"2\">
			<i>Role</i>
		</td>
		<td colspan=\"2\">
			<i>Disk State</i>
		</td>
	</tr>
	<tr>
		<td>
			<i>Resource</i>
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
	</tr>
";

	foreach my $res (sort {$a cmp $b} keys %{$conf->{drbd}})
	{
		# If the DRBD daemon is stopped, I will use the values from the
		# resource files.
		my $say_n1_dev = "--";
		my $say_n2_dev = "--";
		my $say_n1_cs  = "--";
		my $say_n2_cs  = "--";
		my $say_n1_ro  = "--";
		my $say_n2_ro  = "--";
		my $say_n1_ds  = "--";
		my $say_n2_ds  = "--";
		
		# Check if node 1 is online.
		if ($conf->{node}{$node1}{up})
		{
			# It is, but is DRBD running?
			if ($conf->{node}{$node1}{daemon}{drbd}{exit_code} eq "0")
			{
				# It is. 
				$say_n1_dev = $conf->{drbd}{$res}{node}{$node1}{device};
				$say_n1_cs  = $conf->{drbd}{$res}{node}{$node1}{connection_state};
				$say_n1_ro  = $conf->{drbd}{$res}{node}{$node1}{role};
				$say_n1_ds  = $conf->{drbd}{$res}{node}{$node1}{disk_state};
			}
			else
			{
				# It is not, use the {res_file} values.
				$say_n1_dev = $conf->{drbd}{$res}{node}{$node1}{res_file}{device};
				$say_n1_cs  = $conf->{drbd}{$res}{node}{$node1}{res_file}{connection_state};
				$say_n1_ro  = $conf->{drbd}{$res}{node}{$node1}{res_file}{role};
				$say_n1_ds  = $conf->{drbd}{$res}{node}{$node1}{res_file}{disk_state};
			}
		}
		# Check if node 2 is online.
		if ($conf->{node}{$node2}{up})
		{
			# It is, but is DRBD running?
			if ($conf->{node}{$node2}{daemon}{drbd}{exit_code} eq "0")
			{
				# It is. 
				$say_n2_dev = $conf->{drbd}{$res}{node}{$node2}{device};
				$say_n2_cs  = $conf->{drbd}{$res}{node}{$node2}{connection_state};
				$say_n2_ro  = $conf->{drbd}{$res}{node}{$node2}{role};
				$say_n2_ds  = $conf->{drbd}{$res}{node}{$node2}{disk_state};
			}
			else
			{
				# It is not, use the {res_file} values.
				$say_n2_dev = $conf->{drbd}{$res}{node}{$node2}{res_file}{device};
				$say_n2_cs  = $conf->{drbd}{$res}{node}{$node2}{res_file}{connection_state};
				$say_n2_ro  = $conf->{drbd}{$res}{node}{$node2}{res_file}{role};
				$say_n2_ds  = $conf->{drbd}{$res}{node}{$node2}{res_file}{disk_state};
			}
		}
		
		my $class_n1_cs  = "highlight_unavailable";
		$class_n1_cs     = "highlight_good" if $say_n1_cs eq "Connected";
		$class_n1_cs     = "highlight_ready"if $say_n1_cs eq "WFConnection";
		my $class_n2_cs  = "highlight_unavailable";
		$class_n2_cs     = "highlight_good" if $say_n2_cs eq "Connected";
		$class_n2_cs     = "highlight_ready"if $say_n2_cs eq "WFConnection";
		my $class_n1_ro  = "highlight_unavailable";
		$class_n1_ro     = "highlight_good"    if $say_n1_ro eq "Primary";
		$class_n1_ro     = "highlight_warning" if $say_n1_ro eq "Secondary";
		my $class_n2_ro  = "highlight_unavailable";
		$class_n2_ro     = "highlight_good"    if $say_n2_ro eq "Primary";
		$class_n2_ro     = "highlight_warning" if $say_n2_ro eq "Secondary";
		my $class_n1_ds  = "highlight_unavailable";
		$class_n1_ds     = "highlight_good"    if $say_n1_ds eq "UpToDate";
		$class_n1_ds     = "highlight_warning" if $say_n1_ds eq "Inconsistent";
		$class_n1_ds     = "highlight_warning" if $say_n1_ds eq "Outdated";
		$class_n1_ds     = "highlight_bad"     if $say_n1_ds eq "Diskless";
		my $class_n2_ds  = "highlight_unavailable";
		$class_n2_ds     = "highlight_good"    if $say_n2_ds eq "UpToDate";
		$class_n2_ds     = "highlight_warning" if $say_n2_ds eq "Inconsistent";
		$class_n2_ds     = "highlight_warning" if $say_n2_ds eq "Outdated";
		$class_n2_ds     = "highlight_bad"     if $say_n2_ds eq "Diskless";
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$res</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_n1_dev</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_n2_dev</span>
		</td>
		<td>
			<span class=\"$class_n1_cs\">$say_n1_cs</span>
		</td>
		<td>
			<span class=\"$class_n2_cs\">$say_n2_cs</span>
		</td>
		<td>
			<span class=\"$class_n1_ro\">$say_n1_ro</span>
		</td>
		<td>
			<span class=\"$class_n2_ro\">$say_n2_ro</span>
		</td>
		<td>
			<span class=\"$class_n1_ds\">$say_n1_ds</span>
		</td>
		<td>
			<span class=\"$class_n2_ds\">$say_n2_ds</span>
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";
	
	return (0);
}

# This shows the details on each node's GFS2 mount(s)
sub display_gfs2_details
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $say_node1 = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2 = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"6\">
			<b>GFS2 - Shared File Systems</b>
		</td>
	</tr>
	<tr>
		<td>
			<i>Mount Point</i>
		</td>
		<td>
			<i>$say_node1</i>
		</td>
		<td>
			<i>$say_node2</i>
		</td>
		<td>
			<i>Size</i>
		</td>
		<td>
			<i>Used</i>
		</td>
		<td>
			<i>Free</i>
		</td>
	</tr>
";
	my $gfs2_hash;
	my $node;
	#record($conf, "$THIS_FILE ".__LINE__."; node1 - cman exit code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], gfs2 exit code: [$conf->{node}{$node1}{daemon}{gfs2}{exit_code}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; node2 - cman exit code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}], gfs2 exit code: [$conf->{node}{$node2}{daemon}{gfs2}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node1}{daemon}{gfs2}{exit_code} eq "0") && (ref($conf->{node}{$node1}{gfs}) eq "HASH"))
	{
		$gfs2_hash = $conf->{node}{$node1}{gfs};
		$node      = $node1;
		#record($conf, "$THIS_FILE ".__LINE__."; using node1's gfs2 hash: [$gfs2_hash]\n");
	}
	elsif (($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node2}{daemon}{gfs2}{exit_code} eq "0") && (ref($conf->{node}{$node2}{gfs}) eq "HASH"))
	{
		$gfs2_hash = $conf->{node}{$node2}{gfs};
		$node      = $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; using node2's gfs2 hash: [$gfs2_hash]\n");
	}
	else
	{
		# Neither node has the GFS2 partition mounted. Use the data
		# from /etc/fstab. This is what will be stored in either node's
		# hash. So pick a node that's online and use it.
		#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
		if ($conf->{'system'}{up_nodes} == 1)
		{
			$node      = @{$conf->{up_nodes}}[0];
			record($conf, "$THIS_FILE ".__LINE__."; Neither node has the GFS2 partition mounted.\n");
			$gfs2_hash = $conf->{node}{$node}{gfs};
		}
		else
		{
			# Neither node is online at all.
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span> / <span class=\"highlight_unavailable\">--%</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
	</tr>
";
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; gfs2_hash: [$gfs2_hash], node1 hash: [".(ref($conf->{node}{$node1}{gfs}))."], node2 hash: [".(ref($conf->{node}{$node2}{gfs}))."]\n");
	if (ref($gfs2_hash) eq "HASH")
	{
		foreach my $mount_point (sort {$a cmp $b} keys %{$gfs2_hash})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::gfs::${mount_point}::mounted: [$conf->{node}{$node1}{gfs}{$mount_point}{mounted}], node::${node2}::gfs::${mount_point}::mounted: [$conf->{node}{$node2}{gfs}{$mount_point}{mounted}]\n");
			my $say_node1_mounted = $conf->{node}{$node1}{gfs}{$mount_point}{mounted} ? "<span class=\"highlight_good\">Mounted</span>" : "<span class=\"highlight_bad\">Unmounted</span>";
			my $say_node2_mounted = $conf->{node}{$node2}{gfs}{$mount_point}{mounted} ? "<span class=\"highlight_good\">Mounted</span>" : "<span class=\"highlight_bad\">Unmounted</span>";
			#record($conf, "$THIS_FILE ".__LINE__."; say_node1_mounted: [$say_node1_mounted], say_node2_mounted: [$say_node2_mounted]\n");
			my $say_size         = "--";
			my $say_used         = "--";
			my $say_used_percent = "--%";
			my $say_free         = "--";
			
			# This is to avoid the "undefined variable" errors in
			# the log from when a node isn't online.
			$conf->{node}{$node1}{gfs}{$mount_point}{total_size} = "" if not defined $conf->{node}{$node1}{gfs}{$mount_point}{total_size};
			$conf->{node}{$node2}{gfs}{$mount_point}{total_size} = "" if not defined $conf->{node}{$node2}{gfs}{$mount_point}{total_size};
			#record($conf, "$THIS_FILE ".__LINE__."; node1 total size: [$conf->{node}{$node1}{gfs}{$mount_point}{total_size}]\n");
			#record($conf, "$THIS_FILE ".__LINE__."; node2 total size: [$conf->{node}{$node2}{gfs}{$mount_point}{total_size}]\n");
			if ($conf->{node}{$node1}{gfs}{$mount_point}{total_size} =~ /^\d/)
			{
				$say_size         = $conf->{node}{$node1}{gfs}{$mount_point}{total_size};
				$say_used         = $conf->{node}{$node1}{gfs}{$mount_point}{used_space};
				$say_used_percent = $conf->{node}{$node1}{gfs}{$mount_point}{percent_used};
				$say_free         = $conf->{node}{$node1}{gfs}{$mount_point}{free_space};
			}
			elsif ($conf->{node}{$node2}{gfs}{$mount_point}{total_size} =~ /^\d/)
			{
				$say_size         = $conf->{node}{$node2}{gfs}{$mount_point}{total_size};
				$say_used         = $conf->{node}{$node2}{gfs}{$mount_point}{used_space};
				$say_used_percent = $conf->{node}{$node2}{gfs}{$mount_point}{percent_used};
				$say_free         = $conf->{node}{$node2}{gfs}{$mount_point}{free_space};
			}
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$mount_point</span>
		</td>
		<td>
			$say_node1_mounted
		</td>
		<td>
			$say_node2_mounted
		</td>
		<td>
			$say_size
		</td>
		<td>
			$say_used / $say_used_percent
		</td>
		<td>
			$say_free
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td colspan=\"6\">
			<i>No shared file systems were found.</i>
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";

	return (0);
}

# This shows the user the state of the nodes and their daemons.
sub display_node_details
{
	my ($conf) = @_;
	
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"7\">
			<b>Cluster Nodes - Status</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<i>cman</i>
		</td>
		<td>
			<i>rgmanager</i>
		</td>
		<td>
			<i>drbd</i>
		</td>
		<td>
			<i>clvmd</i>
		</td>
		<td>
			<i>gfs2</i>
		</td>
		<td>
			<i>libvirtd</i>
		</td>
	</tr>
";
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$this_cluster}{nodes}})
	{
		# Get the cluster's node name.
		my $say_short_name =  $node;
		$say_short_name    =~ s/\..*//;
		my $node_long_name =  $node1_long =~ /$say_short_name/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};

		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node}{info}{host_name}</span> &nbsp;
			<!-- <img src=\"/img/icon_led_left.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_middle.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_middle.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_right.png\" border=\"0\"> -->
		</td>
		<td>
			$conf->{node}{$node}{daemon}{cman}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{rgmanager}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{drbd}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{clvmd}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{gfs2}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{libvirtd}{status}
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";

	return (0);
}

# This shows the controls for the nodes.
sub display_node_controls
{
	my ($conf) = @_;
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"8\">
			<b>Cluster Nodes - Controls</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"3\">
			<i>Power</i>
		</td>
		<td colspan=\"3\">
			<i>Membership</i>
		</td>
		<td colspan=\"1\">
			<i>Special</i>
		</td>
	</tr>
";
	
	# I want to map storage service to nodes for the "Withdraw" buttons.
	my $disable_join = 0;
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	my $rowspan    = 2;
	my $dual_boot  = (($conf->{node}{$node1}{enable_poweron}) && ($conf->{node}{$node2}{enable_poweron})) ? 1 : 0;
	my $dual_join  = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$this_cluster}{nodes}})
	{
		# Get the cluster's node name.
		my $say_short_name =  $node;
		$say_short_name    =~ s/\..*//;
		my $node_long_name =  $node1_long =~ /$say_short_name/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		$conf->{node}{$node}{enable_withdraw} = 0 if not defined $conf->{node}{$node}{enable_withdraw};
		
		my $say_join      = $conf->{node}{$node}{enable_join}     ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=join_cluster&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_ready_bold\">Join Cluster</span></a>" : "<span class=\"disabled_button\">Join Cluster</span>";
		   $say_join      = "<span class=\"disabled_button\">Join Cluster</span>" if $disable_join;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], enable_withdraw: [$conf->{node}{$node}{enable_withdraw}], node long name: [$node_long_name]\n");
		my $say_withdraw  = $conf->{node}{$node}{enable_withdraw} ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=withdraw&node=$node&node_cluster_name=$node_long_name\">Withdraw</a>"  : "<span class=\"disabled_button\">Withdraw</span>";
		#record($conf, "$THIS_FILE ".__LINE__."; node::${node}::enable_poweroff: [$conf->{node}{$node}{enable_poweroff}]\n");
		my $say_shutdown  = $conf->{node}{$node}{enable_poweroff} ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=poweroff_node&node=$node&node_cluster_name=$node_long_name\">Power Off</a>" : "<span class=\"disabled_button\">Shut Down</span>";
		my $say_boot      = $conf->{node}{$node}{enable_poweron}  ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=poweron_node&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_ready_bold\">Power On</span></a>"   : "<span class=\"disabled_button\">Power On</span>";
		
		# At all times, the option to fence the node is made available.
		my $say_fence     = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=fence_node&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_dangerous\">Fence Node</span></a>";
		my $say_dual_boot = "<span class=\"highlight_unavailable\">Power On Both</span>";
		my $say_dual_join = "<span class=\"highlight_unavailable\">Start Cluster</span>";
		if ($rowspan)
		{
			# First row.
			if ($dual_boot)
			{
				$say_dual_boot = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=dual_boot\"><span class=\"highlight_ready_bold\">Power On Both</span></a>";
			}
			if ($dual_join)
			{
				$say_dual_join = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=dual_join\"><span class=\"highlight_ready_bold\">Start Cluster</span></a>";
				# Disable the per-node "join" options".
				$say_join      = "<span class=\"disabled_button\">Join Cluster</span>";
				$disable_join  = 1;
			}
		}

		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node}{info}{host_name}</span>
		</td>
";
		if ($rowspan)
		{
			print "
		<td rowspan=\"2\">
			$say_dual_boot
		</td>
";
		}
		print "
		<td>
			$say_boot
		</td>
		<td>
			$say_shutdown
		</td>
";
		if ($rowspan)
		{
			print "
		<td rowspan=\"2\">
			$say_dual_join
		</td>
";
		}
		print "
		<td>
			$say_join
		</td>
		<td>
			$say_withdraw
		</td>
		<td>
			$say_fence
		</td>
	</tr>
";
		$rowspan = 0;
	}
	
	print "
</table>
<br />
";

	return (0);
}

1;
