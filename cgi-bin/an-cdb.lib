#!/usr/bin/perl
#
# AN!CDB - Alteeve's Niche! Anvil Dashboard
# 
# This software is released under the GNU GPL v2+ license.
# 
# No warranty is provided. Do not use this software unless you are willing and
# able to take full liability for it's use. The authors take care to prevent
# unexpected side effects when using this program. However, no software is
# perfect and bugs may exist which could lead to hangs or crashes in the
# program, in your Anvil and possibly even data loss.
# 
# If you are concerned about these risks, please stick to command line tools.
# 
# This program is designed to extend Anvils built according to this tutorial:
# - https://alteeve.com/w/2-Node_Red_Hat_KVM_Cluster_Tutorial
#
# This program's source code and updates are available on Github:
# - https://github.com/digimer/an-cdb
#
# Author;
# Alteeve's Niche!  -  https://alteeve.com
# Madison Kelly     -  mkelly@alteeve.ca
# 

use strict;
use warnings;
use CGI;
use Encode;
use IO::Handle;
use CGI::Carp "fatalsToBrowser";

# Setup for UTF-8 mode.
binmode STDOUT, ":utf8:";
$ENV{'PERL_UNICODE'}=1;
my $THIS_FILE = "an-cdb.lib";

# This takes a node name and returns the peer node.
sub get_peer_node
{
	my ($conf, $node) = @_;
	my $peer = "";
	
	my $cluster = $conf->{cgi}{cluster};
	foreach my $this_node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		next if $node eq $this_node;
		$peer = $this_node;
		last;
	}
	
	if (not $peer)
	{
		error($conf, "I was asked to find the peer to: [$node], but failed. This is likely a program error.\n");
	}
	
	return($peer);
}

# This sorts out what needs to happen if 'task' was set.
sub process_task
{
	my ($conf) = @_;
	
	if ($conf->{cgi}{task} eq "withdraw")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			withdraw_node($conf);
		}
		else
		{
			confirm_withdraw_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "join_cluster")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			join_cluster($conf);
		}
		else
		{
			confirm_join_cluster($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "dual_join")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			dual_join($conf);
		}
		else
		{
			confirm_dual_join($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "fence_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			fence_node($conf);
		}
		else
		{
			confirm_fence_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "poweroff_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			poweroff_node($conf);
		}
		else
		{
			confirm_poweroff_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "poweron_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			poweron_node($conf);
		}
		else
		{
			confirm_poweron_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "dual_boot")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			dual_boot($conf);
		}
		else
		{
			confirm_dual_boot($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "start_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			start_vm($conf);
		}
		else
		{
			confirm_start_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "stop_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			stop_vm($conf);
		}
		else
		{
			confirm_stop_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "force_off_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			force_off_vm($conf);
		}
		else
		{
			confirm_force_off_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "delete_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			delete_vm($conf);
		}
		else
		{
			confirm_delete_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "migrate_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			migrate_vm($conf);
		}
		else
		{
			confirm_migrate_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "provision")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			if (verify_vm_config($conf))
			{
				# We're golden
				record($conf, "$THIS_FILE ".__LINE__."; VM verified, creating now.\n");
				provision_vm($conf);
			}
			else
			{
				# Something wasn't sane.
				record($conf, "$THIS_FILE ".__LINE__."; VM verification failed.\n");
				confirm_provision_vm($conf);
			}
		}
		else
		{
			confirm_provision_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "add_vm")
	{
		# This is called after provisioning a VM usually, so no need to
		# confirm
		add_vm_to_cluster($conf);
	}
	elsif ($conf->{cgi}{task} eq "manage_vm")
	{
		manage_vm($conf);
	}
	elsif ($conf->{cgi}{task} eq "display_health")
	{
		print "
<div id=\"hide_when_loaded\">
<table>
	<tr>
		<td>
			<b>Please be patient.</b><br />
			Gathering information from $conf->{cgi}{cluster}.<br />
			This could take a minute to complete.
		</td>
		<td>
			<img src=\"/img/gather_info.gif\" border=\"0\">
		</td>
	</tr>
</table>
<br />
</div>
	";
		get_storage_data($conf, $conf->{cgi}{node});
		if ((not $conf->{storage}{is}{lsi}) && 
		    (not $conf->{storage}{is}{hp})  &&
		    (not $conf->{storage}{is}{mdadm}))
		{
			my $cluster           = $conf->{cgi}{cluster};
			my $node              = $conf->{cgi}{node};
			my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	print "
<table>
	<tr>
		<td colspan=\"3\">
			<b><span class=\"fixed_width\">No Storage Managers Found on $node_cluster_name</span></b>
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<br />
			I am sorry, but I did not find any storage management tools on <span class=\"highlight_detail\">$node</span>.<br />
			Please install <span class=\"fixed_width\">MegaCli64</span> or another supported storage manager and try again.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		}
		else
		{
			my $display_details = 1;
			if ($conf->{cgi}{'do'})
			{
				if ($conf->{cgi}{'do'} eq "start_id_disk")
				{
					lsi_control_disk_id_led($conf, "start");
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "stop_id_disk")
				{
					lsi_control_disk_id_led($conf, "stop");
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "make_disk_good")
				{
					lsi_control_make_disk_good($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "add_disk_to_array")
				{
					lsi_control_add_disk_to_array($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "put_disk_online")
				{
					lsi_control_put_disk_online($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "put_disk_offline")
				{
					lsi_control_put_disk_offline($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "mark_disk_missing")
				{
					lsi_control_mark_disk_missing($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "spin_disk_down")
				{
					lsi_control_spin_disk_down($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "spin_disk_up")
				{
					lsi_control_spin_disk_up($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "make_disk_hot_spare")
				{
					lsi_control_make_disk_hot_spare($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				elsif ($conf->{cgi}{'do'} eq "unmake_disk_as_hot_spare")
				{
					lsi_control_unmake_disk_as_hot_spare($conf);
					get_storage_data($conf, $conf->{cgi}{node});
				}
				### Prepare Unconfigured drives for removal
				# MegaCli64 AdpSetProp AlarmDsbl aN|a0,1,2|aALL 

			}
			if ($display_details)
			{
				display_node_health($conf);
			}
		}
	}
	elsif ($conf->{cgi}{task} eq "restart_tomcat")
	{
		restart_tomcat($conf);
	}
	else
	{
		print "<pre>\n";
		foreach my $var (sort {$a cmp $b} keys %{$conf->{cgi}})
		{
			print "var: [$var] -> [$conf->{cgi}{$var}]\n" if $conf->{cgi}{$var};
		}
		print "</pre>";
	}
	
	return(0);
}

# This restarts tomcat on the local machine.
sub restart_tomcat
{
	my ($conf, $quiet) = @_;
	$quiet = 0 if not defined $quiet;
	
	if (not $quiet)
	{
		print "
<table>
	<tr>
		<td class=\"highlight_ready\" colspan=\"2\">
			Restarting the remote desktop server on this dashboard.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning_bold\">Note</span>
		</td>
		<td>
			<br />
			Restarting the remote desktop server:</br>
			<br />
";
	}
	my $sc = "$conf->{path}{restart_tomcat} restart";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($quiet)
		{
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		}
		else
		{
			print "\t\t\t<span class=\"fixed_width\"><span class=\"code\">$line</span></span><br />\n";
		}
	}
	$fh->close();
	
	if (not $quiet)
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good_bold\">Done</span>
		</td>
		<td>
			<br />
			Any existing open connections to servers may need to be reopened.</br>
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			Please close this brower tab (or window).<br />
			You should now be able to connect to your server.<br />
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This unmarks a disk as a hot spare.
sub lsi_control_unmake_disk_as_hot_spare
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_unmake_disk_as_hot_spare()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Mark the disk as a global hot-spare.
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDHSP Rmv PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /as Hot Spare Success/i)
		{
			$success = 1;
		}
	}
	
	my $title_message = "Success";
	my $title_class   = "highlight_good";
	my $message_body  = "Successfully unmarked the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as a hot-spare.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to unmark the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as a hot-spare.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Unmark Physical Disk as Hot-Spare</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";

	return(0);
}

# This marks a disk as a hot spare.
sub lsi_control_make_disk_hot_spare
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_make_disk_hot_spare()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Mark the disk as a global hot-spare.
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	0,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDHSP Set PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /as Hot Spare Success/i)
		{
			$success = 1;
		}
	}
	
	my $title_message = "Success";
	my $title_class   = "highlight_good";
	my $message_body  = "Successfully marked the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as a global hot-spare.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to mark the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as a global hot-spare.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Mark Physical Disk as Hot-Spare</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";

	return(0);
}

# This marks an "Offline" disk as "Missing".
sub lsi_control_mark_disk_missing
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_mark_disk_missing()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDMarkMissing PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /is marked missing/i)
		{
			$success = 1;
		}
		elsif ($line =~ /in a state that doesn't support the requested command/i)
		{
			$success = 2;
		}
	}
	
	my $title_message = "Success";
	my $title_class   = "highlight_good";
	my $message_body  = "Successfully marked disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as missing.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to mark the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as missing.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	elsif ($success == 2)
	{
		$title_message =  "Note";
		$title_class   =  "highlight_detail";
		$message_body  =  "Unable to mark the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as missing. May not be be required, proceeding with spin-down.";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Mark Physical Disk as Missing</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
	
	if ($success)
	{
		lsi_control_spin_disk_down($conf);
	}

	return(0);
}

# This spins up an "Unconfigured, spun down" disk, making it available again.
sub lsi_control_spin_disk_up
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_spin_disk_up()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# This spins the drive back up.
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDPrpRmv Undo PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Undo Prepare for removal Success/i)
		{
			$success = 1;
		}
	}

	my $title_message = "Success";
	my $title_class   = "highlight_good";
	my $message_body  = "Successfully spun up the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span>.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to spin up the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span>.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Spin Up Physical Disk</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";

	return(0);
}

# This spins down an "Offline" disk, Preparing it for removal.
sub lsi_control_spin_disk_down
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_spin_disk_down()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDPrpRmv PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Prepare for removal Success/i)
		{
			$success = 1;
		}
		elsif ($line =~ /in a state that doesn't support the requested command/i)
		{
			$success = 2;
		}
	}

	my $title_message =  "Success";
	my $title_class   =  "highlight_good";
	my $message_body  =  "Successfully spun down the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> online.<br /><br />";
	   $message_body  .= "<span class=\"highlight_good\">It can now be safely removed.</span>";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to spin down the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> online.<br /><br />";
		$message_body  =  "<span class=\"highlight_dangerous\">It is not safe to remove!</span><br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	elsif ($success == 2)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Unable to spin down the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> online, firmware rejected the request.<br /><br />";
		$message_body  .= "Will try to mark the disk as '<span class=\"highlight_detail\">Unconfigured(good)</span>' and then try again.";
	}
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Spin Down Physical Disk</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
	
	# If this failed because the firmware rejected the request, try to mark
	# the disk as good and then spin it down.
	if ($success == 2)
	{
		if (lsi_control_make_disk_good($conf))
		{
			lsi_control_spin_disk_down($conf);
		}
	}
	
	return(0);
}

# This gets the rebuild status of a drive
sub lsi_control_get_rebuild_progress
{
	my ($conf, $disk_address, $adapter) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_get_rebuild_progress(); disk_address: [$disk_address], adapter: [$adapter]\n");
	
	my $rebuild_percent   = "";
	my $time_to_complete  = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDRbld ShowProg PhysDrv [$disk_address] a$adapter",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /completed (\d+)% in (.*?)\./i)
		{
			$rebuild_percent  = $1;
			$time_to_complete = $2;
		}
	}
	
	return($rebuild_percent, $time_to_complete);
}

# This puts an "Online, Spun Up" disk into "Offline" state.
sub lsi_control_put_disk_offline
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_put_disk_offline()\n");
	
	### NOTE: I don't think I need this function. For now, I simply
	###       redirect to the "prepare for removal" function.
	#lsi_control_mark_disk_missing($conf);
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $this_adapter      = $conf->{cgi}{adapter};
	my $this_logical_disk = $conf->{cgi}{logical_disk};
	
	if (($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{'state'} eq "Degraded") && ($this_logical_disk != 9999))
	{
		my $reason = "Putting this disk offline would destroy the array and cause data loss.";
		if ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{primary_raid_level} eq "6")
		{
			$reason = "Please replace the array's failed disk before taking this disk offline.";
		}
		print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Unable to Remove Physical Disk</span></b>
		</td>
	</tr>
		<td class=\"highlight_warning\">
			Unable to Proceed
		</td>
		<td>
			<br />
			The physical disk: [$conf->{cgi}{disk_address}] is a member of the degraded logical disk: [$this_logical_disk].<br />
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return(0);
	}
	
	if (not $conf->{cgi}{confirm})
	{
		my $message     =  "This will take the disk: [<span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span>] offline, removing it from logical disk: [<span class=\"highlight_detail\">$this_logical_disk</span>].<br /><br />";
		   $message     .= "<span class=\"highlight_dangerous_bold\">This will degrade the array!</span><br /><br />";
		   $message     .= "Please do not proceed until you have the replacement drive ready to install.";
		my $alert       =  "Warning!";
		my $alert_class =  "highlight_warning_bold";
		if ($this_logical_disk == 9999)
		{
			$message     = "This will take the disk: [<span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span>] offline, preparing it for physical removal.";
			$alert       = "Note";
			$alert_class = "highlight_detail_bold";
		}
		print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Confirmation Required</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$alert_class\">
			$alert
		</td>
		<td>
			<br />
			$message<br />
			<br />
			Are you sure you wish to proceed?<br />
			<br />
			<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=put_disk_offline&disk_address=$conf->{cgi}{disk_address}&adapter=$this_adapter&logical_disk=$this_logical_disk&confirm=true\">Confirm</a> - or - <a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health\">Cancel</a><br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return (0);
	}
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDOffline PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /state changed to offline/i)
		{
			$success = 1;
		}
	}
	
	my $title_message =  "Success";
	my $title_class   =  "highlight_good";
	my $message_body  =  "Successfully put the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> offline.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to put the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> offline.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Put Physical Disk Offline</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
	if ($success)
	{
		# Mark the disk as "missing" from the array.
		lsi_control_mark_disk_missing($conf);
	}

	return(0);
}

# This puts an "Offline" disk into "Online" state.
sub lsi_control_put_disk_online
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_put_disk_online()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDRbld Start PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /started rebuild progress on device/i)
		{
			$success = 1;
		}
	}
	
	my $title_message =  "Success";
	my $title_class   =  "highlight_good";
	my $message_body  =  "Successfully put the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> online.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to put the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> online.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Put Physical Disk Online</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";

	return(0);
}

# This adds an "Unconfigured Good" disk to the specified array.
sub lsi_control_add_disk_to_array
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_add_disk_to_array()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PdReplaceMissing PhysDrv [$conf->{cgi}{disk_address}] -array$conf->{cgi}{logical_disk} -row$conf->{cgi}{row} -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if (($line =~ /successfully added the disk/i) || ($line =~ /missing pd at array/i))
		{
			$success = 1;
		}
	}
	
	my $title_message =  "Success";
	my $title_class   =  "highlight_good";
	my $message_body  =  "Successfully added the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> to logical disk <span class=\"highlight_detail\">#$conf->{cgi}{logical_disk}</span>.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to add the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> to logical disk <span class=\"highlight_detail\">#$conf->{cgi}{logical_disk}</span>.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Add Physical Disk to Logical Disk</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
	
	# If successful, put the disk Online.
	if ($success)
	{
		lsi_control_put_disk_online($conf);
	}
	
	return(0);
}

# This looks ip the missing disk(s) in a given degraded array
sub lsi_control_get_missing_disks
{
	my ($conf, $this_adapter, $this_logical_disk) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_get_missing_disks(); this_adapter: [$this_adapter] this_logical_disk: [$this_logical_disk]\n");
	
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PdGetMissing a$this_adapter",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /\d+\s+\d+\s+(\d+)\s(\d+)/i)
		{
			my $this_row     =  $1;
			my $minimum_size =  $2;		# This is in MiB and is the cooerced size.
			   $minimum_size *= 1048576;	# Now it should be in bytes
			$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{missing_row}{$this_row} = $minimum_size;
		}
	}
	
	return(0);
}

# This tells the controller to make the flagged disk "Good"
sub lsi_control_make_disk_good
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_make_disk_good()\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PDMakeGood PhysDrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /state changed to unconfigured-good/i)
		{
			$success = 1;
		}
	}
	
	my $title_message =  "Success";
	my $title_class   =  "highlight_good";
	my $message_body  =  "Successfully marked the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as good.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to mark the disk <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span> as good.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Mark Physical Disk as 'Good'</span></b>
		</td>
	</tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
	
	return($success);
}

# This turns on or off the "locate" LED on the hard drives.
sub lsi_control_disk_id_led
{
	my ($conf, $action) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; lsi_control_disk_id_led(); action: [$action]\n");
	
	my $success           = 0;
	my $return_string     = "";
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $say_action        = "started";
	if ($action eq "stop")
	{
		$say_action = "stopped";
	}
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$conf->{storage}{is}{lsi} PdLocate $action physdrv [$conf->{cgi}{disk_address}] -a$conf->{cgi}{adapter}",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$return_string .= "$line<br />\n";
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /command was successfully sent to firmware/i)
		{
			$success = 1;
		}
	}
	
	my $title_message =  "Success";
	my $title_class   =  "highlight_good";
	my $message_body  =  "Successfully <span class=\"highlight_detail\">$say_action</span> the disk ID LED for <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span>.";
	if (not $success)
	{
		$title_message =  "Warning";
		$title_class   =  "highlight_warning";
		$message_body  =  "Failed to <span class=\"highlight_detail\">${action}</span> the disk ID LED for <span class=\"highlight_detail\">$conf->{cgi}{disk_address}</span> on adapter <span class=\"highlight_detail\">#$conf->{cgi}{adapter}</span>.<br /><br />";
		$message_body  .= "Message from the controller:<br /><br />\n";
		$message_body  .= "<span class=\"fixed_width\">$return_string</span>\n";
	}
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b><span class=\"fixed_width\">Disk ID Call</span></b>
		</td>
	</tr>
	<tr>
	<tr>
		<td class=\"$title_class\">
			$title_message
		</td>
		<td>
			<br />
			$message_body<br />
			<br />
		</td>
	</tr>
	</tr>
</table>
<br />
";
	
	return ($success);
}

# This reads the sensor values of a given node and displays them. Some sensors
# will be controllable; like failing/adding a hard drive.
sub display_node_health
{
	my ($conf) = @_;
	
	my $cluster           = $conf->{cgi}{cluster};
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	print "
<table class=\"hidden_table\">
	<tr>
		<td colspan=\"3\" class=\"td_hidden\">
			<table width=\"100%\">
				<tr>
					<td colspan=\"3\">
						<b><span class=\"fixed_width\">$cluster - $node_cluster_name</span></b>
					</td>
				</tr>
				<tr>
					<td colspan=\"3\">
						<br />
						Status and Managerment of <span class=\"highlight_detail\">$node</span>'s Storage<br />
						<br />
					</td>
				</tr>
			</table>
			<br />
";
	
	# Display results.
	if ($conf->{storage}{is}{lsi})
	{
		#print "<pre style=\"background: white;\">\n";
		#print "Displaying storage\n";
		foreach my $this_adapter (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}})
		{
			foreach my $this_logical_disk (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}})
			{
				foreach my $this_enclosure_device_id (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}})
				{
					foreach my $this_slot_number (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}})
					{
						#print "adapter: [$this_adapter], logical disk: [$this_logical_disk], enclosure: [$this_enclosure_device_id], slot: [$this_slot_number]\n";
						#$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{raw_sector_count_in_hex}
					}
				}
			}
			#print "</pre>\n";
			my $say_bbu   =                      $conf->{storage}{lsi}{adapter}{$this_adapter}{bbu_is}                        ? "Present" : "Not Installed";
			my $say_flash =                      $conf->{storage}{lsi}{adapter}{$this_adapter}{flash_is}                      ? "Present" : "Not Installed";
			my $say_restore_hotspare_on_insert = $conf->{storage}{lsi}{adapter}{$this_adapter}{restore_hotspare_on_insertion} ? "Yes"     : "No";
			print "
			<table width=\"100%\">
				<tr>
					<td colspan=\"3\">
						<b>RAID Controller #$this_adapter</b>
					</td>
				</tr>
				<tr>
					<td rowspan=\"5\" width=\"128px\" style=\"vertical-align: top;\">
						<img src=\"/img/raid_controller_128x128.png\" border=\"0\">
					</td>
					<td class=\"highlight_detail_left\">
						Model:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{product_name}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Cache Size:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{cache_size}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Battery Backup (BBU):
					</td>
					<td class=\"fixed_width_left\">
						$say_bbu
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Flash Module:
					</td>
					<td class=\"fixed_width_left\">
						$say_flash
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Restore Hot-Spare on Insert:
					</td>
					<td class=\"fixed_width_left\">
						$say_restore_hotspare_on_insert
					</td>
				</tr>
			</table>
			<br />
		</td>
	</tr>
";
			if ($conf->{storage}{lsi}{adapter}{$this_adapter}{bbu_is})
			{
				my $say_replace_bbu     = $conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{replace_bbu}        ? "Yes" : "No";
				my $say_learn_cycle     = $conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{learn_cycle_active} ? "Yes" : "No";
				my $battery_state_class = "highlight_good";
				if ($conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{battery_state} ne "Optimal")
				{
					$battery_state_class = "highlight_bad";
				}
				print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\">
			<table width=\"100%\">
				<tr>
					<td colspan=\"3\">
						<b>Battery Backup Unit</b>
					</td>
				</tr>
				<tr>
					<td rowspan=\"8\" width=\"128px\" style=\"vertical-align: top;\">
						<img src=\"/img/raid_battery_128x128.png\" border=\"0\">
					</td>
					<td class=\"highlight_detail_left\">
						Battery State:
					</td>
					<td class=\"fixed_width_left\">
						<span class=\"$battery_state_class\">$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{battery_state}</span>
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Model:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{manufacture_name}, $conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{type}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Capacity (Current / Design):
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{full_capacity} / $conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{design_capacity}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Current Charge:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{remaining_capacity}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Replacement Needed:
					</td>
					<td class=\"fixed_width_left\">
						$say_replace_bbu
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Learn Cycle Active:
					</td>
					<td class=\"fixed_width_left\">
						$say_learn_cycle
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Next Learn Cycle:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{next_learn_time}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Total Drain/Charge Cycles:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{cycle_count}
					</td>
				</tr>
			</table>
			<br />
		</td>
	</tr>
";
			}
			
			# Show the logical disks now.
			foreach my $this_logical_disk (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}})
			{
				next if $this_logical_disk eq "";
				my $say_bad_blocks =  $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{bad_blocks_exist} ? "Yes" : "No";
				my $say_size       =  $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{size};
				   $say_size       =~ s/(\w)B/$1iB/;	# The use 'GB' when it should be 'GiB'.
				my $logical_disk_state_class = "highlight_good";
				my $say_missing    = "";
				my $allow_offline  = 1;
				if ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{'state'} eq "Degraded")
				{
					lsi_control_get_missing_disks($conf, $this_adapter, $this_logical_disk);
					$allow_offline            = 0;
					$logical_disk_state_class = "highlight_bad";
					$say_missing = "<br />";
					foreach my $this_row (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{missing_row}})
					{
						my $say_minimum_size =  bytes_to_hr($conf, $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{missing_row}{$this_row});
						$say_missing         .= " - Missing disk in row: [<span class=\"fixed_width\">$this_row</span>], replace with: [$say_minimum_size] or larger.<br />\n";
					}
				}
				
				if ($this_logical_disk == 9999)
				{
					$allow_offline = 1;
					# Unconfigured disks.
					print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\">
			<table width=\"100%\" colspan=\"2\">
				<tr>
					<td colspan=\"2\">
						<b>Unconfigured Physical Disks</b>
					</td>
				</tr>
				<tr>
					<td colspan=\"2\">
						<br />
						The physical disks below are not currently a member of any logical disk.<br />
						<br />
					</td>
				</tr>
			</table>
			<br />
		</td>
	</tr>
";
				}
				else
				{
					# Real logical disk
					print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\">
			<table width=\"100%\" colspan=\"2\">
				<tr>
					<td colspan=\"3\">
						<b>Logical Disk #$this_logical_disk</b>
					</td>
				</tr>
				<tr>
					<td rowspan=\"9\" width=\"128px\" style=\"vertical-align: top;\">
 						<img src=\"/img/raid_logical-disk_128x128.png\" border=\"0\">
					</td>
					<td class=\"highlight_detail_left\">
						State:
					</td>
					<td class=\"fixed_width_left\">
						<span class=\"$logical_disk_state_class\">$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{state}</span> $say_missing
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Bad Blocks Exist:
					</td>
					<td class=\"fixed_width_left\">
						$say_bad_blocks
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						RAID Level:
					</td>
					<td class=\"fixed_width_left\">
						<a href=\"https://alteeve.ca/w/RAID_level_5#Level_$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{primary_raid_level}\" target=\"_new\">$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{primary_raid_level}</a>
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Size:
					</td>
					<td class=\"fixed_width_left\">
						$say_size
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Number of Drives:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{number_of_drives}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Encryption Type:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{encryption_type}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Target ID:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{target_id}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						LD Cache Policy:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{current_cache_policy}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Disk Cache Policy:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{disk_cache_policy}
					</td>
				</tr>
			</table>
			<br />
		</td>
	</tr>
";
				}
				
				# Display the drives in this logical disk.
				foreach my $this_enclosure_device_id (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}})
				{
					#print " | |- Enclusure Device ID: [$this_enclosure_device_id]<br />\n";
					foreach my $this_slot_number (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}})
					{
						my $raw_size_sectors = hex($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{raw_sector_count_in_hex});
						my $raw_size_bytes   = ($raw_size_sectors * $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sector_size});
						my $say_raw_size     = bytes_to_hr($conf, $raw_size_bytes);
						my $disk_temp_class  = "highlight_good";
						if ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_c} > 54)
						{
							$disk_temp_class = "highlight_dangerous";
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_c} > 45)
						{
							$disk_temp_class = "highlight_warning";
						}
						my $say_temperature = "<span class=\"$disk_temp_class\">$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_c} &deg;C ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_f} &deg;F)</span>";
						
						my $say_location_title = "Span, Arm, Device ID:";
						my $say_location_body  = "$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{span}, $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{arm}, $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_id}";
						if ($this_logical_disk == 9999)
						{
							$say_location_title = "Device ID:";
							$say_location_body  = "$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_id}";
						}
						
						my $offline_button = "<span class=\"highlight_unavailable\">Logical Disk not 'Optimal', Removal disabled";
						if ($allow_offline)
						{
							$offline_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=put_disk_offline&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter&logical_disk=$this_logical_disk\">Remove from Logical Disk</a>";
							if ($this_logical_disk == 9999)
							{
								$offline_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=spin_disk_down&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter&logical_disk=$this_logical_disk\">Spin Down Disk</a>";
							}
						}
						
						my $disk_state_class = "highlight_good";
						my $say_disk_action  = "";
						if ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Unconfigured(bad)")
						{
							$disk_state_class = "highlight_bad";
							$say_disk_action  = "<br /><a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=make_disk_good&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter\">Make Good</a>";
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Offline")
						{
							$disk_state_class = "highlight_detail";
							$say_disk_action  =  " - <a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=put_disk_online&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter\">Put Online</a>";
							$say_disk_action  .= " - <a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=spin_disk_down&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter\">Spin Down</a>";
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Rebuild")
						{
							my ($rebuild_percent, $time_to_complete) = lsi_control_get_rebuild_progress($conf, "$this_enclosure_device_id:$this_slot_number", $this_adapter);
							$disk_state_class = "highlight_warning";
							$say_disk_action  = "<br />Rebuild is <span class=\"highlight_detail\">$rebuild_percent%</span> complete, rebuilding for <span class=\"highlight_detail\">$time_to_complete</span>.";
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Unconfigured(good), Spun Up")
						{
							$disk_state_class = "highlight_detail";
							foreach my $this_logical_disk (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}})
							{
								next if $this_logical_disk eq "";
								if ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{'state'} eq "Degraded")
								{
									foreach my $this_row (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{missing_row}})
									{
										if ($raw_size_bytes >= $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{missing_row}{$this_row})
										{
											$say_disk_action =  "<br />\n" if not $say_disk_action;
											$say_disk_action .= "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=add_disk_to_array&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter&row=$this_row&logical_disk=$this_logical_disk\">Add to Logical Disk #$this_logical_disk</a><br />\n";
										}
									}
								}
								elsif ($this_logical_disk == 9999)
								{
									$say_disk_action =  "<br />\n" if not $say_disk_action;
									$say_disk_action .= "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=make_disk_hot_spare&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter\">Make Hot-Spare</a><br />\n";
									#$offline_button   = "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=make_disk_hot_spare&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter\">Make Hot-Spare</a>";
								}
							}
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Unconfigured(good), Spun down")
						{
							$disk_state_class = "highlight_detail";
							$say_disk_action  = "<br /><a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=spin_disk_up&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter\">Spin Up Drive</a>";
							$say_temperature  = "<span class=\"highlight_unavailable\">Temperaure unavailable while spun down</a>";
							$offline_button   = "Drive can now be removed.";
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Hotspare, Transition")
						{
							$disk_state_class = "highlight_detail";
							$say_disk_action  = "<br />Rebuild will begin in just a moment.";
							$say_temperature  = "<span class=\"highlight_unavailable\">Temperaure unavailable while in transition</a>";
							$offline_button   = "Drive is coming online";
						}
						elsif ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} eq "Hotspare, Spun Up")
						{
							$disk_state_class = "highlight_detail";
							$say_disk_action  = "";
							$offline_button   = "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=unmake_disk_as_hot_spare&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter&logical_disk=$this_logical_disk\">Unmark as Hot-Spare</a>";
						}
						my $disk_icon    = "/img/hard-drive_128x128.png";
						my $id_led_url   = "?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=start_id_disk&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter";
						my $say_identify = "Turn On";
						#print "adapter: [$this_adapter], Disk: [$this_enclosure_device_id:$this_slot_number], Locator ID Status: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit}]\n";
						if ($conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit})
						{
							$disk_icon    = "/img/hard-drive-with-led_128x128.png";
							$id_led_url   = "?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health&do=stop_id_disk&disk_address=$this_enclosure_device_id:$this_slot_number&adapter=$this_adapter";
							$say_identify = "Turn Off";
						}
						print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			<table width=\"100%\">
				<tr>
					<td colspan=\"3\">
						<b>Physical Disk [<span class=\"fixed_width\">$this_enclosure_device_id:$this_slot_number</span>]</b>
					</td>
				</tr>
				<tr>
					<td rowspan=\"16\" width=\"128px\" style=\"vertical-align: top;\">
						<a href=\"$id_led_url\"><img src=\"$disk_icon\" border=\"0\"></a>
					</td>
					<td class=\"highlight_detail_left\">
						Model:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{inquiry_data}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						World Wide Number:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{wwn}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						State:
					</td>
					<td class=\"fixed_width_left\">
						<span class=\"$disk_state_class\">$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state}</span>
						$say_disk_action
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Drive Temperature:
					</td>
					<td class=\"fixed_width_left\">
						$say_temperature
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Identify Light:
					</td>
					<td class=\"fixed_width_left\">
						<a href=\"$id_led_url\">$say_identify</a>
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Device Type:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{media_type}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Media Error Count:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{media_error_count}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						\"Other\" Error Count:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{other_error_count}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Predictive Failure Count:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{predictive_failure_count}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Raw Drive Size:
					</td>
					<td class=\"fixed_width_left\">
						$say_raw_size
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Interface:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{pd_type}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Device -> Adapter Speed:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_speed} -> $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{link_speed}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						SAS Address 0:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sas_address_0}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						SAS Address 01:
					</td>
					<td class=\"fixed_width_left\">
						$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sas_address_1}
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						$say_location_title
					</td>
					<td class=\"fixed_width_left\">
						$say_location_body
					</td>
				</tr>
				<tr>
					<td class=\"highlight_detail_left\">
						Remove Drive:
					</td>
					<td class=\"fixed_width_left\">
						$offline_button
					</td>
				</tr>
			</table>
			<br />
		</td>
	</tr>
";
					}
				}
			}
		}
	}
	
	print "
</table>
<br />
";

	return(0);
}

# This determines what kind of storage the user has and then calls the
# appropriate function to gather the details.
sub get_storage_data
{
	my ($conf, $node) = @_;
	
	$conf->{storage}{is}{lsi}   = "";
	$conf->{storage}{is}{hp}    = "";
	$conf->{storage}{is}{mdadm} = "";
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		#shell_call	=>	"whereis MegaCli64 hpacucli mdadm",
		shell_call	=>	"whereis MegaCli64 hpacucli",
	});
	#record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^(.*?):\s(.*)/)
		{
			my $program = $1;
			my $path    = $2;
			#print "program: [$program], path: [$path]\n";
			if ($program eq "MegaCli64")
			{
				$conf->{storage}{is}{lsi} = $path;
				#record($conf, "$THIS_FILE ".__LINE__."; storage::is::lsi: [$conf->{storage}{is}{lsi}]\n");
			}
			elsif ($program eq "hpacucli")
			{
				$conf->{storage}{is}{hp} = $path;
				#record($conf, "$THIS_FILE ".__LINE__."; storage::is::hp: [$conf->{storage}{is}{hp}]\n");
			}
			elsif ($program eq "mdadm")
			{
				### TODO: This is always installed... 
				### Check if any arrays are configured and drop this if none.
				$conf->{storage}{is}{mdadm} = $path;
				#record($conf, "$THIS_FILE ".__LINE__."; storage::is::mdadm: [$conf->{storage}{is}{mdadm}]\n");
			}
		}
	}
	
	# For now, only LSI is supported.
	if ($conf->{storage}{is}{lsi})
	{
		get_storage_data_lsi($conf, $node);
	}
	
	return(0);
}

# This uses the 'MegaCli64' program to gather information about the LSI-based
# storage of a node.
sub get_storage_data_lsi
{
	my ($conf, $node) = @_;
	#print "<pre style=\"background: white;\">";
	
	# This is used when recording all fields.
	my $this_adapter = "";
	
	# Each section's title has an opening and closing line of "==". This is
	# used to skip the first one.
	my $skip_equal_sign_bar = 0;
	
	# These are used to sort out fields from Hardware Info.
	my $in_hw_information = 0;
	my $in_settings       = 0;
	
	# This is used for sorting logical disk info.
	my $this_logical_disk = "";
	
	# These are used for sorting physical disks.
	my $this_enclosure_device_id = "";
	my $this_slot_number         = "";
	my $this_span                = "";
	my $this_arm                 = "";
	
	# Delete any old data.
	delete $conf->{storage}{lsi}{adapter};
	
	# This is set to 1 once all the discovered physical drives have been
	# found and their ID LED statuses set to '0'.
	my $initial_led_state_set = 0;
	
	# Now call.
	my $in_section     =  0;
	my $megacli64_path =  $conf->{storage}{is}{lsi};
	my $shell_call     =  "echo '==] Start adapter_info'; $megacli64_path AdpAllInfo aAll; ";
	   $shell_call     .= "echo '==] Start bbu_info'; $megacli64_path AdpBbuCmd aAll; ";
	   $shell_call     .= "echo '==] Start logical_disk_info'; $megacli64_path LDInfo Lall aAll; ";
	   $shell_call     .= "echo '==] Start physical_disk_info'; $megacli64_path PDList aAll; ";
	   $shell_call     .= "echo '==] Start pd_id_led_state'; $conf->{path}{grep} \"PD Locate\" /root/MegaSAS.log;";
	record($conf, "$THIS_FILE ".__LINE__."; shell_call: [$shell_call]\n");
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"$shell_call",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if not $line;
		if ($line =~ /==] Start (.*)/)
		{
			$in_section        = $1;
			$this_adapter      = "";
			$this_logical_disk = "";
			next;
		}
		if ($in_section eq "adapter_info")
		{
			### TODO: Get the amount of cache allocated to 
			###       write-back vs. read caching and make it
			###       adjustable.
			#print "in_section: [$in_section], line: [$line]\n";
			if ($line =~ /Adapter #(\d+)/)
			{
				$this_adapter = $1;
				next;
			}
			next if $this_adapter eq "";
			
			if (($skip_equal_sign_bar) && ($line =~ /^====/))
			{
				$skip_equal_sign_bar = 0;
				#print "LSI Adapter: [$conf->{storage}{lsi}{adapter}{$this_adapter}{product_name}], skip_equal_sign_bar: [$skip_equal_sign_bar]\n";
				next;
			}
			
			if ($line =~ /Product Name\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{product_name} = $1;
				#print "LSI Adapter number: [$this_adapter], Controller Description: [$conf->{storage}{lsi}{adapter}{$this_adapter}{product_name}]\n";
			}
			
			# Hardware Configuration values.
			if ($line eq "HW Configuration")
			{
				$in_hw_information   = 1;
				$skip_equal_sign_bar = 1;
				#print "LSI Adapter: [$conf->{storage}{lsi}{adapter}{$this_adapter}{product_name}], in_hw_information: [$in_hw_information], skip_equal_sign_bar: [$skip_equal_sign_bar]\n";
				next
			}
			elsif ($in_hw_information)
			{
				if ($line =~ /^====/)
				{
					$in_hw_information = 0;
					#print "LSI Adapter: [$conf->{storage}{lsi}{adapter}{$this_adapter}{product_name}], in_hw_information: [$in_hw_information]\n";
					next
				}
				elsif ($line =~ /Memory Size\s*:\s*(.*)/)
				{
					$conf->{storage}{lsi}{adapter}{$this_adapter}{cache_size} = $1;
					#print "LSI Adapter number: [$this_adapter], Controller cache_size: [$conf->{storage}{lsi}{adapter}{$this_adapter}{cache_size}]\n";
				}
				elsif ($line =~ /BBU\s*:\s*(.*)/)
				{
					my $bbu_is = $1;
					$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu_is} = $bbu_is eq "Present" ? 1 : 0;
					#print "LSI Adapter number: [$this_adapter], Controller BBU Present? [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu_is} ($bbu_is)]\n";
				}
				elsif ($line =~ /Flash\s*:\s*(.*)/)
				{
					my $flash_is = $1;
					$conf->{storage}{lsi}{adapter}{$this_adapter}{flash_is} = $flash_is eq "Present" ? 1 : 0;
					#print "LSI Adapter number: [$this_adapter], Controller Flash Present? [$conf->{storage}{lsi}{adapter}{$this_adapter}{flash_is} ($flash_is)]\n";
				}
			}
			
			# Settings.
			if ($line eq "Settings")
			{
				$in_settings         = 1;
				$skip_equal_sign_bar = 1;
				next
			}
			elsif ($in_hw_information)
			{
				if ($line =~ /^====/)
				{
					$in_settings = 0;
					next
				}
				elsif ($line =~ /Restore HotSpare on Insertion\s*:\s*(.*)/)
				{
					my $is_enabled = $1;
					$conf->{storage}{lsi}{adapter}{$this_adapter}{restore_hotspare_on_insertion} = $is_enabled eq "Enabled" ? 1 : 0;
					#print "LSI Adapter number: [$this_adapter], Controller Restore HotSpare on Insertion: [$conf->{storage}{lsi}{adapter}{$this_adapter}{restore_hotspare_on_insertion} ($is_enabled)]\n";
				}
			}
		}
		elsif ($in_section eq "bbu_info")
		{
			#print "in_section: [$in_section], line: [$line]\n";
			if ($line =~ /BBU status for Adapter\s*:\s*(\d+)/)
			{
				$this_adapter = $1;
				#print "LSI Adapter number: [$this_adapter], BBU.\n";
				next;
			}
			next if $this_adapter eq "";
			
			if ($line =~ /BatteryType\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{type} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU type: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{type}]\n";
			}
			elsif ($line =~ /Battery State\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{battery_state} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU State: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{battery_state}]\n";
			}
			elsif ($line =~ /Learn Cycle Active\s*:\s*(.*)/)
			{
				my $learn_cycle_active = $1;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{learn_cycle_active} = $learn_cycle_active eq "Yes" ? 1 : 0;
				#print "LSI Adapter number: [$this_adapter], BBU Learn Cycle Active: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{learn_cycle_active} ($learn_cycle_active)]\n";
			}
			elsif ($line =~ /Pack is about to fail & should be replaced\s*:\s*(.*)/)
			{
				my $replace_bbu = $1;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{replace_bbu} = $replace_bbu eq "Yes" ? 1 : 0;
				#print "LSI Adapter number: [$this_adapter], BBU Should be replaced: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{replace_bbu} ($replace_bbu)]\n";
			}
			elsif ($line =~ /Design Capacity\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{design_capacity} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Design Capacity: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{design_capacity}]\n";
			}
			elsif ($line =~ /Remaining Capacity Alarm\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{remaining_capacity_alarm} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Remaining Capacity Alarm: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{remaining_capacity_alarm}]\n";
			}
			elsif ($line =~ /Cycle Count\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{cycle_count} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Cycle Count: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{cycle_count}]\n";
			}
			elsif ($line =~ /Next Learn time\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{next_learn_time} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Next Learn Time: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{next_learn_time}]\n";
			}
			elsif ($line =~ /Remaining Capacity\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{remaining_capacity} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Remaining Capacity: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{remaining_capacity}]\n";
			}
			elsif ($line =~ /Full Charge Capacity\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{full_capacity} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Full Capacity: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{full_capacity}]\n";
			}
			elsif ($line =~ /Manufacture Name\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{manufacture_name} = $1;
				#print "LSI Adapter number: [$this_adapter], BBU Manufactore Name: [$conf->{storage}{lsi}{adapter}{$this_adapter}{bbu}{manufacture_name}]\n";
			}
		}
		elsif ($in_section eq "logical_disk_info")
		{
			#print "in_section: [$in_section], line: [$line]\n";
			if ($line =~ /Adapter (\d+) -- Virtual Drive Information/)
			{
				$this_adapter = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk.\n";
				next;
			}
			next if $this_adapter eq "";
			
			if ($line =~ /Virtual Drive: (\d+) \(Target Id: (\d+)\)/)
			{
				$this_logical_disk = $1;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{target_id} = $2;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Target ID: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{target_id}]\n";
			}
			next if $this_logical_disk eq "";
			
			if ($line =~ /^Size\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{size} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Size: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{size}]\n";
			}
			elsif ($line =~ /State\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{'state'} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], State: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{'state'}]\n";
			}
			elsif ($line =~ /Current Cache Policy\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{current_cache_policy} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Current Cache Policy: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{current_cache_policy}]\n";
			}
			elsif ($line =~ /Bad Blocks Exist\s*:\s*(.*)/)
			{
				my $bad_blocks = $1;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{bad_blocks_exist} = $bad_blocks eq "Yes" ? 1 : 0;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Bad Blocks Exist: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{bad_blocks_exist} ($bad_blocks)]\n";
			}
			elsif ($line =~ /Number Of Drives\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{number_of_drives} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Number of drives: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{number_of_drives}]\n";
			}
			elsif ($line =~ /Encryption Type\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{encryption_type} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Encryption Type: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{encryption_type}]\n";
			}
			elsif ($line =~ /Disk Cache Policy\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{disk_cache_policy} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Disk Cache Policy: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{disk_cache_policy}]\n";
			}
			elsif ($line =~ /Sector Size\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{sector_size} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Sector size: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{sector_size}]\n";
			}
			elsif ($line =~ /RAID Level\s*:\s*Primary-(\d+), Secondary-(\d+), RAID Level Qualifier-(\d+)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{primary_raid_level}   = $1;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{secondary_raid_level} = $2;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{raid_qualifier}       = $3;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Primary RAID level: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{primary_raid_level}]\n";
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Secondary RAID level: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{secondary_raid_level}]\n";
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], RAID Qualifier: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{raid_qualifier}]\n";
			}
		}
		elsif ($in_section eq "physical_disk_info")
		{
			### TODO: Confirm that 'Disk Group' in fact relates to
			###       the logical disk ID.
			#print "in_section: [$in_section], line: [$line]\n";
			if ($line =~ /Adapter #(\d+)/)
			{
				$this_adapter = $1;
				#print "LSI Adapter number: [$this_adapter], Physical Disk.\n";
				next;
			}
			next if $this_adapter eq "";
			
			if ($line =~ /Enclosure Device ID\s*:\s*(\d+)/)
			{
				$this_enclosure_device_id = $1;
				# New device, clear the old logical disk, span and arm.
				$this_logical_disk = "";
				$this_span         = "";
				$this_arm          = "";
				#print "\nLSI Adapter number: [$this_adapter], Physical Disk, Encluse Device ID: [$this_enclosure_device_id].\n";
				next;
			}
			if ($line =~ /Slot Number\s*:\s*(\d+)/)
			{
				$this_slot_number = $1;
				#print "LSI Adapter number: [$this_adapter], Physical Disk, Slot Number: [$this_slot_number].\n";
				next;
			}
			if ($line =~ /Drive's position: DiskGroup: (\d+), Span: (\d+), Arm: (\d+)/)
			{
				$this_logical_disk = $1;
				$this_span         = $2;
				$this_arm          = $3;
				#print "LSI Adapter number: [$this_adapter], Disk Group: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number].\n";
				next;
			}
			if (($line =~ /Enclosure position: N\/A/) && ($this_logical_disk eq ""))
			{
				# This is a disk not yet in any array.
				$this_logical_disk = "9999";
				$this_span         = "9999";
				$this_arm          = "9999";
				#print "LSI Adapter number: [$this_adapter], Disk Group: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number].\n";
				next;
			}
			next if (($this_enclosure_device_id eq "") or ($this_slot_number eq "") or ($this_logical_disk eq ""));
			
			if (not exists $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{span})
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{span} = $this_span;
				#print "LSI Adapter number: [$this_adapter], Disk Group: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number].\n";
			}
			if (not exists $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{arm})
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{arm}  = $this_arm;
			}
			
			# Record the slot number.
			
			if ($line =~ /Device Id\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_id} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Device ID: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_id}]\n";
			}
			elsif ($line =~ /WWN\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{wwn} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], World Wide Number: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{wwn}]\n";
			}
			elsif ($line =~ /Sequence Number\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sequence_number} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Sequence Number: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sequence_number}]\n";
			}
			elsif ($line =~ /Media Error Count\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{media_error_count} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Media Error Count: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{media_error_count}]\n";
			}
			elsif ($line =~ /Other Error Count\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{other_error_count} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Other Error Count: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{other_error_count}]\n";
			}
			elsif ($line =~ /Predictive Failure Count\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{predictive_failure_count} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Predictive Failure Count: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{predictive_failure_count}]\n";
			}
			elsif ($line =~ /PD Type\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{pd_type} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Physical Disk Type: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{pd_type}]\n";
			}
			elsif ($line =~ /Raw Size: .*? \[0x(.*?) Sectors\]/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{raw_sector_count_in_hex} = "0x".$1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Raw Sector Count in Hex: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{raw_sector_count_in_hex}]\n";
			}
			elsif ($line =~ /Sector Size\s*:\s*(.*)/)
			{
				# NOTE: Some drives report 0. If this is the
				#       case, we'll use the logical disk sector
				#       size, if available. If not, we'll 
				#       assume 512 bytes.
				my $sector_size = $1;
				if (not $sector_size)
				{
					$sector_size = $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{sector_size} ? $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{sector_size} : 512;
				}
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sector_size} = $sector_size ? $sector_size : 512;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Sector Size: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sector_size}]\n";
			}
			elsif ($line =~ /Firmware state\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Firmware-Reported State: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{firmware_state}]\n";
			}
			elsif ($line =~ /SAS Address\(0\)\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sas_address_0} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], SAS Address, Port #0: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sas_address_0}]\n";
			}
			elsif ($line =~ /SAS Address\(1\)\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sas_address_1} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], SAS Address, Port #1: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{sas_address_1}]\n";
			}
			elsif ($line =~ /Connected Port Number\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{connected_port_number} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Connected Port Number: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{connected_port_number}]\n";
			}
			elsif ($line =~ /Inquiry Data\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{inquiry_data} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Drive Data: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{inquiry_data}]\n";
			}
			elsif ($line =~ /Device Speed\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_speed} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Device Speed: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{device_speed}]\n";
			}
			elsif ($line =~ /Link Speed\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{link_speed} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Link Speed: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{link_speed}]\n";
			}
			elsif ($line =~ /Media Type\s*:\s*(.*)/)
			{
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{media_type} = $1;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Media Type: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{media_type}]\n";
			}
			elsif ($line =~ /Drive Temperature\s*:\s*(\d+)C \((.*?) F\)/)
			{
				my $temp_c = $1;
				my $temp_f = $2;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_c} = $temp_c;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_f} = $temp_f;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Drive Temperature (*C): [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_c}]\n";
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], Drive Temperature (*F): [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{drive_temp_f}]\n";
			}
			elsif ($line =~ /Drive has flagged a S.M.A.R.T alert\s*:\s*(.*)/)
			{
				my $alert = $1;
				$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{smart_alert} = $alert eq "Yes" ? 1 : 0;
				#print "LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], SMART Alert: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{smart_alert} ($alert)]\n";
			}
		}
		elsif ($in_section eq "pd_id_led_state")
		{
			### TODO: Verify this catches/tracks unconfigured PDs.
			# Assume all physical drives have their ID LEDs off.
			# Not great, but there is no way to check the state
			# directly.
			if (not $initial_led_state_set)
			{
				$initial_led_state_set = 1;
				foreach my $this_adapter (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}})
				{
					#print __LINE__."; LSI Adapter number: [$this_adapter]\n";
					foreach my $this_logical_disk (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}})
					{
						#print __LINE__.";  - Logical Disk: [$this_logical_disk]\n";
						foreach my $this_enclosure_device_id (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}})
						{
							#print __LINE__.";    - Enclosure Device ID: [$this_enclosure_device_id]\n";
							foreach my $this_slot_number (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}})
							{
								#print __LINE__.";      - Slot ID: [$this_slot_number]\n";
								$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit} = 0;
								#print __LINE__."; >> storage::lsi::adapter::${this_adapter}::logical_disk::${this_logical_disk}::enclosure_device_id::${this_enclosure_device_id}::slot_number::${this_slot_number}::id_led_lit: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit}]\n";
								#print __LINE__.";        - LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], id_led_lit: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit}]\n";
							}
						}
					}
				}
			}
			$line = lc($line);
			$this_adapter             = "";
			$this_logical_disk        = "";
			$this_enclosure_device_id = "";
			$this_slot_number         = "";
			my $this_action           = "";
			my $set_state             = "";
			#print "<pre style=\"background: white;\">\n";
			#print __LINE__."; line: [$line]\n";
			if ($line =~ /adapter: (\d+): device at enclid-(\d+) slotid-(\d+) -- pd locate (.*?) command was successfully sent to firmware/)
			{
				$this_adapter             = $1;
				$this_enclosure_device_id = $2;
				$this_slot_number         = $3;
				$this_action              = $4;
				$set_state                = $this_action eq "start" ? 1 : 0;
				#print __LINE__."; - this_adapter: [$this_adapter], this_logical_disk: [$this_logical_disk], this_enclosure_device_id: [$this_enclosure_device_id], this_slot_number: [$this_slot_number], this_action: [$this_action], set_state: [$set_state]\n";
				
				# the log doesn't reference the disk's logic
				# drive, so we loop through all looking for a
				# match.
				foreach my $this_adapter (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}})
				{
					#print __LINE__."; Adapter: [$this_adapter]\n";
					foreach my $this_logical_disk (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}})
					{
						#print __LINE__.";   - Adapter: [$this_logical_disk], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number]\n";
						if (exists $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number})
						{
							$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit} = $set_state;
							#print __LINE__.";     - Exists\n\n";
							#print __LINE__.";     - Set State: LSI Adapter number: [$this_adapter], Logical Disk: [$this_logical_disk], Enclosure Device ID: [$this_enclosure_device_id], Slot Number: [$this_slot_number], id_led_lit: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit}]\n";
							last;
						}
						else
						{
							#print __LINE__.";     - Doesn't exist.\n";
						}
					}
				}
			}
			#print "</pre>\n";
		}
		else
		{
			die "$THIS_FILE ".__LINE__."; unknown section!, line: [$line]\n";
		}
	}
	
	# This is purely debug to show the status of the drive LEDs.
	foreach my $this_adapter (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}})
	{
		foreach my $this_logical_disk (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}})
		{
			foreach my $this_enclosure_device_id (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}})
			{
				foreach my $this_slot_number (sort {$a cmp $b} keys %{$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}})
				{
					if (exists $conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit})
					{
						#print __LINE__."; adapter: [$this_adapter], Logical Disk: [$this_logical_disk], Disk Address: [$this_enclosure_device_id:$this_slot_number], Locator ID Status: [$conf->{storage}{lsi}{adapter}{$this_adapter}{logical_disk}{$this_logical_disk}{enclosure_device_id}{$this_enclosure_device_id}{slot_number}{$this_slot_number}{id_led_lit}]<br />\n";
					}
				}
			}
		}
	}
	#print "</pre>\n";
	
	return(0);
}

# This changes the amount of RAM or the number of CPUs allocated to a VM.
sub change_vm
{
	my ($conf, $node) = @_;
	
	my $cluster             = $conf->{cgi}{cluster};
	my $vm                  = $conf->{cgi}{vm};
	my $say_vm              = ($vm =~ /vm:(.*)/)[0];
	my $node1               = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2               = $conf->{clusters}{$cluster}{nodes}[1];
	my $device              = $conf->{cgi}{device};
	my $definition_file     = "/shared/definitions/$say_vm.xml";
	my $other_allocated_ram = $conf->{resources}{allocated_ram} - $conf->{vm}{$vm}{details}{ram};
	
	# Read the values the user passed, see if they differ from what
	# was read in the config and, if they do differ, make sure the
	# requested resources are available. If all this passes, 
	# rewrite the definition file and tell the user to stop/start
	# their server for the changes to take effect.
	my $current_ram           =  $conf->{vm}{$vm}{details}{ram};
	my $available_ram         =  ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram} - $conf->{resources}{allocated_ram}) + $current_ram;
	   $current_ram           /= 1024;
	my $requested_ram         =  hr_to_bytes($conf, $conf->{cgi}{ram}, $conf->{cgi}{ram_suffix}, 1);
	   $requested_ram         /= 1024;
	my $max_ram               =  $available_ram / 1024;
	my $current_cpus          =  $conf->{vm}{$vm}{details}{cpu_count};
	my $requested_cpus        =  $conf->{cgi}{cpu_cores};
	my $current_boot_device   =  $conf->{vm}{$vm}{current_boot_device};
	my $requested_boot_device =  $conf->{cgi}{boot_device};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - requested RAM:          [$requested_ram]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - current RAM:            [$current_ram]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - requested CPUs: [$requested_cpus]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - current CPUs:   [$current_cpus]\n");
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b>Updating the <span class=\"fixed_width\">$say_vm</span> server's CPU, RAM and boot devices...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			<br />
			Changing<br />
			<br />
		</td>
		<td>
";
	# Make sure something changed.
	if (
		($current_ram         ne $requested_ram)         || 
		($current_cpus        ne $requested_cpus)        || 
		($current_boot_device ne $requested_boot_device)
	)
	{
		# Something has changed. Make sure the request is sane,
		my $max_cpus      = $conf->{resources}{total_threads};
		record($conf, "$THIS_FILE ".__LINE__."; requested ram:    [$requested_ram]\n");
		record($conf, "$THIS_FILE ".__LINE__.";       max ram:    [$max_ram]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; requested cpus:   [$requested_cpus]\n");
		#record($conf, "$THIS_FILE ".__LINE__.";       max cpus:   [$max_cpus]\n");
		if ($requested_ram > $max_ram)
		{
			my $say_requested_ram = bytes_to_hr($conf, ($requested_ram * 1024));
			my $say_max_ram       = bytes_to_hr($conf, ($max_ram * 1024));
			print "
				Requested RAM was higher than available.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning!
		</td>
		<td>
			You've requested that the new RAM for this server be: [<span class=\"fixed_width\">$say_requested_ram</span>].<br />
			Unfortunately, the highest you can use is: [<span class=\"fixed_width\">$say_max_ram</span>].<br />
			Did someone else allocate some of the free RAM to another server?<br />
			No changes were made.<br />
		</td>
	</tr>
</table>
<br />
";
		}
		elsif ($requested_cpus > $max_cpus)
		{
			print "
				Requested CPU count was higher than available.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning!
		</td>
		<td>
			You've requested that the CPU count for this server be: [<span class=\"fixed_width\">$requested_cpus</span>].<br />
			Unfortunately, the highest you can use is: [<span class=\"fixed_width\">$max_cpus</span>].<br />
			No changes were made.<br />
		</td>
	</tr>
</table>
<br />
";
		}
		else
		{
			# Request is sane. Archive the current definition.
			my ($backup) = archive_file($conf, $node, $definition_file, 1);
			
			# Make the boot device easier to understand.
			my $say_requested_boot_device = $requested_boot_device;
			if ($requested_boot_device eq "hd")
			{
				$say_requested_boot_device = "Hard drive";
			}
			elsif ($requested_boot_device eq "cdrom")
			{
				$say_requested_boot_device = "Optical drive";
			}
			
			# Rewrite the XML file.
			print "<br />Setting the RAM to [<span class=\"fixed_width\">$conf->{cgi}{ram} $conf->{cgi}{ram_suffix}</span>], the number of CPUs to: [<span class=\"fixed_width\">$requested_cpus</span>] and the boot device to [<span class=\"fixed_width\">$say_requested_boot_device</span>].<br /><br />\n";
			my $new_definition = "";
			my $in_os          = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my ($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$node,
				port		=>	$conf->{node}{$node}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	"",
				'close'		=>	0,
				shell_call	=>	"cat $definition_file",
			});
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], line: [$line]\n");
				if ($line =~ /^(.*?)<memory>\d+<\/memory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<memory>$requested_ram<\/memory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<memory unit='.*?'>\d+<\/memory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<memory unit='KiB'>$requested_ram<\/memory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<currentMemory>\d+<\/currentMemory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<currentMemory>$requested_ram<\/currentMemory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<currentMemory unit='.*?'>\d+<\/currentMemory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<currentMemory unit='KiB'>$requested_ram<\/currentMemory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<vcpu>(\d+)<\/vcpu>/)
				{
					my $prefix = $1;
					$line = "${prefix}<vcpu>$requested_cpus<\/vcpu>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<vcpu placement='(.*?)'>(\d+)<\/vcpu>/)
				{
					my $prefix    = $1;
					my $placement = $2;
					$line = "${prefix}<vcpu placement='$placement'>$requested_cpus<\/vcpu>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /<os>/)
				{
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], going into the OS block.\n");
					$in_os          =  1;
					$new_definition .= "$line\n";
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding line: [$line].\n");
					next;
				}
				if ($in_os)
				{
					if ($line =~ /<\/os>/)
					{
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], exiting the OS block.\n");
						$in_os          =  0;
						# Write out the new list of 
						# boot devices. Start with the
						# requested boot device and 
						# then loop through the rest.
						$new_definition .= "    <boot dev='$requested_boot_device'/>\n";
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding initiall boot device: [$requested_boot_device]\n");
						foreach my $device (split /,/, $conf->{vm}{$vm}{available_boot_devices})
						{
							next if $device eq $requested_boot_device;
							$new_definition .= "    <boot dev='$device'/>\n";
							#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding device: [$device] to boot list\n");
						}
						
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding line: [$line].\n");
						$new_definition .= "$line\n";
						next;
					}
					elsif ($line !~ /<boot dev/)
					{
						$new_definition .= "$line\n";
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding to 'os' element line: [$line].\n");
						next;
					}
				}
				else
				{
					$new_definition .= "$line\n";
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding line: [$line].\n");
				}
			}
			$new_definition =~ s/(\S)\s+$/$1\n/;
			$conf->{vm}{$vm}{available_boot_devices} =~ s/,$//;
			#record($conf, "$THIS_FILE ".__LINE__."; new definition: [$new_definition]\n");
			
			# Write the new definition file.
			($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$node,
				port		=>	$conf->{node}{$node}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	$ssh_fh,
				'close'		=>	1,
				shell_call	=>	"echo \"$new_definition\" > $definition_file && chmod 644 $definition_file",
			});
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				print "\t\t\t<span class=\"code\">$line</span><br />\n";
			}
			
			# Wipe and re-read the definition file's XML and reset
			# the amount of RAM and the number of CPUs allocated
			# to this machine.
			$conf->{vm}{$vm}{xml}                = [];	# this is probably redundant
			@{$conf->{vm}{$vm}{xml}}             = split/\n/, $new_definition;
			#record($conf, "$THIS_FILE ".__LINE__."; requested_ram: [$requested_ram KiB (".bytes_to_hr($conf, ($requested_ram * 1024)).")], vm::${vm}::details::ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$conf->{vm}{$vm}{details}{ram}       = ($requested_ram * 1024);
			#record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::details::ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$conf->{resources}{allocated_ram}    = $other_allocated_ram + ($requested_ram * 1024);
			$conf->{vm}{$vm}{details}{cpu_count} = $requested_cpus;
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note_bold\">
			Note!
		</td>
		<td>
			<br />
			<i>You need to power off the server for the changes to take effect.</i><br />
			<br />
			There are two ways to do this:<br />
			<br />
			<table class=\"hidden_table\">
				<tr>
					<td class=\"td_hidden\" style=\"text-align: left;\">
						<span class=\"code\">1.</span> Gracefully power off and then boot back up the server.<br />
						<br />
						<span class=\"code\">2.</span> While logged into your server, directly shut the OS down.<br />
						<span class=\"code\"> &nbsp;</span> The Anvil will automatically restart the server with the new settings.<br />
					</td>
				</tr>
			</table>
			<br />
			Please don't just reboot. The configuration file is read on initial boot only.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><a href=\"?cluster=$conf->{cgi}{cluster}&vm=$conf->{cgi}{vm}&task=manage_vm\" class=\"button\">Back to Configuration</a></div>
		</td>
	</tr>
</table>
<br />
";
			footer($conf);
			exit(0);
		}
	}
	else
	{
		# Nothing changed.
		print "
			It looks like neither the amount of RAM or the number of CPUs has changed.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			No change was made to the server.<br />
		</td>
	</tr>
</table>
<br />
";
	}
	
	return (0);
}

# This inserts an ISO into the server's virtual optical drive.
sub vm_insert_media
{
	my ($conf, $node, $insert_media, $insert_drive, $vm_is_running) = @_;
	
	my $cluster         = $conf->{cgi}{cluster};
	my $vm              = $conf->{cgi}{vm};
	my $say_vm          = ($vm =~ /vm:(.*)/)[0];
	my $node1           = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2           = $conf->{clusters}{$cluster}{nodes}[1];
	my $device          = $conf->{cgi}{device};
	my $definition_file = "/shared/definitions/$say_vm.xml";

	# Archive the current config, just in case.
	my ($backup)   = archive_file($conf, $node, $definition_file, 1);
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b>Inserting <span class=\"fixed_width\">$insert_media</span> into <span class=\"fixed_width\">$insert_drive</span>...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Inserting
		</td>
		<td>
";
	
	# How I do this depends on whether the VM is running or not.
	if ($vm_is_running)
	{
		# It is, so I will use 'virsh'.
		my $virsh_exit_code;
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"virsh change-media $say_vm $insert_drive --insert /shared/files/$insert_media; echo virsh:\$?",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			next if not $line;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ /virsh:(\d+)/)
			{
				$virsh_exit_code = $1;
			}
			else
			{
				print "<span class=\"code\">$line</span><br />\n";
			}
		}
		if ($virsh_exit_code eq "1")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Note
		</td>
		<td>
			It looks like someone else already inserted a disc.<br />
		</td>
	</tr>
</table>
<br />
";
			# Update the definition file in case it was missed by .
			update_vm_definition($conf, $node, $vm);
		}
		elsif ($virsh_exit_code eq "0")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Success
		</td>
		<td>
			The disc was inserted successfully.<br />
		</td>
	</tr>
</table>
<br />
";

			# Update the definition file.
			update_vm_definition($conf, $node, $vm);
		}
		else
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to insert the disc: [$insert_media] into the drive: [$insert_drive] and the command should have returned [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$virsh_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		}
	}
	else
	{
		# The VM isn't running. Directly re-write the XML file.
		print "The machine is shut off.<br />\n";
		print "Updating <span class=\"fixed_width\">$say_vm</span>'s definition file directly.<br />\n";
		my $new_definition = "";
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	"cat $definition_file",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /dev='(.*?)'/)
			{
				my $this_device = $1;
				record($conf, "$THIS_FILE ".__LINE__."; Found the device: [$this_device].\n");
				if ($this_device eq $insert_drive)
				{
					$new_definition .= "      <source file='/shared/files/$insert_media'/>\n";
				}
			}
			$new_definition .= "$line\n";
		}
		$new_definition =~ s/(\S)\s+$/$1\n/;
		#record($conf, "$THIS_FILE ".__LINE__."; new definition: [$new_definition]\n");
		
		# Write the new definition file.
		#print "\t\t\tSaving the new configuration...<br />\n";
		($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	$ssh_fh,
			'close'		=>	1,
			shell_call	=>	"echo \"$new_definition\" > $definition_file && chmod 644 $definition_file",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			print "\t\t\t<span class=\"code\">$line</span><br />\n";
		}
		print "
			Done!
			<br />
		</td>
	</tr>
</table>
<br />
";
		# Lastly, copy the new definition to the stored XML for
		# this VM.
		$conf->{vm}{$vm}{xml}    = [];	# this is probably redundant
		@{$conf->{vm}{$vm}{xml}} = split/\n/, $new_definition;
	}
	
	return(0);
}

# This ejects an ISO from a server's virtual optical drive.
sub vm_eject_media
{
	my ($conf, $node, $vm_is_running) = @_;
	
	my $cluster         = $conf->{cgi}{cluster};
	my $vm              = $conf->{cgi}{vm};
	my $say_vm          = ($vm =~ /vm:(.*)/)[0];
	my $node1           = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2           = $conf->{clusters}{$cluster}{nodes}[1];
	my $device          = $conf->{cgi}{device};
	my $definition_file = "/shared/definitions/$say_vm.xml";
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b>Ejecting $conf->{cgi}{device}...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Ejecting
		</td>
		<td>
";
	
	# Archive the current config, just in case.
	my ($backup) = archive_file($conf, $node, $definition_file, 1);
	my $drive    = $conf->{cgi}{device};
	
	# How I do this depends on whether the VM is running or not.
	if ($vm_is_running)
	{
		# It is, so I will use 'virsh'.
		my $virsh_exit_code;
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"virsh change-media $say_vm $conf->{cgi}{device} --eject; echo virsh:\$?",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			next if not $line;
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ /virsh:(\d+)/)
			{
				$virsh_exit_code = $1;
			}
			else
			{
				print "<span class=\"code\">$line</span><br />\n";
			}
		}
		if ($virsh_exit_code eq "1")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Note
		</td>
		<td>
			It would appear that someone else already ejected the disc.<br />
		</td>
	</tr>
</table>
<br />
";
			# Update the definition file in case it was missed by .
			update_vm_definition($conf, $node, $vm);
		}
		elsif ($virsh_exit_code eq "0")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Success
		</td>
		<td>
			The optical drive's media has been ejected.<br />
		</td>
	</tr>
</table>
<br />
";
			
			# Update the definition file.
			update_vm_definition($conf, $node, $vm);
		}
		else
		{
			$virsh_exit_code = "-" if not defined $virsh_exit_code;
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to eject the disc in drive: [<span class=\"fixed_width\">$drive</span>] and the command should have returned [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$virsh_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		}
	}
	else
	{
		# The VM isn't running. Directly re-write the XML file.
		print "The machine is shut off.<br />\n";
		print "Updating <span class=\"fixed_width\">$say_vm</span>'s definition file directly.<br />\n";
		my $in_cdrom       = 0;
		my $this_media     = "";
		my $this_device    = "";
		my $new_definition = "";
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	"cat $definition_file",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$new_definition .= "$line\n";
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if (($line =~ /type='file'/) && ($line =~ /device='cdrom'/))
			{
				record($conf, "$THIS_FILE ".__LINE__."; Found a cdrom disk.\n");
				$in_cdrom = 1;
			}
			if ($in_cdrom)
			{
				if ($line =~ /file='(.*?)'\/>/)
				{
					$this_media = $1;
					record($conf, "$THIS_FILE ".__LINE__."; Found the media: [$this_media].\n");
				}
				if ($line =~ /dev='(.*?)'/)
				{
					$this_device = $1;
					record($conf, "$THIS_FILE ".__LINE__."; Found the device: [$this_device].\n");
				}
				if ($line =~ /<\/disk>/)
				{
					record($conf, "$THIS_FILE ".__LINE__."; Checking if: [$this_device] is the device: [$conf->{cgi}{device}] I want to eject...\n");
					if ($this_device eq $conf->{cgi}{device})
					{
						# This is the device I want to unmount.
						record($conf, "$THIS_FILE ".__LINE__."; It is!\n");
						$new_definition =~ s/<disk(.*?)device='cdrom'(.*?)<source file='$this_media'\/>\s+(.*?)<\/disk>/<disk${1}device='cdrom'${2}${3}<\/disk>/s;
					}
					else
					{
						record($conf, "$THIS_FILE ".__LINE__."; It is not.\n");
					}
					$in_cdrom    = 0;
					$this_device = "";
					$this_media  = "";
				}
			}
		}
		$new_definition =~ s/(\S)\s+$/$1\n/;
		#record($conf, "$THIS_FILE ".__LINE__."; new definition: [$new_definition]\n");
		
		# Write the new definition file.
		print "\t\t\tSaving the new configuration...<br />\n";
		($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	$ssh_fh,
			'close'		=>	1,
			shell_call	=>	"echo \"$new_definition\" > $definition_file && chmod 644 $definition_file",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			print "\t\t\t<span class=\"code\">$line</span><br />\n";
		}
		print "
			Done!
			<br />
		</td>
	</tr>
</table>
<br />
";
		# Lastly, copy the new definition to the stored XML for
		# this VM.
		$conf->{vm}{$vm}{xml}    = [];	# this is probably redundant
		@{$conf->{vm}{$vm}{xml}} = split/\n/, $new_definition;
	}
	
	return(0);
}

# This shows or changes the configuration of the VM, including mounted media.
sub manage_vm
{
	my ($conf) = @_;
	
	# I need to get a list of the running VM's resource/media, read the
	# VM's current XML if it's up, otherwise read the stored XML, read the
	# available ISOs and then display everything in a form. If the user
	# submits the form and something is different, re-write the stored 
	# config and, if possible, make the required changes immediately.
	my $cluster         = $conf->{cgi}{cluster};
	my $vm              = $conf->{cgi}{vm};
	my $say_vm          = ($vm =~ /vm:(.*)/)[0];
	my $node1           = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2           = $conf->{clusters}{$cluster}{nodes}[1];
	my $device          = $conf->{cgi}{device};
	my $definition_file = "/shared/definitions/$say_vm.xml";
	
	# First, see if the VM is up.
	scan_cluster($conf);
	
	# Count how much RAM and CPU cores have been allocated.
	$conf->{resources}{available_ram}   = 0;
	$conf->{resources}{max_cpu_cores}   = 0;
	$conf->{resources}{allocated_cores} = 0;
	$conf->{resources}{allocated_ram}   = 0;
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		# I check GFS2 because, without it, I can't read the VM's details.
		if ($conf->{'system'}{gfs2_down})
		{
			$conf->{resources}{allocated_ram}   = "--";
			$conf->{resources}{allocated_cores} = "--";
		}
		else
		{
			$conf->{resources}{allocated_ram}   += $conf->{vm}{$vm}{details}{ram};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_ram: [$conf->{resources}{allocated_ram}], vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$conf->{resources}{allocated_cores} += $conf->{vm}{$vm}{details}{cpu_count};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_cores: [$conf->{resources}{allocated_cores}], vm: [$vm], cpu_count: [$conf->{vm}{$vm}{details}{cpu_count}]\n");
		}
	}
	
	# First up, if the cluster is not running, go no further.
	#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::daemon::gfs2::exit_code: [$conf->{node}{$node1}{daemon}{gfs2}{exit_code}], node::${node2}::daemon::gfs2::exit_code: [$conf->{node}{$node2}{daemon}{gfs2}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{gfs2}{exit_code}) && ($conf->{node}{$node2}{daemon}{gfs2}{exit_code}))
	{
		print "
<table>
	<tr>
		<td class=\"highlight_warning_bold\">
			Not Ready
		</td>
		<td>
			I am sorry, but the Anvil's storage isn't running on either node.<br />
			Please try again once the Anvil's storage has started on at least one of the nodes.<br />
		</td>
	</tr>
</table>
<br />
";
	}
	
	# Now choose the node to work through.
	my $node;
	my $vm_is_running = 0;
	record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::current_host: [$conf->{vm}{$vm}{current_host}]\n");
	if ($conf->{vm}{$vm}{current_host})
	{
		# Read the current VM config from virsh.
		$vm_is_running = 1;
		$node          = $conf->{vm}{$vm}{current_host};
		record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm] is running on: [$node], will read: [$conf->{vm}{$vm}{definition_file}].\n");
	}
	else
	{
		# The VM isn't running.
		if ($conf->{node}{$node1}{daemon}{gfs2}{exit_code} eq "0")
		{
			# Node 1 is up.
			$node = $node1;
		}
		else
		{
			# Node 2 must be up.
			$node = $node2;
		}
		record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm] is not running, will read: [$conf->{vm}{$vm}{definition_file}] via: [$node].\n");
		read_vm_definition($conf, $node, $vm);
	}
	
	# Find the list of bootable devices and present them in a selection
	# box.
	my $boot_select = "<select name=\"boot_device\" style=\"width: 165px;\">";
	#record($conf, "$THIS_FILE ".__LINE__."; boot select: [$boot_select].\n");
	$conf->{vm}{$vm}{current_boot_device}    = "";
	$conf->{vm}{$vm}{available_boot_devices} = "";
	my $say_current_boot_device              = "";
	my $in_os                                = 0;
	my $saw_cdrom                            = 0;
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; in_os: [$in_os] vm: [$vm], xml line: [$line].\n");
		last if $line =~ /<\/domain>/;
		
		if ($line =~ /<os>/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], going into the OS block.\n");
			$in_os = 1;
			next;
		}
		if ($in_os == 1)
		{
			if ($line =~ /<\/os>/)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], exiting the OS block.\n");
				$in_os = 0;
				if ($saw_cdrom)
				{
					last;
				}
				else
				{
					# I didn't see a CD-ROM boot option, so
					# keep looking.
					$in_os = 2;
				}
			}
			elsif ($line =~ /<boot dev='(.*?)'/)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], OS boot line: [$line].\n");
				my $device                               =  $1;
				my $say_device                           =  $device;
				$conf->{vm}{$vm}{available_boot_devices} .= "$device,";
				if ($device eq "hd")
				{
					$say_device = "Hard Drive";
				}
				elsif ($device eq "cdrom")
				{
					$say_device = "Optical Drive";
					$saw_cdrom  = 1;
				}
				
				my $selected = "";
				if (not $conf->{vm}{$vm}{current_boot_device})
				{
					$conf->{vm}{$vm}{current_boot_device} = $device;
					$say_current_boot_device = $say_device;
					$selected = "selected";
				}
				
				$boot_select .= "<option value=\"$device\" $selected>$say_device</option>";
				#record($conf, "$THIS_FILE ".__LINE__."; boot select: [$boot_select].\n");
			}
		}
		elsif ($in_os == 2)
		{
			# I'm out of the OS block, but I haven't seen a CD-ROM
			# yet, so keep looping and looking for one.
			if ($line =~ /<disk .*?device='cdrom'/)
			{
				# There is a CD-ROM, add it as a boot option.
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Found a CDROM drive, adding it as a boot option.\n");
				my $say_device  =  "Optical Drive";
				   $boot_select .= "<option value=\"cdrom\">$say_device</option>";
				   $in_os = 0;
				last;
			}
		}
	}
	$boot_select .= "</select>";
	#record($conf, "$THIS_FILE ".__LINE__."; boot select: [$boot_select].\n");
	
	# If I need to change the number of CPUs or the amount of RAM, do so
	# now.
	if ($conf->{cgi}{change})
	{
		change_vm($conf, $node);
	}
	
	# If I've been asked to insert a disc, do so now.
	my $do_insert    = 0;
	my $insert_media = "";
	my $insert_drive = "";
	foreach my $key (split/,/, $conf->{cgi}{device_keys})
	{
		next if not $key;
		next if not $conf->{cgi}{$key};
		my $device_key = $key;
		$insert_drive  = ($key =~ /media_(.*)/)[0];
		my $insert_key = "insert_${insert_drive}";
		if ($conf->{cgi}{$insert_key})
		{
			$do_insert    = 1;
			$insert_media = $conf->{cgi}{$device_key};
		}
	}
	
	### TODO: Merge insert and eject into one function.
	#record($conf, "$THIS_FILE ".__LINE__."; do_insert: [$do_insert], insert_drive: [$insert_drive], insert_media: [$insert_media]\n");
	if ($do_insert)
	{
		vm_insert_media($conf, $node, $insert_media, $insert_drive, $vm_is_running);
	}
	
	# If I've been asked to eject a disc, do so now.
	if ($conf->{cgi}{'do'} eq "eject")
	{
		vm_eject_media($conf, $node, $vm_is_running);
	}
	
	# Get the list of files on the /shared/files/ directory.
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"df -P && ls -l /shared/files/",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
		if ($line =~ /\s(\d+)-blocks\s/)
		{
			$conf->{partition}{shared}{block_size} = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; block_size: [$conf->{partition}{shared}{block_size}]\n");
		}
		elsif ($line =~ /^\/.*?\s+(\d+)\s+(\d+)\s+(\d+)\s(\d+)%\s+\/shared/)
		{
			$conf->{partition}{shared}{total_space}  = $1;
			$conf->{partition}{shared}{used_space}   = $2;
			$conf->{partition}{shared}{free_space}   = $3;
			$conf->{partition}{shared}{used_percent} = $4;
			#record($conf, "$THIS_FILE ".__LINE__."; total_space: [$conf->{partition}{shared}{total_space}], used_space: [$conf->{partition}{shared}{used_space} / $conf->{partition}{shared}{used_percent}%], free_space: [$conf->{partition}{shared}{free_space}]\n");
		}
		elsif ($line =~ /^(\S)(\S+)\s+\d+\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(.*)$/)
		{
			my $type   = $1;
			my $mode   = $2;
			my $user   = $3;
			my $group  = $4;
			my $size   = $5;
			my $month  = $6;
			my $day    = $7;
			my $time   = $8; # might be a year, look for '\d+:\d+'.
			my $file   = $9;
			my $target = "";
			if ($type eq "l")
			{
				# It's a symlink, strip off the destination.
				($file, $target) = ($file =~ /^(.*?) -> (.*)$/);
			}
			$conf->{files}{shared}{$file}{type}   = $type;
			$conf->{files}{shared}{$file}{mode}   = $mode;
			$conf->{files}{shared}{$file}{user}   = $user;
			$conf->{files}{shared}{$file}{group}  = $group;
			$conf->{files}{shared}{$file}{size}   = $size;
			$conf->{files}{shared}{$file}{month}  = $month;
			$conf->{files}{shared}{$file}{day}    = $day;
			$conf->{files}{shared}{$file}{'time'} = $time; # might be a year, look for '\d+:\d+'.
			$conf->{files}{shared}{$file}{target} = $target;
			#record($conf, "$THIS_FILE ".__LINE__."; file: [$file], mode: [$conf->{files}{shared}{$file}{type}, $conf->{files}{shared}{$file}{mode}], owner: [$conf->{files}{shared}{$file}{user} / $conf->{files}{shared}{$file}{group}], size: [$conf->{files}{shared}{$file}{size}], modified: [$conf->{files}{shared}{$file}{month} $conf->{files}{shared}{$file}{day} $conf->{files}{shared}{$file}{'time'}], target: [$conf->{files}{shared}{$file}{target}]\n");
		}
	}

	# Find which ISOs are mounted currently.
	my $this_device = "";
	my $this_media  = "";
	my $in_cdrom    = 0;
	### TODO: Find out why the XML data is doubled up.
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], xml line: [$line].\n");
		last if $line =~ /<\/domain>/;
		if ($line =~ /device='cdrom'/)
		{
			$in_cdrom = 1;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], going into a CD-ROM child element on: [$line].\n");
		}
		elsif (($line =~ /<\/disk>/) && ($in_cdrom))
		{
			# Record what I found/
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], exiting a CD-ROM child element on: [$line].\n");
			$conf->{vm}{$vm}{cdrom}{$this_device}{media} = $this_media ? $this_media : "";
			#record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::cdrom::${this_device}::media: [$conf->{vm}{$vm}{cdrom}{$this_device}{media}].\n");
			$in_cdrom    = 0;
			$this_device = "";
			$this_media  = "";
		}
		
		if ($in_cdrom)
		{
			if ($line =~ /source file='(.*?)'/)
			{
				$this_media = $1;
				$this_media =~ s/^.*\/(.*?)$/$1/;
			}
			elsif ($line =~ /target dev='(.*?)'/)
			{
				$this_device = $1;
			}
		}
	}

	#record($conf, "$THIS_FILE ".__LINE__."; current_cpu_count: [$current_cpu_count], current_ram: [$current_ram (".bytes_to_hr($conf, $current_ram).")], available_ram: [$available_ram (".bytes_to_hr($conf, $available_ram).")]\n");
	my $current_cpu_count = $conf->{vm}{$vm}{details}{cpu_count};
	my $max_cpu_count     = $conf->{resources}{total_threads};
	#record($conf, "$THIS_FILE ".__LINE__."; max_ram: [$max_ram (".bytes_to_hr($conf, $max_ram).")], max_cpu_count: [$max_cpu_count]\n");
	
	# Create the media select boxes.
	foreach my $device (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{cdrom}})
	{
		my $key                                      =  "media_$device";
		$conf->{vm}{$vm}{cdrom}{device_keys}         .= "$key,";
		if ($conf->{vm}{$vm}{cdrom}{$device}{media})
		{
			### TODO: If the media no longer exists, re-write the
			###       XML definition immediately.
			# Offer the eject button.
			$conf->{vm}{$vm}{cdrom}{$device}{say_select}   = "<select name=\"$key\" disabled>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_in_drive} = "<span class=\"fixed_width\">$conf->{vm}{$vm}{cdrom}{$device}{media}</span>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_eject}    = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$conf->{cgi}{vm}&task=manage_vm&do=eject&device=$device\" class=\"button\">Eject</a>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_insert}   = "<span class=\"highlight_unavailable\">Insert</span>\n";
		}
		else
		{
			# Offer the insert button
			$conf->{vm}{$vm}{cdrom}{$device}{say_select}   = "<select name=\"$key\">\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_in_drive} = "<span class=\"highlight_unavailable\">(no disc)</span>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_eject}    = "<span class=\"highlight_unavailable\">Eject</span>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_insert}   = "<input type=\"submit\" name=\"insert_$device\" value=\"Insert\" class=\"button\">\n";
		}
		foreach my $file (sort {$a cmp $b} keys %{$conf->{files}{shared}})
		{
			next if ($file eq $conf->{vm}{$vm}{cdrom}{$device}{media});
			#record($conf, "$THIS_FILE ".__LINE__."; file: [$file], cgi::${key}: [$conf->{cgi}{$key}]\n");
			if ((defined $conf->{cgi}{$key}) && ($file eq $conf->{cgi}{$key}))
			{
				$conf->{vm}{$vm}{cdrom}{$device}{say_select} .= "<option name=\"$file\" selected>$file</option>\n";
			}
			else
			{
				$conf->{vm}{$vm}{cdrom}{$device}{say_select} .= "<option name=\"$file\">$file</option>\n";
			}
		}
		$conf->{vm}{$vm}{cdrom}{$device}{say_select} .= "</select>\n";
		#record($conf, "$THIS_FILE ".__LINE__."; Media in: [$device] -> [$conf->{vm}{$vm}{cdrom}{$device}{media}]. [Select: $conf->{vm}{$vm}{cdrom}{$device}{say_select}]\n");
	}
	
	# Allow the user to select the number of CPUs.
	my $cpu_cores = [];
	foreach my $core_num (1..$max_cpu_count)
	{
		if ($max_cpu_count > 9)
		{
			#push @{$cpu_cores}, sprintf("%.2d", $core_num);
			push @{$cpu_cores}, $core_num;
		}
		else
		{
			push @{$cpu_cores}, $core_num;
		}
	}
	$conf->{cgi}{cpu_cores} = $current_cpu_count if not $conf->{cgi}{cpu_cores};
	my $select_cpu_cores    = build_select($conf, "cpu_cores", 0, 0, 60, $conf->{cgi}{cpu_cores}, $cpu_cores);
	#record($conf, "$THIS_FILE ".__LINE__."; select_cpu_cores: [$select_cpu_cores]\n");
	
	# Something has changed. Make sure the request is sane,
	my $current_ram   = $conf->{vm}{$vm}{details}{ram};
	record($conf, "$THIS_FILE ".__LINE__."; current_ram: [$current_ram]\n");

	my $diff          = $conf->{resources}{total_ram} % (1024 ** 3);
	my $available_ram = ($conf->{resources}{total_ram} - $diff - $conf->{'system'}{unusable_ram} - $conf->{resources}{allocated_ram}) + $current_ram;
	my $max_ram       = $available_ram;
	record($conf, "$THIS_FILE ".__LINE__."; available_ram: [$available_ram]\n");
	
	# If the user sets the RAM to less than 1 GiB, warn them. If the user
	# sets the RAM to less that 32 MiB, error out.
	my $say_max_ram          = bytes_to_hr($conf, $max_ram);
	my $say_current_ram      = bytes_to_hr($conf, $current_ram);
	my ($current_ram_value, $current_ram_suffix) = (split/ /, $say_current_ram);
	$conf->{cgi}{ram}        = $current_ram_value if not $conf->{cgi}{ram};
	$conf->{cgi}{ram_suffix} = $current_ram_suffix if not $conf->{cgi}{ram_suffix};
	my $select_ram_suffix    = build_select($conf, "ram_suffix", 0, 0, 60, $conf->{cgi}{ram_suffix}, ["MiB", "GiB"]);
	#record($conf, "$THIS_FILE ".__LINE__."; (<span class=\"subtle_text\">Maximum $say_max_ram</span>) <input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix\n");
	
	# Setup Guacamole, if installed.
	my $message     = "";
	my $remote_icon = "";
	if (-e $conf->{path}{guacamole_config})
	{
		# Installed.
		my ($node, $type, $listen, $port) = get_current_vm_vnc_info($conf, $vm);
		record($conf, "$THIS_FILE ".__LINE__."; node: [$node], type: [$type], listen: [$listen], port: [$port]\n");
		if ($type ne "vnc")
		{
			record($conf, "$THIS_FILE ".__LINE__."; VM: [$say_vm] is not using VNC, can't use Guacamole.\n");
			# Check the recorded XML file and is necesary, update
			# it. In any case, disable VNC and tell the user they
			# will need to power off and restart the server before
			# this will work.
			$message     = "The server is currently not using VNC. The server's configuration will be updated now. Please power off and then start the server (don't reboot) and then try again.";
			$remote_icon = "<img src=\"/img/icon_server-desktop_oops.png\">";
			
			# See if I need to update the XML definition file.
			if (($conf->{vm}{$vm}{graphics}{type} ne "vnc") || ($conf->{vm}{$vm}{graphics}{'listen'} ne "0.0.0.0"))
			{
				# Rewrite the XML definition. The 'graphics' section should look like:
				#     <graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'>
				#       <listen type='address' address='0.0.0.0'/>
				#     </graphics>
				record($conf, "$THIS_FILE ".__LINE__."; VM: [$say_vm]'s definition file is not using VNC, updating it.\n");
				archive_file($conf, $node, $conf->{vm}{$vm}{definition_file});
				switch_vm_xml_to_vnc($conf, $node, $vm);
			}
		}
		else
		{
			record($conf, "$THIS_FILE ".__LINE__."; VM: [$say_vm] is using VNC, we can offer remote desktop access.\n");
			update_guacamole_config($conf, $say_vm, $node, $port);
		}
		if (not $message)
		{
			my ($guacamole_url) = get_guacamole_link($conf, $node);
			$message = "Connect directly to this server's desktop.";
			if (not $node)
			{
				$message     = "The server is turned off.";
				$remote_icon = "<img src=\"/img/icon_server-desktop_offline.png\">";
			}
			elsif ($node =~ /n01/)
			{
				$remote_icon = "<a href=\"$guacamole_url?id=c\%2F$say_vm\" target=\"_new\"><img src=\"/img/icon_server-desktop_n01.png\"></a>";
			}
			elsif ($node =~ /n02/)
			{
				$remote_icon = "<a href=\"$guacamole_url?id=c\%2F$say_vm\" target=\"_new\"><img src=\"/img/icon_server-desktop_n02.png\"></a>";
			}
			else
			{
				$message     = "I think this server is running, but I don't know where. You can try connecting to it anyway.";
				$remote_icon = "<img src=\"/img/icon_server-desktop_oops.png\">";
			}
		}
	}
	else
	{
		# Not installed.
		$message     = "This version of AN!CDB does not have in-browser remote desktop support yet.<br /><a href=\"https://alteeve.ca/w/Support\" target=\"_new\">Please upgrade</a> to enable this feature.";
		$remote_icon = "<img src=\"/img/icon_server-desktop_oops.png\">";
	}
	
	# Finally, print it all
	print "
<table>
	<form method=\"post\">
	<tr>
		<td colspan=\"4\">
			<b>Manage <span class=\"fixed_width\">$say_vm</span>.</b>
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"4\"></td></tr>
";

	my $i = 1;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{cdrom}})
	{
		next if $device eq "device_keys";
		my $say_disk   = $conf->{vm}{$vm}{cdrom}{$device}{say_select};
		my $say_button = $conf->{vm}{$vm}{cdrom}{$device}{say_insert};
		my $say_state  = "Drive empty";
		if ($conf->{vm}{$vm}{cdrom}{$device}{media})
		{
			$say_disk   = $conf->{vm}{$vm}{cdrom}{$device}{say_in_drive};
			$say_button = $conf->{vm}{$vm}{cdrom}{$device}{say_eject};
			$say_state  = "Disc in drive";
		}
		print "
	<tr>
		<td class=\"highlight_good_bold\">
			Optical Drive $i
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">$say_state</span><br />
			$say_disk
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_button
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"5\"></td></tr>
";
		$i++;
	}
	
	print "
	<tr>
		<td class=\"highlight_good_bold\">
			Boot Drive:
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">Currently booting from the $say_current_boot_device.</span><br />
			$boot_select
		</td>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\" rowspan=\"5\">
			<input type=\"submit\" name=\"change\" value=\"Change\" class=\"button\">
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"3\"></td></tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Memory (RAM):
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">Currently $say_current_ram, Maximum $say_max_ram</span><br />
			<input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"3\"></td></tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Number of CPUs:
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">Currently $conf->{vm}{$vm}{details}{cpu_count}</span><br />
			$select_cpu_cores
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"3\"></td></tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Desktop:
		</td>
		<td style=\"text-align: center;\">
			<span class=\"subtle_text_wrap\">Please Note: If the server is migrated to the other node,<br />you will have to refresh this page and then reconnect.</span><br />
			<br />
			$remote_icon<br />
			<br />
			$message<br />
			<br />
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Trouble?
		</td>
		<td style=\"text-align: center;\">
			If you're having trouble connecting to the server's desktop, <a href=\"?cluster=$conf->{cgi}{cluster}&task=restart_tomcat\" target=\"_new\">click here</a>.<br />
			This will restart the remote desktop client on this dashboard.<br />
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
	<tr>
		<td colspan=\"4\">
			<input type=\"hidden\" name=\"cluster\" value=\"$conf->{cgi}{cluster}\">
			<input type=\"hidden\" name=\"vm\" value=\"$conf->{cgi}{vm}\">
			<input type=\"hidden\" name=\"task\" value=\"$conf->{cgi}{task}\">
			<input type=\"hidden\" name=\"device_keys\" value=\"$conf->{vm}{$vm}{cdrom}{device_keys}\">
			<!-- <div class=\"align_right\"><input type=\"submit\" name=\"change\" value=\"Change\" class=\"button\"></div> -->
			&nbsp;
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# This modifies the VM's XML definition file to tell it to use VNC instead of
# spice or another protocol.
sub switch_vm_xml_to_vnc
{
	my ($conf, $node, $vm) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; switch_vm_xml_to_vnc(); node: [$node], vm: [$vm]\n");
	
	my $definition_file = $conf->{vm}{$vm}{definition_file};
	my $new_definition  = "";
	my $in_graphics     = 0;
	foreach my $line (@{$conf->{vm}{$vm}{raw_xml}})
	{
		if ($line =~ /<graphics /)
		{
			$in_graphics = 1;
			next;
		}
		elsif ($in_graphics)
		{
			if ($line =~ /<\/graphics>/)
			{
				# The port here doesn't matter.
				$in_graphics    =  0;
				$new_definition .= "    <graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'>\n";
				$new_definition .= "      <listen type='address' address='0.0.0.0'/>\n";
				$new_definition .= "    </graphics>\n";
				next;
			}
			else
			{
				# Skip this.
				next;
			}
		}
		else
		{
			$new_definition .= "$line\n";
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; New definition file:\n===\n$new_definition\n===\n");
	
	# Write the new definition file.
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"echo \"$new_definition\" > $definition_file && chmod 644 $definition_file",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
	}
	
	return(0);
}

# This reads the current guacamole configuration file and, if necessary,
# updates it to add/modify the given VM's host and port.
sub update_guacamole_config
{
	my ($conf, $say_vm, $node, $port) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; update_guacamole_config; say_vm: [$say_vm], node: [$node], port: [$port]\n");
	
	# Read the guacamole config file.
	$conf->{guacamole}{config}{old} = [];
	my $sc = $conf->{path}{guacamole_config};
	record($conf, "$THIS_FILE ".__LINE__."; Reading: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "<$sc") or die "$THIS_FILE ".__LINE__."; Failed to read: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		push @{$conf->{guacamole}{config}{old}}, $line;
	}
	$fh->close();
	
	my $match_found    = 0;
	my $rewrite_needed = 0;
	my $this_vm        = "";
	my $this_host      = "";
	my $this_port      = "";
	foreach my $line (@{$conf->{guacamole}{config}{old}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^<\/config>/)
		{
			# Save the data.
			$conf->{guacamole}{vm}{$this_vm}{host} = $this_host;
			$conf->{guacamole}{vm}{$this_vm}{port} = $this_port;
			
			# See of this entry matches my current VM and, if so,
			# see if the port or host needs to be updated.
			#record($conf, "$THIS_FILE ".__LINE__."; Checking if this_vm: [$this_vm] matches say_vm: [$say_vm]\n");
			if ($this_vm eq $say_vm)
			{
				$match_found = 1;
				#record($conf, "$THIS_FILE ".__LINE__."; Matched. Checking now if this_host: [$this_host] matches node: [$node] and if this_port: [$this_port] matches port: [$port]\n");
				if (($node ne $this_host) || ($port ne $this_port))
				{
					#record($conf, "$THIS_FILE ".__LINE__."; Difference found, rewrite needed.\n");
					$rewrite_needed                        = 1;
					$conf->{guacamole}{vm}{$this_vm}{host} = $node;
					$conf->{guacamole}{vm}{$this_vm}{port} = $port;
					record($conf, "$THIS_FILE ".__LINE__."; New values; guacamole::vm::${this_vm}::host: [$conf->{guacamole}{vm}{$this_vm}{host}], guacamole::vm::${this_vm}::port: [$conf->{guacamole}{vm}{$this_vm}{port}]!\n");
				}
				else
				{
					#record($conf, "$THIS_FILE ".__LINE__."; Same, rewrite not needed.\n");
				}
			}
			else
			{
				#record($conf, "$THIS_FILE ".__LINE__."; this_vm: [$this_vm], host: [$conf->{guacamole}{vm}{$this_vm}{host}], port: [$conf->{guacamole}{vm}{$this_vm}{port}]\n");
				# See if this VM still exists on the cluster.
				my $exists =  0;
				foreach my $existing_vm (sort {$a cmp $b} keys %{$conf->{vm}})
				{
					$existing_vm =~ s/^vm://;
					if ($existing_vm eq $this_vm)
					{
						#record($conf, "$THIS_FILE ".__LINE__."; this_vm: [$this_vm] still exists on the Anvil!.\n");
						$exists = 1;
					}
				}
				#record($conf, "$THIS_FILE ".__LINE__."; exists: [$exists], this_vm: [$this_vm], say_vm: [$say_vm].\n");
				if ((not $exists) && ($this_vm ne $say_vm))
				{
					# Delete it so that it's removed from guacamole.
					record($conf, "$THIS_FILE ".__LINE__."; Existing server: [$this_vm] no longer exists, deleting it from guacamole.\n");
					delete $conf->{guacamole}{vm}{$this_vm};
					$rewrite_needed = 1;
				}
			}
			
			$this_vm   = "";
			$this_host = "";
			$this_port = "";
			next;
		}
		
		if ($line =~ /^<config /)
		{
			($this_vm) = ($line =~ /name="(.*?)"/);
			#record($conf, "$THIS_FILE ".__LINE__."; this_vm: [$this_vm]\n");
		}
		
		next if not $this_vm;
		if (($line =~ /^<param /) && ($line =~ /name="hostname"/))
		{
			($this_host) = ($line =~ /value="(.*?)"/);
			#record($conf, "$THIS_FILE ".__LINE__."; this_host: [$this_host]\n");
		}
		if (($line =~ /^<param /) && ($line =~ /name="port"/))
		{
			($this_port) = ($line =~ /value="(.*?)"/);
			#record($conf, "$THIS_FILE ".__LINE__."; this_port: [$this_port]\n");
		}
	}
	if (not $match_found)
	{
		$rewrite_needed                       = 1;
		$conf->{guacamole}{vm}{$say_vm}{host} = $node;
		$conf->{guacamole}{vm}{$say_vm}{port} = $port;
		#record($conf, "$THIS_FILE ".__LINE__."; This server not found, rewrite needed to add it.\n");
		record($conf, "$THIS_FILE ".__LINE__."; New values; guacamole::vm::${say_vm}::host: [$conf->{guacamole}{vm}{$say_vm}{host}], guacamole::vm::${say_vm}::port: [$conf->{guacamole}{vm}{$say_vm}{port}].\n");
	}
	
	# Now look to see if we need to update the config.
	if ($rewrite_needed)
	{
		my ($date) = get_date($conf);
		my $new_config;
		$new_config .= "<configs>\n";
		$new_config .= "	<!-- Do not edit this file! Changes will be lost when AN!CDB re-writes it. -->\n";
		$new_config .= "	<!-- Last updated: [$date]. -->\n";
		foreach my $this_vm (sort {$a cmp $b} keys %{$conf->{guacamole}{vm}})
		{
			my $this_host = $conf->{guacamole}{vm}{$this_vm}{host};
			my $this_port = $conf->{guacamole}{vm}{$this_vm}{port};
			$new_config .= "	<config name=\"$this_vm\" protocol=\"vnc\">\n";
			$new_config .= "		<param name=\"hostname\" value=\"$this_host\" />\n";
			$new_config .= "		<param name=\"port\" value=\"$this_port\" />\n";
			$new_config .= "	</config>\n";
		}
		$new_config .= "</configs>\n";
		
		# Save the new config.
		#record($conf, "$THIS_FILE ".__LINE__."; new guacamole config:\n===\n$new_config\n===\n");
		
		# Backup the last config.
		my $backup_file =  "$conf->{path}{guacamole_config}.$date";
		   $backup_file =~ s/ /_/;
		my $fh = IO::Handle->new();
		my $sc = "cp $conf->{path}{guacamole_config} $backup_file";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$sc], error was: $!\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		}
		$fh->close();
		
		# Save the new config.
		$fh = IO::Handle->new();
		$sc = "$conf->{path}{guacamole_config}";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, ">$sc") or die "$THIS_FILE ".__LINE__."; Failed to write: [$sc], error was: $!\n";
		print $fh $new_config;
		$fh->close();
	}
	else
	{
		# Rewrite not needed.
		record($conf, "$THIS_FILE ".__LINE__."; Guacamole config update is not needed.\n");
	}
	
	return(0);
}

# This figures out which node a VM is running on, calls 'virsh dumpxml $vm',
# parses out the currently used VNC port and returns the host and port.
sub get_current_vm_vnc_info
{
	my ($conf, $vm) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; get_current_vm_vnc_info(); vm: [$vm]\n");
	my $say_vm = $vm;
	if ($vm =~ /^vm:/)
	{
		($say_vm) = ($vm =~ /^vm:(.*)/);
	}
	else
	{
		$vm = "vm:$vm";
	}
	record($conf, "$THIS_FILE ".__LINE__."; say_vm: [$say_vm]\n");
	
	my $node    = "";
	my $port    = "";
	my $type    = "";
	my $listen  = "";
	my $xml_ref = "";
	
	record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::current_host: [$conf->{vm}{$vm}{current_host}]\n");
	if ($conf->{vm}{$vm}{current_host})
	{
		$node = $conf->{vm}{$vm}{current_host};
		record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm] is running on: [$node].\n");
		
		# Read the current VM config from virsh.
		read_live_xml($conf, $vm, $say_vm, $node);
		$xml_ref = $conf->{vm}{$vm}{live_xml};
	}
	else
	{
		# The VM isn't running.
		record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm] is not running.\n");
		$xml_ref = $conf->{vm}{$vm}{xml};
	}
	
	foreach my $line (@{$xml_ref})
	{
		if ($line =~ /^<graphics /)
		{
			($port)   = ($line =~ / port='(\d+)'/);
			($type)   = ($line =~ / type='(.*?)'/);
			($listen) = ($line =~ / listen='(.*?)'/);
			record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm] is using: [$type] and listening on: [$listen] port: [$port].\n");
			last;
		}
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], type: [$type], listen: [$listen], port: [$port]\n");
	return($node, $type, $listen, $port);
}

# This uses virsh to dump the running config of a server.
sub read_live_xml
{
	my ($conf, $vm, $say_vm, $node) = @_;
	
	$conf->{vm}{$vm}{live_xml} = [];
	my $fh = IO::Handle->new();
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"virsh dumpxml $say_vm",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		push @{$conf->{vm}{$vm}{live_xml}}, $line;
	}
	
	return(0);
}

# This looks at a VM and determines which storage pool it is on.
sub find_node_storage_pool
{
	my ($conf) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in find_node_storage_pool().\n");
	
	my $vm     = $conf->{cgi}{vm};
	my $say_vm = ($vm =~ /^vm:(.*)/)[0];
	
	my $current_lv = "";
	my $in_block   = 0;
	foreach my $line (sort {$a cmp $b} @{$conf->{vm}{$vm}{xml}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm], xml line: [$line]\n");
		if (($line =~ /<disk/) && ($line =~ /type='block'/))
		{
			$in_block = 1;
			next;
		}
		if ($in_block)
		{
			if ($line =~ /<\/disk>/)
			{
				$in_block = 0;
				next;
			}
			elsif (($line =~ /source/) && ($line =~ /dev='(.*?)'/))
			{
				$current_lv = $1;
				last;
			}
		}
	}
	my $lv_size = $conf->{resources}{lv}{$current_lv}{size};
	my $on_vg   = $conf->{resources}{lv}{$current_lv}{on_vg};
	record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm], current_lv: [$current_lv], size: [$lv_size], on_vg: [$on_vg]\n");
	
	return($on_vg, $lv_size);
}

# This calls 'virsh dumpxml' against the given VM.
sub update_vm_definition
{
	my ($conf, $node, $vm) = @_;
	my $say_vm = $vm;
	if ($vm =~ /^vm:(.*)/)
	{
		$say_vm = $1;
	}
	else
	{
		$vm = "vm:$vm";
	}
	my $definition_file = $conf->{vm}{$vm}{definition_file};
	record($conf, "$THIS_FILE ".__LINE__."; in update_vm_definition(); node: [$node], vm: [$vm], say_vm: [$say_vm], definition_file: [$definition_file]\n");
	
	my $virsh_exit_code;
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"virsh dumpxml $say_vm > $definition_file; echo virsh:\$?",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /virsh:(\d+)/)
		{
			$virsh_exit_code = $1;
		}
		else
		{
			#print "<span class=\"code\">$line</span><br />\n";
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
	if ($virsh_exit_code eq "0")
	{
		# Delete the old definition values and read the new one.
		$conf->{vm}{$vm}{xml} = "";
		read_vm_definition($conf, $node, $vm);
	}
	else
	{
		$virsh_exit_code = "-" if not defined $virsh_exit_code;
		print "
<table>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to update the definition file for: [<span class=\"fixed_width\">$say_vm</span>] and the command should have returned [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$virsh_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return($virsh_exit_code);
	}
	return(0);
}

sub add_vm_to_cluster
{
	my ($conf) = @_;
	
	# Two steps needed; Dump the definition and use ccs to add it to the 
	# cluster.
	my $cluster    = $conf->{cgi}{cluster};
	my $vm         = $conf->{cgi}{name};
	my $node       = $conf->{cgi}{node};
	my $definition = "/shared/definitions/$vm.xml";
	my $peer;
	foreach my $this_node (@{$conf->{clusters}{$cluster}{nodes}})
	{
		if ($this_node ne $node)
		{
			$peer = $this_node;
		}
	}
	my $failover_domain;
	
	# First, find the failover domain...
	$conf->{'system'}{ignore_missing_vm} = 1;
	scan_cluster($conf);
	foreach my $fod (keys %{$conf->{failoverdomain}})
	{
		record($conf, "$THIS_FILE ".__LINE__."; fod: [$fod]\n");
		if ($fod =~ /primary_(.*?)$/)
		{
			my $node_suffix = $1;
			record($conf, "$THIS_FILE ".__LINE__."; node_suffix: [$node_suffix]\n");
			if ($node =~ /$node_suffix/)
			{
				$failover_domain = $fod;
				record($conf, "$THIS_FILE ".__LINE__."; failover_domain: [$failover_domain]\n");
				last;
			}
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; Using failover domain: [$failover_domain]\n");
	
	# If there is no password set, abort.
	if (not $conf->{clusters}{$cluster}{ricci_pw})
	{
		print "
<table>
	<tr>
		<td class=\"highlight_bad_bold\">
			Failure!
		</td>
		<td>
			Unable to add the new <span class=\"fixed_width\">$vm</span> server to the cluster without a <span class=\"fixed_width\">ricci</span> password!
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning\">
			Password
		</td>
		<td>
			Please add the password to the file named above and then reload this page ('<span class=\"fixed_width\">&lt;ctrl&gt;</span> + <span class=\"fixed_width\">r</span>' on most browsers).
		</td>
	</tr>
</table>
<br />
	";
		return(1);
	}

	if (not $failover_domain)
	{
		print "
	<tr>
		<td class=\"highlight_bad_bold\">
			Error
		</td>
		<td>
			I was unable to determine which failover domain to use for this new machine.<br />
			<br />
			I am sorry, but without this information, I can not continue.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
		";
		return (1);
	}
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b>Adding the new <span class=\"fixed_width\">$vm</span> server to the cluster's <span class=\"fixed_width\">$failover_domain</span> failover domain.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Checking VM State
		</td>
		<td>
			<br />
			Checking now to make sure the new virtual server is up and running.
			<br />
";

	# On occasion, the installed VM will power off, not reboot. So this
	# checks to see if the VM needs to be kicked awake.
	my ($host) = find_vm_host($conf, $node, $peer, $vm);
	if ($host eq "none")
	{
		print "It is not running at the moment, I will now boot the VM.<br />\n";
		record($conf, "$THIS_FILE ".__LINE__."; I will now boot the VM.\n");
		my $virsh_exit_code;
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	"virsh start $vm; echo virsh:\$?",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			next if not $line;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /virsh:(\d+)/)
			{
				$virsh_exit_code = $1;
			}
		}
		record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
		if ($virsh_exit_code eq "0")
		{
			print "It should now be booting up.<br />\n";
		}
		else
		{
			# If something undefined the VM already and the server
			# is not running, this will fail. Try to start the
			# server using the definition file before giving up.
			print "It didn't start on the first try. Trying again with the definition file.<br />\n";
			record($conf, "$THIS_FILE ".__LINE__."; It didn't start on the first try. Trying again with the definition file.\n");
			my $virsh_exit_code;
			($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$node,
				port		=>	$conf->{node}{$node}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	$ssh_fh,
				'close'		=>	1,
				shell_call	=>	"virsh create /shared/definitions/${vm}.xml; echo virsh:\$?",
			});
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				next if not $line;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				if ($line =~ /virsh:(\d+)/)
				{
					$virsh_exit_code = $1;
				}
			}
			record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
			if ($virsh_exit_code eq "0")
			{
				print "It should now be booting up.<br />\n";
			}
			else
			{
				print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			The new <span class=\"fixed_width\">$vm</span> server didn't start on reboot.<br />
			I tried to start it, but the command should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
				return (1);
			}
		}
	}
	elsif ($host eq $node)
	{
		print "It is already running, as expected.<br />\n";
	}
	else
	{
		$node = $host;
		print "The VM is now running on the peer. I will use that node for the next steps.<br />\n";
		record($conf, "$THIS_FILE ".__LINE__."; The VM is now running on the peer. Will proceed using: [$node].\n");
	}
	
	# Dump the VM's XML definition.
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Creating Definition
		</td>
		<td>
			<br />
			The cluster needs to know what \"hardware\" to create for the new virtual server when it starts.<br />
			This is done using a \"definition\" file, which I will record now.
	";

	if (not $vm)
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			I was about to add a server to the Anvil! but I don't have the new server's name. This is likely a software error.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return (1);
	}
	my $virsh_exit_code;
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	0,
		shell_call	=>	"virsh dumpxml $vm > $definition; echo virsh:\$?",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /virsh:(\d+)/)
		{
			$virsh_exit_code = $1;
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
	if ($virsh_exit_code eq "0")
	{
		print "Saved successfully as <span class=\"fixed_width\">$definition</span>.<br />\n";
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to record the definition file and the command should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return (1);
	}

	# Undefine the new VM
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Removing libvirtd definition
		</td>
		<td>
			<br />
			We only want the cluster to be able to see and start the new server.<br />
			Removing the <span class=\"fixed_width\">libvirtd</span> definition now.<br />
	";

	undef $virsh_exit_code;
	($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	$ssh_fh,
		'close'		=>	0,
		shell_call	=>	"virsh undefine $vm; echo virsh:\$?",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /virsh:(\d+)/)
		{
			$virsh_exit_code = $1;
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
	if ($virsh_exit_code eq "0")
	{
		print "Successfully removed the <span class=\"fixed_width\">libvirtd</span> definition.<br />\n";
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			<br />
			I tried to remove the <span class=\"fixed_width\">libvirtd</span> definition, which should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />
			<br />
			This is a non-fatal error. Proceeding.<br />
";
	}
	
	# If I've made it this far, I am ready to add it to the cluster configuration.
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Configuring Cluster
		</td>
		<td>
			<br />
			I will now add the new virtual server to the cluster.<br />
			<i>Please be patient!</i></br />
			This can take several minutes to complete.</br >
			<br />
";
	
	my $ccs_exit_code;
	my $ccs_call =  "ccs ";
	   $ccs_call .= "-h localhost --activate --sync --password \"$conf->{clusters}{$cluster}{ricci_pw}\" --addvm $vm ";
	   $ccs_call .= "domain=\"$failover_domain\" ";
	   $ccs_call .= "path=\"/shared/definitions/\" ";
	   $ccs_call .= "autostart=\"0\" ";
	   $ccs_call .= "exclusive=\"0\" ";
	   $ccs_call .= "recovery=\"restart\" ";
	   $ccs_call .= "max_restarts=\"2\" ";
	   $ccs_call .= "restart_expire_time=\"600\"; echo ccs:\$?";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$ccs_call]\n");
	($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	$ssh_fh,
		'close'		=>	0,
		shell_call	=>	"$ccs_call"
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /ccs:(\d+)/)
		{
			$ccs_exit_code = $1;
		}
		else
		{
			if ($line =~ /make sure the ricci server is started/)
			{
				print "<span class=\"highlight_bad\">Error</span>: The <span class=\"code\">ricci</span> daemon is not running on <span class=\"code\">$node</span>.<br />\n";
				print "This is probably a mis-configuration of the cluster node.<br />\n";
				print "Please ensure that <span class=\"code\">ricci</span> is running and is set to start on boot.<br />\n";
			}
			else
			{
				$line = parse_text_line($conf, $line);
				print "<span class=\"fixed_width\">$line</span><br />\n";
			}
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; ccs exit code: [$ccs_exit_code]\n");
	$ccs_exit_code = "-" if not defined $ccs_exit_code;
	if ($ccs_exit_code eq "0")
	{
		print "The VM has been added successfully.<br />\n";
		
		### TODO: Make this watch 'clustat' for the VM to appear.
		sleep 10;
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_bad_bold\">
			Error
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			The call to add the new VM to the cluster should have returned: [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$ccs_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
		";
		return (1);
	}
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Enabling the VM
		</td>
		<td>
			<br />
			Informing the cluster that the VM is running.<br />
			<br />
";
	
	### TODO: Get the cluster's idea of the node name and use '-m ...'.
	# Tell the cluster to start the VM. I don't bother to check for 
	# readiness because I confirmed it was running on this node earlier.
	my $clusvcadm_exit_code;
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [clusvcadm -e vm:$vm; echo clusvcadm:\$?]\n");
	($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	$ssh_fh,
		'close'		=>	1,
		shell_call	=>	"clusvcadm -e vm:$vm; echo clusvcadm:\$?",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /clusvcadm:(\d+)/)
		{
			$clusvcadm_exit_code = $1;
		}
		else
		{
			$line = parse_text_line($conf, $line);
			print "<span class=\"fixed_width\">$line</span><br />\n";
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; clusvcadm exit code: [$clusvcadm_exit_code]\n");
	if ($clusvcadm_exit_code eq "0")
	{
		print "The VM has been added to the cluster.<br />\n";
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_bad_bold\">
			Error
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			The call to tell the cluster that the new VM is running should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$clusvcadm_exit_code</span> was received.<br />
			Is the <span class=\"fixed_width\">ricci_pw</span> set correctly in <span class=\"fixed_width\">/etc/an/an.conf</span> for this Anvil!?<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
		";
		return (1);
	}
	# Done!
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Success!
		</td>
		<td>
			The new virtual machine has been added to the cluster.
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# This looks for a VM on the cluster and returns the current host node, if any.
# If the VM is not running, then "none" is returned.
sub find_vm_host
{
	my ($conf, $node, $peer, $vm) = @_;
	my $host = "none";
	
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"virsh list --all",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /\s$vm\s/)
		{
			record($conf, "$THIS_FILE ".__LINE__."; Found the VM.\n");
			if ($line =~ /^-/)
			{
				# It looks off... We have to go deeper!
				#print "It appears to be off. Checking the peer to see if it is running there.<br />\n";
				record($conf, "$THIS_FILE ".__LINE__."; The VM appears to be off. Checking the peer to see if it is running there.\n");
				my $on_peer = 0;
				my $found   = 0;
				my ($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$peer,
					port		=>	$conf->{node}{$peer}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	"",
					'close'		=>	1,
					shell_call	=>	"virsh list --all",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					if ($line =~ /\s$vm\s/)
					{
						#print "Found it on the peer node. Checking if it's running there.<br />\n";
						record($conf, "$THIS_FILE ".__LINE__."; Found it on the peer. Checking if it's running.\n");
						if ($line =~ /^\d/)
						{
							$found   = 1;
							$on_peer = 1;
							$node    = $peer;
							$host    = $peer;
							#print "It is, I will use that node for the next steps.<br />\n";
							record($conf, "$THIS_FILE ".__LINE__."; It is.\n");
						}
						else
						{
							$found = 1;
							#print "It is not running on the peer.<br />\n";
							record($conf, "$THIS_FILE ".__LINE__."; It is not running on the peer.\n");
						}
					}
				}
				if (($found) && (not $on_peer))
				{
					#print "I did not find it on the peer node.<br />\n";
					record($conf, "$THIS_FILE ".__LINE__."; I did not find it on the peer node.\n");
				}
			}
			else
			{
				$host = $node;
				#print "It is already running, as expected.<br />\n";
			}
		}
	}
	
	return ($host);
}

# This actually kicks off the VM.
sub provision_vm
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<b>Creating your new <span class=\"fixed_width\">$conf->{new_vm}{name}</span> server now.</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Starting
		</td>
		<td>
			In just a moment, your new server should begin installing.<br />
			Once it starts, you will be able to see it appear in the <span class=\"code\">virt-manager</span> window under <span class=\"fixed_width\">$conf->{new_vm}{host_node}</span>.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Note!
		</td>
		<td>
			<br />
			<i>Please leave this window open until you have rebooted the new server for the first time!</i><br />
			<br />
			The server is in a special state until it is rebooted. It must exit this state before being added to the cluster.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Beginning
		</td>
		<td>
			<br />
";
	
	# Create the LVs
	my $provision;
	my $i = 0;
	foreach my $vg (keys %{$conf->{new_vm}{vg}})
	{
		if (lc($conf->{new_vm}{vg}{$vg}{lvcreate_size}) eq "all")
		{
			$provision .= "lvremove -f /dev/$vg/$conf->{new_vm}{name}_$i\n";
			$provision .= "lvcreate -l 100\%FREE -n $conf->{new_vm}{name}_$i $vg\n";
		}
		else
		{
			$provision .= "lvremove -f /dev/$vg/$conf->{new_vm}{name}_$i\n";
			$provision .= "lvcreate -L $conf->{new_vm}{vg}{$vg}{lvcreate_size}GiB -n $conf->{new_vm}{name}_$i $vg\n";
		}
		$i++;
	}
	
	# Setup the 'virt-install' call.
	$provision .= "virt-install --connect qemu:///system \\\\\n";
	$provision .= "  --name $conf->{new_vm}{name} \\\\\n";
	$provision .= "  --ram $conf->{new_vm}{ram} \\\\\n";
	$provision .= "  --arch x86_64 \\\\\n";
	$provision .= "  --vcpus $conf->{new_vm}{cpu_cores} \\\\\n";
	$provision .= "  --cdrom /shared/files/$conf->{new_vm}{install_iso} \\\\\n";
	if ($conf->{cgi}{driver_iso})
	{
		$provision .= "  --disk path=/shared/files/$conf->{new_vm}{driver_iso},device=cdrom --force\\\\\n";
	}
	$provision .= "  --os-variant $conf->{cgi}{os_variant} \\\\\n";
	# VNC doesn't show the mouse pointer properly on the default 'qxl'
	# video driver. So if the OS is Windows, stick with 'qxl', otherwise
	# use 'cirrus'.
	if (($conf->{cgi}{os_variant} ne "vista") && ($conf->{cgi}{os_variant} !~ /^win/))
	{
		$provision .= "  --video cirrus \\\\\n";
	}
	if ($conf->{new_vm}{virtio}{nic})
	{
		$provision .= "  --network bridge=vbr2,model=virtio \\\\\n";
	}
	else
	{
		$provision .= "  --network bridge=vbr2,model=e1000 \\\\\n";
	}
	$i = 0;
	foreach my $vg (keys %{$conf->{new_vm}{vg}})
	{
		my $path = "/dev/$vg/$conf->{new_vm}{name}_$i";
		record($conf, "$THIS_FILE ".__LINE__."; LV: [$path], use virtio: [$conf->{new_vm}{virtio}{disk}]\n");
		$provision .= "  --disk path=$path";
		if ($conf->{new_vm}{virtio}{disk})
		{
			$provision .= ",bus=virtio";
		}
		$provision .= " \\\\\n";
	}
	$provision .= "  --graphics vnc,listen=0.0.0.0 > /var/log/an-install_".$conf->{new_vm}{name}.".log &\n";
	record($conf, "$THIS_FILE ".__LINE__."; provision:\n$provision\n");
	
	### TODO: Make sure the desired node is up and, if not, use the one
	###       good node.
	
	# Push the provision script into a file.
	my $script = "/shared/provision/$conf->{new_vm}{name}.sh";
	print "\t\t\tWriting provision script to <span class=\"code\">$script</span><br />\n";
	my $node = $conf->{new_vm}{host_node};
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	0,
		shell_call	=>	"echo \"$provision\" > $script && chmod 755 $script",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		### I now detach this so I won't be here log enough to see the
		### install complete.
		#chomp;
		#my $line = $_;
		#print "\t\t\t<span class=\"code\">$line</span><br />\n";
	}
	print "
			Done.<br />
			Starting the installation of <span class=\"code\">$conf->{new_vm}{name}</span> now.<br />\n
";
	record($conf, "$THIS_FILE ".__LINE__."; Calling; script: [$script]\n");
	($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	$ssh_fh,
		'close'		=>	1,
		shell_call	=>	"$script",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		next if $line =~ /One or more specified logical volume\(s\) not found./;
		print "\t\t\t<span class=\"fixed_width\"><span class=\"code\">$_</span></span><br />\n";
	}
	print "\t\t\tDone.<br />\n";
	
	if (-e $conf->{path}{guacamole_config})
	{
		# Get the VNC port and add an entry to Guacamole.
		my $node   = $conf->{new_vm}{host_node};
		my $say_vm = $conf->{new_vm}{name};
		my $vm     = "vm:$say_vm";
		record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], say_vm: [$say_vm]\n");
		my $icon   = "";
		# This needs to be set manually as this server didn't exist
		# when the cluster was scanned last.
		$conf->{vm}{$vm}{current_host} = $node;
		sleep 3;
		($node, my $type, my $listen, my $port) = get_current_vm_vnc_info($conf, $vm);
		record($conf, "$THIS_FILE ".__LINE__."; node: [$node], type: [$type], listen: [$listen], port: [$port]\n");
		update_guacamole_config($conf, $say_vm, $node, $port);
		
		### FIXME: This is a dirty nasty hack. Fix this by managing
		###        guacamole's cookies better.
		restart_tomcat($conf, "1");
		my ($guacamole_url) = get_guacamole_link($conf, $node);
		if ($node =~ /n01/)
		{
			$icon = "<a href=\"$guacamole_url?id=c\%2F$say_vm\" target=\"_new\"><img src=\"/img/icon_server-desktop_n01.png\"></a>";
		}
		elsif ($node =~ /n02/)
		{
			$icon = "<a href=\"$guacamole_url?id=c\%2F$say_vm\" target=\"_new\"><img src=\"/img/icon_server-desktop_n02.png\"></a>";
		}
		else
		{
			$icon = "<span class=\"highlight_warning\">Failed to locate the host node!</span><br />Please use 'Virtual Machine Manager' on the dashboard machine to locate this server and finish the install. Sorry for the inconvenience.";
		}
		
		print "
			If there were no errors, the installation should now have started.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Connect to Server
		</td>
		<td>
			<br />
			Connect to your new server!<br />
			<br />
			$icon<br />
			<br />
		</td>
	</tr>
";
		# Disabling this for now as it auto-restarts tomcat for the
		# time being.
# 	<tr>
# 		<td class=\"highlight_good_bold\">
# 			Trouble?
# 		</td>
# 		<td style=\"text-align: center;\">
# 			If you're having trouble connecting to the server's desktop, <a href=\"?cluster=$conf->{cgi}{cluster}&task=restart_tomcat\" target=\"_new\">click here</a>.<br />
# 			This will restart the remote desktop client on this dashboard.<br />
# 		</tr>
# 	</tr>
		print "
	<tr>
		<td class=\"highlight_good_bold\">
			After First Reboot
		</td>
		<td>
			<br />
			Once the installation is complete, please return here and click the link below.<br />
			<br />
		</td>
";
	}
	else
	{
		print "
			If there were no errors, the installation should now have started.<br />
			Please complete the install using <span class=\"code\">virt-manager</span>.<br />
			Once the installation is complete, please return here and click the link below.<br />
			<br />
";
	}
	
	print "
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><b>After</b> the OS install is complete, please <a href=\"?cluster=$conf->{cgi}{cluster}&task=add_vm&name=$conf->{new_vm}{name}&node=$conf->{new_vm}{host_node}\" class=\"button\">click here</a> to add the VM to the cluster.</div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This sanity-checks the requested VM config prior to creating the VM itself.
sub verify_vm_config
{
	my ($conf) = @_;
	
	# First, get a current view of the cluster.
	my $proceed = 1;
	scan_cluster($conf);
	read_files_on_shared($conf);
	
	# If we connected, start parsing.
	my $cluster = $conf->{cgi}{cluster};
	my @errors;
	if ($conf->{'system'}{up_nodes})
	{
		# Did the user name the VM?
		if ($conf->{cgi}{name})
		{
			$conf->{cgi}{name} =~ s/^\s+//;
			$conf->{cgi}{name} =~ s/\s+$//;
			if ($conf->{cgi}{name} =~ /\s/)
			{
				push @errors, "Bad Server Name#!#The server name can't have spaces in the name.";
			}
			else
			{
				my $vm     = $conf->{cgi}{name};
				my $vm_key = "vm:$vm";
				if (exists $conf->{vm}{$vm_key})
				{
					push @errors, "Duplicate Server Name#!#The server name: [<span class=\"code\">$vm</span>] is already in use.";
				}
				else
				{
					$conf->{new_vm}{name} = $vm;
				}
			}
		}
		else
		{
			push @errors, "Missing Server Name#!#All servers need to have a name. This is usally something like <span class=\"code\">vmXX-purpose</span>.";
		}
		
		# Did the user ask for too many cores?
		if ($conf->{cgi}{cpu_cores} =~ /\D/)
		{
			push @errors, "Bad CPU Count#!#Somehow, the number of requested CPUs: [<span class=\"code\">$conf->{cgi}{cpu_cores}</span>] has a non-digit in it. This is probably a program error.";
		}
		elsif ($conf->{cgi}{cpu_cores} > $conf->{resources}{total_threads})
		{
			push @errors, "Not Enough CPUs#!#The cluster reports a maximum of <span class=\"code\">$conf->{resources}{total_threads}</span> CPUs, but it looks like you asked for <span class=\"code\">$conf->{cgi}{cpu_cores}</span>. This is probably a program error.";
		}
		else
		{
			$conf->{new_vm}{cpu_cores} = $conf->{cgi}{cpu_cores};
		}
		
		# Now what about RAM?
		if ($conf->{cgi}{ram} =~ /\D/)
		{
			push @errors, "Bad RAM Size#!#The amount of RAM must only contain digits. It looks like you entered: [<span class=\"code\">$conf->{cgi}{ram}</span>].";
		}
		my $requested_ram = hr_to_bytes($conf, $conf->{cgi}{ram}, $conf->{cgi}{ram_suffix});
		my $diff          = $conf->{resources}{total_ram} % (1024 ** 3);
		my $available_ram = $conf->{resources}{total_ram} - $diff - $conf->{'system'}{unusable_ram};
		if ($requested_ram > $available_ram)
		{
			my $say_free_ram  = bytes_to_hr($conf, $available_ram);
			my $say_requested = bytes_to_hr($conf, $requested_ram);
			push @errors, "Not Enough RAM#!#The cluster reports a maximum of <span class=\"code\">$say_free_ram</span> free RAM, but it looks like you asked for <span class=\"code\">$say_free_ram</span>.";
		}
		else
		{
			# RAM is specified as a number of MiB.
			my $say_ram = sprintf("%.0f", ($requested_ram /= (2 ** 20)));
			$conf->{new_vm}{ram} = $say_ram;
		}
		
		# Look at the selected storage. if VGs named for two separate
		# nodes are defined, error.
		$conf->{new_vm}{host_node} = "";
		#record($conf, "$THIS_FILE ".__LINE__."; host_node: [$conf->{new_vm}{host_node}], vg_list: [$conf->{cgi}{vg_list}]\n");
		foreach my $vg (split /,/, $conf->{cgi}{vg_list})
		{
			my $short_vg   = $vg;
			my $short_node = $vg;
			# Sometimes 'cXXnYY_vgZ' is used, sometimes
			# 'cXXnYY-vgZ' is used.
			#record($conf, "$THIS_FILE ".__LINE__."; short_vg: [$short_vg], short_node: [$short_node], vg: [$vg]\n");
			if ($vg =~ /^(.*?)_(vg\d+)$/)
			{
				$short_node = $1;
				$short_vg   = $2;
				#record($conf, "$THIS_FILE ".__LINE__."; short_vg: [$short_vg], short_node: [$short_node]\n");
			}
			elsif ($vg =~ /^(.*?)-(vg\d+)$/)
			{
				$short_node = $1;
				$short_vg   = $2;
				#record($conf, "$THIS_FILE ".__LINE__."; short_vg: [$short_vg], short_node: [$short_node]\n");
			}
			my $say_node      = $short_vg;
			my $vg_key        = "vg_$vg";
			my $vg_suffix_key = "vg_suffix_$vg";
			#record($conf, "$THIS_FILE ".__LINE__."; say_node: [$say_node], vg_key: [$vg_key], vg_suffix_key: [$vg_suffix_key]\n");
			next if not $conf->{cgi}{$vg_key};
			foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
			{
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], short_node: [$short_node]\n");
				if ($node =~ /$short_node/)
				{
					$say_node = $node;
					#record($conf, "$THIS_FILE ".__LINE__."; say_node: [$say_node]\n");
					last;
				}
			}
			#record($conf, "$THIS_FILE ".__LINE__."; host_node: [$conf->{new_vm}{host_node}]\n");
			if (not $conf->{new_vm}{host_node})
			{
				$conf->{new_vm}{host_node} = $say_node;
				#record($conf, "$THIS_FILE ".__LINE__."; host_node: [$conf->{new_vm}{host_node}]\n");
			}
			elsif ($conf->{new_vm}{host_node} ne $say_node)
			{
				push @errors, "Conflicting Storage#!#It looks like you asked to use storage from both nodes. This is not safe. Please clear one of the node's storage.";
			}
			
			# Setup the 'lvcreate' call
			if ($conf->{cgi}{$vg_key} eq "all")
			{
				$conf->{new_vm}{vg}{$vg}{lvcreate_size} = "all";
			}
			else
			{
				# Make to lvcreate command a GiB value.
				record($conf, "$THIS_FILE ".__LINE__."; cgi::${vg_key}: [$conf->{cgi}{$vg_key}], cgi::${vg_suffix_key}: [$conf->{cgi}{$vg_suffix_key}]\n");
				my $lv_size = hr_to_bytes($conf, $conf->{cgi}{$vg_key}, $conf->{cgi}{$vg_suffix_key});
				record($conf, "$THIS_FILE ".__LINE__."; > lv_size: [$lv_size]\n");
				#$lv_size    = sprintf("%.0f", ($lv_size /= (2 ** 20)));
				$lv_size    = sprintf("%.0f", ($lv_size /= (2 ** 30)));
				record($conf, "$THIS_FILE ".__LINE__."; < lv_size: [$lv_size]\n");
				$conf->{new_vm}{vg}{$vg}{lvcreate_size} = "$lv_size";
			}
		}
		
		# Make sure the user specified an install disc.
		if ($conf->{cgi}{install_iso})
		{
			my $file_name = $conf->{cgi}{install_iso};
			if (exists $conf->{files}{shared}{$file_name})
			{
				$conf->{new_vm}{install_iso} = $conf->{cgi}{install_iso};
			}
			else
			{
				push @errors, "Install Media#!#The installation media you selected seems to have disappeared.";
			}
		}
		else
		{
			push @errors, "Install Media#!#You did not select installation media.";
		}
		
		### TODO: Find a better way to determine this.
		# Look at the OS type to try and determine if 'e1000' or
		# 'virtio' should be used by the network.
		$conf->{new_vm}{virtio}{nic}  = 0;
		$conf->{new_vm}{virtio}{disk} = 0;
		if (($conf->{cgi}{os_variant} =~ /fedora1\d/) || 
		    ($conf->{cgi}{os_variant} =~ /virtio/) || 
		    ($conf->{cgi}{os_variant} =~ /ubuntu/) || 
		    ($conf->{cgi}{os_variant} =~ /sles11/) || 
		    ($conf->{cgi}{os_variant} =~ /rhel5/) || 
		    ($conf->{cgi}{os_variant} =~ /rhel6/))
		{
			$conf->{new_vm}{virtio}{disk} = 1;
			$conf->{new_vm}{virtio}{nic}  = 1;
		}
		
		# Optional driver disk, enables virtio when appropriate
		if ($conf->{cgi}{driver_iso})
		{
			my $file_name = $conf->{cgi}{driver_iso};
			if (exists $conf->{files}{shared}{$file_name})
			{
				$conf->{new_vm}{driver_iso} = $conf->{cgi}{driver_iso};
			}
			else
			{
				push @errors, "Driver Media#!#The driver media you selected seems to have disappeared.";
			}
			
			if (lc($file_name) =~ /virtio/)
			{
				$conf->{new_vm}{virtio}{disk} = 1;
				$conf->{new_vm}{virtio}{nic}  = 1;
			}
		}
		
		# Make sure a valid os-variant was passed.
		if ($conf->{cgi}{os_variant})
		{
			my $match = 0;
			foreach my $os_variant (@{$conf->{'system'}{os_variant}})
			{
				my ($short_name, $desc) = ($os_variant =~ /^(.*?)#!#(.*)$/);
				if ($conf->{cgi}{os_variant} eq $short_name)
				{
					$match = 1;
				}
			}
			if (not $match)
			{
				push @errors, "OS Variant Not Found#!#Somehow, an OS optimization type was specified that is not valid. This is probably a program error.";
			}
		}
		else
		{
			push @errors, "OS Variant#!#No operating system optimization type was specified. This is probably a program error.";
		}
		
		# If there were errors, push the user back to the form.
		if (@errors > 0)
		{
			$proceed = 0;
			print "
<table>
";
			foreach my $error (@errors)
			{
				my ($title, $body) = ($error =~ /^(.*?)#!#(.*)$/);
				print "
	<tr>
		<td class=\"highlight_warning\">
			$title
		</td>
		<td>
			$body
		</td>
	</tr>
"
			}
			print "
</table>
<br />
";
		}
	}
	else
	{
		# Failed to connect to the cluster, errors should already be
		# reported to the user.
	}
	# Check the currently available resources on the cluster.
	
	return ($proceed);
}

# This doesn't so much confirm as it does ask the user how they want to build
# the VM.
sub confirm_provision_vm
{
	my ($conf) = @_;
	
	my ($node) = read_files_on_shared($conf);
	record($conf, "$THIS_FILE ".__LINE__."; read file list from node: [$node]\n");
	return if not $node;
	
	my $cluster = $conf->{cgi}{cluster};
	my $images  = [];
	foreach my $file (sort {$a cmp $b} keys %{$conf->{files}{shared}})
	{
		next if $file !~ /iso$/i;
		push @{$images}, $file;
	}
	my $cpu_cores = [];
	foreach my $core_num (1..$conf->{cgi}{max_cores})
	{
		if ($conf->{cgi}{max_cores} > 9)
		{
			#push @{$cpu_cores}, sprintf("%.2d", $core_num);
			push @{$cpu_cores}, $core_num;
		}
		else
		{
			push @{$cpu_cores}, $core_num;
		}
	}
	$conf->{cgi}{cpu_cores}  = 2 if not $conf->{cgi}{cpu_cores};
	my $select_cpu_cores     = build_select($conf, "cpu_cores", 0, 0, 60, $conf->{cgi}{cpu_cores}, $cpu_cores);
	foreach my $storage (sort {$a cmp $b} split/,/, $conf->{cgi}{max_storage})
	{
		my ($vg, $space)             =  ($storage =~ /^(.*?):(\d+)$/);
		my $say_max_storage          =  bytes_to_hr($conf, $space);
		$say_max_storage             =~ s/\.(\d+)//;
		$conf->{cgi}{vg_list}        .= "$vg,";
		my $vg_key                   =  "vg_$vg";
		my $vg_suffix_key            =  "vg_suffix_$vg";
		$conf->{cgi}{$vg_key}        =  ""    if not $conf->{cgi}{$vg_key};
		$conf->{cgi}{$vg_suffix_key} =  "GiB" if not $conf->{cgi}{$vg_suffix_key};
		my $select_vg_suffix                   =  build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB", "GiB", "TiB"]);
		if ($space < (2 ** 30))
		{
			# Less than a Terabyte
			$select_vg_suffix            = build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB", "GiB"]);
			$conf->{cgi}{$vg_suffix_key} = "GiB" if not $conf->{cgi}{$vg_suffix_key};
		}
		elsif ($space < (2 ** 20))
		{
			# Less than a Gigabyte
			$select_vg_suffix            = build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB"]);
			$conf->{cgi}{$vg_suffix_key} = "MiB" if not $conf->{cgi}{$vg_suffix_key};
		}
		# Devine the node associated with this VG.
		my $short_vg   =  $vg;
		my $short_node =  $vg;
		if ($vg =~ /^(.*?)_(vg\d+)$/)
		{
			$short_node = $1;
			$short_vg   = $2;
		}
		my $say_node =  $short_vg;
		foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
		{
			if ($node =~ /$short_node/)
			{
				$say_node = $node;
				last;
			}
		}
		
		$conf->{vg_selects}{$vg}{space}         = $space;
		$conf->{vg_selects}{$vg}{say_storage}   = $say_max_storage;
		$conf->{vg_selects}{$vg}{select_suffix} = $select_vg_suffix;
		$conf->{vg_selects}{$vg}{say_node}      = $say_node;
		$conf->{vg_selects}{$vg}{short_vg}      = $short_vg;
	}
	my $say_selects;
	my $say_or      = "<span class=\"fixed_width\">- or -</span><br />\n";
	foreach my $vg (sort {$a cmp $b} keys %{$conf->{vg_selects}})
	{
		my $space            =  $conf->{vg_selects}{$vg}{space};
		my $say_max_storage  =  $conf->{vg_selects}{$vg}{say_storage};
		my $select_vg_suffix =  $conf->{vg_selects}{$vg}{select_suffix};
		my $say_node         =  $conf->{vg_selects}{$vg}{say_node};
		$say_node            =~ s/\..*$//;
		my $short_vg         =  $conf->{vg_selects}{$vg}{short_vg};
		my $vg_key           =  "vg_$vg";
		$say_selects         .= "<span class=\"fixed_width\">$say_node</span>, <span class=\"fixed_width\">$short_vg</span> (<span class=\"subtle_text\">$say_max_storage free</span>): <input type=\"text\" name=\"$vg_key\" value=\"$conf->{cgi}{$vg_key}\" style=\"width: 100px\">$select_vg_suffix<br />\n";
		$say_selects         .= "$say_or";
	}
	$say_selects =~ s/$say_or$//m;
	$say_selects .= "<input type=\"hidden\" name=\"vg_list\" value=\"$conf->{cgi}{vg_list}\">\n";
	my $say_max_ram          = bytes_to_hr($conf, $conf->{cgi}{max_ram});
	$conf->{cgi}{ram}        = 2 if not $conf->{cgi}{ram};
	$conf->{cgi}{ram_suffix} = "GiB" if not $conf->{cgi}{ram_suffix};
	my $select_ram_suffix    = build_select($conf, "ram_suffix", 0, 0, 60, $conf->{cgi}{ram_suffix}, ["MiB", "GiB"]);
	$conf->{cgi}{os_variant} = "generic" if not $conf->{cgi}{os_variant};
	my $select_install_iso   = build_select($conf, "install_iso", 1, 1, 300, $conf->{cgi}{install_iso}, $images);
	my $select_driver_iso    = build_select($conf, "driver_iso", 1, 1, 300, $conf->{cgi}{driver_iso}, $images);
	my $select_os_variant    = build_select($conf, "os_variant", 1, 0, 300, $conf->{cgi}{os_variant}, $conf->{'system'}{os_variant});
	
	print "
<table>
	<form method=\"post\">
	<tr>
		<td colspan=\"3\">
			<b>Create a new server on the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span></b> <i>Anvil!</i>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_note\"><b>Note</b></span>:
		</td>
		<td colspan=\"2\">
			<br />
			You will need to answer some questions in order to create a new server.<br />
			If you are unsure what a certain question means, please don't hesitate to <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">ask questions</a>.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Server Name:
		</td>
		<td>
			<input type=\"text\" name=\"name\" value=\"$conf->{cgi}{name}\" style=\"width: 300px\">
		</td>
		<td class=\"subtle_text\">
			This can be whatever you want, but it must be unique.<br />
			It's good to keep this short.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Optimize for:
		</td>
		<td>
			<!-- Update this list by referencing 'virt-install --os-variant list' and feeding it through 'parse-os_variants.pl'. -->
			$select_os_variant
		</td>
		<td class=\"subtle_text\">
			This fine-tunes the cluster for your operating system.<br />
			If your OS is not listed, choose the one that is the closest match.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			New Media:
		</td>
		<td>
			<a href=\"an-mc?cluster=$conf->{cgi}{cluster}\" target=\"_new\">Add a New Disc</a>
		</td>
		<td class=\"subtle_text\">
			This will open a new window where you can upload new disc images.<br />
			Once finished, please reload this page to see them.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Install From:
		</td>
		<td>
			$select_install_iso
		</td>
		<td class=\"subtle_text\">
			You server will boot off of this disc image.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Driver Disc:
		</td>
		<td>
			$select_driver_iso
		</td>
		<td class=\"subtle_text\">
			This is optional.<br />
			If you need a drivers to install your server,<br />
			please select the appropriate disc here.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Memory (RAM):
		</td>
		<td>
			(<span class=\"subtle_text\">$say_max_ram free</span>) <input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix
		</td>
		<td class=\"subtle_text\">
			Most servers work well between 2 and 8 GiB.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Number of CPUs:
		</td>
		<td>
			$select_cpu_cores
		</td>
		<td class=\"subtle_text\">
			Windows servers tend to work best with 2 CPUs.<br />
			Few servers need more than 4 CPUs.<br />
			The cluster uses all CPUs to get the best performance.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Storage Space:
		</td>
		<td>
			$say_selects
		</td>
		<td class=\"subtle_text\">
			Please use only one node.<br />
			Type <span class=\"fixed_width\">all</span> to use the rest of the free space.<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<input type=\"hidden\" name=\"cluster\" value=\"$conf->{cgi}{cluster}\">
			<input type=\"hidden\" name=\"task\" value=\"$conf->{cgi}{task}\">
			<input type=\"hidden\" name=\"max_ram\" value=\"$conf->{cgi}{max_ram}\">
			<input type=\"hidden\" name=\"max_cores\" value=\"$conf->{cgi}{max_cores}\">
			<input type=\"hidden\" name=\"max_storage\" value=\"$conf->{cgi}{max_storage}\">
			<div class=\"align_right\"><input type=\"submit\" name=\"confirm\" value=\"Confirm\" class=\"button\"></div>
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to join both nodes to the cluster.
sub confirm_withdraw_node
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to withdraw <b>$conf->{cgi}{node_cluster_name}</b> from cluster <b>$conf->{cgi}{cluster}</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Caution!</b></span>
		</td>
		<td>
			<br />
			<span class=\"fixed_width\"><u><b>$conf->{cgi}{node_cluster_name}</b></u></span> will leave the <i>Anvil!</i>.<br />
			Once complete, it will no longer be able to run or recover any servers until it rejoins the <i>Anvil!</i>.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to join a node to the cluster.
sub confirm_join_cluster
{
	my ($conf) = @_;

	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to join <b>$conf->{cgi}{node_cluster_name}</b> to cluster <b>$conf->{cgi}{cluster}</b>.</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will attempt to join the node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> to the cluster <span class=\"fixed_width\">$conf->{cgi}{cluster}</span>.<br />
			This is usually a safe action.<br />
			If, for any reason, this node can't connect to it's peer, the peer node could be fenced (forcibly shut off).<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# Confirm that the user wants to join both nodes to the cluster.
sub confirm_dual_join
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to join both nodes to the $conf->{cgi}{cluster} cluster.</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will attempt to join both nodes of the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			This is usually a safe action.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to fence a nodes.
sub confirm_fence_node
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to forcefully power off cluster node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The cluster node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is about to be <span class=\"highlight_dangerous\">forcibly powered off</span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will effectively press and hold your node's power button until the system is forced to power down.<br >
			Should that fail, the power to the node will be cut completely cut off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Reconsider!</b></span>
		</td>
		<td>
			<br />
			This should be done as a last resort, when all other attempts to gracefully shut down the node have failed.<br />
			<i>Every</i> operating system has a chance of corrupting when it is forcibly powered off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# Confirm that the user wants to power-off a nodes.
sub confirm_poweroff_node
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power down the physical node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will send a <span class=\"fixed_width\">poweroff</span> command to the <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> node.<br />
			If all is well, this node should gracefully power off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Warning!</b></span>
		</td>
		<td>
			<br />
			If there is a problem with this node, like an incomplete withdrawl from the cluster, it may hang while trying to shut down.<br />
			If this happens, this browser session may time out. If it does, return to the dashboard and call a <span class=\"fixed_width\">fence</span> action against this node.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to boot a nodes.
sub confirm_poweron_node
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power on the physical node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			An attempt will be made to power on the <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> node.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Careful!</b></span>
		</td>
		<td>
			<br />
			Be aware that if anything blocks this node's ability to talk to it's peer, it will fence the peer node during start up!<br />
			This is by design, as a node can not safely provide clustered services when it's peer is in an unknown state.<br />
			If the peer node is already online and there are not network problems, this node will join the peer safely.<br />
			If the peer node is offline, this node will wait for a while before timing out. Once it times out, the peer node will likely be started.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}

# Confirm that the user wants to boot both nodes.
sub confirm_dual_boot
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power on both nodes!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			An attempt will be made to boot both nodes in the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			Please be patient, it can take a few minutes for the nodes to become accessible.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}
# Confirm that the user wants to start a VM.
sub confirm_start_vm
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to boot up the virtual machine <b>$conf->{cgi}{vm}</b> on <b>$conf->{cgi}{node_cluster_name}</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be booted on cluster node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span>.<br />
			The node was selected because it is either the preferred host or the only host ready to run this server.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}	

# Confirm that the user wants to stop a VM.
sub confirm_stop_vm
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to shut down the virtual machine <b>$conf->{cgi}{vm}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_warning\"><b>Careful!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span>, running on cluster node <span class=\"fixed_width\">$conf->{cgi}{node}</span>, is about to be shut down.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			If $conf->{cgi}{vm} is not listening to ACPI calls, this attempt to shut down the node will fail!<br />
			Make sure that Linux machines are running <span class=\"code\">acpid</span> and that <b>Windows</b> machines have <b>no pending updates</b>.<br />
			If <span class=\"fixed_width\">$conf->{cgi}{vm}</span> doesn't shut down within <u>120 seconds</u>, it will be <span class=\"highlight_dangerous\"><b>forced off</b></span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Precautions!</b></span>
		</td>
		<td>
			<br />
			Before proceeding, it is <b>strongly advised</b> that you connect to the server. If there are updates pending, please <b>reboot</b> the server first.<br />
			This will ensure that server shuts down cleanly.<br />
			Connect to this server by using <span class=\"fixed_width\">virt-manager</span> (connecting to <span class=\"fixed_width\">$conf->{cgi}{node}</span>) or by using an RDP or SSH session.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}

# Confirm that the user wants to force-off a VM.
sub confirm_force_off_vm
{
	my ($conf) = @_;
	
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to forcefully power off <b>$conf->{cgi}{vm}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span>, running on cluster node <span class=\"fixed_width\">$conf->{cgi}{host}</span>, is about to be <span class=\"highlight_dangerous\">forcibly powered off</span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This action is the same as pulling the power on a normal server!<br />
			The virtual machine will have no chance to react and will be instantly turned off. A moment later, the <i>Anvil!</i> will restart this server.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Reconsider!</b></span>
		</td>
		<td>
			<br />
			This should be done as a last resort, when all other attempts to gain control of the server have failed.<br />
			<i>Every</i> operating system has a chance of corrupting when it is forcibly powered off. <br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to migrate a VM.
sub confirm_delete_vm
{
	my ($conf) = @_;

	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to <span class=\"highlight_dangerous\"><b>delete</b></span> the <b>$conf->{cgi}{vm} server!</b></span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be <span class=\"highlight_dangerous\"><b>destroyed and deleted!</b></span><br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Warning!</b></span>
		</td>
		<td>
			<br />
			<u><b>This is a permanent and unreversable action!</b></u><br />
			<br />
			The virtual machine, along with all of it's data, will be deleted.<br />
			It will be removed from the cluster's management and forced off, if necessary.<br />
			The definition file will be deleted and it's backing storage will be wiped clean.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			Ensure you have backed up any data on the machine before proceeding!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to migrate a VM.
sub confirm_migrate_vm
{
	my ($conf) = @_;
	
	# Calculate roughly how long the migration will take.
	my $migration_time_estimate = $conf->{cgi}{vm_ram} / 1073741824; # Get # of GB.
	$migration_time_estimate *= 10; # ~10s / GB
	print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to migrate the virtual machine <b><span class=\"fixed_width_button\">$conf->{cgi}{vm}</span></b> to <b><span class=\"fixed_width_button\">$conf->{cgi}{target}</span></b>.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be migrated to cluster node <span class=\"fixed_width\">$conf->{cgi}{target}</span>.<br />
			This server has ".bytes_to_hr($conf, $conf->{cgi}{vm_ram})." RAM, which will take roughly $migration_time_estimate seconds to migrate.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This boots a VM on a target node.
sub start_vm
{
	my ($conf) = @_;
	
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $vm                = $conf->{cgi}{vm};
	my $say_vm            = ($vm =~ /vm:(.*)/)[0];
	my $remote_message    = "";
	my $remote_icon       = "";
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], node_cluster_name: [$node_cluster_name]\n");
	
	# Make sure the node is still ready to take this VM.
	scan_cluster($conf);
	my $vm_key = "vm:$vm";
	my $ready = check_node_readiness($conf, $vm_key, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], ready: [$ready]\n");
	if ($ready)
	{
		print "
<table>
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\"><b>Booting $vm on $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			System call output below:
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $show_remote_desktop_link = 0;
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	"clusvcadm -e vm:$vm -m $node_cluster_name",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /Success/i)
			{
				# Set the host manually as the server wasn't
				# running when the cluster was last scanned.
				my $vm_key = "vm:$vm";
				$conf->{vm}{$vm_key}{current_host} = $node;
				$show_remote_desktop_link      = 1;
				record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], vm_key: [$vm_key], node: [$node], vm::${vm_key}::current_host: [$conf->{vm}{$vm_key}{current_host}]\n");
			}
			elsif ($line =~ /Service is already running/i)
			{
				$show_remote_desktop_link = 2;
				$line = "";
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_note\">
						Note!
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						The server is already running.<br />
					</td>
				</tr>
";
			}
			elsif ($line =~ /Fail/i)
			{
				# The VM failed to start. Call a stop against it.
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_warning_bold\">
						Warning!
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						It looks like the attempt to start the server Failed. Will try to recover now...<br />
					</td>
				</tr>
";
				($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	$ssh_fh,
					'close'		=>	0,
					shell_call	=>	"clusvcadm -d vm:$vm",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$status
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$message
					</td>
				</tr>
";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_ready_bold\">
						Retry
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						Trying again to start the server<br />
					</td>
				</tr>
";
				($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	$ssh_fh,
					'close'		=>	1,
					shell_call	=>	"clusvcadm -e vm:$vm -m $node_cluster_name",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					if ($line =~ /Fail/i)
					{
						# The VM failed to start. Call a stop against it.
						print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_bad_bold\">
						Error!
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						It looks like there is a problem with this server.<br />
						Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
					</td>
				</tr>
";
					}
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$status
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$message
					</td>
				</tr>
";
				}
			}
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$status
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$message
					</td>
				</tr>
";
		}
		
		if ($show_remote_desktop_link)
		{
			# Show the link to the server's desktop.
			# If guac is installed, of course...
			if (-e $conf->{path}{guacamole_config})
			{
				# Installed.
				record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_vm: [$say_vm]\n");
				# Give time for the server to actually come up.
				if ($show_remote_desktop_link == 1)
				{
					sleep 3;
				}
				my ($node, $type, $listen, $port) = get_current_vm_vnc_info($conf, $vm);
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], type: [$type], listen: [$listen], port: [$port]\n");
				if ($type ne "vnc")
				{
					record($conf, "$THIS_FILE ".__LINE__."; VM: [$say_vm] is not using VNC, can't use Guacamole.\n");
					# Check the recorded XML file and is necesary, update
					# it. In any case, disable VNC and tell the user they
					# will need to power off and restart the server before
					# this will work.
					$remote_message = "The server is currently not using VNC. The server's configuration will be updated now. Please power off and then start the server (don't reboot) and then try again.";
					$remote_icon    = "<img src=\"/img/icon_server-desktop_oops.png\">";
					
					# See if I need to update the XML definition file.
					if (($conf->{vm}{$vm}{graphics}{type} ne "vnc") || ($conf->{vm}{$vm}{graphics}{'listen'} ne "0.0.0.0"))
					{
						# Rewrite the XML definition. The 'graphics' section should look like:
						#     <graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0'>
						#       <listen type='address' address='0.0.0.0'/>
						#     </graphics>
						record($conf, "$THIS_FILE ".__LINE__."; VM: [$say_vm]'s definition file is not using VNC, updating it.\n");
						archive_file($conf, $node, $conf->{vm}{$vm}{definition_file});
						switch_vm_xml_to_vnc($conf, $node, $vm);
					}
				}
				else
				{
					record($conf, "$THIS_FILE ".__LINE__."; VM: [$say_vm] is using VNC, we can offer remote desktop access.\n");
					update_guacamole_config($conf, $say_vm, $node, $port);
				}
				if (not $remote_message)
				{
					my ($guacamole_url) = get_guacamole_link($conf, $node);
					$remote_message     = "Connect directly to this server's desktop.";
					if (not $node)
					{
						$remote_message = "The server is turned off.";
						$remote_icon    = "<img src=\"/img/icon_server-desktop_offline.png\">";
					}
					elsif ($node =~ /n01/)
					{
						$remote_icon = "<a href=\"$guacamole_url?id=c\%2F$say_vm\" target=\"_new\"><img src=\"/img/icon_server-desktop_n01.png\"></a>";
					}
					elsif ($node =~ /n02/)
					{
						$remote_icon = "<a href=\"$guacamole_url?id=c\%2F$say_vm\" target=\"_new\"><img src=\"/img/icon_server-desktop_n02.png\"></a>";
					}
					else
					{
						$remote_message = "I think this server is running, but I don't know where. You can try connecting to it anyway.";
						$remote_icon    = "<img src=\"/img/icon_server-desktop_oops.png\">";
					}
				}
			}
			else
			{
				# Not installed.
				$remote_message = "This version of AN!CDB does not have in-browser remote desktop support yet.<br /><a href=\"https://alteeve.ca/w/Support\" target=\"_new\">Please upgrade</a> to enable this feature.";
				$remote_icon    = "<img src=\"/img/icon_server-desktop_oops.png\">";
			}
		}
		
		print "
			</table>
			<br />
		</td>
	</tr>
";
	if ($show_remote_desktop_link)
	{
		print "
	<tr>
		<td class=\"highlight_good_bold\">
			Desktop:
		</td>
		<td style=\"text-align: center;\">
			<span class=\"subtle_text_wrap\">Please Note: If the server is migrated to the other node,<br />you will have to refresh this page and then reconnect.</span><br />
			<br />
			$remote_icon<br />
			<br />
			$remote_message<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Trouble?
		</td>
		<td style=\"text-align: center;\">
			If you're having trouble connecting to the server's desktop, <a href=\"?cluster=$conf->{cgi}{cluster}&task=restart_tomcat\" target=\"_new\">click here</a>.<br />
			This will restart the remote desktop client on this dashboard.<br />
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td colspan=\"2\">
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Booting of $vm on $node_cluster_name failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$node_cluster_name</span> is no longer ready to run <span class=\"fixed_width\">$vm</span>.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This tries to parse lines coming back from a shell call to add highlighting and what-not.
sub parse_text_line
{
	my ($conf, $line) = @_;
	
	# 'Da good ^_^
	$line =~ s/(success)/<span class="highlight_good">$1<\/span>/ig;
	$line =~ s/\[ (ok) \]/[ <span class="highlight_good">$1<\/span> ]/ig;
	
	# Informational.
	$line =~ s/(done)/<span class="highlight_ready">$1<\/span>/ig;
	$line =~ s/(Starting Cluster):/<span class="highlight_ready">$1<\/span>:/ig;
	$line =~ s/(Stopping Cluster):/<span class="highlight_ready">$1<\/span>:/ig;
	#$line =~ s/(disabled)/<span class="highlight_ready">$1<\/span>/ig;
	#$line =~ s/(shutdown)/<span class="highlight_ready">$1<\/span>/ig;
	$line =~ s/(shut down)/<span class="highlight_ready">$1<\/span>/ig;
	
	# 'Da bad. ;_;
	$line =~ s/(failed)/<span class="highlight_bad">$1<\/span>/ig;
	$line =~ s/\[ (failed) \]/[ <span class="highlight_bad">$1<\/span> ]/ig;
	
	return($line);
}

# This migrates a VM to the target node.
sub migrate_vm
{
	my ($conf) = @_;
	
	my $target = $conf->{cgi}{target};
	my $vm     = $conf->{cgi}{vm};
	my $node   = long_host_name_to_node_name($conf, $target);
	record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], target: [$target]\n");
	
	# Make sure the node is still ready to take this VM.
	scan_cluster($conf);
	my $vm_key = "vm:$vm";
	my $ready = check_node_readiness($conf, $vm_key, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], ready: [$ready]\n");
	if ($ready)
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Migrating $vm to $target now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"$conf->{path}{clusvcadm} -M vm:$vm -m $target",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Migration of $vm to $target aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$target</span> is no longer ready to run <span class=\"fixed_width\">$vm</span>.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This sttempts to shut down a VM on a target node.
sub stop_vm
{
	my ($conf) = @_;
	
	my $node = $conf->{cgi}{node};
	my $vm   = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node]\n");
	
	# This, more than 
	scan_cluster($conf);
	print "
<table>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Attempting orderly shut down of $vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $say_node = node_name_to_long_host_name($conf, $node);
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"$conf->{path}{clusvcadm} -d vm:$vm",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$line =~ s/Local machine/$say_node/;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This sttempts to shut down a VM on a target node.
sub join_cluster
{
	my ($conf) = @_;
	
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $proceed           = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in join_cluster(), node: [$node], node_cluster_name: [$node_cluster_name]\n");
	
	# This, more than 
	scan_cluster($conf);
	
	# Proceed only if all of the storage components, cman and rgmanager are
	# off.
	if (($conf->{node}{$node}{daemon}{cman}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{rgmanager}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{drbd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{gfs2}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{libvirtd}{exit_code} ne "0"))
	{
		$proceed = 1;
	}
	if ($proceed)
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Attempting to join $node_cluster_name to $conf->{cgi}{cluster} now...</b></span><br />
			This can take a while, please be patient!<br />
			This process will complete before the storage service starts. Please give a minute or two for storage to come online.<br />
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"/etc/init.d/cman start && /etc/init.d/rgmanager start",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Joining of $node_cluster_name to $conf->{cgi}{cluster} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that <span class=\"fixed_width\">$node_cluster_name</span> is already running <span class=\"fixed_width\">cman</span>, <span class=\"fixed_width\">rgmanager</span>, <span class=\"fixed_width\">drbd</span>, <span class=\"fixed_width\">clvmd</span> or <span class=\"fixed_width\">gfs2</span>.<br />
			If any of these daemons are running, then either the cluster was already started elsewhere or the last attempt to withdraw the cluster failed.<br />
			If you believe that the cluster has failed, please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			Note that <span class=\"fixed_width\">libvirtd</span> is allowed to be running and would not block this action.<br />
			Please go back and see what the current state of the cluster is.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This sttempts to start the cluster stack on both nodes simultaneously.
sub dual_join
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $proceed = 1;
	#record($conf, "$THIS_FILE ".__LINE__."; in dual_join(), cluster: [$cluster]\n");
	
	# This, more than 
	scan_cluster($conf);
	
	# Proceed only if all of the storage components, cman and rgmanager are
	# off.
	my @abort_reason;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		if (($conf->{node}{$node}{daemon}{cman}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{rgmanager}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{drbd}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{clvmd}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{gfs2}{exit_code} eq "0"))
		{
			$proceed = 0;
			push @abort_reason, "It appears that <span class=\"fixed_width\">$node</span> is already running <span class=\"fixed_width\">cman</span>, <span class=\"fixed_width\">rgmanager</span>, <span class=\"fixed_width\">drbd</span>, <span class=\"fixed_width\">clvmd</span> or <span class=\"fixed_width\">gfs2</span>.";
		}
	}
	if ($proceed)
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Attempting to join both nodes to the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster now...</b></span><br />
			This can take a while, please be patient!<br />
			This process will complete before the storage services start. Please give then minute or two for storage to come online.<br />
		</td>
	</tr>
	<tr>
		<td>
			System call output below:<br />
			<span class=\"highlight_ready_bold\">Note</span>: Output from both nodes will be mixed together.
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		# I need to fork here because the calls won't return until cman
		# either talks to it's peer or fences it.
		my $parent_pid = $$;
		#record($conf, "$THIS_FILE ".__LINE__."; Parent process has PID: [$parent_pid]. Spawning a child process for each node.\n");
		my %pids;
		my $node_count = @{$conf->{clusters}{$cluster}{nodes}};
		foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
		{
			defined(my $pid = fork) or die "$THIS_FILE ".__LINE__."; Can't fork(), error was: $!\n";
			if ($pid)
			{
				# Parent thread.
				$pids{$pid} = 1;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], Spawned child with PID: [$pid].\n");
			}
			else
			{
				# This is the child thread, so do the call.
				# Note that, without the 'die', we could end
				# up here if the fork() failed.
				my ($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	"",
					'close'		=>	1,
					shell_call	=>	"/etc/init.d/cman start && /etc/init.d/rgmanager start",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; $node; $line\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" align=\"right\">
						$node
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				
				# Kill the child process.
				exit;
			}
		}
		
		# Now loop until both child processes are dead.
		# This helps to catch hung children.
		my $saw_reaped = 0;
		
		# If I am here, then I am the parent process and all the child process have
		# been spawned. I will not enter a while() loop that will exist for however
		# long the %pids hash has data.
		while (%pids)
		{
			# This is a bit of an odd loop that put's the while()
			# at the end. It will cycle once per child-exit event.
			my $pid;
			do
			{
				# 'wait' returns the PID of each child as they
				# exit. Once all children are gone it returns 
				# '-1'.
				$pid = wait;
				if ($pid < 1)
				{
					record($conf, "$THIS_FILE ".__LINE__."; Parent process thinks all children are gone now as wait returned: [$pid]. Exiting loop.\n");
				}
				else
				{
					record($conf, "$THIS_FILE ".__LINE__."; Parent process told that child with PID: [$pid] has exited.\n");
				}
				
				# This deletes the just-exited child process' PID from the
				# %pids hash.
				delete $pids{$pid};
				
				# This counter is a safety mechanism. If I see more PIDs exit
				# than I spawned, something went oddly and I need to bail.
				$saw_reaped++;
				error($conf, "All children should be gone now but it seems the program went into an infinit loop.\n") if $saw_reaped > ($node_count + 1);
			}
			while $pid > 0;	# This re-enters the do() loop for as
					# long as the PID returned by wait()
					# was >0.
		}
		record($conf, "$THIS_FILE ".__LINE__."; All child processes reaped, exiting threaded execution.\n");
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Joining of both nodes to the $conf->{cgi}{cluster} cluster aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
";
		foreach my $reason (@abort_reason)
		{
			print "
			$reason<br />
";
		}
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This forcibly shuts down a VM on a target node. The cluster should restart it
# shortly after.
sub force_off_vm
{
	my ($conf) = @_;
	
	my $node = $conf->{cgi}{node};
	my $vm   = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; in force_off_vm(), vm: [$vm], node: [$node]\n");
	
	# This, more than 
	scan_cluster($conf);
	print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Forcibly shutting down $vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"virsh destroy $vm",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			The cluster will restart this VM in a moment, if this call succeeded.
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This stops the VM, if it's running, edits the cluster.conf to remove the VM's
# entry, pushes the changed cluster out, deletes the VM's definition file and 
# finally deletes the LV.
sub delete_vm
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $say_vm  = $conf->{cgi}{vm};
	my $vm      = "vm:$conf->{cgi}{vm}";
	record($conf, "$THIS_FILE ".__LINE__."; in delete_vm(), vm: [$vm], cluster: [$cluster]\n");
	
	# This, more than 
	scan_cluster($conf);
	my $proceed      = 1;
	my $stop_vm      = 0;
	my $say_host     = "";
	my $host         = "";
	my $abort_reason = "";
	my $node         = $conf->{'system'}{cluster}{node1_name};
	my $node1        = $conf->{'system'}{cluster}{node1_name};
	my $node2        = $conf->{'system'}{cluster}{node2_name};
	record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::host: [$conf->{vm}{$vm}{host}]\n");
	if (not $conf->{vm}{$vm}{host})
	{
		$proceed      = 0;
		$abort_reason = "<b>Removal of $say_vm has been aborted!</b><br />\nThe program appears to have failed to read the VM's information properly.<br />\nThis is likely a bug in the program.<br />\n";
	}
	elsif ($conf->{vm}{$vm}{host} ne "none")
	{
		$stop_vm  = 1;
		$say_host = $conf->{vm}{$vm}{host};
		$host     = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
	}
	else
	{
		# Pick the first up node to use.
		if ($conf->{node}{$node1}{up})
		{
			$host = $node1;
		}
		elsif ($conf->{node}{$node2}{up})
		{
			$host = $node2;
		}
		else
		{
			$proceed      = 0;
			$abort_reason = "Can't delete: [$say_vm] until at least one node is online.";
		}
	}
	
	# Get to work!
	print "
<table>
	<tr>
		<td class=\"highlight_ready\">
			<b>Begining the process of deleting $say_vm now...</b></span><br />
		</td>
	</tr>
";

	if ($proceed)
	{
		print "
	<tr>
		<td>
			<br />
			Removing the VM from cluster management:<br />
			<i>Please be patient!</i><br />
			This step could take several minutes to complete.<br />
";
		### Note: I don't use 'path' for these calls as the location of
		###       a program on the cluster may differ from the local
		###       copy. Further, I will have $PATH on the far side of
		###       the ssh call anyway.
		# First, delete the VM from the cluster.
		my $ccs_exit_code;
		   $proceed = 0;
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$host,
			port		=>	$conf->{node}{$host}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	"ccs -h localhost --activate --sync --password \"$conf->{clusters}{$cluster}{ricci_pw}\" --rmvm $conf->{cgi}{vm}; echo ccs:\$?",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			next if not $line;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /ccs:(\d+)/)
			{
				$ccs_exit_code = $1;
			}
			else
			{
				$line = parse_text_line($conf, $line);
				print "<span class=\"fixed_width\">$line</span><br />\n";
			}
		}
		record($conf, "$THIS_FILE ".__LINE__."; ccs exit code: [$ccs_exit_code]\n");
		if ($ccs_exit_code eq "0")
		{
			print "The VM has been removed successfully.<br />\n";
			$proceed = 1;
		}
		else
		{
			print "</br ><span class=\"highlight_bad\"><b>Error</b></span>! It would appear that something went wrong!<br />\n";
			print "The removal call should have exited with exit code <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$ccs_exit_code</span> was received.<br />\n";
			print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
		}
		print "
			<br />
		</td>
	</tr>
";
		my $stop_exit_code;
		if (($stop_vm) && ($ccs_exit_code eq "0"))
		{
			print "
	<tr>
		<td>
			<br />
			The VM appears to still be running. I will force it off now.
			<br />
";
			   $proceed = 0;
			my $virsh_exit_code;
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$host,
				port		=>	$conf->{node}{$host}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	$ssh_fh,
				'close'		=>	0,
				shell_call	=>	"virsh destroy $say_vm; echo virsh:\$?",
			});
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				next if not $line;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				if ($line =~ /virsh:(\d+)/)
				{
					$virsh_exit_code = $1;
				}
				else
				{
					$line = parse_text_line($conf, $line);
					print "<span class=\"fixed_width\">$line</span><br />\n";
				}
			}
			record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
			if ($virsh_exit_code eq "0")
			{
				print "The VM has been forced off.<br />\n";
				$proceed = 1;
			}
			else
			{
				print "</br ><span class=\"highlight_bad\"><b>Error</b></span>! It would appear that something went wrong!<br />\n";
				print "The call to destroy the VM should have exited with exit code '<span class=\"fixed_width\">0</span>', but '<span class=\"fixed_width\">$virsh_exit_code</span>' was received instead.<br />\n";
				print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
			}
			print "
			<br />
		</td>
	</tr>
";
		}
		
		# Now delete the backing LVs
		if ($proceed)
		{
			print "
	<tr>
		<td>
			<br />
			Freeing up the VM's storage now.<br />
			<br />
";
			foreach my $lv (keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
			{
				print "Deleting <span class=\"fixed_width\">$lv</span>...<br />\n";
				my $lvremove_exit_code;
				($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$host,
					port		=>	$conf->{node}{$host}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	$ssh_fh,
					'close'		=>	1,
					shell_call	=>	"lvremove -f $lv; echo lvremove:\$?",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					if ($line =~ /lvremove:(\d+)/)
					{
						$lvremove_exit_code = $1;
					}
					else
					{
						$line = parse_text_line($conf, $line);
						print "<span class=\"fixed_width\">$line</span><br />\n";
					}
				}
				record($conf, "$THIS_FILE ".__LINE__."; lvremove exit code: [$lvremove_exit_code]\n");
				if ($lvremove_exit_code eq "0")
				{
					print "Removed successfully<br />\n";
				}
				else
				{
					print "<br /><span class=\"highlight_warning\"><b>Warning</b></span>! It would appear that <span class=\"fixed_width\">$lv</span> was not removed.<br />\n";
					print "The call to remove the VM's storage should have exited with exit code <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$lvremove_exit_code</span> was received.<br />\n";
					print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
				}
			}
			
			# Regardless of whether the removal succeeded, archive
			# and then delete the definition file.
			my $file = $conf->{vm}{$vm}{definition_file};
			archive_file($conf, $host, $file);
			remove_vm_definition($conf, $host, $file);
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Success</span>! The server <span class=\"fixed_width\">$say_vm</span> has been removed.<br />
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td>
			$abort_reason
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This deletes a VM definition file.
sub remove_vm_definition
{
	my ($conf, $node, $file) = @_;
	
	# We only delete VM definition files.
	if ($file !~ /^\/shared\/definitions\/.*?\.xml/)
	{
		print "<br /><span class=\"highlight_bad\"><b><u>CRITICAL ERROR</u></b></span>! It would appear that something went very wrong!<br />\n";
		print "I was asked to delete a VM definition file, but was asked to delete <span class=\"fixed_width\">$file</span>.<br />\n";
		print "For security reasons, only files in <span class=\"fixed_width\">/shared/definitions/</span> can be deleted.<br />\n";
		print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
		return (1);
	}
	
	# 'rm' seems to return '0' no matter what. So I use the 'ls' to ensure
	# the file is gone. 'ls' will return '2' on file not found.
	my $ls_exit_code;
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"rm -f $file; ls $file; echo ls:\$?",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /ls:(\d+)/)
		{
			$ls_exit_code = $1;
		}
		else
		{
			### There will be output, I don't care about it.
			#$line = parse_text_line($conf, $line);
			#print "<span class=\"fixed_width\">$line</span><br />\n";
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; ls exit code: [$ls_exit_code]\n");
	if ($ls_exit_code eq "2")
	{
		print "The file <span class=\"fixed_width\">$file</span> has been deleted.<br />\n";
	}
	else
	{
		print "<br /><span class=\"highlight_bad\"><b<Warning</b></span>! It would appear that something went wrong!<br />\n";
		print "I tried to delete the file <span class=\"fixed_width\">$file</span> and then verify that it was indeed removed.<br />\n";
		print "This should have returned <span class=\"fixed_width\">2</span>, but <span class=\"fixed_width\">$ls_exit_code</span> was returned instead.<br />\n";
		print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
	}
	
	return (0);
}

# This copies the passed file to 'node:/shared/archive'
sub archive_file
{
	my ($conf, $node, $file, $quiet) = @_;
	$quiet = 0 if not defined $quiet;
	
	### TODO: Check/create the archive directory.
	
	my ($dir, $file_name) = ($file =~ /^(.*)\/(.*?)$/);
	my ($date) = get_date($conf, time);
	my $dest = "/shared/archive/$file_name.$date";
	   $dest =~ s/ /_/;

	my $cp_exit_code;
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"cp $file $dest; echo cp:\$?",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /cp:(\d+)/)
		{
			$cp_exit_code = $1;
		}
		else
		{
			$line = parse_text_line($conf, $line);
			print "<span class=\"fixed_width\">$line</span><br />\n";
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; cp exit code: [$cp_exit_code]\n");
	if ($cp_exit_code eq "0")
	{
		if (not $quiet)
		{
			print "
			The file:<br />\n
			<span class=\"fixed_width\">$file</span><br />\n
			has been archived as<br />\n
			<span class=\"fixed_width\">$dest</span>.<br />\n
";
		}
		record($conf, "$THIS_FILE ".__LINE__."; The file: [$file] has been archived as: [$dest].\n");
	}
	else
	{
		print "
			<br /><span class=\"highlight_bad\"><b>Warning</b></span>! It would appear that something went wrong!<br />\n
			I tried to archive the file <span class=\"fixed_width\">$file</span> as <span class=\"fixed_width\">$dest</span>.<br />\n
			This should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$cp_exit_code</span> was returned instead.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n
";
		$dest = 0;
	}
	
	return ($dest);
}

# This adds or removes a VM from the cluster.conf file.
sub update_cluster_conf
{
	my ($conf, $do, $vm, $node) = @_;
	my $say_vm  = ($vm =~ /vm:(.*)/)[0];
	my $success = 1;
	
	# I 'cat' the current cluster.conf, incrementing 'config_version="x"'
	# by one, add or remove the <vm ...> line and then write out the edited
	# version locally. Next I backup the current cluster.conf to 
	# '/shared/archive/vX.cluster.conf', 'rsync' the updated local copy to
	# the target node, 'ccs_config_validate' it and, if all is well, 
	# 'cman_tool version -r' to push out the changes.
	
	# Read in the current cluster.conf.
	
	return($success);
}

# This makes an ssh call to the node and sends a simple 'poweroff' command.
sub poweroff_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed = $conf->{node}{$node}{enable_poweroff};
	record($conf, "$THIS_FILE ".__LINE__."; in poweroff_node(), node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# Stop rgmanager and then check it's status.
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Shutting down $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			This will complete once $node_cluster_name has closed the connection.<br />
			It may take a minute before the node shows as powered off on the dashboard.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"poweroff && echo \"Power down initiated. Please return to the main page now.\"",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Withdrawl of $conf->{cgi}{node_cluster_name} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is now in use by a VM.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	footer($conf);
	
	return(0);
}

# This uses the local machine to call "power on" against both nodes in the
# cluster.
sub dual_boot
{
	my ($conf) = @_;
	
	my $proceed = 1;
	my $cluster = $conf->{cgi}{cluster};
	my $sc      = "";
	# TODO: Provide an option to boot just one node if one node fails for
	# some reason but the other node is fine.
	scan_cluster($conf);
	my @abort_reasons;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		# Read the cache files.
		read_node_cache($conf, $node);
		if (not $conf->{node}{$node}{info}{power_check_command})
		{
			push @abort_reasons, "I was asked to power on: [$node], but the command to do so was not found in the cache. Manual power up is required.\n";
			$proceed = 0;
		}
		
		# Confirm the node is off still.
		check_if_on($conf, $node);
		record($conf, "$THIS_FILE ".__LINE__."; node::${node}::is_on: [$conf->{node}{$node}{is_on}]\n");
		if ($conf->{node}{$node}{is_on} == 1)
		{
			push @abort_reasons, "I was asked to power on: [$node], but it appears to already be running. Start up aborted.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 2)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I am not able to log into the taget node's out of band management interface: [$target_host].<br />Please check to see if the address, user or password has changed. Unable to continue.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 3)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I am not on the same subnet as it's out of band management interface at: [$target_host].<br />Please restore access to the target subnet. Unable to continue.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 4)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I don't have a recorded method of checking or changing the power state for: [$target_host].<br />Please restore access to the target subnet. Unable to continue.\n";
			$proceed = 0;
		}
		
		# Still alive?
		$sc .= "$conf->{node}{$node}{info}{power_check_command} -o on; ";
	}
	
	# Let's go
	if ($proceed)
	{
		print "
<table>
	<tr>
		<td>
			<b>Powering on both nodes in the cluster now...</b>
		</td>
	</tr>
	<tr>
		<td>
			I will now try to power on both nodes in the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			It may take a few minutes before the dashboard can log into either node.<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				$line = parse_text_line($conf, $line);
				my $message = ($line =~ /^(.*)\[/)[0];
				my $status  = ($line =~ /(\[.*)$/)[0];
				if (not $message)
				{
					$message = $line;
					$status  = "";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
			}
			$fh->close();
			print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Booting both nodes in the $conf->{cgi}{cluster} cluster aborted!</span>
		</td>
	</tr>
";
		foreach my $reason (@abort_reasons)
		{
			print "
	<tr>
		<td>
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
";
		}
		print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This uses the IPMI (or similar) to try and power on the node.
sub poweron_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	record($conf, "$THIS_FILE ".__LINE__."; in poweron_node(), node: [$node]\n");
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	check_if_on($conf, $node);
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
	my $proceed      = 0;
	my $abort_reason = "An unknown error has occured. Is <span class=\"code\">${node}</span>'s IPMI interface reachable?";
	if ($conf->{node}{$node}{is_on} == 0)
	{
		$proceed = 1;
	}
	elsif ($conf->{node}{$node}{is_on} == 1)
	{
		$abort_reason = "The node $node_cluster_name is already reported as being powered up.";
	}
	elsif ($conf->{node}{$node}{is_on} == 2)
	{
		$abort_reason = "The node ${node_cluster_name}'s out of band management interface is currently unreachable.";
	}
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# It is still off.
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Powering on $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now try to power on $node_cluster_name.<br />
			It may take a few minutes before the dashboard can log into it.<br />
		</td>
	</tr>
	<tr>
		<td class=\"fixed_width\">
			<br />
";

		# The node is still off. Now can I call it from it's peer?
		my $peer  = "";
		my $is_on = 2;
		record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
		if ($conf->{'system'}{up_nodes} == 1)
		{
			# It has to be the peer of this node.
			$peer = @{$conf->{up_nodes}}[0];
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
		if ($peer)
		{
			# It's peer is up, use it.
			if (not $conf->{node}{$node}{info}{power_check_command})
			{
				error($conf, "I was asked to power on: [$node] via it's peer: [$peer], but the power command is empty.<br />\nThis is likely a program error.\n");
			}
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
			my ($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$peer,
				port		=>	$conf->{node}{$peer}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	"",
				'close'		=>	1,
				shell_call	=>	"$conf->{node}{$node}{info}{power_check_command} -o on",
			});
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				print "$line<br />\n";
			}
			print "
			<br />
		</td>
	</tr>";
		}
		else
		{
			# Try to boot the node locally.
			if ($conf->{node}{$node}{info}{power_check_command})
			{
				my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], target host: [$target_host], power check command: [$conf->{node}{$node}{info}{power_check_command}].\n");
				my ($local_access, $target_ip) = on_same_network($conf, $target_host, $node);
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], local access: [$local_access].\n");
				if ($local_access)
				{
					# I can reach it directly
					my $sc = "$conf->{node}{$node}{info}{power_check_command} -o on";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
						print "$line<br />\n";
					}
					$fh->close();
					print "
			<br />
		</td>
	</tr>";
				}
				else
				{
					# I can't reach it from here.
					record($conf, "$THIS_FILE ".__LINE__."; This machine is not on the same network out of band management interface: [$target_host] for node: [$node], unable to check power state.\n");
				}
			}
			else
			{
				# Can't check the power.
				print "
			<br />
		</td>
	</tr>
</table>
<br />
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Powering on of $node_cluster_name failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			I wasn't able to find the command needed to power on $node_cluster_name.<br />
			Either this node has not been seen before or the cache for this node was deleted.<br />
			You can not power on the node from the dashboard at this time.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
";
			}
		}
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Powering on of $node_cluster_name aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			$abort_reason<br />
			<br />
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	footer($conf);
	
	return(0);
}

# This uses the fence methods, as defined in cluster.conf and in the proper
# order, to fence the target node.
sub fence_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $peer              = get_peer_node($conf, $node);
	record($conf, "$THIS_FILE ".__LINE__."; in poweron_node(), node: [$node], peer: [$peer], cluster name: [$node_cluster_name]\n");
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed      = 1;
	my @abort_reason = "";
	
	my $fence_string = "";
	# See if I already have the fence string. If not, load it from cache.
	if ($conf->{node}{$node}{info}{fence_methods})
	{
		$fence_string = $conf->{node}{$node}{info}{fence_methods};
	}
	else
	{
		read_node_cache($conf, $node);
		if ($conf->{node}{$node}{info}{fence_methods})
		{
			$fence_string = $conf->{node}{$node}{info}{fence_methods};
		}
		else
		{
			$proceed      = 0;
			push @abort_reason, "Unable to determine the commands needed to fence $node. One of the nodes need to be accessible or the cache file must exist with the correct command.\n";
		}
	}
	
	# If the peer node is up, use the fence command as compiled by it. 
	# Otherwise, read the cache. If the fence command(s) are still not
	# available, abort.
	if ($proceed)
	{
		if (not $conf->{node}{$peer}{up})
		{
			# See if this machine can reach each '-a ...' fence device
			# address.
			foreach my $address ($fence_string =~ /-a\s(.*?)\s/g)
			{
				my ($local_access, $target_ip) = on_same_network($conf, $address, $node);
				if (not $local_access)
				{
					$proceed = 0;
					push @abort_reason, "Trying to fence $node, but it's peer, $peer, is also offline and the fence device at $address is not accessible from this machine.<br />Unable to proceed with fence action.\n";
				}
			}
		}
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Fencing $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now attempt to fence <span class=\"fixed_width\">$node_cluster_name</span>.<br />
		</td>
	</tr>
";
		# This loops for each method, which may have multiple device 
		# calls. I parse each call into an 'off' and 'on' call. If the
		# 'off' call fails, I go to the next method until there are no
		# methods left. If the 'off' works, I call the 'on' call from
		# the same method to (try to) boot the node back up (or simply
		# unfence it in the case of PDUs and the like).
		my $fence_success   = 0;
		my $unfence_success = 0;
		foreach my $line ($fence_string =~ /\d+:.*?;\./g)
		{
			print "
	<tr>
		<td class=\"fixed_width\">
			<br />
";
			my ($method_num, $method_name, $command) = ($line =~ /(\d+):(.*?): (.*?;)\./);
			my $off_command = $command;
			my $on_command  = $command;
			my $off_success = 1;
			my $on_success  = 1;
			
			# If the peer is up, set the command to run through it.
			if ($conf->{node}{$peer}{up})
			{
				# When called remotely, I need to double-escape
				# the $? to protect it inside the "".
				$off_command =~ s/#!action!#;/off; echo fence:\$?;/g;
				$on_command  =~ s/#!action!#;/on;  echo fence:\$?;/g;
				$off_command = "ssh:$peer,$off_command";
				$on_command  = "ssh:$peer,$on_command";
			}
			else
			{
				# When called locally, I only need to escape
				# the $? once.
				$off_command =~ s/#!action!#;/off; echo fence:\$?;/g;
				$on_command  =~ s/#!action!#;/on;  echo fence:\$?;/g;
			}
			
			# Make the off attempt.
			my $output = [];
			my $ssh_fh;
			my $sc = "$off_command";
			if ($sc =~ /ssh:(.*?),(.*)$/)
			{
				my $node    = $1;
				my $command = $2;
				(my $error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	"",
					'close'		=>	0,
					shell_call	=>	"$command",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			}
			else
			{
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					push @{$output}, $_;
				}
				$fh->close()
			}
			foreach my $line (@{$output})
			{
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				# This is how I get the fence call's exit code.
				if ($line =~ /fence:(\d+)/)
				{
					# Anything but '0' is a failure.
					my $exit = $1;
					if ($exit ne "0")
					{
						$off_success = 0;
					}
				}
				else
				{
					print "$line<br />\n";
				}
			}
			print "
			<br />
		</td>
	</tr>
";
			if ($off_success)
			{
				# Fence succeeded!
				record($conf, "$THIS_FILE ".__LINE__."; Fencing using the '$method_name' method succeeded. Proceeding with unfence action.\n");
				print "
	<tr>
		<td>
			Fencing using the <span class=\"fixed_width\">$method_name</span> method succeeded. Proceeding with unfence action.<br />
		</td>
	</tr>
";
				$fence_success = 1;
			}
			else
			{
				# Fence failed!
				record($conf, "$THIS_FILE ".__LINE__."; Fencing using the '$method_name' method failed. Will try next method, if available.\n");
				print "
	<tr>
		<td>
			Fencing using the <span class=\"fixed_width\">$method_name</span> method failed. Will try next method, if available.<br />
		</td>
	</tr>
";
				next;
			}
			
			# If I'm here, I can try the unfence command.
			print "
	<tr>
		<td class=\"fixed_width\">
			<br />
";
			$sc = "$on_command";
			if ($sc =~ /ssh:(.*?),(.*)$/)
			{
				my $node    = $1;
				my $command = $2;
				(my $error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	$ssh_fh,
					'close'		=>	1,
					shell_call	=>	"$command",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			}
			else
			{
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "$THIS_FILE ".__LINE__."; Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					push @{$output}, $_;
				}
				$fh->close()
			}
			foreach my $line (@{$output})
			{
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				# This is how I get the fence call's exit code.
				if ($line =~ /fence:(\d+)/)
				{
					# Anything but '0' is a failure.
					my $exit = $1;
					if ($exit ne "0")
					{
						$on_success = 0;
					}
				}
				else
				{
					print "$line<br />\n";
				}
			}
			print "
			<br />
		</td>
	</tr>
";
			if ($on_success)
			{
				# Unfence succeeded!
				record($conf, "$THIS_FILE ".__LINE__."; Unfencing using the '$method_name' method succeeded. Fence operation a complete success!\n");
				print "
	<tr>
		<td>
			Unfencing using the <span class=\"fixed_width\">$method_name</span> method succeeded. Fence operation a complete success!<br />
		</td>
	</tr>
";
				$unfence_success = 1;
				last;
			}
			else
			{
				# Unfence failed!
				# This is allowed to go to the next fence method
				# because some servers may hang their IPMI 
				# interface after a fence call, requiring power
				# to be cut in order to reset the BMC. HP, I'm
				# looking at you and your DL1** G7 line...
				record($conf, "$THIS_FILE ".__LINE__."; Unfencing using the '$method_name' method failed. The core fence action was a success, but something went wrong and manual intervention may be required before the node can be returned to service. If another fence method remains, it will now be tried in hopes of assisting recovery.\n");
				print "
	<tr>
		<td>
			Unfencing using the <span class=\"fixed_width\">$method_name</span> method failed.<br />\nThe core fence action was a success, but something went wrong and manual intervention may be required before the node can be returned to service.<br />\nIf another fence method remains, it will now be tried in hopes of assisting recovery.<br />			<br />
		</td>
	</tr>
";
			}
		}
	}
	else
	{
		print "
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Powering on of $node_cluster_name aborted!</span>
		</td>
	</tr>
";
		foreach my $reason (@abort_reason)
		{
			print "
	<tr>
		<td>
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
";
		}
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	footer($conf);
	
	return(0);
}

# This does a final check of the target node then withdraws it from the
# cluster.
sub withdraw_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed = $conf->{node}{$node}{enable_withdraw};
	#record($conf, "$THIS_FILE ".__LINE__."; in withdraw_node(), node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# Stop rgmanager and then check it's status.
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Withdrawing $node_cluster_name from the cluster now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			Stopping the cluster resource manager now...<br />
			<span class=\"highlight_ready_bold\">Please be patient</span>! This can take a minute.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $rgmanager_stop = 1;
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	"/etc/init.d/rgmanager stop",
		});
		#record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			if ($line =~ /failed/i)
			{
				$rgmanager_stop = 0;
			}
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		print "
			</table>
			<br />
		</td>
	</tr>
";
		if ($rgmanager_stop)
		{
			print "
	<tr>
		<td>
			<br />
			Cluster resource manager stopped successfully.<br />
			Stopping the cluster communication layer now...<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			my $cman_stop = 1;
			($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$node,
				port		=>	$conf->{node}{$node}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	$ssh_fh,
				'close'		=>	0,
				shell_call	=>	"/etc/init.d/cman stop",
			});
			record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				if ($line =~ /failed/i)
				{
					$cman_stop = 0;
				}
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				$line = parse_text_line($conf, $line);
				my $message = ($line =~ /^(.*)\[/)[0];
				my $status  = ($line =~ /(\[.*)$/)[0];
				if (not $message)
				{
					$message = $line;
					$status  = "";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
			}
			print "
			</table>
			<br />
		</td>
	</tr>
";
			if (not $cman_stop)
			{
				# Crap...
			print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Cluster communication layer failed to stop!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<b>Was something holding open the cluster storage?</b><br />
			If a shell was logged in and sitting in a shared directory, a failure like this can occur.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			<br />
			Attempting to recover now...<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				my $cman_start = 1;
				($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	$ssh_fh,
					'close'		=>	1,
					shell_call	=>	"/etc/init.d/cman start",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$cman_start = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				print "
			</table>
			<br />
		</td>
	</tr>
";
				if ($cman_start)
				{
					# Number 5 is alive
					print "
	<tr>
		<td class=\"highlight_ready\">
			<br />
			Cluster communication layer started successfully!<br />
			<br />
		</td>
	</tr>
";
					recover_rgmanager($conf, $node);
					
				}
				else
				{
					# Failed, call support.
					print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Unable to start the cluster communication layer!<br />
			Please <a href=\"https://alteeve.ca/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
				}
			}
		}
		else
		{
			# Oh shit...
			print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Cluster resource manager failed to stop!<br />
			Was something holding open the cluster storage?<br />
			If a shell was logged in and sitting in a shared directory, a failure like this can occur.<br />
			<br />
		</td>
	</tr>
";
			recover_rgmanager($conf, $node);
		}
		print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<br />
			<span class=\"highlight_bad\"><b>Withdrawl of $conf->{cgi}{node_cluster_name} aborted!</span>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is now in use by a VM.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	footer($conf);
	
	return(0);
}

# This restarts rgmanager and, if necessary, disables and re-enables the 
# storage service
sub recover_rgmanager
{
	my ($conf, $node) = @_;
	
	print "
	<tr>
		<td>
			Attempting to recover rgmanager and, if necessary, the node's storage service...<br />
		</td>
	</tr>
	<tr>
		<td class=\"fixed_width\">
			<br />
";
	my $rgmanager_start = 1;
	my ($error, $ssh_fh, $output) = remote_call($conf, {
		node		=>	$node,
		port		=>	$conf->{node}{$node}{port},
		user		=>	"root",
		password	=>	$conf->{'system'}{root_password},
		ssh_fh		=>	"",
		'close'		=>	1,
		shell_call	=>	"/etc/init.d/rgmanager start",
	});
	record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
	foreach my $line (@{$output})
	{
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		if ($line =~ /failed/i)
		{
			$rgmanager_start = 0;
		}
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		print "$line<br />\n";
	}
	print "
			<br />
		</td>
	</tr>
";
	if ($rgmanager_start)
	{
		my $storage_service = $conf->{node}{$node}{info}{storage_name};
		print "
	<tr>
		<td class=\"highlight_good\">
			Cluster resource manager recovered successfully!<br />
		</td>
	</tr>
";
		if ($storage_service)
		{
			print "
	<tr>
		<td>
			Checking the <span class=\"fixed_width\">$storage_service</span> storage service now.<br />
			This requires a rescan of the cluster, please be patient.<br />
		</td>
	</tr>
";
			# I need to sleep for ~ten seconds to give time for
			# 'clustat' to start showing the service section again.
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rescanning the cluster in ten seconds.\n");
			sleep 10;
			check_node_status($conf);
			my $storage_state = $conf->{node}{$node}{info}{storage_state};
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], storage service: [$storage_service], storage state: [$storage_state]\n");
			if ($storage_state =~ /Failed/i) 
			{
				print "
	<tr>
		<td class=\"highlight_bad\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service has failed!<br />
		</td>
	</tr>
	<tr>
		<td>
			The <span class=\"fixed_width_button\">$storage_service</span> storage will now be cycled...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				# NOTE: This will return 'Warning' because of
				# whatever is holding open the storage. This is
				# fine, as the goal is to enable, not stop.
				my $storage_stop = 1;
				my ($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	"",
					'close'		=>	0,
					shell_call	=>	"$conf->{path}{clusvcadm} -d $storage_service",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$storage_stop = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				print "
			</table>
			<br />
		</td>
	</tr>
";
				if ($storage_stop)
				{
					print "
	<tr>
		<td class=\"highlight_ready\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service has been disabled.<br />
		</td>
	</tr>
	<tr>
		<td>
			Attempting to re-enable it now...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				my $storage_start = 1;
				($error, $ssh_fh, $output) = remote_call($conf, {
					node		=>	$node,
					port		=>	$conf->{node}{$node}{port},
					user		=>	"root",
					password	=>	$conf->{'system'}{root_password},
					ssh_fh		=>	"",
					'close'		=>	1,
					shell_call	=>	"$conf->{path}{clusvcadm} -e $storage_service",
				});
				record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
				foreach my $line (@{$output})
				{
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$storage_start = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				print "
			</table>
			<br />
		</td>
	</tr>
";
					if ($storage_start)
					{
						print "
	<tr>
		<td class=\"highlight_ready\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage has been restarted.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good\">
			Recovery has completed successfully!<br />
		</td>
	</tr>
	<tr>
		<td>
			Please log into <span class=\"fixed_width_button\">$node</span> and locate what held open the storage service.<br />
			Trying to withdraw from the cluster before this is fixed could cause problems. <br />
			Proceed carefully!<br />
		</td>
	</tr>
";
					}
					else
					{
						print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			The <span class=\"fixed_width_button\">$storage_service</span> storage service failed to restart!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
					}
				}
				else
				{
					print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			The <span class=\"fixed_width_button\">$storage_service</span> storage service failed to disable!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
				}
			}
			else
			{
				# TODO: Check each individual storage service
				# and restart each if needed.
				print "
	<tr>
		<td class=\"highlight_good\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service appears to be ok!<br />
			Recovery of the storage services appears to be unnecessary.
		</td>
	</tr>
";
			}
		}
		else
		{
			print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Unable to identify the storage service for this node! This is likely a program error.<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Failed to start the <span class=\"fixed_width_button\">rgmanager</span> daemon back up!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
	}
	
	return(0);
}

# This creates the summary page after a cluster has been selected.
sub display_details
{
	my ($conf) = @_;
	
	print "
<table class=\"hidden_table\" border=\"0\">
	<tr>
		<td class=\"td_hidden\">
";
	# Display the status of each node's daemons
	my $up_nodes = @{$conf->{up_nodes}};
	# TODO: Rework this, I always show nodes now so that the 'fence_...' 
	# calls are available. IE: enable this when the cache exists and the
	# fence command addresses are reachable.
	#record($conf, "$THIS_FILE ".__LINE__."; show nodes: [$conf->{'system'}{show_nodes}], up nodes: [$conf->{'system'}{up_nodes}] ($up_nodes)\n");
#	if ($conf->{'system'}{show_nodes})
	if (1)
	{
		display_node_controls($conf);

		# I don't show below here unless at least one node is up.
		#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}] ($up_nodes)\n");
		if ($conf->{'system'}{up_nodes} > 0)
		{
			# Show the user the current VM states and the control buttons.
			display_vm_state_and_controls($conf);
			
			# Show the state of the daemons.
			display_node_details($conf);
		
			# Show the details about each VM.
			display_vm_details($conf);
			
			# Show the status of each node's GFS2 share(s)
			display_gfs2_details($conf);
		
			# This shows the status of each DRBD resource in the cluster.
			display_drbd_details($conf);
		
			# Show the free resources available for new VMs.
			display_free_resources($conf);
			print "
</table>
<br />
";
		}
		else
		{
			# Was able to confirm the nodes are off.
			print "
<table width=\"100%\">
	<tr>
		<td colspan=\"2\">
			<b>Anvil Offline</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Offline
		</td>
		<td>
			Both physical nodes appear to be powered off. Anvil details are not available at this time.
		</td>
	</tr>
</table>
<!-- <meta http-equiv=\"refresh\" content=\"30\"> -->
<br />
";
		}
	}
	else
	{
		# No access to the cluster at all.
		print "
<table width=\"100%\">
	<tr>
		<td colspan=\"2\">
			<b>Cluster Offline</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_offline\">
			Offline
		</td>
		<td>
			Unable to connect to either cluster node. Cluster status is not available at this time.
		</td>
	</tr>
</table>
<br />
"
	}
	
	return (0);
}

# This shows the free resources available to be assigned to new VMs.
sub display_free_resources
{
	my ($conf) = @_;
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"12\">
			<b>Available Resources</b>
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<i>CPU Cores</i>
		</td>
		<td colspan=\"3\">
			<i>RAM</i>
		</td>
		<td colspan=\"6\">
			<i>Storage</i>
		</td>
	</tr>
	<tr>
		<td>
			Cores
		</td>
		<td>
			Threads
		</td>
		<td>
			Allocated
		</td>
		<td>
			Total
		</td>
		<td>
			Allocated
		</td>
		<td>
			Available
		</td>
		<td>
			VG
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			PV
		</td>
		<td>
			Size
		</td>
		<td>
			Used
		</td>
		<td>
			Free
		</td>
	</tr>
";	
	
	# I only show one row for CPU and RAM, but usually have two or more
	# VGs. So the first step is to put my VG info into an array.
	my $enough_storage = 0;
	my $available_ram  = 0;
	my $max_cpu_cores  = 0;
	my @vg;
	my @vg_size;
	my @vg_used;
	my @vg_free;
	my @pv_name;
	my $vg_link="";
	foreach my $vg (sort {$a cmp $b} keys %{$conf->{resources}{vg}})
	{
		# If it's not a clustered VG, I don't care about it.
		#record($conf, "$THIS_FILE ".__LINE__."; vg: [$vg], clustered: [$conf->{resources}{vg}{$vg}{clustered}]\n");
		next if not $conf->{resources}{vg}{$vg}{clustered};
		push @vg,      $vg;
		push @vg_size, $conf->{resources}{vg}{$vg}{size};
		push @vg_used, $conf->{resources}{vg}{$vg}{used_space};
		push @vg_free, $conf->{resources}{vg}{$vg}{free_space};
		push @pv_name, $conf->{resources}{vg}{$vg}{pv_name};
		#record($conf, "$THIS_FILE ".__LINE__."; vg: [$vg], size: [$conf->{resources}{vg}{$vg}{size}], used space: [$conf->{resources}{vg}{$vg}{used_space}], free space: [$conf->{resources}{vg}{$vg}{free_space}], pv name: [$conf->{resources}{vg}{$vg}{pv_name}]\n");
		
		# If there is at least a GiB free, mark free storage as
		# sufficient.
		if (not $conf->{'system'}{clvmd_down})
		{
			$enough_storage =  1 if $conf->{resources}{vg}{$vg}{free_space} > (2**30);
			$vg_link        .= "$vg:$conf->{resources}{vg}{$vg}{free_space},";
		}
	}
	$vg_link =~ s/,$//;
	
	# Count how much RAM and CPU cores have been allocated.
	my $allocated_cores = 0;
	my $allocated_ram   = 0;
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		# I check GFS2 because, without it, I can't read the VM's details.
		if ($conf->{'system'}{gfs2_down})
		{
			$allocated_ram   = "<span class=\"fixed_width\">--</span>";
			$allocated_cores = "<span class=\"fixed_width\">--</span>";
		}
		else
		{
			$allocated_ram   += $conf->{vm}{$vm}{details}{ram};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_ram: [$allocated_ram], vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$allocated_cores += $conf->{vm}{$vm}{details}{cpu_count};
		}
	}
	
	# Always knock off some RAM for the host OS.
	
	my $real_total_ram            =  bytes_to_hr($conf, $conf->{resources}{total_ram});
	# Reserved RAM and BIOS memory holes rarely leave us with an even GiB
	# of total RAM. So we modulous off the difference, then subtract that
	# plus the reserved RAM to get an even left-over amount of memory for
	# the user to allocate to their servers.
	my $diff                      = $conf->{resources}{total_ram} % (1024 ** 3);
	$conf->{resources}{total_ram} = $conf->{resources}{total_ram} - $diff - $conf->{'system'}{unusable_ram};
	$conf->{resources}{total_ram} =  0 if $conf->{resources}{total_ram} < 0;
	my $free_ram                  =  $conf->{'system'}{gfs2_down}  ? 0    : $conf->{resources}{total_ram} - $allocated_ram;
	my $say_free_ram              =  $conf->{'system'}{gfs2_down}  ? "--" : bytes_to_hr($conf, $free_ram);
	my $say_total_ram             =  bytes_to_hr($conf, $conf->{resources}{total_ram});
	my $say_allocated_ram         =  $conf->{'system'}{gfs2_down}  ? "--" : bytes_to_hr($conf, $allocated_ram);
	my $say_vg_size               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_size[0]);
	my $say_vg_used               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_used[0]);
	my $say_vg_free               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_free[0]);
	my $say_vg                    =  $conf->{'system'}{clvmd_down} ? "--" : $vg[0];
	my $say_pv_name               =  $conf->{'system'}{clvmd_down} ? "--" : $pv_name[0];
	
	# Show the main info.
	print "
	<tr>
		<td>
			$conf->{resources}{total_cores}
		</td>
		<td>
			$conf->{resources}{total_threads}
		</td>
		<td>
			$allocated_cores
		</td>
		<td>
			$real_total_ram ($say_total_ram)
		</td>
		<td>
			$say_allocated_ram
		</td>
		<td>
			$say_free_ram
		</td>
		<td>
			<span class=\"fixed_width\">$say_vg</span>
		</td>
		<td>
			on
		</td>
		<td>
			<span class=\"fixed_width\">$say_pv_name</span>
		</td>
		<td>
			$say_vg_size
		</td>
		<td>
			$say_vg_used
		</td>
		<td>
			$say_vg_free
		</td>
	</tr>
";
	if (@vg > 0)
	{
		for (my $i=1; $i < @vg; $i++)
		{
			my $say_vg_size = bytes_to_hr($conf, $vg_size[$i]);
			my $say_vg_used = bytes_to_hr($conf, $vg_used[$i]);
			my $say_vg_free = bytes_to_hr($conf, $vg_free[$i]);
			my $say_pv_name = $pv_name[$i];
			print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"fixed_width\">$vg[$i]</span>
		</td>
		<td>
			on
		</td>
		<td>
			<span class=\"fixed_width\">$pv_name[$i]</span>
		</td>
		<td>
			$say_vg_size
		</td>
		<td>
			$say_vg_used
		</td>
		<td>
			$say_vg_free
		</td>
	</tr>
";
		}
	}
	
	### NOTE: Disabled in this release.
	# If I found enough free disk space, have at least 1 GiB of free RAM 
	# and both nodes are up, enable the "provision new VM" button.
	my $node1   = $conf->{'system'}{cluster}{node1_name};
	my $node2   = $conf->{'system'}{cluster}{node2_name};
	my $say_bns = "<span class=\"disabled_button\">Build a New Server</span>";
	my $say_mc  = "<span class=\"disabled_button\">Media Library</span>";
	
	#record($conf, "$THIS_FILE ".__LINE__."; in enough_storage: [$enough_storage], free_ram: [$free_ram], node1 cman: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], node2 cman: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && 
	($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0"))
	{
		# The cluster is running, so enable the media library link.
		$say_mc = "<a href=\"/cgi-bin/an-mc?cluster=$conf->{cgi}{cluster}\" target=\"_new\">Media Library</a>";
		
		# Enable the "New Server" button if there is enough free memory
		# and storage space.
		if (($enough_storage) && ($free_ram > 1073741824))
		{
			$say_bns = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=provision&max_ram=$free_ram&max_cores=$conf->{resources}{total_cores}&max_storage=$vg_link\">Build a New Server</a>";
		}
	}
	print "
	<tr>
		<td colspan=\"12\">
			<table class=\"hidden_table\" width=\"100%\">
				<tr>
					<td width=\"50%\" class=\"td_hidden\">
						$say_bns
					</td>
					<td width=\"50%\" class=\"td_hidden\">
						$say_mc
					</td>
				</tr>
			</table>
		</td>
	</tr>
";

	return (0);
}

# Simply converts a full domain name back to the node name used in the main hash.
sub long_host_name_to_node_name
{
	my ($conf, $host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in long_host_name_to_node_name(), host: [$host]\n");
	
	my $cluster   = $conf->{cgi}{cluster};
	my $node_name = "";
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster]\n");
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node]\n");
		my $short_host =  $host;
		   $short_host =~ s/\..*$//;
		my $short_node =  $node;
		   $short_node =~ s/\..*$//;
		#record($conf, "$THIS_FILE ".__LINE__."; short_host: [$short_host], short_node: [$short_node]\n");
		if ($short_host eq $short_node)
		{
			$node_name = $node;
			#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
			last;
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
	return ($node_name);
}

# Simply converts a node name to the full domain name.
sub node_name_to_long_host_name
{
	my ($conf, $host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in node_name_to_long_host_name(), host: [$host]\n");
	
	my $node_name = $conf->{node}{$host}{me}{name};

	#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
	return ($node_name);
}

# This just shows the details of the VM (no controls)
sub display_vm_details
{
	my ($conf) = @_;
	
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"6\">
			<b>Virtual Machines - Details</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<i>CPU</i>
		</td>
		<td>
			<i>RAM</i>
		</td>
		<td colspan=\"2\">
			<i>Storage</i>
		</td>
		<td>
			<i>Network</i>
		</td>
	</tr>
";
	
	# Pull up the VM details.
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		
		my $say_vm  = ($vm =~ /^vm:(.*)/)[0];
		my $say_ram = $conf->{'system'}{gfs2_down} ? "<span class=\"fixed_width\">--</span>" : bytes_to_hr($conf, $conf->{vm}{$vm}{details}{ram});
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_ram: [$say_ram], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		
		# Get the LV arrays populated.
		my @lv_path;
		my @lv_size;
		my $host = $conf->{vm}{$vm}{host};
		
		# If the host is "none", read the details from one of the "up"
		# nodes.
		if ($host eq "none")
		{
			# If the first node is running, use it. Otherwise use
			# the second node.
			my $node1_daemons_running = check_node_daemons($conf, $node1);
			my $node2_daemons_running = check_node_daemons($conf, $node2);
			if ($node1_daemons_running)
			{
				$host = $node1;
			}
			elsif ($node2_daemons_running)
			{
				$host = $node2;
			}
		}
		
		my @bridge;
		my @device;
		my @mac;
		my @type;
		my $node         = "--";
		my $say_net_host = ""; # Don't want anything printed when the VM is down
		my $say_host     = "--";
		if ($host)
		{
			$node = long_host_name_to_node_name($conf, $host);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$host], node: [$node]\n");
			
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$host], node: [$node], lv hash on node1: [$conf->{vm}{$vm}{node}{$node1}{lv}], lv hash on node2: [$conf->{vm}{$vm}{node}{$node2}{lv}]\n");
			foreach my $lv (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
			{
				#record ($conf, "$THIS_FILE ".__LINE__."; lv: [$lv], size: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}]\n");
				push @lv_path, $lv;
				push @lv_size, $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size};
			}
			
			# Get the network arrays built.
			foreach my $current_bridge (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{details}{bridge}})
			{
				push @bridge, $current_bridge;
				push @device, $conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device};
				push @mac,    uc($conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac});
				push @type,   $conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type};
			}
			
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
			if ($conf->{vm}{$vm}{host} ne "none")
			{
				$say_host  =  $conf->{vm}{$vm}{host};
				$say_host  =~ s/\..*//;
				$say_net_host = "<span class=\"highlight_detail\">$say_host</span> -> <span class=\"highlight_detail\">$bridge[0]</span> -> <span class=\"highlight_detail\">$device[0]</span> -> ";
			}
		}
		
		# If there is no host, only the device type and MAC address are valid.
		$conf->{vm}{$vm}{details}{cpu_count} = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$lv_path[0]                          = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$lv_size[0]                          = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$type[0]                             = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$mac[0]                              = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$say_vm</span>
		</td>
		<td>
			$conf->{vm}{$vm}{details}{cpu_count}
		</td>
		<td>
			$say_ram
		</td>
		<td>
			<span class=\"fixed_width\">$lv_path[0]</span>
		</td>
		<td>
			$lv_size[0]
		</td>
		<td>
			$say_net_host <span class=\"highlight_detail\">$type[0]</span> / <span class=\"highlight_detail\">$mac[0]</span>
		</td>
	</tr>
";
		my $lv_count   = @lv_path;
		my $nic_count  = @bridge;
		my $loop_count = $lv_count >= $nic_count ? $lv_count : $nic_count;
		if ($loop_count > 0)
		{
			for (my $i=1; $loop_count > $i; $i++)
			{
				record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], lv_path[$i]: [$lv_path[$i]], lv_size[$i]: [$lv_size[$i]]n");
				my $say_lv_path = $lv_path[$i] ? $lv_path[$i] : "&nbsp;";
				my $say_lv_size = $lv_size[$i] ? $lv_size[$i] : "&nbsp;";
				my $say_network = "&nbsp;";
				if ($bridge[$i])
				{
					my $say_net_host = "";
					record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
					if ($conf->{vm}{$vm}{host} ne "none")
					{
						my $say_host  =  $conf->{vm}{$vm}{host};
						$say_host  =~ s/\..*//;
						$say_net_host = "<span class=\"highlight_detail\">$say_host</span> -> <span class=\"highlight_detail\">$bridge[$i]</span> -> <span class=\"highlight_detail\">$device[$i]</span> -> ";
					}
					$say_network = "$say_net_host <span class=\"highlight_detail\">$type[$i]</span> / <span class=\"highlight_detail\">$mac[$i]</span>";
				}
				
				print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_lv_path
		</td>
		<td>
			$say_lv_size
		</td>
		<td>
			$say_network
		</td>
	</tr>
";
			}
		}
	}
	
	print "
</table>
<br />
";
	return (0);
}

# This checks the daemons running on a node and returns '1' if all are running.
sub check_node_daemons
{
	my ($conf, $node) = @_;
	if (not $node)
	{
		error($conf, "I was asked to check the daemons for a node, but was not passed a node name. This is likely a program error.\n");
	}
	#record($conf, "$THIS_FILE ".__LINE__."; in check_node_daemons(), node: [$node]\n");
	my $ready = 1;
	
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], cman exit_code:      [$conf->{node}{$node}{daemon}{cman}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rgmanager exit_code: [$conf->{node}{$node}{daemon}{rgmanager}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], drbd exit_code:      [$conf->{node}{$node}{daemon}{drbd}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], clvmd exit_code:     [$conf->{node}{$node}{daemon}{clvmd}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], gfs2 exit_code:      [$conf->{node}{$node}{daemon}{gfs2}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], libvirtd exit_code:  [$conf->{node}{$node}{daemon}{libvirtd}{exit_code}]\n");
	
	if (($conf->{node}{$node}{daemon}{cman}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{rgmanager}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{drbd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{gfs2}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{libvirtd}{exit_code} ne "0"))
	{
		$ready = 0;
	}
	
	return($ready);
}

# This checks a node to see if it's ready to run a given VM.
sub check_node_readiness
{
	my ($conf, $vm, $node) = @_;
	if (not $node)
	{
		error($conf, "I was asked to check the node readiness to run the $vm VM, but was not passed a node name. This is likely a program error.\n");
	}

	#record($conf, "$THIS_FILE ".__LINE__."; in check_node_readiness(); vm: [$vm], node: [$node]\n");
	
	# This will get negated if something isn't ready.
	my $ready = check_node_daemons($conf, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; 1. vm: [$vm], node: [$node], ready: [$ready]\n");
	
	# TODO: Add split-brain detection. If both nodes are 
	# Primary/StandAlone, shut the whole cluster down.
	
	# Make sure the storage is ready.
	if ($ready)
	{
		# Still alive, find out what storage backs this VM and ensure
		# that the LV is 'active' and that the DRBD resource(s) they
		# sit on are Primary and UpToDate.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm]\n");
		read_vm_definition($conf, $node, $vm);
		
		foreach my $lv (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
		{
			# Make sure the LV is active.
			#record($conf, "$THIS_FILE ".__LINE__.";  - vm: [$vm], node: [$node], lv: [$lv]\n");
			#record($conf, "$THIS_FILE ".__LINE__.";    - active:           [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active}]\n");
			if ($conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active})
			{
				# It's active, so now check the backing storage.
				foreach my $res (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}})
				{
					# For easier reading...
					my $cs = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{connection_state};
					my $ro = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{role};
					my $ds = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{disk_state};
					#record($conf, "$THIS_FILE ".__LINE__.";    - res:              [$res]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - connection state: [$cs]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - role:             [$ro]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - disk state:       [$ds]\n");
					
					# I consider a node "ready" if it is UpToDate and Primary.
					if (($ro ne "Primary") || ($ds ne "UpToDate"))
					{
						$ready = 0;
						#record($conf, "$THIS_FILE ".__LINE__."; 2. ready: [$ready]\n");
					}
				}
			}
			else
			{
				# The LV is inactive.
				# TODO: Try to change the LV to active.
				$ready = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; 3. vm: [$vm], node: [$node], ready: [$ready]\n");
			}
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; 4. vm: [$vm], node: [$node], ready: [$ready]\n");
	
	return ($ready);
}

# This reads a VM's definition file and pulls out information about the system.
sub read_vm_definition
{
	my ($conf, $node, $vm) = @_;
	if (not $vm)
	{
		error($conf, "I was asked to look at a VM's definition file, but no VM was specified.", 1);
	}
	my $say_vm = $vm;
	if ($vm =~ /vm:(.*)/)
	{
		$say_vm = $1;
	}
	else
	{
		$vm = "vm:$vm";
	}
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_vm: [$say_vm]\n");
	$conf->{vm}{$vm}{definition_file} = "" if not defined $conf->{vm}{$vm}{definition_file};
	$conf->{vm}{$vm}{xml}             = "" if not defined $conf->{vm}{$vm}{xml};
	#record($conf, "$THIS_FILE ".__LINE__."; in read_vm_definition(); node: [$node], vm: [$vm], say_vm: [$say_vm], definition_file: [$conf->{vm}{$vm}{definition_file}], XML array? [".ref($conf->{vm}{$vm}{xml})."]\n");

	# Here I want to parse the VM definition XML. Hopefully it was already
	# read in, but if not, I'll make a specific SSH call to get it.
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], XML: [$conf->{vm}{$vm}{xml}], def: [$conf->{vm}{$vm}{definition_file}]\n");
	if ((not ref($conf->{vm}{$vm}{xml}) eq "ARRAY") && ($conf->{vm}{$vm}{definition_file}))
	{
		$conf->{vm}{$vm}{raw_xml} = [];
		$conf->{vm}{$vm}{xml}     = [];
		my ($error, $ssh_fh, $output) = remote_call($conf, {
			node		=>	$node,
			port		=>	$conf->{node}{$node}{port},
			user		=>	"root",
			password	=>	$conf->{'system'}{root_password},
			ssh_fh		=>	"",
			'close'		=>	1,
			shell_call	=>	"cat $conf->{vm}{$vm}{definition_file}",
		});
		record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
		foreach my $line (@{$output})
		{
			push @{$conf->{vm}{$vm}{raw_xml}}, $line;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			push @{$conf->{vm}{$vm}{xml}}, $line;
		}
	}
	
	my $in_disk      = 0;
	my $in_interface = 0;
	my $current_bridge;
	my $current_device;
	my $current_mac_address;
	my $current_interface_type;
	if (not $conf->{vm}{$vm}{xml})
	{
		record($conf, "$THIS_FILE ".__LINE__."; I was asked to look at: [$vm]'s definition file, it was not read or was not found.");
		return (0);
	}
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		#$line = lc($line); # everything should be lower case already.
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], line: [$line]\n");
		
		# Pull out RAM amount.
		if ($line =~ /<memory>(\d+)<\/memory>/)
		{
			# Record the memory, multiple by 1024 to get bytes.
			$conf->{vm}{$vm}{details}{ram} =  $1;
			$conf->{vm}{$vm}{details}{ram} *= 1024;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		}
		if ($line =~ /<memory unit='(.*?)'>(\d+)<\/memory>/)
		{
			# Record the memory, multiple by 1024 to get bytes.
			my $units                      =  $1;
			my $ram                        =  $2;
			$conf->{vm}{$vm}{details}{ram} = hr_to_bytes($conf, $ram, $units, 1);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		}
		
		# TODO: Support pinned cores.
		# Pull out the CPU details
		if ($line =~ /<vcpu>(\d+)<\/vcpu>/)
		{
			$conf->{vm}{$vm}{details}{cpu_count} = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], cpu count: [$conf->{vm}{$vm}{details}{cpu_count}]\n");
		}
		if ($line =~ /<vcpu placement='(.*?)'>(\d+)<\/vcpu>/)
		{
			my $cpu_type                         = $1;
			$conf->{vm}{$vm}{details}{cpu_count} = $2;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], cpu count: [$conf->{vm}{$vm}{details}{cpu_count}], type: [$cpu_type]\n");
		}
		
		# Pull out network details.
		if (($line =~ /<interface/) && ($line =~ /type='bridge'/))
		{
			$in_interface = 1;
			next;
		}
		elsif ($line =~ /<\/interface/)
		{
			# Record the values I found
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device} = $current_device         ? $current_device         : "unknown";
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac}    = $current_mac_address    ? $current_mac_address    : "unknown";
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type}   = $current_interface_type ? $current_interface_type : "unknown";
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], bride: [$current_bridge], device: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device}], mac: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac}], type: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type}]\n");
			$current_bridge         = "";
			$current_device         = "";
			$current_mac_address    = "";
			$current_interface_type = "";
			$in_interface           = 0;
			next;
		}
		if ($in_interface)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], interface line: [$line]\n");
			if ($line =~ /source bridge='(.*?)'/)
			{
				$current_bridge = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], bridge: [$current_bridge]\n");
			}
			if ($line =~ /mac address='(.*?)'/)
			{
				$current_mac_address = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], mac: [$current_mac_address]\n");
			}
			if ($line =~ /target dev='(.*?)'/)
			{
				$current_device = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], device: [$current_device]\n");
			}
			if ($line =~ /model type='(.*?)'/)
			{
				$current_interface_type = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], type: [$current_interface_type]\n");
			}
		}
		
		# Pull out disk info.
		if (($line =~ /<disk/) && ($line =~ /type='block'/) && ($line =~ /device='disk'/))
		{
			$in_disk = 1;
			next;
		}
		elsif ($line =~ /<\/disk/)
		{
			$in_disk = 0;
			next;
		}
		if ($in_disk)
		{
			if ($line =~ /source dev='(.*?)'/)
			{
				my $lv = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], checking LV: [$lv]\n");
				check_lv($conf, $node, $vm, $lv);
			}
		}
		
		# Record what graphics we're using for remote connection.
		if ($line =~ /^<graphics /)
		{
			my ($port)   = ($line =~ / port='(\d+)'/);
			my ($type)   = ($line =~ / type='(.*?)'/);
			my ($listen) = ($line =~ / listen='(.*?)'/);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm] is using: [$type] and listening on: [$listen] port: [$port].\n");
			$conf->{vm}{$vm}{graphics}{type}     = $type;
			$conf->{vm}{$vm}{graphics}{port}     = $port;
			$conf->{vm}{$vm}{graphics}{'listen'} = $listen;
		}
	}
	
	return (0);
}

# This takes a node name and an LV and checks the DRBD resources to see if they
# are Primary and UpToDate.
sub check_lv
{
	my ($conf, $node, $vm, $lv) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VM: [$vm], LV: [$lv]\n");
	
	# If this node is down, just return.
	if ($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0")
	{
		#record($conf, "$THIS_FILE ".__LINE__."; The node: [$node] is down, skipping LV check for: [$lv] for VM: [$vm]\n");
		return(0);
	}
	
	$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active} = $conf->{node}{$node}{lvm}{lv}{$lv}{active};
	$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}   = bytes_to_hr($conf, $conf->{node}{$node}{lvm}{lv}{$lv}{total_size});
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VM: [$vm], LV: [$lv], active: [$conf->{node}{$node}{lvm}{lv}{$lv}{active}], size: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$lv}{on_devices}]\n");
	
	# If there is a comman in the devices, the LV spans multiple devices.
	foreach my $device (split/,/, $conf->{node}{$node}{lvm}{lv}{$lv}{on_devices})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; device: [$device]\n");
		# Find the resource name.
		my $on_res;
		foreach my $res (sort {$a cmp $b} keys %{$conf->{drbd}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; res: [$res]\n");
			my $res_device = $conf->{drbd}{$res}{node}{$node}{device};
			#record($conf, "$THIS_FILE ".__LINE__."; res: [$res], device: [$device], res. device: [$res_device]\n");
			if ($device eq $res_device)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; match! Recording res as: [$res]\n");
				$on_res = $res;
				last;
			}
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], on_res: [$on_res]\n");
		
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{connection_state} = $conf->{drbd}{$on_res}{node}{$node}{connection_state};
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{role}             = $conf->{drbd}{$on_res}{node}{$node}{role};
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{disk_state}       = $conf->{drbd}{$on_res}{node}{$node}{disk_state};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], cs: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{connection_state}]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], ro: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{role}]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], ds: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{disk_state}]\n");
	}
	
	return (0);
}

# Check the status of VMs.
sub check_vms
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	
	#record($conf, "$THIS_FILE ".__LINE__."; node 1: n[$node1] s[$conf->{node}{$node1}{info}{short_host_name}] l[$conf->{node}{$node1}{info}{host_name}], node 2: n[$node2] s[$conf->{node}{$node2}{info}{short_host_name}] l[$conf->{node}{$node2}{info}{host_name}]\n");
	my $short_node1 = "$conf->{node}{$node1}{info}{short_host_name}";
	my $short_node2 = "$conf->{node}{$node2}{info}{short_host_name}";
	my $long_node1  = "$conf->{node}{$node1}{info}{host_name}";
	my $long_node2  = "$conf->{node}{$node2}{info}{host_name}";
	my $say_node1   = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2   = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		my $say_vm;
		if ($vm =~ /^vm:(.*)/)
		{
			$say_vm = $1;
		}
		else
		{
			error($conf, "I was asked to check on a VM that didn't have the <span class=\"code\">vm:</span> prefix. I got the name: <span class=\"code\">$vm</span>. This is likely a programming error.\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_vm: [$say_vm]\n");
		
		# This will control the buttons.
		$conf->{vm}{$vm}{can_start}        = 0;
		$conf->{vm}{$vm}{can_stop}         = 0;
		$conf->{vm}{$vm}{can_migrate}      = 0;
		$conf->{vm}{$vm}{current_host}     = 0;
		$conf->{vm}{$vm}{migration_target} = "";
		
		# Find out who, if anyone, is running this VM and who *can* run
		# it. 2 == Running, 1 == Can run, 0 == Can't run.
		$conf->{vm}{$vm}{say_node1}        = $conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0" ? "<span class=\"highlight_warning\">Not Ready</span>" : "<span class=\"code\">--</span>";
		$conf->{vm}{$vm}{node1_ready}      = 0;
		#record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::say_node1: [$conf->{vm}{$vm}{say_node1}], node::${node1}::daemon::cman::exit_code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}]\n");
		$conf->{vm}{$vm}{say_node2}        = $conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0" ? "<span class=\"highlight_warning\">Not Ready</span>" : "<span class=\"code\">--</span>";
		$conf->{vm}{$vm}{node2_ready}      = 0;
		#record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::say_node2: [$conf->{vm}{$vm}{say_node2}], node::${node2}::daemon::cman::exit_code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
		
		# If a VM's XML definition file is found but there is no host,
		# the user probably forgot to define it.
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
		if ((not $conf->{vm}{$vm}{host}) && (not $conf->{'system'}{ignore_missing_vm}))
		{
			# Pull the host node and current state out of the hash.
			my $host_node = "";
			my $vm_state  = "";
			foreach my $node (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}})
			{
				$host_node = $node;
				foreach my $key (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{virsh}})
				{
					if ($key eq "state") 
					{
						$vm_state = $conf->{vm}{$vm}{node}{$host_node}{virsh}{'state'};
					}
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], virsh '$key': [$conf->{vm}{$vm}{node}{$node}{virsh}{$key}]\n");
				}
			}
			$conf->{vm}{$vm}{say_node1} = "--";
			$conf->{vm}{$vm}{say_node2} = "--";
			error($conf, "I found a server with the name: [<span class=\"highlight_detail\">$say_vm</span>] which is not managed by the Anvil! yet.<br /><b>If this is a new server that is still being installed, please ignore this message.</b><br />If you do not have the original dashboard install window open anymore, you can <a href=\"?cluster=$conf->{cgi}{cluster}&task=add_vm&name=$say_vm&node=$host_node&state=$vm_state\"><b>click here to add it</b></a> to this Anvil! now.", 0);
			next;
		}
		
		$conf->{vm}{$vm}{host} = "" if not defined $conf->{vm}{$vm}{host};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], current host: [$conf->{vm}{$vm}{host}], node1 / node2 short names: [$short_node1] / [$short_node2]\n");
		if ($conf->{vm}{$vm}{host} =~ /$short_node1/)
		{
			# Even though I know the host is ready, this function
			# loads some data, like LV details, which I will need
			# later.
			check_node_readiness($conf, $vm, $node1);
			$conf->{vm}{$vm}{can_start}     = 0;
			$conf->{vm}{$vm}{can_stop}      = 1;
			$conf->{vm}{$vm}{current_host}  = $node1;
			$conf->{vm}{$vm}{node1_ready}   = 2;
			($conf->{vm}{$vm}{node2_ready}) = check_node_readiness($conf, $vm, $node2);
			if ($conf->{vm}{$vm}{node2_ready})
			{
				$conf->{vm}{$vm}{migration_target} = $long_node2;
				$conf->{vm}{$vm}{can_migrate}      = 1;
			}
			# Disable cluster withdrawl of this node.
			$conf->{node}{$node1}{enable_withdraw} = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1: [$node1], node2 ready: [$conf->{vm}{$vm}{node2_ready}], can migrate: [$conf->{vm}{$vm}{can_migrate}], migration target: [$conf->{vm}{$vm}{migration_target}]\n");
		}
		elsif ($conf->{vm}{$vm}{host} =~ /$short_node2/)
		{
			# Even though I know the host is ready, this function
			# loads some data, like LV details, which I will need
			# later.
			check_node_readiness($conf, $vm, $node2);
			$conf->{vm}{$vm}{can_start}     = 0;
			$conf->{vm}{$vm}{can_stop}      = 1;
			$conf->{vm}{$vm}{current_host}  = $node2;
			($conf->{vm}{$vm}{node1_ready}) = check_node_readiness($conf, $vm, $node1);
			$conf->{vm}{$vm}{node2_ready}   = 2;
			if ($conf->{vm}{$vm}{node1_ready})
			{
				$conf->{vm}{$vm}{migration_target} = $long_node1;
				$conf->{vm}{$vm}{can_migrate}      = 1;
			}
			# Disable withdrawl of this node.
			$conf->{node}{$node2}{enable_withdraw} = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1: [$node1], node2 ready: [$conf->{vm}{$vm}{node2_ready}], can migrate: [$conf->{vm}{$vm}{can_migrate}], migration target: [$conf->{vm}{$vm}{migration_target}]\n");
		}
		else
		{
			$conf->{vm}{$vm}{can_stop}      = 0;
			($conf->{vm}{$vm}{node1_ready}) = check_node_readiness($conf, $vm, $node1);
			($conf->{vm}{$vm}{node2_ready}) = check_node_readiness($conf, $vm, $node2);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1_ready: [$conf->{vm}{$vm}{node1_ready}], node2_ready: [$conf->{vm}{$vm}{node2_ready}]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], current host: [$conf->{vm}{$vm}{current_host}]\n");
		$conf->{vm}{$vm}{boot_target} = "";
		if ($conf->{vm}{$vm}{current_host})
		{
			# This is a bit expensive, but read the VM's running
			# definition.
			my $node   = $conf->{vm}{$vm}{current_host};
			my $say_vm = $vm;
			$say_vm =~ s/^vm://;
			#record($conf, "$THIS_FILE ".__LINE__."; Reading the XML for the VM: [$vm] which is currently running on: [$conf->{vm}{$vm}{current_host}]\n");
			my ($error, $ssh_fh, $output) = remote_call($conf, {
				node		=>	$node,
				port		=>	$conf->{node}{$node}{port},
				user		=>	"root",
				password	=>	$conf->{'system'}{root_password},
				ssh_fh		=>	"",
				'close'		=>	1,
				shell_call	=>	"virsh dumpxml $say_vm",
			});
			#record($conf, "$THIS_FILE ".__LINE__."; error: [$error], ssh_fh: [$ssh_fh], output: [$output (".@{$output}." lines)]\n");
			foreach my $line (@{$output})
			{
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				push @{$conf->{vm}{$vm}{xml}}, $line;
			}
		}
		else
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1_ready: [$conf->{vm}{$vm}{node1_ready}], node2_ready: [$conf->{vm}{$vm}{node2_ready}]\n");
			if (($conf->{vm}{$vm}{node1_ready}) && ($conf->{vm}{$vm}{node2_ready}))
			{
				# I can boot on either node, so choose the 
				# first one in the VM's failover domain.
				$conf->{vm}{$vm}{boot_target} = find_prefered_host($conf, $vm);
				$conf->{vm}{$vm}{can_start}   = 1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}], vm::${vm}::can_start: [$conf->{vm}{$vm}{can_start}]\n");
			}
			elsif ($conf->{vm}{$vm}{node1_ready})
			{
				$conf->{vm}{$vm}{boot_target} = $node1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}]\n");
			}
			elsif ($conf->{vm}{$vm}{node2_ready})
			{
				$conf->{vm}{$vm}{boot_target} = $node2;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}]\n");
			}
			else
			{
				$conf->{vm}{$vm}{can_start} = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], can_start: [$conf->{vm}{$vm}{can_start}]\n");
			}
		}
	}
	
	return (0);
}

### NOTE: Yes, I know 'prefered' is spelled wrong...
# This looks through the failover domain for a VM and returns the prefered host.
sub find_prefered_host
{
	my ($conf, $vm) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in find_prefered_host(), vm: [$vm]\n");
	my $prefered_host = "";
	
	my $failover_domain = $conf->{vm}{$vm}{failover_domain};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], failover_domain: [$failover_domain]\n");
	if (not $failover_domain)
	{
		# Not yet defined in the cluster.
		return("--");
	}
	
	# TODO: Check to see if I need to use <=> instead of cmp.
	foreach my $priority (sort {$a cmp $b} keys %{$conf->{failoverdomain}{$failover_domain}{priority}})
	{
		# I only care about the first entry, so I will
		# exit the loop as soon as I analyze it.
		$prefered_host = $conf->{failoverdomain}{$failover_domain}{priority}{$priority}{node};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], prefered host: [$prefered_host]\n");
		last;
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], prefered host: [$prefered_host]\n");
	return ($prefered_host);
}

# This function simply sets a couple variables using the node names as set in
# the $conf hash declaration
sub set_node_names
{
	my ($conf) = @_;
	
	# First pull the names into easier to follow variables.
	my $this_cluster = $conf->{cgi}{cluster};
	$conf->{'system'}{cluster}{node1_name} = $conf->{clusters}{$this_cluster}{nodes}[0];
	$conf->{'system'}{cluster}{node2_name} = $conf->{clusters}{$this_cluster}{nodes}[1];
	#record($conf, "$THIS_FILE ".__LINE__."; this_cluster: [$this_cluster], node1: [$conf->{'system'}{cluster}{node1_name}], node2: [$conf->{'system'}{cluster}{node2_name}]\n");
	
	return (0);
}

# This shows the current state of the VMs as well as the available control
# buttons.
sub display_vm_state_and_controls
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	#record($conf, "$THIS_FILE ".__LINE__."; node1: [$node1], node1_long: [$node1_long]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; node2: [$node2], node2_long: [$node2_long]\n");
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"10\">
			<b>Virtual Machines - Status and Control</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>
		</td>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>
		</td>
		<td>
			Preferred Host
		</td>
		<td colspan=\"6\">
			<i>Controls</i>
		</td>
	</tr>
";

	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		# Break the name out of the hash key.
		my ($say_vm) = ($vm =~ /^vm:(.*)/);
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say vm: [$say_vm]\n");
		
		# Use the node's short name for the buttons.
		my $say_start_target     =  $conf->{vm}{$vm}{boot_target} ? $conf->{vm}{$vm}{boot_target} : "--";
		$say_start_target        =~ s/\..*?$//;
		my $start_target_long    = $node1_long =~ /$say_start_target/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		my $start_target_name    = $node1      =~ /$say_start_target/ ? $node1 : $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; say_start_target: [$say_start_target], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}], start_target_long: [$start_target_long]\n");
		
		my $prefered_host        =  find_prefered_host($conf, $vm);
		$prefered_host           =~ s/\..*$//;
		if ($conf->{vm}{$vm}{boot_target})
		{
			$prefered_host = "<span class=\"highlight_ready\">$prefered_host</span>";
		}
		else
		{
			my $on_host =  $conf->{vm}{$vm}{host};
			   $on_host =~ s/\..*$//;
			#record($conf, "$THIS_FILE ".__LINE__."; on_host: [$on_host], prefered_host: [$prefered_host]\n");
			if (($on_host eq $prefered_host) || ($on_host eq "none"))
			{
				$prefered_host = "<span class=\"highlight_good\">$prefered_host</span>";
			}
			else
			{
				$prefered_host = "<span class=\"highlight_warning\">$prefered_host</span>";
			}
			#record($conf, "$THIS_FILE ".__LINE__."; prefered_host: [$prefered_host]\n");
		}
		
		my $say_migration_target =  $conf->{vm}{$vm}{migration_target};
		$say_migration_target    =~ s/\..*?$//;
		my $migrate_button = "<span class=\"disabled_button\">Migrate</span>";
		if ($conf->{vm}{$vm}{can_migrate})
		{
			$migrate_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=migrate_vm&target=$conf->{vm}{$vm}{migration_target}&vm_ram=$conf->{vm}{$vm}{details}{ram}\">Migrate to <span class=\"fixed_width_button\">$say_migration_target</span></a>";
		}
		my $host_node        = "$conf->{vm}{$vm}{host}";
		my $stop_button      = "<span class=\"disabled_button\">Shut Down</span>";
		my $force_off_button = "<span class=\"disabled_button\">Force Off</span>";
		if ($conf->{vm}{$vm}{can_stop})
		{
			$host_node        = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host node: [$host_node], vm host: [$conf->{vm}{$vm}{host}]\n");
			$stop_button      = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=stop_vm&vm=$say_vm&node=$host_node\">Orderly Shut Down</a>";
			$force_off_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=force_off_vm&vm=$say_vm&node=$host_node&host=$conf->{vm}{$vm}{host}\" class=\"highlight_dangerous\">Force Off</a>";
		}
		my $start_button     = "<span class=\"disabled_button\">Boot Up</span>";
		if ($conf->{vm}{$vm}{boot_target})
		{
			$start_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=start_vm&vm=$say_vm&node=$start_target_name&node_cluster_name=$start_target_long\">Boot Up</a>";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; start_button:     [$start_button], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}]\n");
		
		# I need both nodes up to delete a VM.
		#my $say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		# I need both nodes up to delete a VM.
		my $say_delete_button = "<span class=\"disabled_button\">Delete</span>";
		#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::daemon::cman::exit_code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], node::${node2}::daemon::cman::exit_code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
		if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0"))
		{
			$say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		}
		
		#record($conf, "$THIS_FILE ".__LINE__." > say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		if ($conf->{vm}{$vm}{node1_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node1_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_ready\">Ready</span>";
		}
		if ($conf->{vm}{$vm}{node2_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node2_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_ready\">Ready</span>";
		}
		#record($conf, "$THIS_FILE ".__LINE__." < say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		
		# I don't want to make the VM editable until the cluster is
		# runnong on at least one node.
		my $dual_join   = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
		my $say_vm_link = "<span class=\"fixed_width\"><a href=\"?cluster=$conf->{cgi}{cluster}&vm=$vm&task=manage_vm\">$say_vm</a></span>";
		if ($dual_join)
		{
			$say_vm_link   = "<span class=\"highlight_unavailable\">$say_vm</span>";
		}
		
		print "
	<tr>
		<td>
			$say_vm_link
		</td>
		<td>
			$conf->{vm}{$vm}{say_node1}
		</td>
		<td>
			$conf->{vm}{$vm}{say_node2}
		</td>
		<td>
			<span class=\"fixed_width\">$prefered_host</span>
		</td>
		<td>
			$start_button
		</td>
		<td>
			$migrate_button
		</td>
		<td>
			$stop_button
		</td>
		<td>
			$force_off_button
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_delete_button
		</td>
	</tr>
";
	}
	
	# When enabling the "Start" button, be sure to start on the highest 
	# priority host in the failover domain, when possible.
	
	print "
</table>
<br />
";
	
	return (0);
}

# This shows the status of each DRBD resource in the cluster.
sub display_drbd_details
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $say_node1 = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2 = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"9\">
			<b>Replicated Storage</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\">
			<i>Device</i>
		</td>
		<td colspan=\"2\">
			<i>Connection</i>
		</td>
		<td colspan=\"2\">
			<i>Role</i>
		</td>
		<td colspan=\"2\">
			<i>Disk State</i>
		</td>
	</tr>
	<tr>
		<td>
			<i>Resource</i>
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
	</tr>
";

	foreach my $res (sort {$a cmp $b} keys %{$conf->{drbd}})
	{
		# If the DRBD daemon is stopped, I will use the values from the
		# resource files.
		my $say_n1_dev  = "--";
		my $say_n2_dev  = "--";
		my $say_n1_cs   = "--";
		my $say_n2_cs   = "--";
		my $say_n1_ro   = "--";
		my $say_n2_ro   = "--";
		my $say_n1_ds   = "--";
		my $say_n2_ds   = "--";
		
		# Check if node 1 is online.
		if ($conf->{node}{$node1}{up})
		{
			# It is, but is DRBD running?
			if ($conf->{node}{$node1}{daemon}{drbd}{exit_code} eq "0")
			{
				# It is. 
				$say_n1_dev = $conf->{drbd}{$res}{node}{$node1}{device};
				$say_n1_cs  = $conf->{drbd}{$res}{node}{$node1}{connection_state};
				$say_n1_ro  = $conf->{drbd}{$res}{node}{$node1}{role};
				$say_n1_ds  = $conf->{drbd}{$res}{node}{$node1}{disk_state};
				if (($conf->{drbd}{$res}{node}{$node1}{disk_state} eq "Inconsistent") && ($conf->{drbd}{$res}{node}{$node1}{resync_percent} =~ /^\d/))
				{
					$say_n1_ds .= " <span class=\"subtle_text\" style=\"font-style: normal;\">($conf->{drbd}{$res}{node}{$node1}{resync_percent}%)</span>";
				}
			}
			else
			{
				# It is not, use the {res_file} values.
				$say_n1_dev = $conf->{drbd}{$res}{node}{$node1}{res_file}{device};
				$say_n1_cs  = $conf->{drbd}{$res}{node}{$node1}{res_file}{connection_state};
				$say_n1_ro  = $conf->{drbd}{$res}{node}{$node1}{res_file}{role};
				$say_n1_ds  = $conf->{drbd}{$res}{node}{$node1}{res_file}{disk_state};
			}
		}
		# Check if node 2 is online.
		if ($conf->{node}{$node2}{up})
		{
			# It is, but is DRBD running?
			if ($conf->{node}{$node2}{daemon}{drbd}{exit_code} eq "0")
			{
				# It is. 
				$say_n2_dev = $conf->{drbd}{$res}{node}{$node2}{device};
				$say_n2_cs  = $conf->{drbd}{$res}{node}{$node2}{connection_state};
				$say_n2_ro  = $conf->{drbd}{$res}{node}{$node2}{role};
				$say_n2_ds  = $conf->{drbd}{$res}{node}{$node2}{disk_state};
				if (($conf->{drbd}{$res}{node}{$node2}{disk_state} eq "Inconsistent") && ($conf->{drbd}{$res}{node}{$node2}{resync_percent} =~ /^\d/))
				{
					$say_n2_ds .= " <span class=\"subtle_text\" style=\"font-style: normal;\">($conf->{drbd}{$res}{node}{$node2}{resync_percent}%)</span>";
				}
			}
			else
			{
				# It is not, use the {res_file} values.
				$say_n2_dev = $conf->{drbd}{$res}{node}{$node2}{res_file}{device};
				$say_n2_cs  = $conf->{drbd}{$res}{node}{$node2}{res_file}{connection_state};
				$say_n2_ro  = $conf->{drbd}{$res}{node}{$node2}{res_file}{role};
				$say_n2_ds  = $conf->{drbd}{$res}{node}{$node2}{res_file}{disk_state};
			}
		}
		
		my $class_n1_cs  = "highlight_unavailable";
		   $class_n1_cs  = "highlight_good"    if $say_n1_cs eq "Connected";
		   $class_n1_cs  = "highlight_good"    if $say_n1_cs eq "SyncSource";
		   $class_n1_cs  = "highlight_ready"   if $say_n1_cs eq "WFConnection";
		   $class_n1_cs  = "highlight_ready"   if $say_n1_cs eq "PausedSyncS";
		   $class_n1_cs  = "highlight_warning" if $say_n1_cs eq "PausedSyncT";
		   $class_n1_cs  = "highlight_warning" if $say_n1_cs eq "SyncTarget";
		my $class_n2_cs  = "highlight_unavailable";
		   $class_n2_cs  = "highlight_good"    if $say_n2_cs eq "Connected";
		   $class_n2_cs  = "highlight_good"    if $say_n2_cs eq "SyncSource";
		   $class_n2_cs  = "highlight_ready"   if $say_n2_cs eq "WFConnection";
		   $class_n2_cs  = "highlight_ready"   if $say_n2_cs eq "PausedSyncS";
		   $class_n2_cs  = "highlight_warning" if $say_n2_cs eq "PausedSyncT";
		   $class_n2_cs  = "highlight_warning" if $say_n2_cs eq "SyncTarget";
		my $class_n1_ro  = "highlight_unavailable";
		   $class_n1_ro  = "highlight_good"    if $say_n1_ro eq "Primary";
		   $class_n1_ro  = "highlight_warning" if $say_n1_ro eq "Secondary";
		my $class_n2_ro  = "highlight_unavailable";
		   $class_n2_ro  = "highlight_good"    if $say_n2_ro eq "Primary";
		   $class_n2_ro  = "highlight_warning" if $say_n2_ro eq "Secondary";
		my $class_n1_ds  = "highlight_unavailable";
		   $class_n1_ds  = "highlight_good"    if $say_n1_ds eq "UpToDate";
		   $class_n1_ds  = "highlight_warning" if $say_n1_ds =~ /Inconsistent/;
		   $class_n1_ds  = "highlight_warning" if $say_n1_ds eq "Outdated";
		   $class_n1_ds  = "highlight_bad"     if $say_n1_ds eq "Diskless";
		my $class_n2_ds  = "highlight_unavailable";
		   $class_n2_ds  = "highlight_good"    if $say_n2_ds eq "UpToDate";
		   $class_n2_ds  = "highlight_warning" if $say_n2_ds =~ /Inconsistent/;
		   $class_n2_ds  = "highlight_warning" if $say_n2_ds eq "Outdated";
		   $class_n2_ds  = "highlight_bad"     if $say_n2_ds eq "Diskless";
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$res</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_n1_dev</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_n2_dev</span>
		</td>
		<td>
			<span class=\"$class_n1_cs\">$say_n1_cs</span>
		</td>
		<td>
			<span class=\"$class_n2_cs\">$say_n2_cs</span>
		</td>
		<td>
			<span class=\"$class_n1_ro\">$say_n1_ro</span>
		</td>
		<td>
			<span class=\"$class_n2_ro\">$say_n2_ro</span>
		</td>
		<td>
			<span class=\"$class_n1_ds\">$say_n1_ds</span>
		</td>
		<td>
			<span class=\"$class_n2_ds\">$say_n2_ds</span>
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";
	
	return (0);
}

# This shows the details on each node's GFS2 mount(s)
sub display_gfs2_details
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $say_node1 = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2 = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"6\">
			<b>Shared File Systems</b>
		</td>
	</tr>
	<tr>
		<td>
			<i>Mount Point</i>
		</td>
		<td>
			<i>$say_node1</i>
		</td>
		<td>
			<i>$say_node2</i>
		</td>
		<td>
			<i>Size</i>
		</td>
		<td>
			<i>Used</i>
		</td>
		<td>
			<i>Free</i>
		</td>
	</tr>
";
	my $gfs2_hash;
	my $node;
	#record($conf, "$THIS_FILE ".__LINE__."; node1 - cman exit code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], gfs2 exit code: [$conf->{node}{$node1}{daemon}{gfs2}{exit_code}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; node2 - cman exit code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}], gfs2 exit code: [$conf->{node}{$node2}{daemon}{gfs2}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node1}{daemon}{gfs2}{exit_code} eq "0") && (ref($conf->{node}{$node1}{gfs}) eq "HASH"))
	{
		$gfs2_hash = $conf->{node}{$node1}{gfs};
		$node      = $node1;
		#record($conf, "$THIS_FILE ".__LINE__."; using node1's gfs2 hash: [$gfs2_hash]\n");
	}
	elsif (($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node2}{daemon}{gfs2}{exit_code} eq "0") && (ref($conf->{node}{$node2}{gfs}) eq "HASH"))
	{
		$gfs2_hash = $conf->{node}{$node2}{gfs};
		$node      = $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; using node2's gfs2 hash: [$gfs2_hash]\n");
	}
	else
	{
		# Neither node has the GFS2 partition mounted. Use the data
		# from /etc/fstab. This is what will be stored in either node's
		# hash. So pick a node that's online and use it.
		#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
		if ($conf->{'system'}{up_nodes} == 1)
		{
			$node      = @{$conf->{up_nodes}}[0];
			record($conf, "$THIS_FILE ".__LINE__."; Neither node has the GFS2 partition mounted.\n");
			$gfs2_hash = $conf->{node}{$node}{gfs};
		}
		else
		{
			# Neither node is online at all.
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span> / <span class=\"highlight_unavailable\">--%</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
	</tr>
";
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; gfs2_hash: [$gfs2_hash], node1 hash: [".(ref($conf->{node}{$node1}{gfs}))."], node2 hash: [".(ref($conf->{node}{$node2}{gfs}))."]\n");
	if (ref($gfs2_hash) eq "HASH")
	{
		foreach my $mount_point (sort {$a cmp $b} keys %{$gfs2_hash})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::gfs::${mount_point}::mounted: [$conf->{node}{$node1}{gfs}{$mount_point}{mounted}], node::${node2}::gfs::${mount_point}::mounted: [$conf->{node}{$node2}{gfs}{$mount_point}{mounted}]\n");
			my $say_node1_mounted = $conf->{node}{$node1}{gfs}{$mount_point}{mounted} ? "<span class=\"highlight_good\">Mounted</span>" : "<span class=\"highlight_bad\">Unmounted</span>";
			my $say_node2_mounted = $conf->{node}{$node2}{gfs}{$mount_point}{mounted} ? "<span class=\"highlight_good\">Mounted</span>" : "<span class=\"highlight_bad\">Unmounted</span>";
			#record($conf, "$THIS_FILE ".__LINE__."; say_node1_mounted: [$say_node1_mounted], say_node2_mounted: [$say_node2_mounted]\n");
			my $say_size         = "--";
			my $say_used         = "--";
			my $say_used_percent = "--%";
			my $say_free         = "--";
			
			# This is to avoid the "undefined variable" errors in
			# the log from when a node isn't online.
			$conf->{node}{$node1}{gfs}{$mount_point}{total_size} = "" if not defined $conf->{node}{$node1}{gfs}{$mount_point}{total_size};
			$conf->{node}{$node2}{gfs}{$mount_point}{total_size} = "" if not defined $conf->{node}{$node2}{gfs}{$mount_point}{total_size};
			#record($conf, "$THIS_FILE ".__LINE__."; node1 total size: [$conf->{node}{$node1}{gfs}{$mount_point}{total_size}]\n");
			#record($conf, "$THIS_FILE ".__LINE__."; node2 total size: [$conf->{node}{$node2}{gfs}{$mount_point}{total_size}]\n");
			if ($conf->{node}{$node1}{gfs}{$mount_point}{total_size} =~ /^\d/)
			{
				$say_size         = $conf->{node}{$node1}{gfs}{$mount_point}{total_size};
				$say_used         = $conf->{node}{$node1}{gfs}{$mount_point}{used_space};
				$say_used_percent = $conf->{node}{$node1}{gfs}{$mount_point}{percent_used};
				$say_free         = $conf->{node}{$node1}{gfs}{$mount_point}{free_space};
			}
			elsif ($conf->{node}{$node2}{gfs}{$mount_point}{total_size} =~ /^\d/)
			{
				$say_size         = $conf->{node}{$node2}{gfs}{$mount_point}{total_size};
				$say_used         = $conf->{node}{$node2}{gfs}{$mount_point}{used_space};
				$say_used_percent = $conf->{node}{$node2}{gfs}{$mount_point}{percent_used};
				$say_free         = $conf->{node}{$node2}{gfs}{$mount_point}{free_space};
			}
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$mount_point</span>
		</td>
		<td>
			$say_node1_mounted
		</td>
		<td>
			$say_node2_mounted
		</td>
		<td>
			$say_size
		</td>
		<td>
			$say_used / $say_used_percent
		</td>
		<td>
			$say_free
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td colspan=\"6\">
			<i>No shared file systems were found.</i>
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";

	return (0);
}

# This shows the user the state of the nodes and their daemons.
sub display_node_details
{
	my ($conf) = @_;
	
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"7\">
			<b>Cluster Nodes - Status</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<i>cman</i>
		</td>
		<td>
			<i>rgmanager</i>
		</td>
		<td>
			<i>drbd</i>
		</td>
		<td>
			<i>clvmd</i>
		</td>
		<td>
			<i>gfs2</i>
		</td>
		<td>
			<i>libvirtd</i>
		</td>
	</tr>
";
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$this_cluster}{nodes}})
	{
		# Get the cluster's node name.
		my $say_short_name =  $node;
		$say_short_name    =~ s/\..*//;
		my $node_long_name =  $node1_long =~ /$say_short_name/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};

		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node}{info}{host_name}</span> &nbsp;
			<!-- <img src=\"/img/icon_led_left.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_middle.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_middle.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_right.png\" border=\"0\"> -->
		</td>
		<td>
			$conf->{node}{$node}{daemon}{cman}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{rgmanager}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{drbd}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{clvmd}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{gfs2}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{libvirtd}{status}
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";

	return (0);
}

# This shows the controls for the nodes.
sub display_node_controls
{
	my ($conf) = @_;
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"8\">
			<b>Cluster Nodes - Controls</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"3\">
			<i>Power</i>
		</td>
		<td colspan=\"3\">
			<i>Membership</i>
		</td>
		<td colspan=\"1\">
			<i>Special</i>
		</td>
	</tr>
";
	
	# I want to map storage service to nodes for the "Withdraw" buttons.
	my $disable_join = 0;
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	#record($conf, "$THIS_FILE ".__LINE__."; node1: [$node1], node2: [$node2]\n");
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	#record($conf, "$THIS_FILE ".__LINE__."; node1_long: [$node1_long], node2_long: [$node2_long]\n");
	my $rowspan    = 2;
	my $dual_boot  = (($conf->{node}{$node1}{enable_poweron}) && ($conf->{node}{$node2}{enable_poweron})) ? 1 : 0;
	my $dual_join  = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$this_cluster}{nodes}})
	{
		# Get the cluster's node name.
		my $say_short_name =  $node;
		$say_short_name    =~ s/\..*//;
		my $node_long_name =  $node1_long =~ /$say_short_name/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		$conf->{node}{$node}{enable_withdraw} = 0 if not defined $conf->{node}{$node}{enable_withdraw};
		
		my $say_join      = $conf->{node}{$node}{enable_join}     ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=join_cluster&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_ready_bold\">Join Cluster</span></a>" : "<span class=\"disabled_button\">Join Cluster</span>";
		   $say_join      = "<span class=\"disabled_button\">Join Cluster</span>" if $disable_join;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], enable_withdraw: [$conf->{node}{$node}{enable_withdraw}], node long name: [$node_long_name]\n");
		my $say_withdraw  = $conf->{node}{$node}{enable_withdraw} ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=withdraw&node=$node&node_cluster_name=$node_long_name\">Withdraw</a>"  : "<span class=\"disabled_button\">Withdraw</span>";
		#record($conf, "$THIS_FILE ".__LINE__."; node::${node}::enable_poweroff: [$conf->{node}{$node}{enable_poweroff}]\n");
		my $say_shutdown  = $conf->{node}{$node}{enable_poweroff} ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=poweroff_node&node=$node&node_cluster_name=$node_long_name\">Power Off</a>" : "<span class=\"disabled_button\">Shut Down</span>";
		my $say_boot      = $conf->{node}{$node}{enable_poweron}  ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=poweron_node&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_ready_bold\">Power On</span></a>"   : "<span class=\"disabled_button\">Power On</span>";
		
		# At all times, the option to fence the node is made available.
		my $say_fence     = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=fence_node&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_dangerous\">Fence Node</span></a>";
		my $say_dual_boot = "<span class=\"highlight_unavailable\">Power On Both</span>";
		my $say_dual_join = "<span class=\"highlight_unavailable\">Start Cluster</span>";
		if ($rowspan)
		{
			# First row.
			if ($dual_boot)
			{
				$say_dual_boot = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=dual_boot\"><span class=\"highlight_ready_bold\">Power On Both</span></a>";
			}
			if ($dual_join)
			{
				$say_dual_join = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=dual_join\"><span class=\"highlight_ready_bold\">Start Cluster</span></a>";
				# Disable the per-node "join" options".
				$say_join      = "<span class=\"disabled_button\">Join Cluster</span>";
				$disable_join  = 1;
			}
		}
		
		# Make the node names click-able to show the hardware states.
		my $say_node_name = "$conf->{node}{$node}{info}{host_name}";
		if ($conf->{node}{$node}{connected})
		{
			$say_node_name = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=display_health&node=$node&node_cluster_name=$node_long_name\" target=\"new\">$conf->{node}{$node}{info}{host_name}</a>";
		}

		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$say_node_name</span>
		</td>
";
		if ($rowspan)
		{
			print "
		<td rowspan=\"2\">
			$say_dual_boot
		</td>
";
		}
		print "
		<td>
			$say_boot
		</td>
		<td>
			$say_shutdown
		</td>
";
		if ($rowspan)
		{
			print "
		<td rowspan=\"2\">
			$say_dual_join
		</td>
";
		}
		print "
		<td>
			$say_join
		</td>
		<td>
			$say_withdraw
		</td>
		<td>
			$say_fence
		</td>
	</tr>
";
		$rowspan = 0;
	}
	
	print "
</table>
<br />
";

	return (0);
}

1;
