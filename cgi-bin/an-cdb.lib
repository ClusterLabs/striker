#!/usr/bin/perl
#
# AN!CDB - Alteeve's Niche! Anvil Dashboard
# 
# This software is released under the GNU GPL v2+ license.
# 
# No warranty is provided. Do not use this software unless you are willing and
# able to take full liability for it's use. The authors take care to prevent
# unexpected side effects when using this program. However, no software is
# perfect and bugs may exist which could lead to hangs or crashes in the
# program, in your Anvil and possibly even data loss.
# 
# If you are concerned about these risks, please stick to command line tools.
# 
# This program is designed to extend Anvils built according to this tutorial:
# - https://alteeve.com/w/2-Node_Red_Hat_KVM_Cluster_Tutorial
#
# This program's source code and updates are available on Github:
# - https://github.com/digimer/an-cdb
#
# Author;
# Alteeve's Niche!  -  https://alteeve.com
# Madison Kelly     -  mkelly@alteeve.ca
# 

use strict;
use warnings;
use CGI;
use Encode;
use IO::Handle;
use CGI::Carp "fatalsToBrowser";

# Setup for UTF-8 mode.
binmode STDOUT, ":utf8:";
$ENV{'PERL_UNICODE'}=1;
my $THIS_FILE = "an-cdb.lib";

# This tries to ping a node given it's name. If it doesn't answer, it tries 
# again after adding/subtracting the '.remote' suffix. If that works, it will
# change the node name.
sub ping_node
{
	my ($conf, $node) = @_;
	
	my $exit;
	my $fh = IO::Handle->new;
	my $sc = "$conf->{path}{ping} -c 1 $node; echo ping:\$?";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^ping:(\d+)/)
		{
			$exit = $1;
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; exit: [$exit]\n");
	
	if ($exit)
	{
		my $old_node = $node;
		if ($node =~ /\.remote/)
		{
			$node =~ s/\.remote//;
		}
		else
		{
			$node .= ".remote";
		}
		my $sc = "$conf->{path}{ping} -c 1 $node; echo ping:\$?";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /^ping:(\d+)/)
			{
				$exit = $1;
			}
		}
		$fh->close();
		record($conf, "$THIS_FILE ".__LINE__."; exit: [$exit]\n");
		
		if ($exit)
		{
			record($conf, "$THIS_FILE ".__LINE__."; Unable to ping the node: [$old_node] at alternate name: [$node]\n");
			$node = $old_node;
		}
		else
		{
			record($conf, "$THIS_FILE ".__LINE__."; The node: [$old_node] appears to be available at: [$node], renaming.\n");
		}
	}
	else
	{
		record($conf, "$THIS_FILE ".__LINE__."; The node: [$node] is ping-able.\n");
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; Returning node: [$node].\n");
	return ($node);
}

# This does the actual call out to get the data and parse the returned data.
sub gather_node_details
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in gather_node_details() for node: [$node]\n");
	
	# This will flip true if I see 'start dmidecode' (the first line to
	# return from the client).
	$conf->{node}{$node}{connected}      = 0;
	$conf->{node}{$node}{info}{'state'}  = "<span class=\"highlight_unavailable\">Unknown</span>";
	$conf->{node}{$node}{info}{note}     = "";
	$conf->{node}{$node}{up}             = 0;
	$conf->{node}{$node}{enable_poweron} = 0;
	
	# Check to see if I can ping the nodes as they're named.
	#($node) = ping_node($conf, $node);
	
	# I echo 'start purpose:' before each call so that I know for
	# sure when I am switching between shell calls.
	my $sc =  "$conf->{path}{ssh} -o ConnectTimeout=10 root\@$node \"";
	   $sc .= "echo \\\"start dmidecode:\\\"; dmidecode -t 4,16,17; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start meminfo:\\\"; cat /proc/meminfo; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start drbd-status:\\\"; drbdadm status; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start drbd-res-file:\\\"; cat /etc/drbd.d/r?.res; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start clustat:\\\"; clustat; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start cluster.conf:\\\"; cat /etc/cluster/cluster.conf; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start daemons:\\\"; ";
	   $sc .= "/etc/init.d/rgmanager status; echo an-sve:rgmanager:\\\$?; ";
	   $sc .= "/etc/init.d/cman status; echo an-sve:cman:\\\$?; ";
	   $sc .= "/etc/init.d/drbd status; echo an-sve:drbd:\\\$?; ";
	   $sc .= "/etc/init.d/clvmd status; echo an-sve:clvmd:\\\$?; ";
	   $sc .= "/etc/init.d/gfs2 status; echo an-sve:gfs2:\\\$?; ";
	   $sc .= "/etc/init.d/libvirtd status; echo an-sve:libvirtd:\\\$?; ";
	   $sc .= "echo \\\"lvm-scan start:\\\"; pvscan; vgscan; lvscan; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"lvm-data start:\\\"; ";
	   $sc .= "pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid; ";
	   $sc .= "vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name; ";
	   $sc .= "lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices; ";
	   $sc .= "echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start gfs2:\\\"; cat /etc/fstab | grep gfs2 && df -hP; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start virsh:\\\"; virsh list --all; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start vm defs:\\\"; cat /shared/definitions/*; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond0:\\\"; cat /proc/net/bonding/bond0; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond1:\\\"; cat /proc/net/bonding/bond1; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond2:\\\"; cat /proc/net/bonding/bond2; echo \\\"#!end!#\\\"; ";
	   $sc .= "\"";
	   #$sc = "./data_${node}.txt";
	# These keep track of where I am.
	my $in_dmidecode     = 0;
	my $in_meminfo       = 0;
	my $in_drbd_status   = 0;
	my $in_drbd_res_file = 0;
	my $in_clustat       = 0;
	my $in_cluster_conf  = 0;
	my $in_daemons       = 0;
	my $in_lvm_scan      = 0;
	my $in_lvm_data      = 0;
	my $in_gfs2          = 0;
	my $in_virsh         = 0;
	my $in_vm_defs       = 0;
	my $in_bond          = 0;
	
	# This is used to track the bond I am reading.
	my $bond = "";
	
	# These store the data read.
	my @dmidecode;
	my @meminfo;
	my @drbd_status;
	my @drbd_res_file;
	my @clustat;
	my @cluster_conf;
	my @daemons;
	my @lvm_scan;
	my @lvm_data;
	my @gfs2;
	my @virsh;
	my @vm_defs;
	my @bond;
	
	# If I run into a long string of @, I need to read the next line to see
	# what ssh is complaining about.
	my $read_next = 0;
	
	### NOTE: This is over 1 KiB long and causes some IDEs, like 'kate', to
	### flip the file into read-only mode. Enable only when needed.
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	my $raw;
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	#open ($fh, "<$sc") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		#$raw .= $_;
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], read_next: [$read_next], line: [$line]\n");
		
		# If I was asked to read the next line, I am dead but I need
		# details.
		if ($read_next)
		{
			if ($line =~ /UNPROTECTED PRIVATE KEY FILE/)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />It appears that there is a file permission issue in the dashboard.<br />The server's <span class=\"fixed_width\">$conf->{'system'}{username}</span> user's <span class=\"fixed_width\">~/.ssh/id_rsa</span> file is bad.<br />Please set the permissions to <span class=\"fixed_width\">600</span> (only readable by <span class=\"fixed_width\">$conf->{'system'}{username}</span>).<br />Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a> if you would like assistance with this issue.";
				set_daemons($conf, $node, "Unknown", "highlight_unavailable");
				record($conf, "$THIS_FILE ".__LINE__."; Note: [$conf->{node}{$node}{info}{note}]\n");
				last;
			}
			else
			{
				record($conf, "$THIS_FILE ".__LINE__."; Other issue.\n");
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. It appears that the node has changed!<br />If this node failed and was replaced, be sure to remove the old key from <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file.<br />If the node has not been replaced, then someone might be trying to trick you into logging into it.";
				record($conf, "$THIS_FILE ".__LINE__."; Note: [$conf->{node}{$node}{info}{note}]\n");
				last;
			}
		}
		
		# This catches connectivity problems.
		if ($line =~ /No route to host/i)
		{
			my $local_access = on_same_network($conf, $node);
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">No Access</span>";
			if ($local_access)
			{
				$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. It is on an accessible subnet, so the node is likely off or there is a network problem.";
			}
			else
			{
				$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. The server running AN!CDB is not currently on the same subnet as the node.";
			}
			last;
		}
		elsif ($line =~ /host key verification failed/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Verification Failed!</span>";
			$conf->{node}{$node}{info}{note}    = "SSH host key validation failed.<br />Have you saved <span class=\"fixed_width\">${node}</span>'s fingerprint in <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file?<br />If this is a new issue, the physical node may have changed, requiring the old fingerprint be deleted and the new fingerprint be saved.<br />If the machine has not changed, then this might be a sign of an attempt to intercept your connection to the node.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /could not resolve hostname/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Bad Hostname!</span>";
			$conf->{node}{$node}{info}{note}    = "Could not resolve the hostname: <span class=\"fixed_width\">$node</span>. Have you setup your <span class=\"fixed_width\">/etc/hosts</span> file or DNS server properly?";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /permission denied/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Permission Denied!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. Have you added <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/id_rsa.pub</span> public key to <span class=\"fixed_width\">$node</span>'s <span class=\"fixed_width\">/root/.ssh/authorized_keys</span> file? If so, check <span class=\"fixed_width\">/var/log/secure</span> on <span class=\"fixed_width\">$node</span> for errors.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /connection refused/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Refused!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />Either it is refusing incoming connections or this machine does not have access to the node's subnet.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /Connection timed out/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Timed Out</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The connection timed out.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /Network is unreachable/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Network Unreachable</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The network is not reachable. Is this machine hosting this program on the same subnet?";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /\@\@\@\@/)
		{
			# When the host-key fails to match, a box made
			# of '@@@@' is displayed, and is the entire 
			# first line.
			$read_next = 1;
			next;
		}
		
		# Catch the end of sections
		if ($line =~ /#!end!#/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; end\n");
			$in_dmidecode    = 0;
			$in_meminfo      = 0;
			$in_drbd_status  = 0;
			$in_clustat      = 0;
			$in_cluster_conf = 0;
			$in_daemons      = 0;
			$in_lvm_scan     = 0;
			$in_lvm_data     = 0;
			$in_gfs2         = 0;
			$in_virsh        = 0;
			$in_vm_defs      = 0;
			$in_bond         = 0;
			$bond            = "";
		}
		#if ($line =~ /^start (.*?):/) { record($conf, "$THIS_FILE ".__LINE__."; start: [$line]\n"); }
		
		# Figure out where I am.
		if ($line =~ /^start dmidecode:/)
		{
			$conf->{node}{$node}{connected}     = 1;
			$in_dmidecode                       = 1;
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_good\">Up!</span>";
			next;
		}
		if ($line =~ /^start meminfo:/)       { $in_meminfo       = 1; next; }
		if ($line =~ /^start drbd-status:/)   { $in_drbd_status   = 1; next; }
		if ($line =~ /^start drbd-res-file:/) { $in_drbd_res_file = 1; next; }
		if ($line =~ /^start clustat:/)       { $in_clustat       = 1; next; }
		if ($line =~ /^start cluster.conf:/)  { $in_cluster_conf  = 1; next; }
		if ($line =~ /^start daemons:/)       { $in_daemons       = 1; next; }
		if ($line =~ /^lvm-scan start:/)      { $in_lvm_scan      = 1; next; }
		if ($line =~ /^lvm-data start:/)      { $in_lvm_data      = 1; next; }
		if ($line =~ /^start gfs2:/)          { $in_gfs2          = 1; next; }
		if ($line =~ /^start virsh:/)         { $in_virsh         = 1; next; }
		if ($line =~ /^start vm defs:/)       { $in_vm_defs       = 1; next; }
		if ($line =~ /^start vm defs:/)       { $in_vm_defs       = 1; next; }
		if ($line =~ /^start bond(\d+):/)
		{
			$bond       = $1;
			$in_vm_defs = 1;
			next;
		}
		
		# If I am in a section, push the lines into the
		# appropriate array.
		if ($in_dmidecode)     { push @dmidecode,     $line; }
		if ($in_meminfo)       { push @meminfo,       $line; }
		if ($in_drbd_status)   { push @drbd_status,   $line; }
		if ($in_drbd_res_file) { push @drbd_res_file, $line; }
		if ($in_clustat)       { push @clustat,       $line; }
		if ($in_cluster_conf)  { push @cluster_conf,  $line; }
		if ($in_daemons)       { push @daemons,       $line; }
		if ($in_lvm_scan)      { push @lvm_scan,      $line; }
		if ($in_lvm_data)      { push @lvm_data,      $line; }
		if ($in_gfs2)          { push @gfs2,          $line; }
		if ($in_virsh)         { push @virsh,         $line; }
		if ($in_vm_defs)       { push @vm_defs,       $line; }
		if ($in_bond)
		{
			push @bond, "$bond:$line";
		}
	}
	$fh->close();
	#record($conf, "$THIS_FILE ".__LINE__."; raw $node:\n===========================\n$raw\n===========================\n");
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], connected: [$conf->{node}{$node}{connected}], state: [$conf->{node}{$node}{info}{'state'}], note: [$conf->{node}{$node}{info}{note}]\n");
	if ($conf->{node}{$node}{connected})
	{
		$conf->{'system'}{show_nodes} = 1;
		$conf->{node}{$node}{up}      = 1;
		push @{$conf->{up_nodes}}, $node;
		parse_dmidecode    ($conf, $node, \@dmidecode);
		parse_meminfo      ($conf, $node, \@meminfo);
		parse_drbd_status  ($conf, $node, \@drbd_status);
		parse_drbd_res_file($conf, $node, \@drbd_res_file);
		parse_clustat      ($conf, $node, \@clustat);
		parse_cluster_conf ($conf, $node, \@cluster_conf);
		parse_daemons      ($conf, $node, \@daemons);
		parse_lvm_scan     ($conf, $node, \@lvm_scan);
		parse_lvm_data     ($conf, $node, \@lvm_data);
		parse_gfs2         ($conf, $node, \@gfs2);
		parse_virsh        ($conf, $node, \@virsh);
		parse_vm_defs      ($conf, $node, \@vm_defs);
		parse_bonds        ($conf, $node, \@bond);
		# Some stuff, like setting the system memory, needs some
		# post-scan math.
		post_node_calculations($conf, $node);
	}
	else
	{
		check_if_on($conf, $node);
		record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
		if ($conf->{node}{$node}{is_on} == 0)
		{
			$conf->{'system'}{show_nodes}         = 1;
			$conf->{node}{$node}{enable_poweron}  = 1;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{enable_fence}    = 0;
			#$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">Powered Off</span>";
			#$conf->{node}{$node}{info}{note}    = "The node <span class=\"fixed_width\">$node</span> is powered down.";
		}
		elsif ($conf->{node}{$node}{is_on} == 1)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 1;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 1;
			# Disable poweroff if I wasn't able to SSH into the
			# node.
			if (not $conf->{node}{$node}{connected})
			{
				$conf->{node}{$node}{enable_poweroff} = 0;
			}
			$conf->{node}{$node}{enable_fence}    = 1;
			if ((not $conf->{node}{$node}{info}{'state'}) or (not $conf->{node}{$node}{info}{note}))
			{
				$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">No Access</span>";
				$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, but it is reported as being powered on.<br />If you just powered on this system, please wait a moment for it to boot.<br />If you just powered off this node, it might still be shutting down.<br /> Otherwise, the node may have crashed.";
			}
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		elsif ($conf->{node}{$node}{is_on} == 2)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 0;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">Inaccesible</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />The out of band management interface's address, user name or password may have changed since it was last cached.<br />Please manually check the Anvil's cluster and update the cluster's fencing information if needed.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		elsif ($conf->{node}{$node}{is_on} == 3)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 0;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">Inaccesible</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />The machine running the dashboard is not on the same subnet as the out of band management, so the node's current state is unknown.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		else
		{
			# Unable to determine node state.
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{enable_fence}    = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">No Access</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />Please check the network connections between this machine and the nodes.<br />If the power feeding the node was cut at the PDUs, fencing the node may restore access.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		
		# If I have confirmed the node is powered off, don't display this.
		#record($conf, "$THIS_FILE ".__LINE__."; enable power on: [$conf->{node}{$node}{enable_poweron}], task: [$conf->{cgi}{task}]\n");
		if ((not $conf->{node}{$node}{enable_poweron}) && (not $conf->{cgi}{task}))
		{
			print "
<table align=\"center\">
	<tr>
		<td>
			$conf->{node}{$node}{info}{'state'}
		</td>
		<td>
			$conf->{node}{$node}{info}{note}
		</td>
	</tr>
</table>
<br />
";
		}
	}
	
	return (0);
}

# This sets all of the daemons to a given state.
sub set_daemons
{
	my ($conf, $node, $state, $class) = @_;
	
	my @daemons = ("cman", "rgmanager", "drbd", "clvmd", "gfs2", "libvirtd");
	foreach my $daemon (@daemons)
	{
		$conf->{node}{$node}{daemon}{$daemon}{status}    = "<span class=\"$class\">$state</span>";
		$conf->{node}{$node}{daemon}{$daemon}{exit_code} = "";
	}
	return(0);
}

# This checks to see if the node's power is on, when possible.
sub check_if_on
{
	my ($conf, $node) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; in check_if_on(); node: [$node]\n");
	
	# If the peer is on, use it to check the power.
	my $peer                    = "";
	$conf->{node}{$node}{is_on} = 9;
	#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
	### TODO: This fails when node 1 is down because it has not yet looked
	###       for node 2 to see if it is on or not. Check manually.
	if ($conf->{'system'}{up_nodes} == 1)
	{
		# It has to be the peer of this node.
		$peer = @{$conf->{up_nodes}}[0];
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
	if ($peer)
	{
		# Check the power state using the peer node.
		if (not $conf->{node}{$node}{info}{power_check_command})
		{
			error($conf, "I was asked to check the power staus of: [$node] via it's peer: [$peer], but the power check command is empty.<br />\nThis is likely a program error.\n");
		}
		else
		{
			# Escape out password double-quotes.
			$conf->{node}{$node}{info}{power_check_command} =~ s/-p \"(.*?)\"/-p \\\"$1\\\"/g;
			#record($conf, "$THIS_FILE ".__LINE__."; node::${node}::info::power_check_command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		my $sc = "$conf->{path}{ssh} root\@$peer \"$conf->{node}{$node}{info}{power_check_command} -o status\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ / On$/i)
			{
				$conf->{node}{$node}{is_on} = 1;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
			}
			if ($line =~ / Off$/i)
			{
				$conf->{node}{$node}{is_on} = 0;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
			}
		}
		$fh->close();
	}
	else
	{
		# Read the cache and check the power directly, if possible.
		read_node_cache($conf, $node);
		$conf->{node}{$node}{info}{power_check_command} = "" if not defined $conf->{node}{$node}{info}{power_check_command};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		if ($conf->{node}{$node}{info}{power_check_command})
		{
			# Get the address from the command and see if it's in
			# one of my subnet.
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			my $local_access = on_same_network($conf, $target_host);
			
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], local_access: [$local_access]\n");
			if ($local_access)
			{
				# I can reach it directly
				my $sc = "$conf->{node}{$node}{info}{power_check_command} -o status";
				#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
					if ($line =~ / On$/i)
					{
						$conf->{node}{$node}{is_on} = 1;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
					}
					if ($line =~ / Off$/i)
					{
						$conf->{node}{$node}{is_on} = 0;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
					}
					if ($line =~ / Unknown$/i)
					{
						$conf->{node}{$node}{is_on} = 2;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}] - Failed to get info from IPMI!\n");
					}
				}
				$fh->close();
			}
			else
			{
				# I can't reach it from here.
				#record($conf, "$THIS_FILE ".__LINE__."; This machine is not on the same network out of band management interface: [$target_host] for node: [$node], unable to check power state.\n");
				$conf->{node}{$node}{is_on} = 3;
			}
		}
		else
		{
			# No power-check command
			$conf->{node}{$node}{is_on} = 4;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}] - Unable to find power check command!\n");
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
	if ($conf->{node}{$node}{is_on} == 0)
	{
		# I need to preset the services as stopped because the little
		# hack I have below doesn't echo when a service isn't running.
		$conf->{node}{$node}{enable_poweron} = 1;
		set_daemons($conf, $node, "Offline", "highlight_unavailable");
	}
	
	return(0);
}

# This takes a host name (or IP) and sees if it's reachable from the machine
# running this program.
sub on_same_network
{
	my ($conf, $target_host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in on_same_network(); target host: [$target_host]\n");
	
	my $local_access = 0;
	my $target_ip;
	
	my $sc = "$conf->{path}{gethostip} -d $target_host";
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^(\d+\.\d+\.\d+\.\d+)$/)
		{
			$target_ip = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; target_ip: [$target_ip]\n");
		}
		elsif ($line =~ /Unknown host/i)
		{
			#Failed to resolve
			error($conf, "I was trying to resolve the host name: [$target_host] but was unable to do so. Is this a valid host name? If so, do you have an entry in DNS or in your /etc/hosts file?\n");
		}
		elsif ($line =~ /Usage: gethostip/i)
		{
			#No hostname parsed out.
			error($conf, "I was trying to resolve a host name, but no name was given. This is likely a program error.\n");
		}
	}
	$fh->close();
	
	#record($conf, "$THIS_FILE ".__LINE__."; target_ip: [$target_ip]\n");
	if ($target_ip)
	{
		# Find out my own IP(s) and subnet(s).
		my $in_dev       = "";
		my $this_ip      = "";
		my $this_nm      = "";
		
		my $sc           = "$conf->{path}{ifconfig}";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /^(.*?)\s+Link encap/)
			{
				$in_dev = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; in_dev: [$in_dev]\n");
				next;
			}
			elsif ($line =~ /^(.*?): flags/)
			{
				$in_dev = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; in_dev: [$in_dev]\n");
				next;
			}
			if (not $line)
			{
				# See if this network gives me access 
				# to the power check device.
				my $target_ip_range = $target_ip;
				my $this_ip_range   = $this_ip;
				#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip: [$this_ip]\n");
				if ($this_nm eq "255.255.255.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+$//;
					$this_ip_range   =~ s/.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				if ($this_nm eq "255.255.0.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+.\d+$//;
					$this_ip_range   =~ s/.\d+.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				if ($this_nm eq "255.0.0.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+.\d+.\d+$//;
					$this_ip_range   =~ s/.\d+.\d+.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				if ($this_ip_range eq $target_ip_range)
				{
					# Match! I can reach it directly.
					$local_access = 1;
					#record($conf, "$THIS_FILE ".__LINE__."; local_access: [$local_access]\n");
					last;
				}
				
				$in_dev = "";
				$this_ip = "";
				$this_nm = "";
				next;
			}
			
			if ($in_dev)
			{
				next if $line !~ /inet /;
				if ($line =~ /inet addr:(\d+\.\d+\.\d+\.\d+) /)
				{
					$this_ip = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_ip: [$this_ip]\n");
				}
				elsif ($line =~ /inet (\d+\.\d+\.\d+\.\d+) /)
				{
					$this_ip = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_ip: [$this_ip]\n");
				}
				
				if ($line =~ /Mask:(\d+\.\d+\.\d+\.\d+)/i)
				{
					$this_nm = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_nm: [$this_nm]\n");
				}
				elsif ($line =~ /netmask (\d+\.\d+\.\d+\.\d+) /)
				{
					$this_nm = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_nm: [$this_nm]\n");
				}
			}
		}
		$fh->close();
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; local_access: [$local_access]\n");
	return($local_access);
}

# This records this scan's data to the cache file.
sub write_node_cache
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in write_node_cache(); node: [$node]\n");
	
	# It's a program error to try and write the cache file when the node
	# is down.
	my $cluster    = $conf->{cgi}{cluster};
	my $cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".an-cdb";
	if (($conf->{node}{$node}{info}{host_name}) && ($conf->{node}{$node}{info}{power_check_command}))
	{
		# Write the command to disk so that I can check the power state
		# in the future when both nodes are offline.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		my $fh         = IO::Handle->new();
		#record($conf, "$THIS_FILE ".__LINE__."; writting: [$cache_file]\n");
		open ($fh, "> $cache_file") or error($conf, "Failed to write: [<span class=\"fixed_width\">$cache_file</span>] as UID: [<span class=\"fixed_width\">$<</span>].<br />The error was: <span class=\"fixed_width\">$!</span>\n");
		
		print $fh "host_name = $conf->{node}{$node}{info}{host_name}\n";
		print $fh "power_check_command = $conf->{node}{$node}{info}{power_check_command}\n";
		print $fh "fence_methods = $conf->{node}{$node}{info}{fence_methods}\n";
		
		$fh->close();
	}
	elsif (not -e $cache_file)
	{
		# I've probably never seen the cache file before, so don't
		# error out.
	}
	else
	{
		#error($conf, "I was asked to write the cache file for: [$node], but I didn't have all the cache data.<br />\nI was passed; host name: [$conf->{node}{$node}{info}{host_name}], power check command: [$conf->{node}{$node}{info}{power_check_command}].<br />\nThis is likely a program error.\n");
	}
	
	return(0);
}

# This reads the cached data for this node, if available.
sub read_node_cache
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in read_node_cache(); node: [$node]\n");
	
	# Write the command to disk so that I can check the power state
	# in the future when both nodes are offline.
	my $cluster    = $conf->{cgi}{cluster};
	my $cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".an-cdb";
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster], cache file: [$cache_file]\n");
	if (not -e $cache_file)
	{
		# See if there is a version with or without '<node>.remote'
		if ($node =~ /\.remote/)
		{
			# Strip it off
			$cache_file =~ s/\.remote//;
		}
		else
		{
			# Add the .remote suffix.
			$cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".remote.an-cdb";
		}
	}
	if (-e $cache_file)
	{
		# It exists! Read it.
		my $sc = $cache_file;
		#record($conf, "$THIS_FILE ".__LINE__."; Reading: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or die "Failed to read: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			next if $line !~ /=/;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			#record($conf, "$THIS_FILE ".__LINE__."; var: [$var], val: [$val]\n");
			
			$conf->{node}{$node}{info}{$var} = $val;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], var: [$var] -> [$conf->{node}{$node}{info}{$var}]\n");
		}
		$fh->close();
	}
	else
	{
		$conf->{node}{$node}{info}{host_name} = $node;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; host name: [$conf->{node}{$node}{info}{host_name}], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
	
	return(0);
}

# This parse bond data
sub parse_bonds
{
	my ($conf, $node, $array) = @_;
	
	
	return (0);
}

# This (tries to) parse the VM definitions files.
sub parse_vm_defs
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_vm_defs() for node: [$node]\n");
	my $this_vm    = "";
	my $in_domain  = 0;
	my $this_array = [];
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		# Find the start of a domain.
		if ($line =~ /<domain/)
		{
			$in_domain = 1;
		}
		
		# Get this name of the current domain
		if ($line =~ /<name>(.*?)<\/name>/)
		{
			$this_vm = $1;
		}
		
		# Push all lines into the current domain array.
		if ($in_domain)
		{
			push @{$this_array}, $line;
		}
		
		# When the end of a domain is found, push the array over to
		# $conf.
		if ($line =~ /<\/domain>/)
		{
			my $vm_key = "vm:$this_vm";
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$this_vm], array: [$this_array], lines: [".@{$this_array}."]\n");
			$conf->{vm}{$vm_key}{xml} = $this_array;
			$in_domain  = 0;
			$this_array = [];
		}
	}
	
	return (0);
}

# Parse the dmidecode data.
sub parse_dmidecode
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_dmidecode() for node: [$node]\n");
	#foreach my $line (@{$array}) { record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n"); }
	
	# Some variables I will need.
	my $in_cpu           = 0;
	my $in_system_ram    = 0;
	my $in_dimm_module   = 0;
	
	# On SMP machines, the CPU socket becomes important. This 
	# tracks which CPU I am looking at.
	my $this_socket      = "";
	
	# Same deal with volume groups.
	my $this_vg          = "";
	
	# RAM is all over the place, so I need to record all the bits
	# in strings and push to the hash when I see a blank line.
	my $dimm_locator     = "";
	my $dimm_bank        = "";
	my $dimm_size        = "";
	my $dimm_type        = "";
	my $dimm_speed       = "";
	my $dimm_form_factor = "";
	
	# This will be set to the values I find on this node.
	$conf->{node}{$node}{hardware}{total_node_cores}   = 0;
	$conf->{node}{$node}{hardware}{total_node_threads} = 0;
	$conf->{node}{$node}{hardware}{total_memory}       = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	
	# These will be set to the lowest available RAM, and CPU core
	# available.
	$conf->{resources}{total_cores}   = 0;
	$conf->{resources}{total_threads} = 0;
	$conf->{resources}{total_ram}     = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; Cluster; total cores: [$conf->{resources}{total_cores}], total threads: [$conf->{resources}{total_threads}], total memory: [$conf->{resources}{total_ram}]\n");
	
	foreach my $line (@{$array})
	{
		if ($line =~ /dmidecode: command not found/)
		{
			die "Unable to read system information on node: [$node]. Is 'dmidecode' installed?";
		}
		
		# Find out what I am looking at.
		if (not $line)
		{
			# Blank lines break sections.
			# If I had been reading DIMM info, push it into
			# the hash.
			if ($in_dimm_module)
			{
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{bank}        = $dimm_bank;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{size}        = $dimm_size;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{type}        = $dimm_type;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{speed}       = $dimm_speed;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{form_factor} = $dimm_form_factor;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], dimm: [$dimm_locator], bank: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{bank}], size: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{size}], type: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{type}], speed: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{speed}], form factor: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{form_factor}]\n");
			}
			$in_cpu         = 0;
			$in_system_ram  = 0;
			$in_dimm_module = 0;
			$this_socket    = "";
			$this_vg        = "";
			next;
		}
		if ($line =~ /Processor Information/)
		{
			$in_cpu         = 1;
			next;
		}
		if ($line =~ /Physical Memory Array/)
		{
			$in_system_ram  = 1;
			next;
		}
		if ($line =~ /Memory Device/)
		{
			$in_dimm_module = 1;
			next;
		}
		if ((not $in_cpu) && (not $in_system_ram) && (not $in_dimm_module))
		{
			next;
		}
		
		# Now pull out data based on where I am.
		if ($in_cpu)
		{
			# The socket is the first line, so I can safely
			# assume that 'this_socket' will be populated
			# after this.
			if ($line =~ /Socket Designation: (.*)/)
			{
				$this_socket = $1;
				next;
			}
			
			# Grab some deets!
			if ($line =~ /Family: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{family}    = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu family: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{family}]\n");
			}
			if ($line =~ /Manufacturer: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{oem}       = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu oem: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{oem}]\n");
			}
			if ($line =~ /Version: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{version}   = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu version: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{version}]\n");
			}
			if ($line =~ /Max Speed: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{max_speed} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu max speed: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{max_speed}]\n");
			}
			if ($line =~ /Status: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{status}    = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu status: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{status}]\n");
			}
			if ($line =~ /Core Count: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores} =  $1;
				$conf->{node}{$node}{hardware}{total_node_cores}         += $conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores};
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], socket cores: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores}], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}]\n");
			}
			if ($line =~ /Thread Count: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads} =  $1;
				$conf->{node}{$node}{hardware}{total_node_threads}         += $conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads};
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], socket threads: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}]\n");
			}
		}
		if ($in_system_ram)
		{
			# Not much in system RAM, but good to know stuff.
			if ($line =~ /Error Correction Type: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{ecc_support} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], RAM ECC: [$conf->{node}{$node}{hardware}{ram}{ecc_support}]\n");
			}
			if ($line =~ /Number Of Devices: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{slots}       = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], RAM slots: [$conf->{node}{$node}{hardware}{ram}{slots}]\n");
			}
			# This needs to be converted to bytes.
			if ($line =~ /Maximum Capacity: (\d+) (.*)$/)
			{
				my $size   = $1;
				my $suffix = $2;
				$conf->{node}{$node}{hardware}{ram}{max_support} = hr_to_bytes($conf, $size, $suffix, 1);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], max. supported RAM: [$conf->{node}{$node}{hardware}{ram}{max_support}]\n");
			}
			if ($line =~ /Maximum Capacity: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{max_support} = $1;
				$conf->{node}{$node}{hardware}{ram}{max_support} = hr_to_bytes($conf, $conf->{node}{$node}{hardware}{ram}{max_support}, "", 1);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], max. supported RAM: [$conf->{node}{$node}{hardware}{ram}{max_support}]\n");
			}
		}
		if ($in_dimm_module)
		{
			if ($line =~ /Locator: (.*)/)      { $dimm_locator     = $1; }
			if ($line =~ /Bank Locator: (.*)/) { $dimm_bank        = $1; }
			if ($line =~ /Type: (.*)/)         { $dimm_type        = $1; }
			if ($line =~ /Speed: (.*)/)        { $dimm_speed       = $1; }
			if ($line =~ /Form Factor: (.*)/)  { $dimm_form_factor = $1; }
			if ($line =~ /Size: (.*)/)
			{
				$dimm_size = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size]\n");
				# If the DIMM couldn't be read, it will
				# show "Unknown". I set this to 0 in 
				# that case.
				if ($dimm_size !~ /^\d/)
				{
					$dimm_size = 0;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size]\n");
				}
				else
				{
					$dimm_size                                   =  hr_to_bytes($conf, $dimm_size, "", 1);
					$conf->{node}{$node}{hardware}{total_memory} += $dimm_size;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
				}
			}
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; Cluster; total cores: [$conf->{resources}{total_cores}], total threads: [$conf->{resources}{total_threads}], total memory: [$conf->{resources}{total_ram}]\n");
	return(0);
}

# Parse the memory information.
sub parse_meminfo
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_meminfo() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /MemTotal:\s+(.*)/)
		{
			$conf->{node}{$node}{hardware}{meminfo}{memtotal} = $1;
			$conf->{node}{$node}{hardware}{meminfo}{memtotal} = hr_to_bytes($conf, $conf->{node}{$node}{hardware}{meminfo}{memtotal}, "", 1);
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], meminfo total memory: [$conf->{node}{$node}{hardware}{meminfo}{memtotal}]\n");
		}
	}
	
	return(0);
}

# Parse the DRBD status.
sub parse_drbd_status
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_drbd_status() for node: [$node]\n");
	my $resources = 0;
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if $line !~ /^<resource /;
		$resources++;
		
		# Make sure I only display "unknown" or the read value.
		my $minor = "--";
		my $res   = "--";
		my $cs    = "--";
		my $ro    = "--";
		my $ds    = "--";
		my $dev   = "--";
		($minor) = ($line =~ /minor="(.*?)"/);
		($res)   = ($line =~ /name="(.*?)"/);
		($cs)    = ($line =~ /cs="(.*?)"/);
		($ro)    = ($line =~ /ro1="(.*?)"/);
		($ds)    = ($line =~ /ds1="(.*?)"/);
		$dev = "/dev/drbd$minor" if $minor =~ /^\d+$/;
		
		# This is the new way of recording.
		$conf->{drbd}{$res}{node}{$node}{minor}            = $minor ? $minor : "--";
		$conf->{drbd}{$res}{node}{$node}{connection_state} = $cs    ? $cs    : "--";
		$conf->{drbd}{$res}{node}{$node}{role}             = $ro    ? $ro    : "--";
		$conf->{drbd}{$res}{node}{$node}{disk_state}       = $ds    ? $ds    : "--";
		$conf->{drbd}{$res}{node}{$node}{device}           = $dev   ? $dev   : "--";
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], New - res: [$res], minor: [$conf->{drbd}{$res}{node}{$node}{minor}], cs: [$conf->{drbd}{$res}{node}{$node}{connection_state}], ro: [$conf->{drbd}{$res}{node}{$node}{role}], ds: [$conf->{drbd}{$res}{node}{$node}{disk_state}], dev: [$conf->{drbd}{$res}{node}{$node}{device}]\n");
	}
	if (not $resources)
	{
		# DRBD isn't running.
		#record($conf, "$THIS_FILE ".__LINE__."; DRBD does not appear to be running on node: [$node]\n");
	}
	
	return(0);
}

# This reads the DRBD resource details from the resource definition files.
sub parse_drbd_res_file
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_drbd_res_file() for node: [$node]\n");
	
	my $in_res      = "";
	my $in_on       = "";
	my $this_device = "--";
	
	my $resources = 0;
	foreach my $line (@{$array})
	{
		$line =~ s/#.*//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		if ($line =~ /^resource (.*?) {/)
		{
			$in_res = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res]\n");
			next;
		}
		
		if ($in_res)
		{
			if ($line =~ /on (.*?) {/)
			{
				$in_on = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res], on: [$in_on]\n");
				next;
			}
			if ($in_on)
			{
				# I don't want the closing brace of an 
				# "on ... {" directive closing "in_res" early.
				if ($line eq "}")
				{
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], closing 'on': [$in_on]\n");
					$in_on = "";
					next;
				}
			}
			else
			{
				if ($line eq "}")
				{
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], closing 'res': [$in_res]\n");
					$conf->{node}{$node}{drbd}{res_file}{$in_res}{device}           = $this_device;
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{device}           = $this_device;
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{connection_state} = "--";
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{role}             = "--";
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{disk_state}       = "--";
					
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res], device: [$conf->{node}{$node}{drbd}{res_file}{$in_res}{device}]\n");
					$in_res      = "";
					$this_device = "--";
				}
				if ($line =~ /device\s+(.*?);/)
				{
					$this_device = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], device: [$this_device]\n");
				}
			}
		}
	}
	
	return(0);
}

# Parse the cluster status.
sub parse_clustat
{
	my ($conf, $node, $array) = @_;
	
	# Setup some variables.
	my $in_member  = 0;
	my $in_service = 0;
	my $line_num   = 0;
	
	my $host_name                         = "unknown";
	my $storage_name                      = "unknown";
	my $storage_state                     = "unknown";
	$conf->{node}{$node}{me}{cman}        = 0;
	$conf->{node}{$node}{me}{rgmanager}   = 0;
	$conf->{node}{$node}{peer}{cman}      = 0;
	$conf->{node}{$node}{peer}{rgmanager} = 0;
	$conf->{node}{$node}{enable_join}     = 0;
	$conf->{node}{$node}{get_host_from_cluster_conf} = 0;

	### NOTE: This check seems odd, but I've run intp cases where a node,
	###       otherwise behaving fine, simple returns nothing when cman is
	###       off. Couldn't reproduce on the command line.
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_clustat() for node: [$node]\n");
	my $line_count = @{$array};
	if (not $line_count)
	{
		# CMAN isn't running.
		record($conf, "$THIS_FILE ".__LINE__."; The cluster manager, cman, does not appear to be running on node: [$node] (nothing returned by the 'clustat' call).\n");
		$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
		$conf->{node}{$node}{enable_join}                = 1;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; Will parse: [$line_count] lines.\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Could not connect to CMAN/i)
		{
			# CMAN isn't running.
			#record($conf, "$THIS_FILE ".__LINE__."; CMAN does not appear to be running on node: [$node]\n");
			$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
			$conf->{node}{$node}{enable_join}                = 1;
		}
		next if not $line;
		next if $line =~ /^-/;
		
		if ($line =~ /^Member Name/)
		{
			$in_member  = 1;
			$in_service = 0;
			next;
		}
		elsif ($line =~ /^Service Name/)
		{
			$in_member  = 0;
			$in_service = 1;
			next;
		}
		if ($in_member)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /Local/)
			{
				($conf->{node}{$node}{me}{name}, undef, my $services) = (split/ /, $line, 3);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - me: [$conf->{node}{$node}{me}{name}], services: [$services]\n");
				$services =~ s/local//;
				$services =~ s/ //g;
				$services =~ s/,,/,/g;
				$conf->{node}{$node}{me}{cman}      =  1 if $services =~ /Online/;
				$conf->{node}{$node}{me}{rgmanager} =  1 if $services =~ /rgmanager/;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - Me   -> [$conf->{node}{$node}{me}{name}]; cman: [$conf->{node}{$node}{me}{cman}], rgmanager: [$conf->{node}{$node}{me}{rgmanager}]\n");
			}
			else
			{
				($conf->{node}{$node}{peer}{name}, undef, my $services) = split/ /, $line, 3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - peer: [$conf->{node}{$node}{peer}{name}], services: [$services]\n");
				$services =~ s/ //g;
				$services =~ s/,,/,/g;
				$conf->{node}{peer}{cman}      = 1 if $services =~ /Online/;
				$conf->{node}{peer}{rgmanager} = 1 if $services =~ /rgmanager/;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - Peer -> [$conf->{node}{$node}{peer}{name}]; cman: [$conf->{node}{peer}{cman}], rgmanager: [$conf->{node}{peer}{rgmanager}]\n");
			}
		}
		elsif ($in_service)
		{
			if ($line =~ /^vm:/)
			{
				my ($vm, $host, $state) = split/ /, $line, 3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$host], state: [$state]\n");
				if (($state eq "disabled") || ($state eq "stopped"))
				{
					$host = "none";
				}
				if ($state eq "failed")
				{
					# Disable the VM.
					my $sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -d $vm\"";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						$line =~ s/^\s+//;
						$line =~ s/\s+$//;
						$line =~ s/\s+/ /g;
						record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					}
					$fh->close();
				}
				
				# If the service is disabled, it will 
				# have '()' which I need to remove.
				$host =~ s/\(//g;
				$host =~ s/\)//g;
				
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$host]\n");
				$host = "none" if not $host;
				$conf->{vm}{$vm}{host}    = $host;
				$conf->{vm}{$vm}{'state'} = $state;
				# TODO: If the state is "failed", call 
				# 'virsh list --all' against both nodes. If the
				# VM is found, try to recover the service.
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$conf->{vm}{$vm}{host}], state: [$conf->{vm}{$vm}{'state'}]\n");
				
				# Pick out who the peer node is.
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host: [$host], me: [$conf->{node}{$node}{me}{name}]\n");
				if ($host eq $conf->{node}{$node}{me}{name})
				{
					$conf->{vm}{$vm}{peer} = $conf->{node}{$node}{peer}{name};
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], peer: [$conf->{vm}{$vm}{peer}]\n");
				}
				else
				{
					$conf->{vm}{$vm}{peer} = $conf->{node}{$node}{me}{name};
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], peer: [$conf->{vm}{$vm}{peer}]\n");
				}
			}
			elsif ($line =~ /^service:(.*?)\s+(.*?)\s+(.*)$/)
			{
				my $name  = $1;
				my $host  = $2;
				my $state = $3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name], host: [$host], state: [$state]\n");
				
				if ($state eq "failed")
				{
					# Disable the service and then call a
					# start against it.
					# Disable the VM.
					my $sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -d service:$name\"";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						$line =~ s/^\s+//;
						$line =~ s/\s+$//;
						$line =~ s/\s+/ /g;
						record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					}
					$fh->close();
					sleep 5;
					$sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -e service:$name\"";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					$fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						$line =~ s/^\s+//;
						$line =~ s/\s+$//;
						$line =~ s/\s+/ /g;
						record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					}
					$fh->close();
				}
				
				# If the service is disabled, it will 
				# have '()' which I need to remove.
				$host =~ s/\(//g;
				$host =~ s/\)//g;
				
				$conf->{service}{$name}{host}    = $host;
				$conf->{service}{$name}{'state'} = $state;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name], host: [$conf->{service}{$name}{host}], state: [$conf->{service}{$name}{'state'}]\n");
			}
		}
	}
	
	# If this is set, the cluster isn't running.
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
	if (not $conf->{node}{$node}{get_host_from_cluster_conf})
	{
		$host_name = $conf->{node}{$node}{me}{name};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host name: [$host_name]\n");
		foreach my $name (sort {$a cmp $b} keys %{$conf->{service}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name]\n");
			next if $conf->{service}{$name}{host} ne $host_name;
			next if $name !~ /storage/;
			$storage_name  = $name;
			$storage_state = $conf->{service}{$name}{'state'};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - storage name: [$storage_name], storage state: [$storage_state]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host name: [$host_name]\n");
		if ($host_name)
		{
			$conf->{node}{$node}{info}{host_name}            =  $host_name;
			$conf->{node}{$node}{info}{short_host_name}      =  $host_name;
			$conf->{node}{$node}{info}{short_host_name}      =~ s/\..*$//;
			$conf->{node}{$node}{get_host_from_cluster_conf} = 0;
		}
		else
		{
			$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
		$conf->{node}{$node}{info}{storage_name}    = $storage_name;
		$conf->{node}{$node}{info}{storage_state}   = $storage_state;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - host name: [$conf->{node}{$node}{info}{host_name}], short host name: [$conf->{node}{$node}{info}{short_host_name}], storage name: [$conf->{node}{$node}{info}{storage_name}], storage state: [$conf->{node}{$node}{info}{storage_state}]\n");
	}
	
	return(0);
}

# Parse the cluster configuration.
sub parse_cluster_conf
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_cluster_conf(); node: [$node]\n");
	
	my $in_fod          = 0;
	my $current_fod     = "";
	my $in_node         = "";
	my $in_fence        = 0;
	my $in_method       = "";
	my $device_count    = 0;
	my $in_fence_device = 0;
	my $this_host_name  = "";
	my $this_node       = "";
	my $method_counter  = 0;
	
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
		
		# Find failover domains.
		if ($line =~ /<failoverdomain /)
		{
			$current_fod = ($line =~ /name="(.*?)"/)[0];
			#record($conf, "$THIS_FILE ".__LINE__."; current_fod: [$current_fod]\n");
			$in_fod      = 1;
			next;
		}
		if ($line =~ /<\/failoverdomain>/)
		{
			$current_fod = "";
			$in_fod      = 0;
			next;
		}
		if ($in_fod)
		{
			next if $line !~ /failoverdomainnode/;
			my $node     = ($line =~ /name="(.*?)"/)[0];
			my $priority = ($line =~ /priority="(.*?)"/)[0] ? $1 : 0;
			$conf->{failoverdomain}{$current_fod}{priority}{$priority}{node} = $node;
			#record($conf, "$THIS_FILE ".__LINE__."; failover domain: [$current_fod], node: [$conf->{failoverdomain}{$current_fod}{priority}{$priority}{node}], priority: [$priority]\n");
		}
		
		# If I didn't get the hostname from clustat, try to find it here.
		if ($line =~ /<clusternode.*?name="(.*?)"/)
		{
			   $this_host_name  =  $1;
			my $short_host_name =  $this_host_name;
			   $short_host_name =~ s/\..*$//;
			my $short_node_name =  $node;
			   $short_node_name =~ s/\..*$//;
			   
			# If I need to record the host name from cluster.conf,
			# do so here.
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], short host name: [$short_host_name], short node name: [$short_node_name], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
			if ($short_host_name eq $short_node_name)
			{
				# Found it.
				if ($conf->{node}{$node}{get_host_from_cluster_conf})
				{
					$conf->{node}{$node}{info}{host_name}            = $this_host_name;
					$conf->{node}{$node}{info}{short_host_name}      = $short_host_name;
					$conf->{node}{$node}{get_host_from_cluster_conf} = 0;
				}
				$this_node = $node;
			}
			else
			{
				$this_node = get_peer_node($conf, $node);
				if (not $conf->{node}{$this_node}{host_name})
				{
					$conf->{node}{$this_node}{info}{host_name}       = $this_host_name;
					$conf->{node}{$this_node}{info}{short_host_name} = $short_host_name;
				}
			}
			
			# Mark that I am in a node child element.
			$in_node = $node;
		}
		if ($line =~ /<\/clusternode>/)
		{
			# Record my fence findings.
			$in_node        = "";
			$this_node      = "";
			$method_counter = 0;
		}
		
		if (($in_node) && ($line =~ /<fence>/))
		{
			$in_fence = 1;
		}
		if ($line =~ /<\/fence>/)
		{
			$in_fence = 0;
		}
		if (($in_fence) && ($line =~ /<method.*name="(.*?)"/))
		{
			# The method counter ensures ordered use of the fence
			# devices.
			$in_method = "$method_counter:$1";
			$method_counter++;
		}
		if ($line =~ /<\/method>/)
		{
			$in_method    = "";
			$device_count = 0;
		}
		if (($in_method) && ($line =~ /<device\s/))
		{
			my $name   = $line =~ /name="(.*?)"/   ? $1 : "";
			my $port   = $line =~ /port="(.*?)"/   ? $1 : "";
			my $action = $line =~ /action="(.*?)"/ ? $1 : "";
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}   = $name;
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}   = $port;
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action} = $action;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node], method: [$in_method], method count: [$device_count], name: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}], port: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}], action: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}]\n");
			$device_count++;
		}
		
		# Parse out the fence device details.
		if ($line =~ /<fencedevices>/)
		{
			$in_fence_device = 1;
		}
		if ($line =~ /<\/fencedevices>/)
		{
			$in_fence_device = 0;
		}
		# This could be duplicated, but I don't care as cluster.conf
		# has to be the same on both nodes, anyway.
		if ($in_fence_device)
		{
			my $name     = $line =~ /name="(.*?)"/   ? $1 : "";
			my $agent    = $line =~ /agent="(.*?)"/  ? $1 : "";
			my $address  = $line =~ /ipaddr="(.*?)"/ ? $1 : "";
			my $login    = $line =~ /login="(.*?)"/  ? $1 : "";
			my $password = $line =~ /passwd="(.*?)"/ ? $1 : "";
			# If the password has a single-quote, ricci changes it to &apos;. We need to change it back.
			$password =~ s/&apos;/'/g;
			$conf->{fence}{$name}{agent}    = $agent;
			$conf->{fence}{$name}{address}  = $address;
			$conf->{fence}{$name}{login}    = $login;
			$conf->{fence}{$name}{password} = $password;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], fence name: [$name], agent: [$conf->{fence}{$name}{agent}], address: [$conf->{fence}{$name}{address}], login: [$conf->{fence}{$name}{login}], password: [$conf->{fence}{$name}{password}]\n");
		}
		
		# Find VMs.
		if ($line =~ /<vm.*?name="(.*?)"/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			my $vm     = $1;
			my $vm_key = "vm:$vm";
			my $def    = ($line =~ /path="(.*?)"/)[0].$vm.".xml";
			my $domain = ($line =~ /domain="(.*?)"/)[0];
			# I need to set the host to 'none' to avoid triggering
			# the error caused by seeing and foo.xml VM def outside
			# of here.
			#record($conf, "$THIS_FILE ".__LINE__."; vm_key: [$vm_key], def: [$def], domain: [$domain]\n");
			$conf->{vm}{$vm_key}{definition_file} = $def;
			$conf->{vm}{$vm_key}{failover_domain} = $domain;
			$conf->{vm}{$vm_key}{host}            = "none" if not $conf->{vm}{$vm_key}{host};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm_key: [$vm_key], definition: [$conf->{vm}{$vm_key}{definition_file}], host: [$conf->{vm}{$vm_key}{host}]\n");
		}
	}
	
	# See if I got the fence details for both nodes.
	my $peer = get_peer_node($conf, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
	foreach my $this_node ($node, $peer)
	{
		# This will contain possible fence methods.
		$conf->{node}{$this_node}{info}{fence_methods} = "";
		
		# This will contain the command needed to check the node's
		# power.
		$conf->{node}{$this_node}{info}{power_check_command} = "";
		
		#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node]\n");
		foreach my $in_method (sort {$a cmp $b} keys %{$conf->{node}{$this_node}{fence}{method}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node], method: [$in_method]\n");
			my $fence_command = "$in_method: ";
			foreach my $device_count (sort {$a cmp $b} keys %{$conf->{node}{$this_node}{fence}{method}{$in_method}{device}})
			{
				#$fence_command .= " [$device_count]";
				#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node], method: [$in_method], method count: [$device_count], name: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}], port: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}], action: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}]\n");
				#Find the matching fence device entry.
				foreach my $name (sort {$a cmp $b} keys %{$conf->{fence}})
				{
					if ($name eq $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name})
					{
						my $agent    = $conf->{fence}{$name}{agent};
						my $address  = $conf->{fence}{$name}{address};
						my $login    = $conf->{fence}{$name}{login};
						my $password = $conf->{fence}{$name}{password};
						my $port     = $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port};
						#my $action   = $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action};
						#   $action   = "reboot" if not $action;
						my $command  = "$agent -a $address ";
						   $command .= "-l $login "        if $login;
						   $command .= "-p \"$password\" " if $password;	# quote the password in case it has spaces in it.
						   $command .= "-n $port "         if $port;
						   $command =~ s/ $//;
						$conf->{node}{$this_node}{fence_method}{$in_method}{device}{$device_count}{command} = $command;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node], fence command: [$conf->{node}{$this_node}{fence_method}{$in_method}{device}{$device_count}{command}]\n");
						if ($agent eq "fence_ipmilan")
						{
							$conf->{node}{$this_node}{info}{power_check_command} = $command;
							#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: power check command: [$conf->{node}{$this_node}{info}{power_check_command}]\n");
						}
						$fence_command .= "$command -o #!action!#; ";
					}
				}
			}
			# Record the fence command.
			$fence_command =~ s/ $/. /;
			if ($node eq $this_node)
			{
				$conf->{node}{$node}{info}{fence_methods} .= "$fence_command";
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: fence command: $conf->{node}{$node}{info}{fence_methods}\n");
			}
			else
			{
				$conf->{node}{$peer}{info}{fence_methods} .= "$fence_command";
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: peer: [$peer], fence command: $conf->{node}{$peer}{info}{fence_methods}\n");
			}
		}
		$conf->{node}{$this_node}{info}{fence_methods} =~ s/\s+$//;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], fence command: [$conf->{node}{$node}{info}{fence_methods}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; peer: [$peer], fence command: [$conf->{node}{$peer}{info}{fence_methods}]\n");
	
	# If the host name was set, then I can trust that I had good data.
	if ($conf->{node}{$node}{info}{host_name})
	{
		# Find out if the nodes are powered up or not.
		write_node_cache($conf, $node);
	}
	
	return(0);
}

# This takes a node name and returns the peer node.
sub get_peer_node
{
	my ($conf, $node) = @_;
	my $peer = "";
	
	my $cluster = $conf->{cgi}{cluster};
	foreach my $this_node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		next if $node eq $this_node;
		$peer = $this_node;
		last;
	}
	
	if (not $peer)
	{
		error($conf, "I was asked to find the peer to: [$node], but failed. This is likely a program error.\n");
	}
	
	return($peer);
}

# Parse the daemon statuses.
sub parse_daemons
{
	my ($conf, $node, $array) = @_;
	
	# If all daemons are down, record here that I can shut down
	# this VM. If any are up, enable withdrawl.
	$conf->{node}{$node}{enable_poweroff} = 0;
	$conf->{node}{$node}{enable_withdraw} = 0;
	
	# I need to preset the services as stopped because the little
	# hack I have below doesn't echo when a service isn't running.
	set_daemons($conf, $node, "Stopped", "highlight_bad");
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_daemons() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if $line !~ /^an-sve:/;
		my ($daemon, $exit_code) = ($line =~ /^.*?:(.*?):(.*?)$/);
		$exit_code = "" if not defined $exit_code;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], exit_code: [$exit_code]\n");
		if ($exit_code eq "0")
		{
			$conf->{node}{$node}{daemon}{$daemon}{status} = "<span class=\"highlight_good\">Running</span>";
			$conf->{node}{$node}{enable_poweroff}         = 0;
		}
		$conf->{node}{$node}{daemon}{$daemon}{exit_code} = defined $exit_code ? $exit_code : "";
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], exit code: [$conf->{node}{$node}{daemon}{$daemon}{exit_code}], status: [$conf->{node}{$node}{daemon}{$daemon}{status}]\n");
	}
	
	# If cman is running, enable withdrawl. If not, enable shut down.
	my $cman_exit      = $conf->{node}{$node}{daemon}{cman}{exit_code};
	my $rgmanager_exit = $conf->{node}{$node}{daemon}{rgmanager}{exit_code};
	my $drbd_exit      = $conf->{node}{$node}{daemon}{drbd}{exit_code};
	my $clvmd_exit     = $conf->{node}{$node}{daemon}{clvmd}{exit_code};
	my $gfs2_exit      = $conf->{node}{$node}{daemon}{gfs2}{exit_code};
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], cman_exit:      [$cman_exit]\n");
	if ($cman_exit eq "0")
	{
		$conf->{node}{$node}{enable_withdraw} = 1;
	}
	else
	{
		# If something went wrong, one of the storage resources might still be running.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rgmanager_exit: [$rgmanager_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], drbd_exit:      [$drbd_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], clvmd_exit:     [$clvmd_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], gfs2_exit:      [$gfs2_exit]\n");
		if (($rgmanager_exit eq "0") ||
		($drbd_exit eq "0") ||
		($clvmd_exit eq "0") ||
		($gfs2_exit eq "0"))
		{
			# Uh oh...
			error($conf, "One of more of the storage daemons are running on $node while the Anvil's cluster is down. This is generally the sign of an unclean withdrawl of a node from the cluster! Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.\n"); 
		}
		else
		{
			# Ready to power off the node, if I was actually able
			# to connect to the node.
			if ($conf->{node}{$node}{connected})
			{
				$conf->{node}{$node}{enable_poweroff} = 1;
			}
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], enable poweroff: [$conf->{node}{$node}{enable_poweroff}], enable withdrawl: [$conf->{node}{$node}{enable_withdraw}]\n");
	#foreach my $daemon (@daemons) { record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], status: [$conf->{node}{$node}{daemon}{$daemon}{status}], exit_code: [$conf->{node}{$node}{daemon}{$daemon}{exit_code}]\n"); }
	
	return(0);
}

# Parse the LVM scan output.
sub parse_lvm_scan
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_lvm_scan() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /(.*?)\s+'(.*?)'\s+\[(.*?)\]/)
		{
			my $state     = $1;
			my $lv        = $2;
			my $size      = $3;
			my $bytes     = hr_to_bytes($conf, $size);
			my $vg        = ($lv =~ /^\/dev\/(.*?)\//)[0];
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], state: [$state], vg: [$vg], lv: [$lv], size: [$size], bytes: [$bytes]\n");
			
			if (lc($state) eq "inactive")
			{
				print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning_bold\">
			Inactive LV!
		</td>
		<td>
			The logical volume: [<span class=\"fixed_width\">$lv</span>] on node: [<span class=\"fixed_width\">$node</span>] is inactive!<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>, or if you are comfortable, active the LV as soon as possible.<br />
		</td>
	</tr>
</table>
<br />
";
			}
			
			if (exists $conf->{resources}{lv}{$lv})
			{
				if (($conf->{resources}{lv}{$lv}{on_vg} ne $vg) || ($conf->{resources}{lv}{$lv}{size} ne $bytes))
				{
					error($conf, "There was a problem when scanning the storage. The nodes report different sizes and/or volume groups for the logical volume: [$lv]. Saw sizes: [$conf->{resources}{lv}{$lv}{size}] vs. [$bytes] and the backing volume group is: [$conf->{resources}{lv}{$lv}{on_vg}] vs [$vg]", 1);
				}
				
			}
			else
			{
				$conf->{resources}{lv}{$lv}{on_vg} = $vg;
				$conf->{resources}{lv}{$lv}{size}  = $bytes;
				#record($conf, "$THIS_FILE ".__LINE__."; lv: [$lv], vg: [$conf->{resources}{lv}{$lv}{on_vg}], size: [$conf->{resources}{lv}{$lv}{size}]\n");
			}
		}
	}
	
	return(0);
}

# Parse the LVM data.
sub parse_lvm_data
{
	my ($conf, $node, $array) = @_;
	
	my $in_pvs = 0;
	my $in_vgs = 0;
	my $in_lvs = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_lvm_data() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^PV/)
		{
			$in_pvs = 1;
			$in_vgs = 0;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^VG/)
		{
			$in_pvs = 0;
			$in_vgs = 1;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^LV/)
		{
			$in_pvs = 0;
			$in_vgs = 0;
			$in_lvs = 1;
			next;
		}
		
		if ($in_pvs)
		{
			# pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			#   pv_name,  vg_name,     pv_fmt,  pv_attr,     pv_size,     pv_free,   pv_used,     pv_uuid
			my ($this_pv, $used_by_vg, $format, $attributes, $total_size, $free_size, $used_size, $uuid) = (split /#!#/, $line);
			$total_size =~ s/B$//;
			$free_size  =~ s/B$//;
			$used_size  =~ s/B$//;
			#record($conf, "$THIS_FILE ".__LINE__."; PV: [$this_pv], used by VG: [$used_by_vg], format: [$format], attributes: [$attributes], total size: [$total_size], free size: [$free_size], used size: [$used_size], uuid: [$uuid]\n");
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_by_vg} = $used_by_vg;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{attributes} = $attributes;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{total_size} = $total_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{free_size}  = $free_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_size}  = $used_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{uuid}       = $uuid;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], PV: [$this_pv], used by VG: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_by_vg}], attributes: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{attributes}], total size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{total_size}], free size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{free_size}], used size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_size}], uuid: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{uuid}]\n");
		}
		elsif ($in_vgs)
		{
			# vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			#   vg_name,  vg_attr,     vg_extent_size, vg_extent_count, vg_uuid, vg_size,  vg_free_count, vg_free,  pv_name
			my ($this_vg, $attributes, $pe_size,       $total_pe,       $uuid,   $vg_size, $free_pe,      $vg_free, $pv_name) = split /#!#/, $line;
			$pe_size    = "" if not defined $pe_size;
			$vg_size    = "" if not defined $vg_size;
			$vg_free    = "" if not defined $vg_free;
			$attributes = "" if not defined $attributes;
			$pe_size =~ s/B$//;
			$vg_size =~ s/B$//;
			$vg_free =~ s/B$//;
			my $used_pe    = $total_pe - $free_pe if (($total_pe) && ($free_pe));
			my $used_space = $vg_size - $vg_free  if (($vg_size) && ($vg_free));
			#record($conf, "$THIS_FILE ".__LINE__."; VG: [$this_vg], attributes: [$attributes], PE size: [$pe_size], total PE: [$total_pe], uuid: [$uuid], VG size: [$vg_size], used PE: [$used_pe], used space: [$used_space], free PE: [$free_pe], free space: [$vg_free], VG free: [$vg_free], pv_name: [$pv_name]\n");
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{clustered}  = $attributes =~ /c$/ ? 1 : 0;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pe_size}    = $pe_size;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{total_pe}   = $total_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{uuid}       = $uuid;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{size}       = $vg_size;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_pe}    = $used_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_space} = $used_space;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_pe}    = $free_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_space} = $vg_free;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pv_name}    = $pv_name;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VG: [$this_vg], clustered: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{clustered}], pe size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pe_size}], total pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{total_pe}], uuid: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{uuid}], size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{size}], used pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_pe}], used space: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_space}], free pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_pe}], free space: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_space}], PV name: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pv_name}]\n");
		}
		elsif ($in_lvs)
		{
			# lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			my ($lv_name, $on_vg, $attributes, $total_size, $uuid, $path, $devices) = (split /#!#/, $line);
			#record($conf, "$THIS_FILE ".__LINE__."; LV name: [$lv_name], on VG: [$on_vg], attributes: [$attributes], total size: [$total_size], uuid: [$uuid], path: [$path], device(s): [$devices]\n");
			$total_size =~ s/B$//;
			$devices    =~ s/\(\d+\)//g;	# Strip the starting PE number
			$conf->{node}{$node}{lvm}{lv}{$path}{name}       = $lv_name;
			$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}      = $on_vg;
			$conf->{node}{$node}{lvm}{lv}{$path}{active}     = ($attributes =~ /.{4}(.{1})/)[0] eq "a" ? 1 : 0;
			$conf->{node}{$node}{lvm}{lv}{$path}{attributes} = $attributes;
			$conf->{node}{$node}{lvm}{lv}{$path}{total_size} = $total_size;
			$conf->{node}{$node}{lvm}{lv}{$path}{uuid}       = $uuid;
			$conf->{node}{$node}{lvm}{lv}{$path}{on_devices} = $devices;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], path: [$path], name: [$conf->{node}{$node}{lvm}{lv}{$path}{name}], on VG: [$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}], active: [$conf->{node}{$node}{lvm}{lv}{$path}{active}], attribute: [$conf->{node}{$node}{lvm}{lv}{$path}{attributes}], total size: [$conf->{node}{$node}{lvm}{lv}{$path}{total_size}], uuid: [$conf->{node}{$node}{lvm}{lv}{$path}{uuid}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$path}{on_devices}]\n");
		}
	}
	
	return(0);
}

# Parse the virsh data.
sub parse_virsh
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_virsh(), node: [$node]\n");
	
	foreach my $line (@{$array})
	{
		next if $line !~ /^\d/;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		my ($id, $say_vm, $state) = split/ /, $line, 3;
		#record($conf, "$THIS_FILE ".__LINE__."; id: [$id], saw vm: [$say_vm], state: [$state]\n");
		
		my $vm = "vm:$say_vm";
		$conf->{vm}{$vm}{node}{$node}{virsh}{'state'} = $state;
		if ($state eq "paused")
		{
			# This VM is being migrated here, disable withdrawl of
			# this node and migration of this VM.
			$conf->{node}{$node}{enable_withdraw} = 0;
			$conf->{vm}{$vm}{can_migrate}         = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
		}
	}
	
	return(0);
}

# Parse the GFS2 data.
sub parse_gfs2
{
	my ($conf, $node, $array) = @_;
	
	my $in_fs = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_gfs2() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Filesystem/)
		{
			$in_fs = 1;
			next;
		}
		
		if ($in_fs)
		{
			next if $line !~ /^\//;
			my ($device_path, $total_size, $used_space, $free_space, $percent_used, $mount_point) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)$/);
			next if not $mount_point;
			$total_size   = "" if not defined $total_size;
			$used_space   = "" if not defined $used_space;
			$free_space   = "" if not defined $free_space;
			$percent_used = "" if not defined $percent_used;
			next if not exists $conf->{node}{$node}{gfs}{$mount_point};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], device path: [$device_path], total size: [$total_size], used space: [$used_space], free space: [$free_space], percent used: [$percent_used], mount point: [$mount_point]\n");
			$conf->{node}{$node}{gfs}{$mount_point}{device_path}  = $device_path;
			$conf->{node}{$node}{gfs}{$mount_point}{total_size}   = $total_size;
			$conf->{node}{$node}{gfs}{$mount_point}{used_space}   = $used_space;
			$conf->{node}{$node}{gfs}{$mount_point}{free_space}   = $free_space;
			$conf->{node}{$node}{gfs}{$mount_point}{percent_used} = $percent_used;
			$conf->{node}{$node}{gfs}{$mount_point}{mounted}      = 1;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], device path: [$conf->{node}{$node}{gfs}{$mount_point}{device_path}], total size: [$conf->{node}{$node}{gfs}{$mount_point}{total_size}], used space: [$conf->{node}{$node}{gfs}{$mount_point}{used_space}], free space: [$conf->{node}{$node}{gfs}{$mount_point}{free_space}], percent used: [$conf->{node}{$node}{gfs}{$mount_point}{percent_used}], mounted: [$conf->{node}{$node}{gfs}{$mount_point}{mounted}]\n");
		}
		else
		{
			# Read the GFS info.
			next if $line !~ /gfs2/;
			my (undef, $mount_point, $fs) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s/);
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], fs: [$fs]\n");
			$conf->{node}{$node}{gfs}{$mount_point}{device_path}  = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{total_size}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{used_space}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{free_space}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{percent_used} = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{mounted}      = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], device path: [$conf->{node}{$node}{gfs}{$mount_point}{device_path}], total size: [$conf->{node}{$node}{gfs}{$mount_point}{total_size}], used space: [$conf->{node}{$node}{gfs}{$mount_point}{used_space}], free space: [$conf->{node}{$node}{gfs}{$mount_point}{free_space}], percent used: [$conf->{node}{$node}{gfs}{$mount_point}{percent_used}], mounted: [$conf->{node}{$node}{gfs}{$mount_point}{mounted}]\n");
		}
	}
	
	return(0);
}

# This sorts out what needs to happen if 'task' was set.
sub process_task
{
	my ($conf) = @_;
	
	if ($conf->{cgi}{task} eq "withdraw")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			withdraw_node($conf);
		}
		else
		{
			confirm_withdraw_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "join_cluster")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			join_cluster($conf);
		}
		else
		{
			confirm_join_cluster($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "dual_join")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			dual_join($conf);
		}
		else
		{
			confirm_dual_join($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "fence_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			fence_node($conf);
		}
		else
		{
			confirm_fence_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "poweroff_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			poweroff_node($conf);
		}
		else
		{
			confirm_poweroff_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "poweron_node")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			poweron_node($conf);
		}
		else
		{
			confirm_poweron_node($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "dual_boot")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			dual_boot($conf);
		}
		else
		{
			confirm_dual_boot($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "start_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			start_vm($conf);
		}
		else
		{
			confirm_start_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "stop_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			stop_vm($conf);
		}
		else
		{
			confirm_stop_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "force_off_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			force_off_vm($conf);
		}
		else
		{
			confirm_force_off_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "delete_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			delete_vm($conf);
		}
		else
		{
			confirm_delete_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "migrate_vm")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			migrate_vm($conf);
		}
		else
		{
			confirm_migrate_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "provision")
	{
		# Confirmed yet?
		if ($conf->{cgi}{confirm})
		{
			if (verify_vm_config($conf))
			{
				# We're golden
				record($conf, "$THIS_FILE ".__LINE__."; VM verified, creating now.\n");
				provision_vm($conf);
			}
			else
			{
				# Something wasn't sane.
				record($conf, "$THIS_FILE ".__LINE__."; VM verification failed.\n");
				confirm_provision_vm($conf);
			}
		}
		else
		{
			confirm_provision_vm($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "add_vm")
	{
		# This is called after provisioning a VM usually, so no need to
		# confirm
		add_vm_to_cluster($conf);
	}
	elsif ($conf->{cgi}{task} eq "manage_vm")
	{
		manage_vm($conf);
	}
	else
	{
		print "<pre>\n";
		foreach my $var (sort {$a cmp $b} keys %{$conf->{cgi}})
		{
			print "var: [$var] -> [$conf->{cgi}{$var}]\n" if $conf->{cgi}{$var};
		}
		print "</pre>";
	}
	
	return(0);
}

# This changes the amount of RAM or the number of CPUs allocated to a VM.
sub change_vm
{
	my ($conf, $node) = @_;
	
	my $cluster             = $conf->{cgi}{cluster};
	my $vm                  = $conf->{cgi}{vm};
	my $say_vm              = ($vm =~ /vm:(.*)/)[0];
	my $node1               = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2               = $conf->{clusters}{$cluster}{nodes}[1];
	my $device              = $conf->{cgi}{device};
	my $definition_file     = "/shared/definitions/$say_vm.xml";
	my $other_allocated_ram = $conf->{resources}{allocated_ram} - $conf->{vm}{$vm}{details}{ram};
	
	# Read the values the user passed, see if they differ from what
	# was read in the config and, if they do differ, make sure the
	# requested resources are available. If all this passes, 
	# rewrite the definition file and tell the user to stop/start
	# their server for the changes to take effect.
	my $current_ram           =  $conf->{vm}{$vm}{details}{ram};
	my $available_ram         =  ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram} - $conf->{resources}{allocated_ram}) + $current_ram;
	   $current_ram           /= 1024;
	my $requested_ram         =  hr_to_bytes($conf, $conf->{cgi}{ram}, $conf->{cgi}{ram_suffix}, 1);
	   $requested_ram         /= 1024;
	my $max_ram               =  $available_ram / 1024;
	my $current_cpus          =  $conf->{vm}{$vm}{details}{cpu_count};
	my $requested_cpus        =  $conf->{cgi}{cpu_cores};
	my $current_boot_device   =  $conf->{vm}{$vm}{current_boot_device};
	my $requested_boot_device =  $conf->{cgi}{boot_device};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - requested RAM:          [$requested_ram]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - current RAM:            [$current_ram]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - requested CPUs: [$requested_cpus]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; - current CPUs:   [$current_cpus]\n");
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<b>Updating the <span class=\"fixed_width\">$say_vm</span> server's CPU, RAM and boot devices...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			<br />
			Changing<br />
			<br />
		</td>
		<td>
";
	# Make sure something changed.
	if (
		($current_ram         ne $requested_ram)         || 
		($current_cpus        ne $requested_cpus)        || 
		($current_boot_device ne $requested_boot_device)
	)
	{
		# Something has changed. Make sure the request is sane,
		my $max_cpus      = $conf->{resources}{total_threads};
		record($conf, "$THIS_FILE ".__LINE__."; requested ram:    [$requested_ram]\n");
		record($conf, "$THIS_FILE ".__LINE__.";       max ram:    [$max_ram]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; requested cpus:   [$requested_cpus]\n");
		#record($conf, "$THIS_FILE ".__LINE__.";       max cpus:   [$max_cpus]\n");
		if ($requested_ram > $max_ram)
		{
			my $say_requested_ram = bytes_to_hr($conf, ($requested_ram * 1024));
			my $say_max_ram       = bytes_to_hr($conf, ($max_ram * 1024));
			print "
				Requested RAM was higher than available.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning!
		</td>
		<td>
			You've requested that the new RAM for this server be: [<span class=\"fixed_width\">$say_requested_ram</span>].<br />
			Unfortunately, the highest you can use is: [<span class=\"fixed_width\">$say_max_ram</span>].<br />
			Did someone else allocate some of the free RAM to another server?<br />
			No changes were made.<br />
		</td>
	</tr>
</table>
<br />
";
		}
		elsif ($requested_cpus > $max_cpus)
		{
			print "
				Requested CPU count was higher than available.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning!
		</td>
		<td>
			You've requested that the CPU count for this server be: [<span class=\"fixed_width\">$requested_cpus</span>].<br />
			Unfortunately, the highest you can use is: [<span class=\"fixed_width\">$max_cpus</span>].<br />
			No changes were made.<br />
		</td>
	</tr>
</table>
<br />
";
		}
		else
		{
			# Request is sane. Archive the current definition.
			my ($backup) = archive_file($conf, $node, $definition_file, 1);
			
			# Make the boot device easier to understand.
			my $say_requested_boot_device = $requested_boot_device;
			if ($requested_boot_device eq "hd")
			{
				$say_requested_boot_device = "Hard drive";
			}
			elsif ($requested_boot_device eq "cdrom")
			{
				$say_requested_boot_device = "Optical drive";
			}
			
			# Rewrite the XML file.
			print "<br />Setting the RAM to [<span class=\"fixed_width\">$conf->{cgi}{ram} $conf->{cgi}{ram_suffix}</span>], the number of CPUs to: [<span class=\"fixed_width\">$requested_cpus</span>] and the boot device to [<span class=\"fixed_width\">$say_requested_boot_device</span>].<br /><br />\n";
			my $new_definition = "";
			my $sc             = "$conf->{path}{ssh} root\@$node \"cat $definition_file\"";
			my $fh             = IO::Handle->new();
			my $in_os          = 0;
			my $raw;
			#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], line: [$line]\n");
				if ($line =~ /^(.*?)<memory>\d+<\/memory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<memory>$requested_ram<\/memory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<memory unit='.*?'>\d+<\/memory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<memory unit='KiB'>$requested_ram<\/memory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<currentMemory>\d+<\/currentMemory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<currentMemory>$requested_ram<\/currentMemory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<currentMemory unit='.*?'>\d+<\/currentMemory>/)
				{
					my $prefix = $1;
					$line = "${prefix}<currentMemory unit='KiB'>$requested_ram<\/currentMemory>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<vcpu>(\d+)<\/vcpu>/)
				{
					my $prefix = $1;
					$line = "${prefix}<vcpu>$requested_cpus<\/vcpu>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /^(.*?)<vcpu placement='(.*?)'>(\d+)<\/vcpu>/)
				{
					my $prefix    = $1;
					my $placement = $2;
					$line = "${prefix}<vcpu placement='$placement'>$requested_cpus<\/vcpu>";
					#record($conf, "$THIS_FILE ".__LINE__."; Changed line:    [$line]\n");
				}
				if ($line =~ /<os>/)
				{
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], going into the OS block.\n");
					$in_os          =  1;
					$new_definition .= "$line\n";
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding line: [$line].\n");
					next;
				}
				if ($in_os)
				{
					if ($line =~ /<\/os>/)
					{
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], exiting the OS block.\n");
						$in_os          =  0;
						# Write out the new list of 
						# boot devices. Start with the
						# requested boot device and 
						# then loop through the rest.
						$new_definition .= "    <boot dev='$requested_boot_device'/>\n";
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding initiall boot device: [$requested_boot_device]\n");
						foreach my $device (split /,/, $conf->{vm}{$vm}{available_boot_devices})
						{
							next if $device eq $requested_boot_device;
							$new_definition .= "    <boot dev='$device'/>\n";
							#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding device: [$device] to boot list\n");
						}
						
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding line: [$line].\n");
						$new_definition .= "$line\n";
						next;
					}
					elsif ($line !~ /<boot dev/)
					{
						$new_definition .= "$line\n";
						#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding to 'os' element line: [$line].\n");
						next;
					}
				}
				else
				{
					$new_definition .= "$line\n";
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Adding line: [$line].\n");
				}
			}
			$fh->close();
			$new_definition =~ s/(\S)\s+$/$1\n/;
			$conf->{vm}{$vm}{available_boot_devices} =~ s/,$//;
			#record($conf, "$THIS_FILE ".__LINE__."; new definition: [$new_definition]\n");
			
			# Write the new definition file.
			$fh = IO::Handle->new();
			$sc = "echo \"$new_definition\" | $conf->{path}{ssh} root\@$node \"cat > $definition_file && chmod 644 $definition_file\"";
			#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				print "\t\t\t<span class=\"code\">$_</span><br />\n";
			}
			$fh->close();
			
			# Wipe and re-read the definition file's XML and reset
			# the amount of RAM and the number of CPUs allocated
			# to this machine.
			$conf->{vm}{$vm}{xml}                = [];	# this is probably redundant
			@{$conf->{vm}{$vm}{xml}}             = split/\n/, $new_definition;
			#record($conf, "$THIS_FILE ".__LINE__."; requested_ram: [$requested_ram KiB (".bytes_to_hr($conf, ($requested_ram * 1024)).")], vm::${vm}::details::ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$conf->{vm}{$vm}{details}{ram}       = ($requested_ram * 1024);
			#record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::details::ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$conf->{resources}{allocated_ram}    = $other_allocated_ram + ($requested_ram * 1024);
			$conf->{vm}{$vm}{details}{cpu_count} = $requested_cpus;
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note_bold\">
			Note!
		</td>
		<td>
			<br />
			<i>You need to power off the server for the changes to take effect.</i><br />
			<br />
			There are two ways to do this:<br />
			<br />
			<table class=\"hidden_table\">
				<tr>
					<td class=\"td_hidden\" style=\"text-align: left;\">
						<span class=\"code\">1.</span> Gracefully power off and then boot back up the server.<br />
						<br />
						<span class=\"code\">2.</span> While logged into your server, directly shut the OS down.<br />
						<span class=\"code\"> &nbsp;</span> The Anvil will automatically restart the server with the new settings.<br />
					</td>
				</tr>
			</table>
			<br />
			Please don't just reboot. The configuration file is read on initial boot only.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><a href=\"?cluster=$conf->{cgi}{cluster}&vm=$conf->{cgi}{vm}&task=manage_vm\" class=\"button\">Back to Configuration</a></div>
		</td>
	</tr>
</table>
<br />
";
			footer($conf);
			exit(0);
		}
	}
	else
	{
		# Nothing changed.
		print "
			It looks like neither the amount of RAM or the number of CPUs has changed.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			No change was made to the server.<br />
		</td>
	</tr>
</table>
<br />
";
	}
	
	return (0);
}

# This inserts an ISO into the server's virtual optical drive.
sub vm_insert_media
{
	my ($conf, $node, $insert_media, $insert_drive, $vm_is_running) = @_;
	
	my $cluster         = $conf->{cgi}{cluster};
	my $vm              = $conf->{cgi}{vm};
	my $say_vm          = ($vm =~ /vm:(.*)/)[0];
	my $node1           = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2           = $conf->{clusters}{$cluster}{nodes}[1];
	my $device          = $conf->{cgi}{device};
	my $definition_file = "/shared/definitions/$say_vm.xml";

	# Archive the current config, just in case.
	my ($backup)   = archive_file($conf, $node, $definition_file, 1);
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<b>Inserting <span class=\"fixed_width\">$insert_media</span> into <span class=\"fixed_width\">$insert_drive</span>...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Inserting
		</td>
		<td>
";
	
	# How I do this depends on whether the VM is running or not.
	if ($vm_is_running)
	{
		# It is, so I will use 'virsh'.
		my $virsh_exit_code;
		my $sc   = "$conf->{path}{ssh} root\@$node \"virsh change-media $say_vm $insert_drive --insert /shared/files/$insert_media; echo virsh:\\\$?\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		my $raw;
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			next if not $line;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ /virsh:(\d+)/)
			{
				$virsh_exit_code = $1;
			}
			else
			{
				print "<span class=\"code\">$line</span><br />\n";
			}
		}
		$fh->close();
		if ($virsh_exit_code eq "1")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Note
		</td>
		<td>
			It looks like someone else already inserted a disc.<br />
		</td>
	</tr>
</table>
<br />
";
			# Update the definition file in case it was missed by .
			update_vm_definition($conf, $node, $vm);
		}
		elsif ($virsh_exit_code eq "0")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Success
		</td>
		<td>
			The disc was inserted successfully.<br />
		</td>
	</tr>
</table>
<br />
";

			# Update the definition file.
			update_vm_definition($conf, $node, $vm);
		}
		else
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to insert the disc: [$insert_media] into the drive: [$insert_drive] and the command should have returned [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$virsh_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		}
	}
	else
	{
		# The VM isn't running. Directly re-write the XML file.
		print "The machine is shut off.<br />\n";
		print "Updating <span class=\"fixed_width\">$say_vm</span>'s definition file directly.<br />\n";
		my $new_definition = "";
		my $sc             = "$conf->{path}{ssh} root\@$node \"cat $definition_file\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		my $raw;
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /dev='(.*?)'/)
			{
				my $this_device = $1;
				record($conf, "$THIS_FILE ".__LINE__."; Found the device: [$this_device].\n");
				if ($this_device eq $insert_drive)
				{
					$new_definition .= "      <source file='/shared/files/$insert_media'/>\n";
				}
			}
			$new_definition .= "$line\n";
		}
		$fh->close();
		$new_definition =~ s/(\S)\s+$/$1\n/;
		#record($conf, "$THIS_FILE ".__LINE__."; new definition: [$new_definition]\n");
		
		# Write the new definition file.
		print "\t\t\tSaving the new configuration...<br />\n";
		$fh = IO::Handle->new();
		$sc = "echo \"$new_definition\" | $conf->{path}{ssh} root\@$node \"cat > $definition_file && chmod 644 $definition_file\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			print "\t\t\t<span class=\"code\">$_</span><br />\n";
		}
		$fh->close();
		print "
			Done!
			<br />
		</td>
	</tr>
</table>
<br />
";
		# Lastly, copy the new definition to the stored XML for
		# this VM.
		$conf->{vm}{$vm}{xml}    = [];	# this is probably redundant
		@{$conf->{vm}{$vm}{xml}} = split/\n/, $new_definition;
	}
	
	return(0);
}

# This ejects an ISO from a server's virtual optical drive.
sub vm_eject_media
{
	my ($conf, $node, $vm_is_running) = @_;
	
	my $cluster         = $conf->{cgi}{cluster};
	my $vm              = $conf->{cgi}{vm};
	my $say_vm          = ($vm =~ /vm:(.*)/)[0];
	my $node1           = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2           = $conf->{clusters}{$cluster}{nodes}[1];
	my $device          = $conf->{cgi}{device};
	my $definition_file = "/shared/definitions/$say_vm.xml";
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<b>Ejecting $conf->{cgi}{device}...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Ejecting
		</td>
		<td>
";
	
	# Archive the current config, just in case.
	my ($backup) = archive_file($conf, $node, $definition_file, 1);
	my $drive    = $conf->{cgi}{device};
	
	# How I do this depends on whether the VM is running or not.
	if ($vm_is_running)
	{
		# It is, so I will use 'virsh'.
		my $virsh_exit_code;
		my $sc   = "$conf->{path}{ssh} root\@$node \"virsh change-media $say_vm $conf->{cgi}{device} --eject; echo virsh:\\\$?\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		my $raw;
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			next if not $line;
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ /virsh:(\d+)/)
			{
				$virsh_exit_code = $1;
			}
			else
			{
				print "<span class=\"code\">$line</span><br />\n";
			}
		}
		$fh->close();
		if ($virsh_exit_code eq "1")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Note
		</td>
		<td>
			It would appear that someone else already ejected the disc.<br />
		</td>
	</tr>
</table>
<br />
";
			# Update the definition file in case it was missed by .
			update_vm_definition($conf, $node, $vm);
		}
		elsif ($virsh_exit_code eq "0")
		{
			print "
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Success
		</td>
		<td>
			The optical drive's media has been ejected.<br />
		</td>
	</tr>
</table>
<br />
";
			
			# Update the definition file.
			update_vm_definition($conf, $node, $vm);
		}
		else
		{
			$virsh_exit_code = "-" if not defined $virsh_exit_code;
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to eject the disc in drive: [<span class=\"fixed_width\">$drive</span>] and the command should have returned [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$virsh_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		}
	}
	else
	{
		# The VM isn't running. Directly re-write the XML file.
		print "The machine is shut off.<br />\n";
		print "Updating <span class=\"fixed_width\">$say_vm</span>'s definition file directly.<br />\n";
		my $in_cdrom       = 0;
		my $this_media     = "";
		my $this_device    = "";
		my $new_definition = "";
		my $sc             = "$conf->{path}{ssh} root\@$node \"cat $definition_file\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		my $raw;
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			$new_definition .= $_;
			chomp;
			my $line = $_;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if (($line =~ /type='file'/) && ($line =~ /device='cdrom'/))
			{
				record($conf, "$THIS_FILE ".__LINE__."; Found a cdrom disk.\n");
				$in_cdrom = 1;
			}
			if ($in_cdrom)
			{
				if ($line =~ /file='(.*?)'\/>/)
				{
					$this_media = $1;
					record($conf, "$THIS_FILE ".__LINE__."; Found the media: [$this_media].\n");
				}
				if ($line =~ /dev='(.*?)'/)
				{
					$this_device = $1;
					record($conf, "$THIS_FILE ".__LINE__."; Found the device: [$this_device].\n");
				}
				if ($line =~ /<\/disk>/)
				{
					record($conf, "$THIS_FILE ".__LINE__."; Checking if: [$this_device] is the device: [$conf->{cgi}{device}] I want to eject...\n");
					if ($this_device eq $conf->{cgi}{device})
					{
						# This is the device I want to unmount.
						record($conf, "$THIS_FILE ".__LINE__."; It is!\n");
						$new_definition =~ s/<disk(.*?)device='cdrom'(.*?)<source file='$this_media'\/>\s+(.*?)<\/disk>/<disk${1}device='cdrom'${2}${3}<\/disk>/s;
					}
					else
					{
						record($conf, "$THIS_FILE ".__LINE__."; It is not.\n");
					}
					$in_cdrom    = 0;
					$this_device = "";
					$this_media  = "";
				}
			}
		}
		$fh->close();
		$new_definition =~ s/(\S)\s+$/$1\n/;
		#record($conf, "$THIS_FILE ".__LINE__."; new definition: [$new_definition]\n");
		
		# Write the new definition file.
		print "\t\t\tSaving the new configuration...<br />\n";
		$fh = IO::Handle->new();
		$sc = "echo \"$new_definition\" | $conf->{path}{ssh} root\@$node \"cat > $definition_file && chmod 644 $definition_file\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			print "\t\t\t<span class=\"code\">$_</span><br />\n";
		}
		$fh->close();
		print "
			Done!
			<br />
		</td>
	</tr>
</table>
<br />
";
		# Lastly, copy the new definition to the stored XML for
		# this VM.
		$conf->{vm}{$vm}{xml}    = [];	# this is probably redundant
		@{$conf->{vm}{$vm}{xml}} = split/\n/, $new_definition;
	}
	
	return(0);
}

# This shows or changes the configuration of the VM, including mounted media.
sub manage_vm
{
	my ($conf) = @_;
	
	# I need to get a list of the running VM's resource/media, read the
	# VM's current XML if it's up, otherwise read the stored XML, read the
	# available ISOs and then display everything in a form. If the user
	# submits the form and something is different, re-write the stored 
	# config and, if possible, make the required changes immediately.
	my $cluster         = $conf->{cgi}{cluster};
	my $vm              = $conf->{cgi}{vm};
	my $say_vm          = ($vm =~ /vm:(.*)/)[0];
	my $node1           = $conf->{clusters}{$cluster}{nodes}[0];
	my $node2           = $conf->{clusters}{$cluster}{nodes}[1];
	my $device          = $conf->{cgi}{device};
	my $definition_file = "/shared/definitions/$say_vm.xml";
	
	# First, see if the VM is up.
	scan_cluster($conf);
	
	# Count how much RAM and CPU cores have been allocated.
	$conf->{resources}{available_ram}   = 0;
	$conf->{resources}{max_cpu_cores}   = 0;
	$conf->{resources}{allocated_cores} = 0;
	$conf->{resources}{allocated_ram}   = 0;
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		# I check GFS2 because, without it, I can't read the VM's details.
		if ($conf->{'system'}{gfs2_down})
		{
			$conf->{resources}{allocated_ram}   = "--";
			$conf->{resources}{allocated_cores} = "--";
		}
		else
		{
			$conf->{resources}{allocated_ram}   += $conf->{vm}{$vm}{details}{ram};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_ram: [$conf->{resources}{allocated_ram}], vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$conf->{resources}{allocated_cores} += $conf->{vm}{$vm}{details}{cpu_count};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_cores: [$conf->{resources}{allocated_cores}], vm: [$vm], cpu_count: [$conf->{vm}{$vm}{details}{cpu_count}]\n");
		}
	}
	
	# First up, if the cluster is not running, go no further.
	#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::daemon::gfs2::exit_code: [$conf->{node}{$node1}{daemon}{gfs2}{exit_code}], node::${node2}::daemon::gfs2::exit_code: [$conf->{node}{$node2}{daemon}{gfs2}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{gfs2}{exit_code}) && ($conf->{node}{$node2}{daemon}{gfs2}{exit_code}))
	{
		print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning_bold\">
			Not Ready
		</td>
		<td>
			I am sorry, but the Anvil's storage isn't running on either node.<br />
			Please try again once the Anvil's storage has started on at least one of the nodes.<br />
		</td>
	</tr>
</table>
<br />
";
	}
	
	# Now choose the node to work through.
	my $node;
	my $vm_is_running = 0;
	record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::current_host: [$conf->{vm}{$vm}{current_host}]\n");
	if ($conf->{vm}{$vm}{current_host})
	{
		# Read the current VM config from virsh.
		$vm_is_running = 1;
		$node          = $conf->{vm}{$vm}{current_host};
		record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm] is running on: [$node], will read: [$conf->{vm}{$vm}{definition_file}].\n");
	}
	else
	{
		# The VM isn't running.
		if ($conf->{node}{$node1}{daemon}{gfs2}{exit_code} eq "0")
		{
			# Node 1 is up.
			$node = $node1;
		}
		else
		{
			# Node 2 must be up.
			$node = $node2;
		}
		record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm] is not running, will read: [$conf->{vm}{$vm}{definition_file}]. Will use: [$node].\n");
	}
	
	# Find the list of bootable devices and present them in a selection
	# box.
	my $boot_select = "<select name=\"boot_device\" style=\"width: 165px;\">";
	#record($conf, "$THIS_FILE ".__LINE__."; boot select: [$boot_select].\n");
	$conf->{vm}{$vm}{current_boot_device}    = "";
	$conf->{vm}{$vm}{available_boot_devices} = "";
	my $say_current_boot_device              = "";
	my $in_os                                = 0;
	my $saw_cdrom                            = 0;
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; in_os: [$in_os] vm: [$vm], xml line: [$line].\n");
		last if $line =~ /<\/domain>/;
		
		if ($line =~ /<os>/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], going into the OS block.\n");
			$in_os = 1;
			next;
		}
		if ($in_os == 1)
		{
			if ($line =~ /<\/os>/)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], exiting the OS block.\n");
				$in_os = 0;
				if ($saw_cdrom)
				{
					last;
				}
				else
				{
					# I didn't see a CD-ROM boot option, so
					# keep looking.
					$in_os = 2;
				}
			}
			elsif ($line =~ /<boot dev='(.*?)'/)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], OS boot line: [$line].\n");
				my $device                               =  $1;
				my $say_device                           =  $device;
				$conf->{vm}{$vm}{available_boot_devices} .= "$device,";
				if ($device eq "hd")
				{
					$say_device = "Hard Drive";
				}
				elsif ($device eq "cdrom")
				{
					$say_device = "Optical Drive";
					$saw_cdrom  = 1;
				}
				
				my $selected = "";
				if (not $conf->{vm}{$vm}{current_boot_device})
				{
					$conf->{vm}{$vm}{current_boot_device} = $device;
					$say_current_boot_device = $say_device;
					$selected = "selected";
				}
				
				$boot_select .= "<option value=\"$device\" $selected>$say_device</option>";
				#record($conf, "$THIS_FILE ".__LINE__."; boot select: [$boot_select].\n");
			}
		}
		elsif ($in_os == 2)
		{
			# I'm out of the OS block, but I haven't seen a CD-ROM
			# yet, so keep looping and looking for one.
			if ($line =~ /<disk .*?device='cdrom'/)
			{
				# There is a CD-ROM, add it as a boot option.
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], Found a CDROM drive, adding it as a boot option.\n");
				my $say_device  =  "Optical Drive";
				   $boot_select .= "<option value=\"cdrom\">$say_device</option>";
				   $in_os = 0;
				last;
			}
		}
	}
	$boot_select .= "</select>";
	#record($conf, "$THIS_FILE ".__LINE__."; boot select: [$boot_select].\n");
	
	# If I need to change the number of CPUs or the amount of RAM, do so
	# now.
	if ($conf->{cgi}{change})
	{
		change_vm($conf, $node);
	}
	
	# If I've been asked to insert a disc, do so now.
	my $do_insert    = 0;
	my $insert_media = "";
	my $insert_drive = "";
	foreach my $key (split/,/, $conf->{cgi}{device_keys})
	{
		next if not $key;
		next if not $conf->{cgi}{$key};
		my $device_key = $key;
		$insert_drive  = ($key =~ /media_(.*)/)[0];
		my $insert_key = "insert_${insert_drive}";
		if ($conf->{cgi}{$insert_key})
		{
			$do_insert    = 1;
			$insert_media = $conf->{cgi}{$device_key};
		}
	}
	
	### TODO: Merge insert and eject into one function.
	#record($conf, "$THIS_FILE ".__LINE__."; do_insert: [$do_insert], insert_drive: [$insert_drive], insert_media: [$insert_media]\n");
	if ($do_insert)
	{
		vm_insert_media($conf, $node, $insert_media, $insert_drive, $vm_is_running);
	}
	
	# If I've been asked to eject a disc, do so now.
	if ($conf->{cgi}{'do'} eq "eject")
	{
		vm_eject_media($conf, $node, $vm_is_running);
	}
	
	# Get the list of files on the /shared/files/ directory.
	my $sc = "$conf->{path}{ssh} -o ConnectTimeout=10 root\@$node \"df -P && ls -l /shared/files/\"";
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	my $raw;
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
		if ($line =~ /\s(\d+)-blocks\s/)
		{
			$conf->{partition}{shared}{block_size} = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; block_size: [$conf->{partition}{shared}{block_size}]\n");
		}
		elsif ($line =~ /^\/.*?\s+(\d+)\s+(\d+)\s+(\d+)\s(\d+)%\s+\/shared/)
		{
			$conf->{partition}{shared}{total_space}  = $1;
			$conf->{partition}{shared}{used_space}   = $2;
			$conf->{partition}{shared}{free_space}   = $3;
			$conf->{partition}{shared}{used_percent} = $4;
			#record($conf, "$THIS_FILE ".__LINE__."; total_space: [$conf->{partition}{shared}{total_space}], used_space: [$conf->{partition}{shared}{used_space} / $conf->{partition}{shared}{used_percent}%], free_space: [$conf->{partition}{shared}{free_space}]\n");
		}
		elsif ($line =~ /^(\S)(\S+)\s+\d+\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(.*)$/)
		{
			my $type   = $1;
			my $mode   = $2;
			my $user   = $3;
			my $group  = $4;
			my $size   = $5;
			my $month  = $6;
			my $day    = $7;
			my $time   = $8; # might be a year, look for '\d+:\d+'.
			my $file   = $9;
			my $target = "";
			if ($type eq "l")
			{
				# It's a symlink, strip off the destination.
				($file, $target) = ($file =~ /^(.*?) -> (.*)$/);
			}
			$conf->{files}{shared}{$file}{type}   = $type;
			$conf->{files}{shared}{$file}{mode}   = $mode;
			$conf->{files}{shared}{$file}{user}   = $user;
			$conf->{files}{shared}{$file}{group}  = $group;
			$conf->{files}{shared}{$file}{size}   = $size;
			$conf->{files}{shared}{$file}{month}  = $month;
			$conf->{files}{shared}{$file}{day}    = $day;
			$conf->{files}{shared}{$file}{'time'} = $time; # might be a year, look for '\d+:\d+'.
			$conf->{files}{shared}{$file}{target} = $target;
			#record($conf, "$THIS_FILE ".__LINE__."; file: [$file], mode: [$conf->{files}{shared}{$file}{type}, $conf->{files}{shared}{$file}{mode}], owner: [$conf->{files}{shared}{$file}{user} / $conf->{files}{shared}{$file}{group}], size: [$conf->{files}{shared}{$file}{size}], modified: [$conf->{files}{shared}{$file}{month} $conf->{files}{shared}{$file}{day} $conf->{files}{shared}{$file}{'time'}], target: [$conf->{files}{shared}{$file}{target}]\n");
		}
	}
	$fh->close();

	# Find which ISOs are mounted currently.
	my $this_device = "";
	my $this_media  = "";
	my $in_cdrom    = 0;
	### TODO: Find out why the XML data is doubled up.
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], xml line: [$line].\n");
		last if $line =~ /<\/domain>/;
		if ($line =~ /device='cdrom'/)
		{
			$in_cdrom = 1;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], going into a CD-ROM child element on: [$line].\n");
		}
		elsif (($line =~ /<\/disk>/) && ($in_cdrom))
		{
			# Record what I found/
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], exiting a CD-ROM child element on: [$line].\n");
			$conf->{vm}{$vm}{cdrom}{$this_device}{media} = $this_media ? $this_media : "";
			#record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::cdrom::${this_device}::media: [$conf->{vm}{$vm}{cdrom}{$this_device}{media}].\n");
			$in_cdrom    = 0;
			$this_device = "";
			$this_media  = "";
		}
		
		if ($in_cdrom)
		{
			if ($line =~ /source file='(.*?)'/)
			{
				$this_media = $1;
				$this_media =~ s/^.*\/(.*?)$/$1/;
			}
			elsif ($line =~ /target dev='(.*?)'/)
			{
				$this_device = $1;
			}
		}
	}

	#record($conf, "$THIS_FILE ".__LINE__."; current_cpu_count: [$current_cpu_count], current_ram: [$current_ram (".bytes_to_hr($conf, $current_ram).")], available_ram: [$available_ram (".bytes_to_hr($conf, $available_ram).")]\n");
	my $current_cpu_count = $conf->{vm}{$vm}{details}{cpu_count};
	my $max_cpu_count     = $conf->{resources}{total_threads};
	#record($conf, "$THIS_FILE ".__LINE__."; max_ram: [$max_ram (".bytes_to_hr($conf, $max_ram).")], max_cpu_count: [$max_cpu_count]\n");
	
	# Create the media select boxes.
	foreach my $device (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{cdrom}})
	{
		my $key                                      =  "media_$device";
		$conf->{vm}{$vm}{cdrom}{device_keys}         .= "$key,";
		if ($conf->{vm}{$vm}{cdrom}{$device}{media})
		{
			### TODO: If the media no longer exists, re-write the
			###       XML definition immediately.
			# Offer the eject button.
			$conf->{vm}{$vm}{cdrom}{$device}{say_select}   = "<select name=\"$key\" disabled>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_in_drive} = "<span class=\"fixed_width\">$conf->{vm}{$vm}{cdrom}{$device}{media}</span>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_eject}    = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$conf->{cgi}{vm}&task=manage_vm&do=eject&device=$device\" class=\"button\">Eject</a>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_insert}   = "<span class=\"highlight_unavailable\">Insert</span>\n";
		}
		else
		{
			# Offer the insert button
			$conf->{vm}{$vm}{cdrom}{$device}{say_select}   = "<select name=\"$key\">\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_in_drive} = "<span class=\"highlight_unavailable\">(no disc)</span>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_eject}    = "<span class=\"highlight_unavailable\">Eject</span>\n";
			$conf->{vm}{$vm}{cdrom}{$device}{say_insert}   = "<input type=\"submit\" name=\"insert_$device\" value=\"Insert\" class=\"button\">\n";
		}
		foreach my $file (sort {$a cmp $b} keys %{$conf->{files}{shared}})
		{
			next if ($file eq $conf->{vm}{$vm}{cdrom}{$device}{media});
			#record($conf, "$THIS_FILE ".__LINE__."; file: [$file], cgi::${key}: [$conf->{cgi}{$key}]\n");
			if ((defined $conf->{cgi}{$key}) && ($file eq $conf->{cgi}{$key}))
			{
				$conf->{vm}{$vm}{cdrom}{$device}{say_select} .= "<option name=\"$file\" selected>$file</option>\n";
			}
			else
			{
				$conf->{vm}{$vm}{cdrom}{$device}{say_select} .= "<option name=\"$file\">$file</option>\n";
			}
		}
		$conf->{vm}{$vm}{cdrom}{$device}{say_select} .= "</select>\n";
		#record($conf, "$THIS_FILE ".__LINE__."; Media in: [$device] -> [$conf->{vm}{$vm}{cdrom}{$device}{media}]. [Select: $conf->{vm}{$vm}{cdrom}{$device}{say_select}]\n");
	}
	
	# Allow the user to select the number of CPUs.
	my $cpu_cores = [];
	foreach my $core_num (1..$max_cpu_count)
	{
		if ($max_cpu_count > 9)
		{
			#push @{$cpu_cores}, sprintf("%.2d", $core_num);
			push @{$cpu_cores}, $core_num;
		}
		else
		{
			push @{$cpu_cores}, $core_num;
		}
	}
	$conf->{cgi}{cpu_cores} = $current_cpu_count if not $conf->{cgi}{cpu_cores};
	my $select_cpu_cores    = build_select($conf, "cpu_cores", 0, 0, 60, $conf->{cgi}{cpu_cores}, $cpu_cores);
	#record($conf, "$THIS_FILE ".__LINE__."; select_cpu_cores: [$select_cpu_cores]\n");
	
	# Something has changed. Make sure the request is sane,
	my $current_ram   = $conf->{vm}{$vm}{details}{ram};
	my $available_ram = ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram} - $conf->{resources}{allocated_ram}) + $current_ram;
	my $max_ram       = $available_ram;
	
	# If the user sets the RAM to less than 1 GiB, warn them. If the user
	# sets the RAM to less that 32 MiB, error out.
	my $say_max_ram          = bytes_to_hr($conf, $max_ram);
	my $say_current_ram      = bytes_to_hr($conf, $current_ram);
	my ($current_ram_value, $current_ram_suffix) = (split/ /, $say_current_ram);
	$conf->{cgi}{ram}        = $current_ram_value if not $conf->{cgi}{ram};
	$conf->{cgi}{ram_suffix} = $current_ram_suffix if not $conf->{cgi}{ram_suffix};
	my $select_ram_suffix    = build_select($conf, "ram_suffix", 0, 0, 60, $conf->{cgi}{ram_suffix}, ["MiB", "GiB"]);
	#record($conf, "$THIS_FILE ".__LINE__."; (<span class=\"subtle_text\">Maximum $say_max_ram</span>) <input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix\n");
	
	# Finally, print it all
	print "
<table align=\"center\">
	<form method=\"post\">
	<tr>
		<td colspan=\"4\">
			<b>Manage <span class=\"fixed_width\">$say_vm</span>.</b>
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"4\"></td></tr>
";

	my $i = 1;
	foreach my $device (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{cdrom}})
	{
		next if $device eq "device_keys";
		my $say_disk   = $conf->{vm}{$vm}{cdrom}{$device}{say_select};
		my $say_button = $conf->{vm}{$vm}{cdrom}{$device}{say_insert};
		my $say_state  = "Drive empty";
		if ($conf->{vm}{$vm}{cdrom}{$device}{media})
		{
			$say_disk   = $conf->{vm}{$vm}{cdrom}{$device}{say_in_drive};
			$say_button = $conf->{vm}{$vm}{cdrom}{$device}{say_eject};
			$say_state  = "Disc in drive";
		}
		print "
	<tr>
		<td class=\"highlight_good_bold\">
			Optical Drive $i
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">$say_state</span><br />
			$say_disk
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_button
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"5\"></td></tr>
";
		$i++;
	}
	
	### NOTE: This is likely not going to happen in this version.
# 	# Figure out which storage pool the server is on.
# 	my ($on_vg, $lv_size) = find_node_storage_pool($conf);
# 	
# 	# Now that I know the LV, get it's size and parse out the VG.
# 	my $printed_header = 0;
# 	my @candidate_vgs;
# 	foreach my $vg (sort {$a cmp $b} keys %{$conf->{resources}{vg}})
# 	{
# 		next if $vg eq $on_vg;
# 		my $clustered   = $conf->{resources}{vg}{$vg}{clustered};
# 		my $free_space  = $conf->{resources}{vg}{$vg}{free_space};
# 		my $used_space  = $conf->{resources}{vg}{$vg}{used_space};
# 		my $total_space = $conf->{resources}{vg}{$vg}{size};
# 		
# 		if (($clustered) && ($lv_size >= $free_space))
# 		{
# 			if (not $printed_header)
# 			{
# 				print "
# 	<tr>
# ";
# 			}
# 			print "
# 		<td class=\"highlight_good_bold\">
# 			Storage
# 		</td>
# 		<td>
# 			Permanently move to storage pool <span class=\"fixed_width\">$vg</span>
# 		</td>
# 		<td>
# 			<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$conf->{vm}{$vm}&task=move_storage&target=$vg\">Permanently Move</a>
# 		</td>
# ";
# # 			my $string = "vg=$vg,clustered=1,free_space=$free_space,used_space=$used_space,total_space=$total_space";
# # 			push @candidate_vgs, $string;
# # 			record($conf, "$THIS_FILE ".__LINE__."; candidate target vg: [$vg] ($string)\n");
# 		}
# 	}
# 	if ($printed_header)
# 	{
# 		# Print the footer
# 		print "
# 	</tr>
# 	<tr><td style=\"height:10px; padding:0px\" colspan=\"3\"></td></tr>
# ";
# 	}
	
	
	print "
	<tr>
		<td class=\"highlight_good_bold\">
			Boot Drive:
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">Currently booting from the $say_current_boot_device.</span><br />
			$boot_select
		</td>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\" rowspan=\"5\">
			<input type=\"submit\" name=\"change\" value=\"Change\" class=\"button\">
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"3\"></td></tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Memory (RAM):
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">Currently $say_current_ram, Maximum $say_max_ram</span><br />
			<input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
	<tr><td style=\"height:10px; padding:0px\" colspan=\"3\"></td></tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Number of CPUs:
		</td>
		<td style=\"text-align: left;\">
			<span class=\"subtle_text\">Currently $conf->{vm}{$vm}{details}{cpu_count}</span><br />
			$select_cpu_cores
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
	<tr>
		<td colspan=\"4\">
			<input type=\"hidden\" name=\"cluster\" value=\"$conf->{cgi}{cluster}\">
			<input type=\"hidden\" name=\"vm\" value=\"$conf->{cgi}{vm}\">
			<input type=\"hidden\" name=\"task\" value=\"$conf->{cgi}{task}\">
			<input type=\"hidden\" name=\"device_keys\" value=\"$conf->{vm}{$vm}{cdrom}{device_keys}\">
			<!-- <div class=\"align_right\"><input type=\"submit\" name=\"change\" value=\"Change\" class=\"button\"></div> -->
			&nbsp;
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# This looks at a VM and determines which storage pool it is on.
sub find_node_storage_pool
{
	my ($conf) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in find_node_storage_pool().\n");
	
	my $vm     = $conf->{cgi}{vm};
	my $say_vm = ($vm =~ /^vm:(.*)/)[0];
	
	my $current_lv = "";
	my $in_block   = 0;
	foreach my $line (sort {$a cmp $b} @{$conf->{vm}{$vm}{xml}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm], xml line: [$line]\n");
		if (($line =~ /<disk/) && ($line =~ /type='block'/))
		{
			$in_block = 1;
			next;
		}
		if ($in_block)
		{
			if ($line =~ /<\/disk>/)
			{
				$in_block = 0;
				next;
			}
			elsif (($line =~ /source/) && ($line =~ /dev='(.*?)'/))
			{
				$current_lv = $1;
				last;
			}
		}
	}
	my $lv_size = $conf->{resources}{lv}{$current_lv}{size};
	my $on_vg   = $conf->{resources}{lv}{$current_lv}{on_vg};
	record($conf, "$THIS_FILE ".__LINE__."; vm: [$say_vm], current_lv: [$current_lv], size: [$lv_size], on_vg: [$on_vg]\n");
	
	return($on_vg, $lv_size);
}

# This calls 'virsh dumpxml' against the given VM.
sub update_vm_definition
{
	my ($conf, $node, $vm) = @_;
	my $say_vm = $vm;
	if ($vm =~ /^vm:(.*)/)
	{
		$say_vm = $1;
	}
	else
	{
		$vm = "vm:$vm";
	}
	my $definition_file = $conf->{vm}{$vm}{definition_file};
	record($conf, "$THIS_FILE ".__LINE__."; in update_vm_definition(); node: [$node], vm: [$vm], say_vm: [$say_vm], definition_file: [$definition_file]\n");
	
	my $virsh_exit_code;
	my $sc = "$conf->{path}{ssh} root\@$node \"virsh dumpxml $say_vm > $definition_file; echo virsh:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /virsh:(\d+)/)
		{
			$virsh_exit_code = $1;
		}
		else
		{
			#print "<span class=\"code\">$line</span><br />\n";
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
	if ($virsh_exit_code eq "0")
	{
		# Delete the old definition values and read the new one.
		$conf->{vm}{$vm}{xml} = "";
		read_vm_definition($conf, $node, $vm);
	}
	else
	{
		$virsh_exit_code = "-" if not defined $virsh_exit_code;
		print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to update the definition file for: [<span class=\"fixed_width\">$say_vm</span>] and the command should have returned [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$virsh_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return($virsh_exit_code);
	}
	return(0);
}

sub add_vm_to_cluster
{
	my ($conf) = @_;
	
	# Two steps needed; Dump the definition and use ccs to add it to the 
	# cluster.
	my $cluster    = $conf->{cgi}{cluster};
	my $vm         = $conf->{cgi}{name};
	my $node       = $conf->{cgi}{node};
	my $definition = "/shared/definitions/$vm.xml";
	my $peer;
	foreach my $this_node (@{$conf->{clusters}{$cluster}{nodes}})
	{
		if ($this_node ne $node)
		{
			$peer = $this_node;
		}
	}
	my $failover_domain;
	
	# First, find the failover domain...
	$conf->{'system'}{ignore_missing_vm} = 1;
	scan_cluster($conf);
	foreach my $fod (keys %{$conf->{failoverdomain}})
	{
		record($conf, "$THIS_FILE ".__LINE__."; fod: [$fod]\n");
		if ($fod =~ /primary_(.*?)$/)
		{
			my $node_suffix = $1;
			record($conf, "$THIS_FILE ".__LINE__."; node_suffix: [$node_suffix]\n");
			if ($node =~ /$node_suffix/)
			{
				$failover_domain = $fod;
				record($conf, "$THIS_FILE ".__LINE__."; failover_domain: [$failover_domain]\n");
				last;
			}
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; Using failover domain: [$failover_domain]\n");
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<b>Adding the new <span class=\"fixed_width\">$vm</span> server to the cluster's <span class=\"fixed_width\">$failover_domain</span> failover domain.
		</td>
	</tr>
	";

	if (not $failover_domain)
	{
		print "
	<tr>
		<td class=\"highlight_bad_bold\">
			Error
		</td>
		<td>
			I was unable to determine which failover domain to use for this new machine.<br />
			<br />
			I am sorry, but without this information, I can not continue.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
		";
		return (1);
	}
	
	print "
	<tr>
		<td class=\"highlight_good_bold\">
			Checking VM State
		</td>
		<td>
			<br />
			Checking now to make sure the new virtual server is up and running.
			<br />
	";

	# On occasion, the installed VM will power off, not reboot. So this
	# checks to see if the VM needs to be kicked awake.
	my ($host) = find_vm_host($conf, $node, $peer, $vm);
	if ($host eq "none")
	{
		print "It is not running at the moment, I will now boot the VM.<br />\n";
		record($conf, "$THIS_FILE ".__LINE__."; I will now boot the VM.\n");
		my $virsh_exit_code;
		my $sc = "$conf->{path}{ssh} root\@$node \"virsh start $vm; echo virsh:\\\$?\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			next if not $line;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /virsh:(\d+)/)
			{
				$virsh_exit_code = $1;
			}
		}
		$fh->close();
		record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
		if ($virsh_exit_code eq "0")
		{
			print "It should now be booting up.<br />\n";
		}
		else
		{
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			The new <span class=\"fixed_width\">$vm</span> server didn't start on reboot.<br />
			I tried to start it, but the command should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
			return (1);
		}
	}
	elsif ($host eq $node)
	{
		print "It is already running, as expected.<br />\n";
	}
	else
	{
		$node = $host;
		print "The VM is now running on the peer. I will use that node for the next steps.<br />\n";
		record($conf, "$THIS_FILE ".__LINE__."; The VM is now running on the peer. Will proceed using: [$node].\n");
	}
	
	# Dump the VM's XML definition.
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Creating Definition
		</td>
		<td>
			<br />
			The cluster needs to know what \"hardware\" to create for the new virtual server when it starts.<br />
			This is done using a \"definition\" file, which I will record now.
	";

	my $virsh_exit_code;
	my $sc = "$conf->{path}{ssh} root\@$node \"virsh dumpxml $vm > $definition; echo virsh:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /virsh:(\d+)/)
		{
			$virsh_exit_code = $1;
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
	if ($virsh_exit_code eq "0")
	{
		print "Saved successfully as <span class=\"fixed_width\">$definition</span>.<br />\n";
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			It would appear that something went wrong!<br />
			I tried to record the definition file and the command should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
";
		return (1);
	}

	# Undefine the new VM
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Removing libvirtd definition
		</td>
		<td>
			<br />
			We only want the cluster to be able to see and start the new server.<br />
			Removing the <span class=\"fixed_width\">libvirtd</span> definition now.<br />
	";

	undef $virsh_exit_code;
	$sc = "$conf->{path}{ssh} root\@$node \"virsh undefine $vm; echo virsh:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /virsh:(\d+)/)
		{
			$virsh_exit_code = $1;
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
	if ($virsh_exit_code eq "0")
	{
		print "Successfully removed the <span class=\"fixed_width\">libvirtd</span> definition.<br />\n";
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Warning
		</td>
		<td>
			<br />
			I tried to remove the <span class=\"fixed_width\">libvirtd</span> definition, which should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />
			<br />
			This is a non-fatal error. Proceeding.<br />
";
	}
	
	# If I've made it this far, I am ready to add it to the cluster configuration.
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Configuring Cluster
		</td>
		<td>
			<br />
			I will now add the new virtual server to the cluster.<br />
			<i>Please be patient!</i></br />
			This can take several minutes to complete.</br >
			<br />
";
	
	my $ccs_exit_code;
	$sc =  "$conf->{path}{ssh} root\@$node \"ccs ";
	$sc .= "-h localhost $conf->{cgi}{vm} --activate --sync --password \"$conf->{'system'}{ricci_password}\" --addvm $vm ";
	$sc .= "domain=\"$failover_domain\" ";
	$sc .= "path=\"/shared/definitions/\" ";
	$sc .= "autostart=\"0\" ";
	$sc .= "exclusive=\"0\" ";
	$sc .= "recovery=\"restart\" ";
	$sc .= "max_restarts=\"2\" ";
	$sc .= "restart_expire_time=\"600\"";
	$sc .= "; echo ccs:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /ccs:(\d+)/)
		{
			$ccs_exit_code = $1;
		}
		else
		{
			if ($line =~ /make sure the ricci server is started/)
			{
				print "<span class=\"highlight_bad\">Error</span>: The <span class=\"code\">ricci</span> daemon is not running on <span class=\"code\">$node</span>.<br />\n";
				print "This is probably a mis-configuration of the cluster node.<br />\n";
				print "Please ensure that <span class=\"code\">ricci</span> is running and is set to start on boot.<br />\n";
			}
			else
			{
				$line = parse_text_line($conf, $line);
				print "<span class=\"fixed_width\">$line</span><br />\n";
			}
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; ccs exit code: [$ccs_exit_code]\n");
	$ccs_exit_code = "-" if not defined $ccs_exit_code;
	if ($ccs_exit_code eq "0")
	{
		print "The VM has been added successfully.<br />\n";
		
		### TODO: Make this watch 'clustat' for the VM to appear.
		sleep 10;
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_bad_bold\">
			Error
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			The call to add the new VM to the cluster should have returned: [<span class=\"fixed_width\">0</span>], but [<span class=\"fixed_width\">$ccs_exit_code</span>] was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
		";
		return (1);
	}
	print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Enabling the VM
		</td>
		<td>
			<br />
			Informing the cluster that the VM is running.<br />
			<br />
";
	
	### TODO: Get the cluster's idea of the node name and use '-m ...'.
	# Tell the cluster to start the VM. I don't bother to check for 
	# readiness because I confirmed it was running on this node earlier.
	my $clusvcadm_exit_code;
	$sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -e vm:$vm; echo clusvcadm:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	$fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /clusvcadm:(\d+)/)
		{
			$clusvcadm_exit_code = $1;
		}
		else
		{
			$line = parse_text_line($conf, $line);
			print "<span class=\"fixed_width\">$line</span><br />\n";
		}
	}
	record($conf, "$THIS_FILE ".__LINE__."; clusvcadm exit code: [$clusvcadm_exit_code]\n");
	if ($clusvcadm_exit_code eq "0")
	{
		print "The VM has been added to the cluster.<br />\n";
	}
	else
	{
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_bad_bold\">
			Error
		</td>
		<td>
			<br />
			It would appear that something went wrong!<br />
			The call to tell the cluster that the new VM is running should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$clusvcadm_exit_code</span> was received.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
			<br />
		</td>
	</tr>
</table>
<br />
		";
		return (1);
	}
		print "
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Success!
		</td>
		<td>
			The new virtual machine has been added to the cluster.
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# This looks for a VM on the cluster and returns the current host node, if any.
# If the VM is not running, then "none" is returned.
sub find_vm_host
{
	my ($conf, $node, $peer, $vm) = @_;
	my $host = "none";
	
	my $sc = "$conf->{path}{ssh} root\@$node \"virsh list --all\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /\s$vm\s/)
		{
			record($conf, "$THIS_FILE ".__LINE__."; Found the VM.\n");
			if ($line =~ /^-/)
			{
				# It looks off... We have to go deeper!
				#print "It appears to be off. Checking the peer to see if it is running there.<br />\n";
				record($conf, "$THIS_FILE ".__LINE__."; The VM appears to be off. Checking the peer to see if it is running there.\n");
				my $on_peer = 0;
				my $found   = 0;
				my $sc = "$conf->{path}{ssh} root\@$peer \"virsh list --all\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					if ($line =~ /\s$vm\s/)
					{
						#print "Found it on the peer node. Checking if it's running there.<br />\n";
						record($conf, "$THIS_FILE ".__LINE__."; Found it on the peer. Checking if it's running.\n");
						if ($line =~ /^\d/)
						{
							$found   = 1;
							$on_peer = 1;
							$node    = $peer;
							$host    = $peer;
							#print "It is, I will use that node for the next steps.<br />\n";
							record($conf, "$THIS_FILE ".__LINE__."; It is.\n");
						}
						else
						{
							$found = 1;
							#print "It is not running on the peer.<br />\n";
							record($conf, "$THIS_FILE ".__LINE__."; It is not running on the peer.\n");
						}
					}
				}
				$fh->close();
				if (($found) && (not $on_peer))
				{
					#print "I did not find it on the peer node.<br />\n";
					record($conf, "$THIS_FILE ".__LINE__."; I did not find it on the peer node.\n");
				}
			}
			else
			{
				$host = $node;
				#print "It is already running, as expected.<br />\n";
			}
		}
	}
	
	
	return ($host);
}

# This actually kicks off the VM.
sub provision_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<b>Creating your new <span class=\"fixed_width\">$conf->{new_vm}{name}</span> server now.</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Starting
		</td>
		<td>
			In just a moment, your new server should begin installing.<br />
			Once it starts, you will be able to see it appear in the <span class=\"code\">virt-manager</span> window under <span class=\"fixed_width\">$conf->{new_vm}{host_node}</span>.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_warning_bold\">
			Note!
		</td>
		<td>
			<br />
			<i>Please leave this window open until you have rebooted the new server for the first time!</i><br />
			<br />
			The server is in a special state until it is rebooted. It must exit this state before being added to the cluster.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Beginning
		</td>
		<td>
			<br />
";
	
	# Create the LVs
	my $provision;
	my $i = 0;
	foreach my $vg (keys %{$conf->{new_vm}{vg}})
	{
		if (lc($conf->{new_vm}{vg}{$vg}{lvcreate_size}) eq "all")
		{
			$provision .= "lvremove -f /dev/$vg/$conf->{new_vm}{name}_$i\n";
			$provision .= "lvcreate -l 100\%FREE -n $conf->{new_vm}{name}_$i $vg\n";
		}
		else
		{
			$provision .= "lvremove -f /dev/$vg/$conf->{new_vm}{name}_$i\n";
			$provision .= "lvcreate -L $conf->{new_vm}{vg}{$vg}{lvcreate_size}MB -n $conf->{new_vm}{name}_$i $vg\n";
		}
		$i++;
	}
	
	# Setup the 'virt-install' call.
	$provision .= "virt-install --connect qemu:///system \\\\\n";
	$provision .= "  --name $conf->{new_vm}{name} \\\\\n";
	$provision .= "  --ram $conf->{new_vm}{ram} \\\\\n";
	$provision .= "  --arch x86_64 \\\\\n";
	$provision .= "  --vcpus $conf->{new_vm}{cpu_cores} \\\\\n";
	$provision .= "  --cdrom /shared/files/$conf->{new_vm}{install_iso} \\\\\n";
	if ($conf->{cgi}{driver_iso})
	{
		$provision .= "  --disk path=/shared/files/$conf->{new_vm}{driver_iso},device=cdrom --force\\\\\n";
	}
	$provision .= "  --os-variant $conf->{cgi}{os_variant} \\\\\n";
	if ($conf->{new_vm}{virtio}{nic})
	{
		$provision .= "  --network bridge=vbr2,model=virtio \\\\\n";
	}
	else
	{
		$provision .= "  --network bridge=vbr2,model=e1000 \\\\\n";
	}
	$i = 0;
	foreach my $vg (keys %{$conf->{new_vm}{vg}})
	{
		my $path = "/dev/$vg/$conf->{new_vm}{name}_$i";
		record($conf, "$THIS_FILE ".__LINE__."; LV: [$path], use virtio: [$conf->{new_vm}{virtio}{disk}]\n");
		$provision .= "  --disk path=$path";
		if ($conf->{new_vm}{virtio}{disk})
		{
			$provision .= ",bus=virtio";
		}
		$provision .= " \\\\\n";
	}
	$provision .= "  --graphics spice > /var/log/an-install_".$conf->{new_vm}{name}.".log &\n";
	record($conf, "$THIS_FILE ".__LINE__."; provision:\n$provision\n");
	
	### TODO: Make sure the desired node is up and, if not, use the one
	###       good node.
	
	# Push the provision script into a file.
	my $error  = "";
	my $script = "/shared/provision/$conf->{new_vm}{name}.sh";
	print "\t\t\tWriting provision script to <span class=\"code\">$script</span><br />\n";
	my $fh = IO::Handle->new();
	my $sc = "echo \"$provision\" | $conf->{path}{ssh} root\@$conf->{new_vm}{host_node} \"cat > $script && chmod 755 $script\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		### I now detach this so I won't be here log enough to see the
		### install complete.
		#chomp;
		#my $line = $_;
		#print "\t\t\t<span class=\"code\">$line</span><br />\n";
	}
	$fh->close();
	print "\t\t\tDone.\n";
	print "\t\t\t<br />\n";
	
	print "\t\t\tStarting the installation of <span class=\"code\">$conf->{new_vm}{name}</span> now.<br />\n";
	print "\t\t\tPlease open <i>Virtual Machine Manager</i> on the dashboard and connect to <span class=\"code\">$conf->{new_vm}{host_node}</span>.<br />\n";
	print "\t\t\tDouble-click on the <span class=\"code\">$conf->{new_vm}{name}</span> server to complete the OS install.<br />\n";
	print "\t\t\t<br />\n";
	$fh = IO::Handle->new();
	$sc = "$conf->{path}{ssh} root\@$conf->{new_vm}{host_node} \"$script\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		print "\t\t\t<span class=\"fixed_width\"><span class=\"code\">$_</span></span><br />\n";
	}
	$fh->close();
	print "\t\t\t<br />\n";
	print "\t\t\tDone.\n";
	print "\t\t\t<br />\n";
	print "\t\t\tIf there were no errors, the installation should now have started.<br />\n";
	print "\t\t\tPlease complete the install using <span class=\"code\">virt-manager</span>.<br />\n";
	print "\t\t\tOnce the installation is complete, please return here and click \"Next\".<br />\n";
	print "\t\t\t<br />\n";
	
	print "
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><b>After</b> the OS install is complete, please <a href=\"?cluster=$conf->{cgi}{cluster}&task=add_vm&name=$conf->{new_vm}{name}&node=$conf->{new_vm}{host_node}\" class=\"button\">click here</a> to add the VM to the cluster.</div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This sanity-checks the requested VM config prior to creating the VM itself.
sub verify_vm_config
{
	my ($conf) = @_;
	
	# First, get a current view of the cluster.
	my $proceed = 1;
	scan_cluster($conf);
	read_files_on_shared($conf);
	
	# If we connected, start parsing.
	my $cluster = $conf->{cgi}{cluster};
	my @errors;
	if ($conf->{'system'}{up_nodes})
	{
		# Did the user name the VM?
		if ($conf->{cgi}{name})
		{
			$conf->{cgi}{name} =~ s/^\s+//;
			$conf->{cgi}{name} =~ s/\s+$//;
			if ($conf->{cgi}{name} =~ /\s/)
			{
				push @errors, "Bad Server Name#!#The server name can't have spaces in the name.";
			}
			else
			{
				my $vm = $conf->{cgi}{name};
				if (exists $conf->{vm}{$vm})
				{
					push @errors, "Duplicate Server Name#!#The server name: [<span class=\"code\">$vm</span>] is already in use.";
				}
				else
				{
					$conf->{new_vm}{name} = $vm;
				}
			}
		}
		else
		{
			push @errors, "Missing Server Name#!#All servers need to have a name. This is usally something like <span class=\"code\">vmXX-purpose</span>.";
		}
		
		# Did the user ask for too many cores?
		if ($conf->{cgi}{cpu_cores} =~ /\D/)
		{
			push @errors, "Bad CPU Count#!#Somehow, the number of requested CPUs: [<span class=\"code\">$conf->{cgi}{cpu_cores}</span>] has a non-digit in it. This is probably a program error.";
		}
		elsif ($conf->{cgi}{cpu_cores} > $conf->{resources}{total_threads})
		{
			push @errors, "Not Enough CPUs#!#The cluster reports a maximum of <span class=\"code\">$conf->{resources}{total_threads}</span> CPUs, but it looks like you asked for <span class=\"code\">$conf->{cgi}{cpu_cores}</span>. This is probably a program error.";
		}
		else
		{
			$conf->{new_vm}{cpu_cores} = $conf->{cgi}{cpu_cores};
		}
		
		# Now what about RAM?
		if ($conf->{cgi}{ram} =~ /\D/)
		{
			push @errors, "Bad RAM Size#!#The amount of RAM must only contain digits. It looks like you entered: [<span class=\"code\">$conf->{cgi}{ram}</span>].";
		}
		my $requested_ram = hr_to_bytes($conf, $conf->{cgi}{ram}, $conf->{cgi}{ram_suffix});
		if ($requested_ram > ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram}))
		{
			my $say_free_ram  = bytes_to_hr($conf, ($conf->{resources}{total_ram} - $conf->{'system'}{unusable_ram}));
			my $say_requested = bytes_to_hr($conf, $requested_ram);
			push @errors, "Not Enough RAM#!#The cluster reports a maximum of <span class=\"code\">$say_free_ram</span> free RAM, but it looks like you asked for <span class=\"code\">$say_free_ram</span>.";
		}
		else
		{
			# RAM is specified as a number of MiB.
			my $say_ram = sprintf("%.0f", ($requested_ram /= (2 ** 20)));
			$conf->{new_vm}{ram} = $say_ram;
		}
		
		# Look at the selected storage. if VGs named for two separate
		# nodes are defined, error.
		$conf->{new_vm}{host_node} = "";
		#record($conf, "$THIS_FILE ".__LINE__."; host_node: [$conf->{new_vm}{host_node}], vg_list: [$conf->{cgi}{vg_list}]\n");
		foreach my $vg (split /,/, $conf->{cgi}{vg_list})
		{
			my $short_vg   = $vg;
			my $short_node = $vg;
			# Sometimes 'cXXnYY_vgZ' is used, sometimes
			# 'cXXnYY-vgZ' is used.
			#record($conf, "$THIS_FILE ".__LINE__."; short_vg: [$short_vg], short_node: [$short_node], vg: [$vg]\n");
			if ($vg =~ /^(.*?)_(vg\d+)$/)
			{
				$short_node = $1;
				$short_vg   = $2;
				#record($conf, "$THIS_FILE ".__LINE__."; short_vg: [$short_vg], short_node: [$short_node]\n");
			}
			elsif ($vg =~ /^(.*?)-(vg\d+)$/)
			{
				$short_node = $1;
				$short_vg   = $2;
				#record($conf, "$THIS_FILE ".__LINE__."; short_vg: [$short_vg], short_node: [$short_node]\n");
			}
			my $say_node      = $short_vg;
			my $vg_key        = "vg_$vg";
			my $vg_suffix_key = "vg_suffix_$vg";
			#record($conf, "$THIS_FILE ".__LINE__."; say_node: [$say_node], vg_key: [$vg_key], vg_suffix_key: [$vg_suffix_key]\n");
			next if not $conf->{cgi}{$vg_key};
			foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
			{
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], short_node: [$short_node]\n");
				if ($node =~ /$short_node/)
				{
					$say_node = $node;
					#record($conf, "$THIS_FILE ".__LINE__."; say_node: [$say_node]\n");
					last;
				}
			}
			#record($conf, "$THIS_FILE ".__LINE__."; host_node: [$conf->{new_vm}{host_node}]\n");
			if (not $conf->{new_vm}{host_node})
			{
				$conf->{new_vm}{host_node} = $say_node;
				#record($conf, "$THIS_FILE ".__LINE__."; host_node: [$conf->{new_vm}{host_node}]\n");
			}
			elsif ($conf->{new_vm}{host_node} ne $say_node)
			{
				push @errors, "Conflicting Storage#!#It looks like you asked to use storage from both nodes. This is not safe. Please clear one of the node's storage.";
			}
			
			# Make to lvcreate command a MiB value.
			my $lv_size = hr_to_bytes($conf, $conf->{cgi}{$vg_key}, $conf->{cgi}{$vg_suffix_key});
			$lv_size    = sprintf("%.0f", ($lv_size /= (2 ** 20)));
			$conf->{new_vm}{vg}{$vg}{lvcreate_size} = "$lv_size";
		}
		
		# Make sure the user specified an install disc.
		if ($conf->{cgi}{install_iso})
		{
			my $file_name = $conf->{cgi}{install_iso};
			if (exists $conf->{files}{shared}{$file_name})
			{
				$conf->{new_vm}{install_iso} = $conf->{cgi}{install_iso};
			}
			else
			{
				push @errors, "Install Media#!#The installation media you selected seems to have disappeared.";
			}
		}
		else
		{
			push @errors, "Install Media#!#You did not select installation media.";
		}
		
		### TODO: Find a better way to determine this.
		# Look at the OS type to try and determine if 'e1000' or
		# 'virtio' should be used by the network.
		$conf->{new_vm}{virtio}{nic}  = 0;
		$conf->{new_vm}{virtio}{disk} = 0;
		if (($conf->{cgi}{os_variant} =~ /fedora1\d/) || 
		    ($conf->{cgi}{os_variant} =~ /virtio/) || 
		    ($conf->{cgi}{os_variant} =~ /ubuntu/) || 
		    ($conf->{cgi}{os_variant} =~ /sles11/) || 
		    ($conf->{cgi}{os_variant} =~ /rhel5/) || 
		    ($conf->{cgi}{os_variant} =~ /rhel6/))
		{
			$conf->{new_vm}{virtio}{disk} = 1;
			$conf->{new_vm}{virtio}{nic}  = 1;
		}
		
		# Optional driver disk, enables virtio when appropriate
		if ($conf->{cgi}{driver_iso})
		{
			my $file_name = $conf->{cgi}{driver_iso};
			if (exists $conf->{files}{shared}{$file_name})
			{
				$conf->{new_vm}{driver_iso} = $conf->{cgi}{driver_iso};
			}
			else
			{
				push @errors, "Driver Media#!#The driver media you selected seems to have disappeared.";
			}
			
			if (lc($file_name) =~ /virtio/)
			{
				$conf->{new_vm}{virtio}{disk} = 1;
				$conf->{new_vm}{virtio}{nic}  = 1;
			}
		}
		
		# Make sure a valid os-variant was passed.
		if ($conf->{cgi}{os_variant})
		{
			my $match = 0;
			foreach my $os_variant (@{$conf->{'system'}{os_variant}})
			{
				my ($short_name, $desc) = ($os_variant =~ /^(.*?)#!#(.*)$/);
				if ($conf->{cgi}{os_variant} eq $short_name)
				{
					$match = 1;
				}
			}
			if (not $match)
			{
				push @errors, "OS Variant Not Found#!#Somehow, an OS optimization type was specified that is not valid. This is probably a program error.";
			}
		}
		else
		{
			push @errors, "OS Variant#!#No operating system optimization type was specified. This is probably a program error.";
		}
		
		# If there were errors, push the user back to the form.
		if (@errors > 0)
		{
			$proceed = 0;
			print "
<table align=\"center\">
";
			foreach my $error (@errors)
			{
				my ($title, $body) = ($error =~ /^(.*?)#!#(.*)$/);
				print "
	<tr>
		<td class=\"highlight_warning\">
			$title
		</td>
		<td>
			$body
		</td>
	</tr>
"
			}
			print "
</table>
<br />
";
		}
	}
	else
	{
		# Failed to connect to the cluster, errors should already be
		# reported to the user.
	}
	# Check the currently available resources on the cluster.
	
	return ($proceed);
}

# This doesn't so much confirm as it does ask the user how they want to build
# the VM.
sub confirm_provision_vm
{
	my ($conf) = @_;
	
	my ($node) = read_files_on_shared($conf);
	record($conf, "$THIS_FILE ".__LINE__."; read file list from node: [$node]\n");
	return if not $node;
	
	my $cluster = $conf->{cgi}{cluster};
	my $images  = [];
	foreach my $file (sort {$a cmp $b} keys %{$conf->{files}{shared}})
	{
		next if $file !~ /iso$/i;
		push @{$images}, $file;
	}
	my $cpu_cores = [];
	foreach my $core_num (1..$conf->{cgi}{max_cores})
	{
		if ($conf->{cgi}{max_cores} > 9)
		{
			#push @{$cpu_cores}, sprintf("%.2d", $core_num);
			push @{$cpu_cores}, $core_num;
		}
		else
		{
			push @{$cpu_cores}, $core_num;
		}
	}
	$conf->{cgi}{cpu_cores}  = 2 if not $conf->{cgi}{cpu_cores};
	my $select_cpu_cores     = build_select($conf, "cpu_cores", 0, 0, 60, $conf->{cgi}{cpu_cores}, $cpu_cores);
	foreach my $storage (sort {$a cmp $b} split/,/, $conf->{cgi}{max_storage})
	{
		my ($vg, $space)             =  ($storage =~ /^(.*?):(\d+)$/);
		my $say_max_storage          =  bytes_to_hr($conf, $space);
		$say_max_storage             =~ s/\.(\d+)//;
		$conf->{cgi}{vg_list}        .= "$vg,";
		my $vg_key                   =  "vg_$vg";
		my $vg_suffix_key            =  "vg_suffix_$vg";
		$conf->{cgi}{$vg_key}        =  ""    if not $conf->{cgi}{$vg_key};
		$conf->{cgi}{$vg_suffix_key} =  "GiB" if not $conf->{cgi}{$vg_suffix_key};
		my $select_vg_suffix                   =  build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB", "GiB", "TiB"]);
		if ($space < (2 ** 30))
		{
			# Less than a Terabyte
			$select_vg_suffix            = build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB", "GiB"]);
			$conf->{cgi}{$vg_suffix_key} = "GiB" if not $conf->{cgi}{$vg_suffix_key};
		}
		elsif ($space < (2 ** 20))
		{
			# Less than a Gigabyte
			$select_vg_suffix            = build_select($conf, "$vg_suffix_key", 0, 0, 60, $conf->{cgi}{$vg_suffix_key}, ["MiB"]);
			$conf->{cgi}{$vg_suffix_key} = "MiB" if not $conf->{cgi}{$vg_suffix_key};
		}
		# Devine the node associated with this VG.
		my $short_vg   =  $vg;
		my $short_node =  $vg;
		if ($vg =~ /^(.*?)_(vg\d+)$/)
		{
			$short_node = $1;
			$short_vg   = $2;
		}
		my $say_node =  $short_vg;
		foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
		{
			if ($node =~ /$short_node/)
			{
				$say_node = $node;
				last;
			}
		}
		
		$conf->{vg_selects}{$vg}{space}         = $space;
		$conf->{vg_selects}{$vg}{say_storage}   = $say_max_storage;
		$conf->{vg_selects}{$vg}{select_suffix} = $select_vg_suffix;
		$conf->{vg_selects}{$vg}{say_node}      = $say_node;
		$conf->{vg_selects}{$vg}{short_vg}      = $short_vg;
	}
	my $say_selects;
	my $say_or      = "<span class=\"fixed_width\">- or -</span><br />\n";
	foreach my $vg (sort {$a cmp $b} keys %{$conf->{vg_selects}})
	{
		my $space            =  $conf->{vg_selects}{$vg}{space};
		my $say_max_storage  =  $conf->{vg_selects}{$vg}{say_storage};
		my $select_vg_suffix =  $conf->{vg_selects}{$vg}{select_suffix};
		my $say_node         =  $conf->{vg_selects}{$vg}{say_node};
		$say_node            =~ s/\..*$//;
		my $short_vg         =  $conf->{vg_selects}{$vg}{short_vg};
		my $vg_key           =  "vg_$vg";
		$say_selects         .= "<span class=\"fixed_width\">$say_node</span>, <span class=\"fixed_width\">$short_vg</span> (<span class=\"subtle_text\">$say_max_storage free</span>): <input type=\"text\" name=\"$vg_key\" value=\"$conf->{cgi}{$vg_key}\" style=\"width: 100px\">$select_vg_suffix<br />\n";
		$say_selects         .= "$say_or";
	}
	$say_selects =~ s/$say_or$//m;
	$say_selects .= "<input type=\"hidden\" name=\"vg_list\" value=\"$conf->{cgi}{vg_list}\">\n";
	my $say_max_ram          = bytes_to_hr($conf, $conf->{cgi}{max_ram});
	$conf->{cgi}{ram}        = 2 if not $conf->{cgi}{ram};
	$conf->{cgi}{ram_suffix} = "GiB" if not $conf->{cgi}{ram_suffix};
	my $select_ram_suffix    = build_select($conf, "ram_suffix", 0, 0, 60, $conf->{cgi}{ram_suffix}, ["MiB", "GiB"]);
	$conf->{cgi}{os_variant} = "generic" if not $conf->{cgi}{os_variant};
	my $select_install_iso   = build_select($conf, "install_iso", 1, 1, 300, $conf->{cgi}{install_iso}, $images);
	my $select_driver_iso    = build_select($conf, "driver_iso", 1, 1, 300, $conf->{cgi}{driver_iso}, $images);
	my $select_os_variant    = build_select($conf, "os_variant", 1, 0, 300, $conf->{cgi}{os_variant}, $conf->{'system'}{os_variant});
	
	print "
<table align=\"center\">
	<form method=\"post\">
	<tr>
		<td colspan=\"3\">
			<b>Create a new VM on the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster</b>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_note\"><b>Note</b></span>:
		</td>
		<td colspan=\"2\">
			<br />
			You will need to answer some questions in order to create a new virtual server.<br />
			If you are unsure what a certain question means, please don't hesitate to <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">ask questions</a>.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Server Name:
		</td>
		<td>
			<input type=\"text\" name=\"name\" value=\"$conf->{cgi}{name}\" style=\"width: 300px\">
		</td>
		<td class=\"subtle_text\">
			This can be whatever you want, but it must be unique.<br />
			It's good to keep this short.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Optimize for:
		</td>
		<td>
			<!-- Update this list by referencing 'virt-install --os-variant list' and feeding it through 'parse-os_variants.pl'. -->
			$select_os_variant
		</td>
		<td class=\"subtle_text\">
			This fine-tunes the cluster for your operating system.<br />
			If your OS is not listed, choose the one that is the closest match.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			New Media:
		</td>
		<td>
			<a href=\"an-mc?cluster=$conf->{cgi}{cluster}\" target=\"_new\">Add a New Disc</a>
		</td>
		<td class=\"subtle_text\">
			This will open a new window where you can upload new disc images.<br />
			Once finished, please reload this page to see them.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Install From:
		</td>
		<td>
			$select_install_iso
		</td>
		<td class=\"subtle_text\">
			You server will boot off of this disc image.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Driver Disc:
		</td>
		<td>
			$select_driver_iso
		</td>
		<td class=\"subtle_text\">
			This is optional.<br />
			If you need a drivers to install your server,<br />
			please select the appropriate disc here.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Memory (RAM):
		</td>
		<td>
			(<span class=\"subtle_text\">$say_max_ram free</span>) <input type=\"input\" name=\"ram\" value=\"$conf->{cgi}{ram}\" style=\"width: 100px;\"> $select_ram_suffix
		</td>
		<td class=\"subtle_text\">
			Most servers work well between 2 and 8 GiB.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Number of CPUs:
		</td>
		<td>
			$select_cpu_cores
		</td>
		<td class=\"subtle_text\">
			Windows servers tend to work best with 2 CPUs.<br />
			Few servers need more than 4 CPUs.<br />
			The cluster uses all CPUs to get the best performance.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good_bold\">
			Storage Space:
		</td>
		<td>
			$say_selects
		</td>
		<td class=\"subtle_text\">
			Please use only one node.<br />
			Type <span class=\"fixed_width\">all</span> to use the rest of the free space.<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<input type=\"hidden\" name=\"cluster\" value=\"$conf->{cgi}{cluster}\">
			<input type=\"hidden\" name=\"task\" value=\"$conf->{cgi}{task}\">
			<input type=\"hidden\" name=\"max_ram\" value=\"$conf->{cgi}{max_ram}\">
			<input type=\"hidden\" name=\"max_cores\" value=\"$conf->{cgi}{max_cores}\">
			<input type=\"hidden\" name=\"max_storage\" value=\"$conf->{cgi}{max_storage}\">
			<div class=\"align_right\"><input type=\"submit\" name=\"confirm\" value=\"Confirm\" class=\"button\"></div>
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to join both nodes to the cluster.
sub confirm_withdraw_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to withdraw <b>$conf->{cgi}{node_cluster_name}</b> from cluster <b>$conf->{cgi}{cluster}</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Caution!</b></span>
		</td>
		<td>
			<br />
			<span class=\"fixed_width\"><u><b>$conf->{cgi}{node_cluster_name}</b></u></span> will leave the cluster.<br />
			Once complete, it will no longer be able to run or recover any VMs until it rejoins!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to join a node to the cluster.
sub confirm_join_cluster
{
	my ($conf) = @_;

	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to join <b>$conf->{cgi}{node_cluster_name}</b> to cluster <b>$conf->{cgi}{cluster}</b>.</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will attempt to join the node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> to the cluster <span class=\"fixed_width\">$conf->{cgi}{cluster}</span>.<br />
			This is usually a safe action.<br />
			If, for any reason, this node can't connect to it's peer, the peer node could be fenced (forcibly shut off).<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# Confirm that the user wants to join both nodes to the cluster.
sub confirm_dual_join
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to join both nodes to the $conf->{cgi}{cluster} cluster.</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will attempt to join both nodes of the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			This is usually a safe action.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to fence a nodes.
sub confirm_fence_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to forcefully power off cluster node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The cluster node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is about to be <span class=\"highlight_dangerous\">forcibly powered off</span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will effectively press and hold your node's power button until the system is forced to power down.<br >
			Should that fail, the power to the node will be cut completely cut off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Reconsider!</b></span>
		</td>
		<td>
			<br />
			This should be done as a last resort, when all other attempts to gracefully shut down the node have failed.<br />
			<i>Every</i> operating system has a chance of corrupting when it is forcibly powered off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";

	return (0);
}

# Confirm that the user wants to power-off a nodes.
sub confirm_poweroff_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power down the physical node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This will send a <span class=\"fixed_width\">poweroff</span> command to the <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> node.<br />
			If all is well, this node should gracefully power off.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Warning!</b></span>
		</td>
		<td>
			<br />
			If there is a problem with this node, like an incomplete withdrawl from the cluster, it may hang while trying to shut down.<br />
			If this happens, this browser session may time out. If it does, return to the dashboard and call a <span class=\"fixed_width\">fence</span> action against this node.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to boot a nodes.
sub confirm_poweron_node
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power on the physical node <b>$conf->{cgi}{node_cluster_name}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			An attempt will be made to power on the <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> node.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Careful!</b></span>
		</td>
		<td>
			<br />
			Be aware that if anything blocks this node's ability to talk to it's peer, it will fence the peer node during start up!<br />
			This is by design, as a node can not safely provide clustered services when it's peer is in an unknown state.<br />
			If the peer node is already online and there are not network problems, this node will join the peer safely.<br />
			If the peer node is offline, this node will wait for a while before timing out. Once it times out, the peer node will likely be started.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}

# Confirm that the user wants to boot both nodes.
sub confirm_dual_boot
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to power on both nodes!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			An attempt will be made to boot both nodes in the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			Please be patient, it can take a few minutes for the nodes to become accessible.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}
# Confirm that the user wants to start a VM.
sub confirm_start_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to boot up the virtual machine <b>$conf->{cgi}{vm}</b> on <b>$conf->{cgi}{node_cluster_name}</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be booted on cluster node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span>.<br />
			The node was selected because it is either the prefered host or the only host ready to run this VM.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}	

# Confirm that the user wants to stop a VM.
sub confirm_stop_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to shut down the virtual machine <b>$conf->{cgi}{vm}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_warning\"><b>Careful!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span>, running on cluster node <span class=\"fixed_width\">$conf->{cgi}{node}</span>, is about to be shut down.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			If $conf->{cgi}{vm} is not listening to ACPI calls, this attempt to shut down the node will fail!<br />
			Make sure that Linux machines are running <span class=\"code\">acpid</span> and that <b>Windows</b> machines have <b>no pending updates</b>.<br />
			If <span class=\"fixed_width\">$conf->{cgi}{vm}</span> doesn't shut down within <u>120 seconds</u>, it will be <span class=\"highlight_dangerous\"><b>forced off</b></span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Precautions!</b></span>
		</td>
		<td>
			<br />
			Before proceeding, it is <b>strongly advised</b> that you connect to the VM. If there are updates pending, please <b>reboot</b> the VM first.<br />
			This will ensure that VM shuts down cleanly.<br />
			Connect to this VM by using <span class=\"fixed_width\">virt-manager</span> (connecting to <span class=\"fixed_width\">$conf->{cgi}{node}</span>) or by using an RDP or SSH session.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	return (0);
}
# Confirm that the user wants to force-off a VM.
sub confirm_force_off_vm
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to forcefully power off <b>$conf->{cgi}{vm}</b>!</span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span>, running on cluster node <span class=\"fixed_width\">$conf->{cgi}{host}</span>, is about to be <span class=\"highlight_dangerous\">forcibly powered off</span>!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			This action is the same as pulling the power on a normal server!<br />
			The virtual machine will have no chance to react and will be instantly turned off. A moment later, the cluster will restart this VM.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Reconsider!</b></span>
		</td>
		<td>
			<br />
			This should be done as a last resort, when all other attempts to gain control of the VM have failed.<br />
			<i>Every</i> operating system has a chance of corrupting when it is forcibly powered off. <br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to migrate a VM.
sub confirm_delete_vm
{
	my ($conf) = @_;

	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to <span class=\"highlight_dangerous\"><b>delete</b></span> the <b>$conf->{cgi}{vm} server!</b></span>
		</td>
	</tr>
	<tr>
		<td>
			
			<span class=\"highlight_dangerous\"><b>Dangerous!</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be <span class=\"highlight_dangerous\"><b>destroyed and deleted!</b></span><br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Warning!</b></span>
		</td>
		<td>
			<br />
			<u><b>This is a permanent and unreversable action!</b></u><br />
			<br />
			The virtual machine, along with all of it's data, will be deleted.<br />
			It will be removed from the cluster's management and forced off, if necessary.<br />
			The definition file will be deleted and it's backing storage will be wiped clean.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note!</b></span>
		</td>
		<td>
			<br />
			Ensure you have backed up any data on the machine before proceeding!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# Confirm that the user wants to migrate a VM.
sub confirm_migrate_vm
{
	my ($conf) = @_;
	
	# Calculate roughly how long the migration will take.
	my $migration_time_estimate = $conf->{cgi}{vm_ram} / 1073741824; # Get # of GB.
	$migration_time_estimate *= 10; # ~10s / GB
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"2\">
			<span class=\"highlight_ready\">About to migrate the virtual machine <b><span class=\"fixed_width_button\">$conf->{cgi}{vm}</span></b> to <b><span class=\"fixed_width_button\">$conf->{cgi}{target}</span></b>.
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Note</b></span>
		</td>
		<td>
			<br />
			The virtual machine named <span class=\"fixed_width\">$conf->{cgi}{vm}</span> will be migrated to cluster node <span class=\"fixed_width\">$conf->{cgi}{target}</span>.<br />
			This VM has ".bytes_to_hr($conf, $conf->{cgi}{vm_ram})." RAM, which will take roughly $migration_time_estimate seconds to migrate.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This boots a VM on a target node.
sub start_vm
{
	my ($conf) = @_;
	
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $vm                = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], node_cluster_name: [$node_cluster_name]\n");
	
	# Make sure the node is still ready to take this VM.
	scan_cluster($conf);
	my $vm_key = "vm:$vm";
	my $ready = check_node_readiness($conf, $vm_key, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], ready: [$ready]\n");
	if ($ready)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Booting $vm on $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -e vm:$vm -m $node_cluster_name\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /Fail/i)
			{
				# The VM failed to start. Call a stop against it.
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_warning_bold\" align=\"center\">
						Warning!
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						It looks like the attempt to start the VM Failed. Will try to recover now...<br />
					</td>
				</tr>
";
				my $sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -d vm:$vm\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$status
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$message
					</td>
				</tr>
";
				}
				$fh->close();
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_ready_bold\" align=\"center\">
						Retry
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						Trying again to start the VM<br />
					</td>
				</tr>
";
				$sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -e vm:$vm -m $node_cluster_name\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				$fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					if ($line =~ /Fail/i)
					{
						# The VM failed to start. Call a stop against it.
						print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"highlight_bad_bold\" align=\"center\">
						Error!
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						It looks like there is a problem with this server.<br />
						Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br />
					</td>
				</tr>
";
					}
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$status
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$message
					</td>
				</tr>
";
				}
				$fh->close();
			}
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$status
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$message
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Booting of $vm on $node_cluster_name failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$node_cluster_name</span> is no longer ready to run <span class=\"fixed_width\">$vm</span>.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This tries to parse lines coming back from a shell call to add highlighting and what-not.
sub parse_text_line
{
	my ($conf, $line) = @_;
	
	# 'Da good ^_^
	$line =~ s/(success)/<span class="highlight_good">$1<\/span>/ig;
	$line =~ s/\[ (ok) \]/[ <span class="highlight_good">$1<\/span> ]/ig;
	
	# Informational.
	$line =~ s/(done)/<span class="highlight_ready">$1<\/span>/ig;
	$line =~ s/(Starting Cluster):/<span class="highlight_ready">$1<\/span>:/ig;
	$line =~ s/(Stopping Cluster):/<span class="highlight_ready">$1<\/span>:/ig;
	#$line =~ s/(disabled)/<span class="highlight_ready">$1<\/span>/ig;
	#$line =~ s/(shutdown)/<span class="highlight_ready">$1<\/span>/ig;
	$line =~ s/(shut down)/<span class="highlight_ready">$1<\/span>/ig;
	
	# 'Da bad. ;_;
	$line =~ s/(failed)/<span class="highlight_bad">$1<\/span>/ig;
	$line =~ s/\[ (failed) \]/[ <span class="highlight_bad">$1<\/span> ]/ig;
	
	return($line);
}

# This migrates a VM to the target node.
sub migrate_vm
{
	my ($conf) = @_;
	
	my $target = $conf->{cgi}{target};
	my $vm     = $conf->{cgi}{vm};
	my $node   = long_host_name_to_node_name($conf, $target);
	record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], target: [$target]\n");
	
	# Make sure the node is still ready to take this VM.
	scan_cluster($conf);
	my $vm_key = "vm:$vm";
	my $ready = check_node_readiness($conf, $vm_key, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], ready: [$ready]\n");
	if ($ready)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Migrating $vm to $target now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -M vm:$vm -m $target\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Migration of $vm to $target aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$target</span> is no longer ready to run <span class=\"fixed_width\">$vm</span>.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This sttempts to shut down a VM on a target node.
sub stop_vm
{
	my ($conf) = @_;
	
	my $node = $conf->{cgi}{node};
	my $vm   = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node]\n");
	
	# This, more than 
	scan_cluster($conf);
	print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Attempting orderly shut down of $vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $say_node = node_name_to_long_host_name($conf, $node);
		my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -d vm:$vm\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$line =~ s/Local machine/$say_node/;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This sttempts to shut down a VM on a target node.
sub join_cluster
{
	my ($conf) = @_;
	
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $proceed           = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in join_cluster(), node: [$node], node_cluster_name: [$node_cluster_name]\n");
	
	# This, more than 
	scan_cluster($conf);
	
	# Proceed only if all of the storage components, cman and rgmanager are
	# off.
	if (($conf->{node}{$node}{daemon}{cman}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{rgmanager}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{drbd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{gfs2}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{libvirtd}{exit_code} ne "0"))
	{
		$proceed = 1;
	}
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Attempting to join $node_cluster_name to $conf->{cgi}{cluster} now...</b></span><br />
			This can take a while, please be patient!<br />
			This process will complete before the storage service starts. Please give a minute or two for storage to come online.<br />
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman start && /etc/init.d/rgmanager start\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Joining of $node_cluster_name to $conf->{cgi}{cluster} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that <span class=\"fixed_width\">$node_cluster_name</span> is already running <span class=\"fixed_width\">cman</span>, <span class=\"fixed_width\">rgmanager</span>, <span class=\"fixed_width\">drbd</span>, <span class=\"fixed_width\">clvmd</span> or <span class=\"fixed_width\">gfs2</span>.<br />
			If any of these daemons are running, then either the cluster was already started elsewhere or the last attempt to withdraw the cluster failed.<br />
			If you believe that the cluster has failed, please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			Note that <span class=\"fixed_width\">libvirtd</span> is allowed to be running and would not block this action.<br />
			Please go back and see what the current state of the cluster is.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This sttempts to start the cluster stack on both nodes simultaneously.
sub dual_join
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $proceed = 1;
	#record($conf, "$THIS_FILE ".__LINE__."; in dual_join(), cluster: [$cluster]\n");
	
	# This, more than 
	scan_cluster($conf);
	
	# Proceed only if all of the storage components, cman and rgmanager are
	# off.
	my @abort_reason;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		if (($conf->{node}{$node}{daemon}{cman}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{rgmanager}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{drbd}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{clvmd}{exit_code} eq "0") ||
		($conf->{node}{$node}{daemon}{gfs2}{exit_code} eq "0"))
		{
			$proceed = 0;
			push @abort_reason, "It appears that <span class=\"fixed_width\">$node</span> is already running <span class=\"fixed_width\">cman</span>, <span class=\"fixed_width\">rgmanager</span>, <span class=\"fixed_width\">drbd</span>, <span class=\"fixed_width\">clvmd</span> or <span class=\"fixed_width\">gfs2</span>.";
		}
	}
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_good\"><b>Attempting to join both nodes to the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster now...</b></span><br />
			This can take a while, please be patient!<br />
			This process will complete before the storage services start. Please give then minute or two for storage to come online.<br />
		</td>
	</tr>
	<tr>
		<td>
			System call output below:<br />
			<span class=\"highlight_ready_bold\">Note</span>: Output from both nodes will be mixed together.
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		# I need to fork here because the calls won't return until cman
		# either talks to it's peer or fences it.
		my $parent_pid = $$;
		#record($conf, "$THIS_FILE ".__LINE__."; Parent process has PID: [$parent_pid]. Spawning a child process for each node.\n");
		my %pids;
		my $node_count = @{$conf->{clusters}{$cluster}{nodes}};
		foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
		{
			defined(my $pid = fork) or die "Can't fork(), error was: $!\n";
			if ($pid)
			{
				# Parent thread.
				$pids{$pid} = 1;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], Spawned child with PID: [$pid].\n");
			}
			else
			{
				# This is the child thread, so do the call.
				# Note that, without the 'die', we could end
				# up here if the fork() failed.
				my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman start && /etc/init.d/rgmanager start\"";
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; $node; $line\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" align=\"right\">
						$node
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				
				# Kill the child process.
				exit;
			}
		}
		
		# Now loop until both child processes are dead.
		# This helps to catch hung children.
		my $saw_reaped = 0;
		
		# If I am here, then I am the parent process and all the child process have
		# been spawned. I will not enter a while() loop that will exist for however
		# long the %pids hash has data.
		while (%pids)
		{
			# This is a bit of an odd loop that put's the while()
			# at the end. It will cycle once per child-exit event.
			my $pid;
			do
			{
				# 'wait' returns the PID of each child as they
				# exit. Once all children are gone it returns 
				# '-1'.
				$pid = wait;
				if ($pid < 1)
				{
					record($conf, "$THIS_FILE ".__LINE__."; Parent process thinks all children are gone now as wait returned: [$pid]. Exiting loop.\n");
				}
				else
				{
					record($conf, "$THIS_FILE ".__LINE__."; Parent process told that child with PID: [$pid] has exited.\n");
				}
				
				# This deletes the just-exited child process' PID from the
				# %pids hash.
				delete $pids{$pid};
				
				# This counter is a safety mechanism. If I see more PIDs exit
				# than I spawned, something went oddly and I need to bail.
				$saw_reaped++;
				error($conf, "All children should be gone now but it seems the program went into an infinit loop.\n") if $saw_reaped > ($node_count + 1);
			}
			while $pid > 0;	# This re-enters the do() loop for as
					# long as the PID returned by wait()
					# was >0.
		}
		record($conf, "$THIS_FILE ".__LINE__."; All child processes reaped, exiting threaded execution.\n");
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Joining of both nodes to the $conf->{cgi}{cluster} cluster aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
";
		foreach my $reason (@abort_reason)
		{
			print "
			$reason<br />
";
		}
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This forcibly shuts down a VM on a target node. The cluster should restart it
# shortly after.
sub force_off_vm
{
	my ($conf) = @_;
	
	my $node = $conf->{cgi}{node};
	my $vm   = $conf->{cgi}{vm};
	#record($conf, "$THIS_FILE ".__LINE__."; in force_off_vm(), vm: [$vm], node: [$node]\n");
	
	# This, more than 
	scan_cluster($conf);
	print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Forcibly shutting down $vm now...</b></span><br />
			This can take a while, please be patient!
		</td>
	</tr>
	<tr>
		<td>
			System call output below:
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"virsh destroy $vm\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			The cluster will restart this VM in a moment, if this call succeeded.
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This stops the VM, if it's running, edits the cluster.conf to remove the VM's
# entry, pushes the changed cluster out, deletes the VM's definition file and 
# finally deletes the LV.
sub delete_vm
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $say_vm  = $conf->{cgi}{vm};
	my $vm      = "vm:$conf->{cgi}{vm}";
	record($conf, "$THIS_FILE ".__LINE__."; in delete_vm(), vm: [$vm], cluster: [$cluster]\n");
	
	# This, more than 
	scan_cluster($conf);
	my $proceed      = 1;
	my $stop_vm      = 0;
	my $say_host     = "";
	my $host         = "";
	my $abort_reason = "";
	my $node         = $conf->{'system'}{cluster}{node1_name};
	my $node1        = $conf->{'system'}{cluster}{node1_name};
	my $node2        = $conf->{'system'}{cluster}{node2_name};
	record($conf, "$THIS_FILE ".__LINE__."; vm::${vm}::host: [$conf->{vm}{$vm}{host}]\n");
	if (not $conf->{vm}{$vm}{host})
	{
		$proceed      = 0;
		$abort_reason = "<b>Removal of $say_vm has been aborted!</b><br />\nThe program appears to have failed to read the VM's information properly.<br />\nThis is likely a bug in the program.<br />\n";
	}
	elsif ($conf->{vm}{$vm}{host} ne "none")
	{
		$stop_vm  = 1;
		$say_host = $conf->{vm}{$vm}{host};
		$host     = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
	}
	else
	{
		# Pick the first up node to use.
		if ($conf->{node}{$node1}{up})
		{
			$host = $node1;
		}
		elsif ($conf->{node}{$node2}{up})
		{
			$host = $node2;
		}
		else
		{
			$proceed      = 0;
			$abort_reason = "Can't delete: [$say_vm] until at least one node is online.";
		}
	}
	
	# Get to work!
	print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_ready\">
			<b>Begining the process of deleting $say_vm now...</b></span><br />
		</td>
	</tr>
";

	if ($proceed)
	{
		print "
	<tr>
		<td>
			<br />
			Removing the VM from cluster management:<br />
			<i>Please be patient!</i><br />
			This step could take several minutes to complete.<br />
";
		### Note: I don't use 'path' for these calls as the location of
		###       a program on the cluster may differ from the local
		###       copy. Further, I will have $PATH on the far side of
		###       the ssh call anyway.
		# First, delete the VM from the cluster.
		my $ccs_exit_code;
		   $proceed = 0;
		my $sc = "$conf->{path}{ssh} root\@$host \"ccs -h localhost --activate --sync --password \"$conf->{'system'}{ricci_password}\" --rmvm $conf->{cgi}{vm}; echo ccs:\\\$?\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			next if not $line;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /ccs:(\d+)/)
			{
				$ccs_exit_code = $1;
			}
			else
			{
				$line = parse_text_line($conf, $line);
				print "<span class=\"fixed_width\">$line</span><br />\n";
			}
		}
		record($conf, "$THIS_FILE ".__LINE__."; ccs exit code: [$ccs_exit_code]\n");
		if ($ccs_exit_code eq "0")
		{
			print "The VM has been removed successfully.<br />\n";
			$proceed = 1;
		}
		else
		{
			print "</br ><span class=\"highlight_bad\"><b>Error</b></span>! It would appear that something went wrong!<br />\n";
			print "The removal call should have exited with exit code <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$ccs_exit_code</span> was received.<br />\n";
			print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
		}
		print "
			<br />
		</td>
	</tr>
";
		my $stop_exit_code;
		if (($stop_vm) && ($ccs_exit_code eq "0"))
		{
			print "
	<tr>
		<td>
			<br />
			The VM appears to still be running. I will force it off now.
			<br />
";
			   $proceed = 0;
			my $virsh_exit_code;
			my $sc = "$conf->{path}{ssh} root\@$host \"virsh destroy $say_vm; echo virsh:\\\$?\"";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				next if not $line;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				if ($line =~ /virsh:(\d+)/)
				{
					$virsh_exit_code = $1;
				}
				else
				{
					$line = parse_text_line($conf, $line);
					print "<span class=\"fixed_width\">$line</span><br />\n";
				}
			}
			$fh->close();
			record($conf, "$THIS_FILE ".__LINE__."; virsh exit code: [$virsh_exit_code]\n");
			if ($virsh_exit_code eq "0")
			{
				print "The VM has been forced off.<br />\n";
				$proceed = 1;
			}
			else
			{
				print "</br ><span class=\"highlight_bad\"><b>Error</b></span>! It would appear that something went wrong!<br />\n";
				print "The call to destroy the VM should have exited with exit code <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$virsh_exit_code</span> was received.<br />\n";
				print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
			}
			print "
			<br />
		</td>
	</tr>
";
		}
		
		# Now delete the backing LVs
		if ($proceed)
		{
			print "
	<tr>
		<td>
			<br />
			Freeing up the VM's storage now.<br />
			<br />
";
			foreach my $lv (keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
			{
				print "Deleting <span class=\"fixed_width\">$lv</span>...<br />\n";
				my $lvremove_exit_code;
				my $sc = "$conf->{path}{ssh} root\@$host \"lvremove -f $lv; echo lvremove:\\\$?\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					next if not $line;
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					if ($line =~ /lvremove:(\d+)/)
					{
						$lvremove_exit_code = $1;
					}
					else
					{
						$line = parse_text_line($conf, $line);
						print "<span class=\"fixed_width\">$line</span><br />\n";
					}
				}
				record($conf, "$THIS_FILE ".__LINE__."; lvremove exit code: [$lvremove_exit_code]\n");
				if ($lvremove_exit_code eq "0")
				{
					print "Removed successfully<br />\n";
				}
				else
				{
					print "<br /><span class=\"highlight_warning\"><b>Warning</b></span>! It would appear that <span class=\"fixed_width\">$lv</span> was not removed.<br />\n";
					print "The call to remove the VM's storage should have exited with exit code <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$lvremove_exit_code</span> was received.<br />\n";
					print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
				}
			}
			
			# Regardless of whether the removal succeeded, archive
			# and then delete the definition file.
			my $file   = $conf->{vm}{$vm}{definition_file};
			archive_file($conf, $host, $file);
			remove_vm_definition($conf, $host, $file);
			print "
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_good\">Success</span>! The server <span class=\"fixed_width\">$say_vm</span> has been removed.<br />
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td>
			$abort_reason
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return(0);
}

# This deletes a VM definition file.
sub remove_vm_definition
{
	my ($conf, $node, $file) = @_;
	
	# We only delete VM definition files.
	if ($file !~ /^\/shared\/definitions\/.*?\.xml/)
	{
		print "<br /><span class=\"highlight_bad\"><b><u>CRITICAL ERROR</u></b></span>! It would appear that something went very wrong!<br />\n";
		print "I was asked to delete a VM definition file, but was asked to delete <span class=\"fixed_width\">$file</span>.<br />\n";
		print "For security reasons, only files in <span class=\"fixed_width\">/shared/definitions/</span> can be deleted.<br />\n";
		print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
		return (1);
	}
	
	# 'rm' seems to return '0' no matter what. So I use the 'ls' to ensure
	# the file is gone. 'ls' will return '2' on file not found.
	my $ls_exit_code;
	my $sc = "$conf->{path}{ssh} root\@$node \"rm -f $file; ls $file; echo ls:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /ls:(\d+)/)
		{
			$ls_exit_code = $1;
		}
		else
		{
			### There will be output, I don't care about it.
			#$line = parse_text_line($conf, $line);
			#print "<span class=\"fixed_width\">$line</span><br />\n";
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; ls exit code: [$ls_exit_code]\n");
	if ($ls_exit_code eq "2")
	{
		print "The file <span class=\"fixed_width\">$file</span> has been deleted.<br />\n";
	}
	else
	{
		print "<br /><span class=\"highlight_bad\"><b<Warning</b></span>! It would appear that something went wrong!<br />\n";
		print "I tried to delete the file <span class=\"fixed_width\">$file</span> and then verify that it was indeed removed.<br />\n";
		print "This should have returned <span class=\"fixed_width\">2</span>, but <span class=\"fixed_width\">$ls_exit_code</span> was returned instead.<br />\n";
		print "Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n";
	}
	
	return (0);
}

# This returns a 'YY-MM-DD_hh:mm:ss' formatted string based on the given time
# stamp
sub get_date
{
	my ($conf, $time) = @_;
	$time = time if not defined $time;
	
	my @time = localtime($time);
	
	# this returns "yyyy-mm-dd_hh:mm:ss".
	my $date = ($time[5] += 1900)."-".sprintf("%.2d", ($time[4]++))."-".sprintf("%.2d", $time[3])."_".sprintf("%.2d", $time[2]).":".sprintf("%.2d", $time[1]).":".sprintf("%.2d", $time[0]);
	
	return ($date);
}

# This copies the passed file to 'node:/shared/archive'
sub archive_file
{
	my ($conf, $node, $file, $quiet) = @_;
	$quiet = 0 if not defined $quiet;
	
	### TODO: Check/create the archive directory.
	
	my ($dir, $file_name) = ($file =~ /^(.*)\/(.*?)$/);
	my ($date) = get_date($conf, time);
	my $dest = "/shared/archive/$file_name.$date";

	my $cp_exit_code;
	my $sc = "$conf->{path}{ssh} root\@$node \"cp $file $dest; echo cp:\\\$?\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /cp:(\d+)/)
		{
			$cp_exit_code = $1;
		}
		else
		{
			$line = parse_text_line($conf, $line);
			print "<span class=\"fixed_width\">$line</span><br />\n";
		}
	}
	$fh->close();
	#record($conf, "$THIS_FILE ".__LINE__."; cp exit code: [$cp_exit_code]\n");
	if ($cp_exit_code eq "0")
	{
		if (not $quiet)
		{
			print "
			The file:<br />\n
			<span class=\"fixed_width\">$file</span><br />\n
			has been archived as<br />\n
			<span class=\"fixed_width\">$dest</span>.<br />\n
";
		}
		record($conf, "$THIS_FILE ".__LINE__."; The file: [$file] has been archived as: [$dest].\n");
	}
	else
	{
		print "
			<br /><span class=\"highlight_bad\"><b>Warning</b></span>! It would appear that something went wrong!<br />\n
			I tried to archive the file <span class=\"fixed_width\">$file</span> as <span class=\"fixed_width\">$dest</span>.<br />\n
			This should have returned <span class=\"fixed_width\">0</span>, but <span class=\"fixed_width\">$cp_exit_code</span> was returned instead.<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>.<br /><br />\n
";
		$dest = 0;
	}
	
	return ($dest);
}

# This adds or removes a VM from the cluster.conf file.
sub update_cluster_conf
{
	my ($conf, $do, $vm, $node) = @_;
	my $say_vm  = ($vm =~ /vm:(.*)/)[0];
	my $success = 1;
	
	# I 'cat' the current cluster.conf, incrementing 'config_version="x"'
	# by one, add or remove the <vm ...> line and then write out the edited
	# version locally. Next I backup the current cluster.conf to 
	# '/shared/archive/vX.cluster.conf', 'rsync' the updated local copy to
	# the target node, 'ccs_config_validate' it and, if all is well, 
	# 'cman_tool version -r' to push out the changes.
	
	# Read in the current cluster.conf.
	
	return($success);
}

# This makes an ssh call to the node and sends a simple 'poweroff' command.
sub poweroff_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed = $conf->{node}{$node}{enable_poweroff};
	record($conf, "$THIS_FILE ".__LINE__."; in poweroff_node(), node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# Stop rgmanager and then check it's status.
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Shutting down $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			This will complete once $node_cluster_name has closed the connection.<br />
			It may take a minute before the node shows as powered off on the dashboard.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $sc = "$conf->{path}{ssh} root\@$node \"poweroff && echo \"Power down initiated. Please return to the main page now.\"\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Withdrawl of $conf->{cgi}{node_cluster_name} aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is now in use by a VM.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	footer($conf);
	
	return(0);
}

# This uses the local machine to call "power on" against both nodes in the
# cluster.
sub dual_boot
{
	my ($conf) = @_;
	
	my $proceed = 1;
	my $cluster = $conf->{cgi}{cluster};
	my $sc      = "";
	# TODO: Provide an option to boot just one node if one node fails for
	# some reason but the other node is fine.
	scan_cluster($conf);
	my @abort_reasons;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		# Read the cache files.
		read_node_cache($conf, $node);
		if (not $conf->{node}{$node}{info}{power_check_command})
		{
			push @abort_reasons, "I was asked to power on: [$node], but the command to do so was not found in the cache. Manual power up is required.\n";
			$proceed = 0;
		}
		
		# Confirm the node is off still.
		check_if_on($conf, $node);
		record($conf, "$THIS_FILE ".__LINE__."; node::${node}::is_on: [$conf->{node}{$node}{is_on}]\n");
		if ($conf->{node}{$node}{is_on} == 1)
		{
			push @abort_reasons, "I was asked to power on: [$node], but it appears to already be running. Start up aborted.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 2)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I am not able to log into the taget node's out of band management interface: [$target_host].<br />Please check to see if the address, user or password has changed. Unable to continue.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 3)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I am not on the same subnet as it's out of band management interface at: [$target_host].<br />Please restore access to the target subnet. Unable to continue.\n";
			$proceed = 0;
		}
		elsif ($conf->{node}{$node}{is_on} == 4)
		{
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			push @abort_reasons, "I was asked to power on: [$node], but I don't have a recorded method of checking or changing the power state for: [$target_host].<br />Please restore access to the target subnet. Unable to continue.\n";
			$proceed = 0;
		}
		
		# Still alive?
		$sc .= "$conf->{node}{$node}{info}{power_check_command} -o on; ";
	}
	
	# Let's go
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<b>Powering on both nodes in the cluster now...</b>
		</td>
	</tr>
	<tr>
		<td>
			I will now try to power on both nodes in the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			It may take a few minutes before the dashboard can log into either node.<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				$line = parse_text_line($conf, $line);
				my $message = ($line =~ /^(.*)\[/)[0];
				my $status  = ($line =~ /(\[.*)$/)[0];
				if (not $message)
				{
					$message = $line;
					$status  = "";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
			}
			$fh->close();
			print "
			</table>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Booting both nodes in the $conf->{cgi}{cluster} cluster aborted!</span>
		</td>
	</tr>
";
		foreach my $reason (@abort_reasons)
		{
			print "
	<tr>
		<td>
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
";
		}
		print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	return(0);
}

# This uses the IPMI (or similar) to try and power on the node.
sub poweron_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	record($conf, "$THIS_FILE ".__LINE__."; in poweron_node(), node: [$node]\n");
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	check_if_on($conf, $node);
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
	my $proceed      = 0;
	my $abort_reason = "An unknown error has occured. Is <span class=\"code\">${node}</span>'s IPMI interface reachable?";
	if ($conf->{node}{$node}{is_on} == 0)
	{
		$proceed = 1;
	}
	elsif ($conf->{node}{$node}{is_on} == 1)
	{
		$abort_reason = "The node $node_cluster_name is already reported as being powered up.";
	}
	elsif ($conf->{node}{$node}{is_on} == 2)
	{
		$abort_reason = "The node ${node_cluster_name}'s out of band management interface is currently unreachable.";
	}
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# It is still off.
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Powering on $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now try to power on $node_cluster_name.<br />
			It may take a few minutes before the dashboard can log into it.<br />
		</td>
	</tr>
	<tr>
		<td class=\"fixed_width\">
			<br />
";

		# The node is still off. Now can I call it from it's peer?
		my $peer  = "";
		my $is_on = 2;
		record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
		if ($conf->{'system'}{up_nodes} == 1)
		{
			# It has to be the peer of this node.
			$peer = @{$conf->{up_nodes}}[0];
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
		if ($peer)
		{
			# It's peer is up, use it.
			if (not $conf->{node}{$node}{info}{power_check_command})
			{
				error($conf, "I was asked to power on: [$node] via it's peer: [$peer], but the power command is empty.<br />\nThis is likely a program error.\n");
			}
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
			my $sc = "$conf->{path}{ssh} root\@$peer \"$conf->{node}{$node}{info}{power_check_command} -o on\"";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				print "$line<br />\n";
			}
			$fh->close();
			print "
			<br />
		</td>
	</tr>";
		}
		else
		{
			# Try to boot the node locally.
			if ($conf->{node}{$node}{info}{power_check_command})
			{
				my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], target host: [$target_host], power check command: [$conf->{node}{$node}{info}{power_check_command}].\n");
				my $local_access = on_same_network($conf, $target_host);
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], local access: [$local_access].\n");
				if ($local_access)
				{
					# I can reach it directly
					my $sc = "$conf->{node}{$node}{info}{power_check_command} -o on";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
						print "$line<br />\n";
					}
					$fh->close();
					print "
			<br />
		</td>
	</tr>";
				}
				else
				{
					# I can't reach it from here.
					record($conf, "$THIS_FILE ".__LINE__."; This machine is not on the same network out of band management interface: [$target_host] for node: [$node], unable to check power state.\n");
				}
			}
			else
			{
				# Can't check the power.
				print "
			<br />
		</td>
	</tr>
</table>
<br />
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Powering on of $node_cluster_name failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			I wasn't able to find the command needed to power on $node_cluster_name.<br />
			Either this node has not been seen before or the cache for this node was deleted.<br />
			You can not power on the node from the dashboard at this time.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
";
			}
		}
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Powering on of $node_cluster_name aborted!</span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			$abort_reason<br />
			<br />
		</td>
	</tr>
";
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	footer($conf);
	
	return(0);
}

# This uses the fence methods, as defined in cluster.conf and in the proper
# order, to fence the target node.
sub fence_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	my $peer              = get_peer_node($conf, $node);
	record($conf, "$THIS_FILE ".__LINE__."; in poweron_node(), node: [$node], peer: [$peer], cluster name: [$node_cluster_name]\n");
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed      = 1;
	my @abort_reason = "";
	
	my $fence_string = "";
	# See if I already have the fence string. If not, load it from cache.
	if ($conf->{node}{$node}{info}{fence_methods})
	{
		$fence_string = $conf->{node}{$node}{info}{fence_methods};
	}
	else
	{
		read_node_cache($conf, $node);
		if ($conf->{node}{$node}{info}{fence_methods})
		{
			$fence_string = $conf->{node}{$node}{info}{fence_methods};
		}
		else
		{
			$proceed      = 0;
			push @abort_reason, "Unable to determine the commands needed to fence $node. One of the nodes need to be accessible or the cache file must exist with the correct command.\n";
		}
	}
	
	# If the peer node is up, use the fence command as compiled by it. 
	# Otherwise, read the cache. If the fence command(s) are still not
	# available, abort.
	if ($proceed)
	{
		if (not $conf->{node}{$peer}{up})
		{
			# See if this machine can reach each '-a ...' fence device
			# address.
			foreach my $address ($fence_string =~ /-a\s(.*?)\s/g)
			{
				if (not on_same_network($conf, $address))
				{
					$proceed = 0;
					push @abort_reason, "Trying to fence $node, but it's peer, $peer, is also offline and the fence device at $address is not accessible from this machine.<br />Unable to proceed with fence action.\n";
				}
			}
		}
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Fencing $node_cluster_name now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			I will now attempt to fence <span class=\"fixed_width\">$node_cluster_name</span>.<br />
		</td>
	</tr>
";
		# This loops for each method, which may have multiple device 
		# calls. I parse each call into an 'off' and 'on' call. If the
		# 'off' call fails, I go to the next method until there are no
		# methods left. If the 'off' works, I call the 'on' call from
		# the same method to (try to) boot the node back up (or simply
		# unfence it in the case of PDUs and the like).
		my $fence_success   = 0;
		my $unfence_success = 0;
		foreach my $line ($fence_string =~ /\d+:.*?;\./g)
		{
			print "
	<tr>
		<td class=\"fixed_width\">
			<br />
";
			my ($method_num, $method_name, $command) = ($line =~ /(\d+):(.*?): (.*?;)\./);
			my $off_command =  $command;
			my $on_command  =  $command;
			
			# If the peer is up, set the command to run through it.
			if ($conf->{node}{$peer}{up})
			{
				# When called remotely, I need to double-escape
				# the $? to protect it inside the "".
				$off_command =~ s/#!action!#;/off; echo fence:\\\$?;/g;
				$on_command  =~ s/#!action!#;/on;  echo fence:\\\$?;/g;
				$off_command = "$conf->{path}{ssh} root\@$peer \"$off_command\"";
				$on_command  = "$conf->{path}{ssh} root\@$peer \"$on_command\"";
			}
			else
			{
				# When called locally, I only need to escape
				# the $? once.
				$off_command =~ s/#!action!#;/off; echo fence:\$?;/g;
				$on_command  =~ s/#!action!#;/on;  echo fence:\$?;/g;
			}
			my $off_success = 1;
			my $on_success  = 1;
			
			# Make the off attempt.
			my $sc = "$off_command";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				# This is how I get the fence call's exit code.
				if ($line =~ /fence:(\d+)/)
				{
					# Anything but '0' is a failure.
					my $exit = $1;
					if ($exit ne "0")
					{
						$off_success = 0;
					}
				}
				else
				{
					print "$line<br />\n";
				}
			}
			$fh->close();
			print "
			<br />
		</td>
	</tr>
";
			if ($off_success)
			{
				# Fence succeeded!
				record($conf, "$THIS_FILE ".__LINE__."; Fencing using the '$method_name' method succeeded. Proceeding with unfence action.\n");
				print "
	<tr>
		<td>
			Fencing using the <span class=\"fixed_width\">$method_name</span> method succeeded. Proceeding with unfence action.<br />
		</td>
	</tr>
";
				$fence_success = 1;
			}
			else
			{
				# Fence failed!
				record($conf, "$THIS_FILE ".__LINE__."; Fencing using the '$method_name' method failed. Will try next method, if available.\n");
				print "
	<tr>
		<td>
			Fencing using the <span class=\"fixed_width\">$method_name</span> method failed. Will try next method, if available.<br />
		</td>
	</tr>
";
				next;
			}
			
			# If I'm here, I can try the unfence command.
			print "
	<tr>
		<td class=\"fixed_width\">
			<br />
";
			$sc = "$on_command";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			$fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
				# This is how I get the fence call's exit code.
				if ($line =~ /fence:(\d+)/)
				{
					# Anything but '0' is a failure.
					my $exit = $1;
					if ($exit ne "0")
					{
						$on_success = 0;
					}
				}
				else
				{
					print "$line<br />\n";
				}
			}
			$fh->close();
			print "
			<br />
		</td>
	</tr>
";
			if ($on_success)
			{
				# Unfence succeeded!
				record($conf, "$THIS_FILE ".__LINE__."; Unfencing using the '$method_name' method succeeded. Fence operation a complete success!\n");
				print "
	<tr>
		<td>
			Unfencing using the <span class=\"fixed_width\">$method_name</span> method succeeded. Fence operation a complete success!<br />
		</td>
	</tr>
";
				$unfence_success = 1;
				last;
			}
			else
			{
				# Unfence failed!
				# This is allowed to go to the next fence method
				# because some servers may hang their IPMI 
				# interface after a fence call, requiring power
				# to be cut in order to reset the BMC. HP, I'm
				# looking at you and your DL1** G7 line...
				record($conf, "$THIS_FILE ".__LINE__."; Unfencing using the '$method_name' method failed. The core fence action was a success, but something went wrong and manual intervention may be required before the node can be returned to service. If another fence method remains, it will now be tried in hopes of assisting recovery.\n");
				print "
	<tr>
		<td>
			Unfencing using the <span class=\"fixed_width\">$method_name</span> method failed.<br />\nThe core fence action was a success, but something went wrong and manual intervention may be required before the node can be returned to service.<br />\nIf another fence method remains, it will now be tried in hopes of assisting recovery.<br />			<br />
		</td>
	</tr>
";
			}
		}
	}
	else
	{
		print "
	<tr>
		<td>
			<span class=\"highlight_bad\"><b>Powering on of $node_cluster_name aborted!</span>
		</td>
	</tr>
";
		foreach my $reason (@abort_reason)
		{
			print "
	<tr>
		<td>
			<br />
			$reason<br />
			<br />
		</td>
	</tr>
";
		}
	}
	print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	footer($conf);
	
	return(0);
}

# This does a final check of the target node then withdraws it from the
# cluster.
sub withdraw_node
{
	my ($conf) = @_;
	
	# Make sure no VMs are running.
	my $node              = $conf->{cgi}{node};
	my $node_cluster_name = $conf->{cgi}{node_cluster_name};
	
	# Scan the cluster, then confirm that withdrawl is still enabled.
	scan_cluster($conf);
	my $proceed = $conf->{node}{$node}{enable_withdraw};
	#record($conf, "$THIS_FILE ".__LINE__."; in withdraw_node(), node: [$node], proceed: [$proceed]\n");
	if ($proceed)
	{
		# Stop rgmanager and then check it's status.
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Withdrawing $node_cluster_name from the cluster now...</b></span>
		</td>
	</tr>
	<tr>
		<td>
			<br />
			Stopping the cluster resource manager now...<br />
			<span class=\"highlight_ready_bold\">Please be patient</span>! This can take a minute.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
		my $rgmanager_stop = 1;
		my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/rgmanager stop\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			if ($line =~ /failed/i)
			{
				$rgmanager_stop = 0;
			}
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			$line = parse_text_line($conf, $line);
			my $message = ($line =~ /^(.*)\[/)[0];
			my $status  = ($line =~ /(\[.*)$/)[0];
			if (not $message)
			{
				$message = $line;
				$status  = "";
			}
			print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
		}
		$fh->close();
		print "
			</table>
			<br />
		</td>
	</tr>
";
		if ($rgmanager_stop)
		{
			print "
	<tr>
		<td>
			<br />
			Cluster resource manager stopped successfully.<br />
			Stopping the cluster communication layer now...<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
			my $cman_stop = 1;
			my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman stop\"";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				if ($line =~ /failed/i)
				{
					$cman_stop = 0;
				}
				record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				$line = parse_text_line($conf, $line);
				my $message = ($line =~ /^(.*)\[/)[0];
				my $status  = ($line =~ /(\[.*)$/)[0];
				if (not $message)
				{
					$message = $line;
					$status  = "";
				}
				print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
			}
			$fh->close();
			print "
			</table>
			<br />
		</td>
	</tr>
";
			if (not $cman_stop)
			{
				# Crap...
			print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Cluster communication layer failed to stop!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<b>Was something holding open the cluster storage?</b><br />
			If a shell was logged in and sitting in a shared directory, a failure like this can occur.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			<br />
			Attempting to recover now...<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				my $cman_start = 1;
				my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/cman start\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$cman_start = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				print "
			</table>
			<br />
		</td>
	</tr>
";
				if ($cman_start)
				{
					# Number 5 is alive
					print "
	<tr>
		<td class=\"highlight_ready\">
			<br />
			Cluster communication layer started successfully!<br />
			<br />
		</td>
	</tr>
";
					recover_rgmanager($conf, $node);
					
				}
				else
				{
					# Failed, call support.
					print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Unable to start the cluster communication layer!<br />
			Please <a href=\"https://alteeve.ca/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
				}
			}
		}
		else
		{
			# Oh shit...
			print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Cluster resource manager failed to stop!<br />
			Was something holding open the cluster storage?<br />
			If a shell was logged in and sitting in a shared directory, a failure like this can occur.<br />
			<br />
		</td>
	</tr>
";
			recover_rgmanager($conf, $node);
		}
		print "
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<br />
			<span class=\"highlight_bad\"><b>Withdrawl of $conf->{cgi}{node_cluster_name} aborted!</span>
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			It appears that node <span class=\"fixed_width\">$conf->{cgi}{node_cluster_name}</span> is now in use by a VM.<br />
			This could be because some time has passed and the state of the node has changed.<br />
			Please go back to the status page for more details.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<!-- <a href=\"?cluster=$conf->{cgi}{cluster}\">Back</a> -->
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	}
	
	footer($conf);
	
	return(0);
}

# This restarts rgmanager and, if necessary, disables and re-enables the 
# storage service
sub recover_rgmanager
{
	my ($conf, $node) = @_;
	
	print "
	<tr>
		<td>
			Attempting to recover rgmanager and, if necessary, the node's storage service...<br />
		</td>
	</tr>
	<tr>
		<td class=\"fixed_width\">
			<br />
";
	my $rgmanager_start = 1;
	my $sc = "$conf->{path}{ssh} root\@$node \"/etc/init.d/rgmanager start\"";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		if ($line =~ /failed/i)
		{
			$rgmanager_start = 0;
		}
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		print "$line<br />\n";
	}
	$fh->close();
	print "
			<br />
		</td>
	</tr>
";
	if ($rgmanager_start)
	{
		my $storage_service = $conf->{node}{$node}{info}{storage_name};
		print "
	<tr>
		<td class=\"highlight_good\">
			Cluster resource manager recovered successfully!<br />
		</td>
	</tr>
";
		if ($storage_service)
		{
			print "
	<tr>
		<td>
			Checking the <span class=\"fixed_width\">$storage_service</span> storage service now.<br />
			This requires a rescan of the cluster, please be patient.<br />
		</td>
	</tr>
";
			# I need to sleep for ~ten seconds to give time for
			# 'clustat' to start showing the service section again.
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rescanning the cluster in ten seconds.\n");
			sleep 10;
			check_node_status($conf);
			my $storage_state = $conf->{node}{$node}{info}{storage_state};
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], storage service: [$storage_service], storage state: [$storage_state]\n");
			if ($storage_state =~ /Failed/i) 
			{
				print "
	<tr>
		<td class=\"highlight_bad\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service has failed!<br />
		</td>
	</tr>
	<tr>
		<td>
			The <span class=\"fixed_width_button\">$storage_service</span> storage will now be cycled...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				# NOTE: This will return 'Warning' because of
				# whatever is holding open the storage. This is
				# fine, as the goal is to enable, not stop.
				my $storage_stop = 1;
				my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -d $storage_service\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$storage_stop = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				print "
			</table>
			<br />
		</td>
	</tr>
";
				if ($storage_stop)
				{
					print "
	<tr>
		<td class=\"highlight_ready\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service has been disabled.<br />
		</td>
	</tr>
	<tr>
		<td>
			Attempting to re-enable it now...<br />
		</td>
	</tr>
	<tr>
		<td>
			<br />
			<table class=\"hidden_table\" width=\"100%\">
";
				my $storage_start = 1;
				my $sc = "$conf->{path}{ssh} root\@$node \"$conf->{path}{clusvcadm} -e $storage_service\"";
				record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					$line =~ s/^\s+//;
					$line =~ s/\s+$//;
					$line =~ s/\s+/ /g;
					if ($line =~ /failed/i)
					{
						$storage_start = 0;
					}
					record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					$line = parse_text_line($conf, $line);
					my $message = ($line =~ /^(.*)\[/)[0];
					my $status  = ($line =~ /(\[.*)$/)[0];
					if (not $message)
					{
						$message = $line;
						$status  = "";
					}
					print "
				<tr>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"center\">
						$message
					</td>
					<td style=\"border: 1px solid white;\" class=\"fixed_width\" align=\"left\">
						$status
					</td>
				</tr>
";
				}
				$fh->close();
				print "
			</table>
			<br />
		</td>
	</tr>
";
					if ($storage_start)
					{
						print "
	<tr>
		<td class=\"highlight_ready\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage has been restarted.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good\">
			Recovery has completed successfully!<br />
		</td>
	</tr>
	<tr>
		<td>
			Please log into <span class=\"fixed_width_button\">$node</span> and locate what held open the storage service.<br />
			Trying to withdraw from the cluster before this is fixed could cause problems. <br />
			Proceed carefully!<br />
		</td>
	</tr>
";
					}
					else
					{
						print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			The <span class=\"fixed_width_button\">$storage_service</span> storage service failed to restart!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
					}
				}
				else
				{
					print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			The <span class=\"fixed_width_button\">$storage_service</span> storage service failed to disable!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
				}
			}
			else
			{
				# TODO: Check each individual storage service
				# and restart each if needed.
				print "
	<tr>
		<td class=\"highlight_good\">
			The <span class=\"fixed_width_button\">$storage_service</span> storage service appears to be ok!<br />
			Recovery of the storage services appears to be unnecessary.
		</td>
	</tr>
";
			}
		}
		else
		{
			print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Unable to identify the storage service for this node! This is likely a program error.<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td class=\"highlight_bad\">
			<br />
			Failed to start the <span class=\"fixed_width_button\">rgmanager</span> daemon back up!<br />
			Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.
			<br />
		</td>
	</tr>
";
	}
	
	return(0);
}

# This is a new attempt at an interface
sub display_details2
{
	my ($conf) = @_;
	
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	my $rowspan    = 2;
	my $dual_boot  = (($conf->{node}{$node1}{enable_poweron}) && ($conf->{node}{$node2}{enable_poweron})) ? 1 : 0;
	my $dual_join  = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
	
	print "
<table class=\"hidden_table\" align=\"center\" border=\"0\">
	<tr>
		<td class=\"td_hidden\">
			<table width=\"100%\" border=\"0\">
";
	
	# Node header
	my $node1_class = "highlight_unavailable";
	if (check_node_daemons($conf, $node1))        { $node1_class = "highlight_good"; }
	elsif ($conf->{node}{$node1}{up})             { $node1_class = "highlight_warning"; }
	elsif ($conf->{node}{$node1}{enable_poweron}) { $node1_class = "highlight_ready"; }
	my $node2_class = "highlight_unavailable";
	if (check_node_daemons($conf, $node2))        { $node2_class = "highlight_good"; }
	elsif ($conf->{node}{$node2}{up})             { $node2_class = "highlight_warning"; }
	elsif ($conf->{node}{$node2}{enable_poweron}) { $node2_class = "highlight_ready"; }
	print "
				<tr>
					<td nowrap=\"nowrap\">
						<b>Node</b><br />
						<span class=\"$node1_class\">$node1_long</span>
					</td>
					<td nowrap=\"nowrap\">
						<b>Node</b><br />
						<span class=\"$node2_class\">$node2_long</span>
					</td>
				</tr>
";
	
	# Show the VMs.
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		# Break the name out of the hash key.
		my ($say_vm) = ($vm =~ /^vm:(.*)/);
		my $say_power        =  "<span class=\"highlight_unavailable\">--</span>";
		my $say_reset        =  "<span class=\"highlight_unavailable\">--</span>";
		my $prefered_host    =  find_prefered_host($conf, $vm);
		   $prefered_host    =~ s/\..*$//;
		my $say_migrate      =  "<span class=\"highlight_unavailable\">--</span>";
		# If it's not running, setup the start button.
		my $show_on_host;
		if ($conf->{vm}{$vm}{host})
		{
			$say_power   = "S";
			$say_reset   = "R";
			$say_migrate = "M";
			if ($conf->{vm}{$vm}{host} eq $node1_long)
			{
				$show_on_host = $node1_long;
			}
			elsif ($conf->{vm}{$vm}{host} eq $node2_long)
			{
				$show_on_host = $node2_long;
			}
		}
		else
		{
			$say_power = "Power Up";
			$say_reset = "&nbsp;";
		}
		if ($show_on_host eq $node1_long)
		{
			print "
				<tr>
					<td nowrap=\"nowrap\">
						<span class=\"fixed_width\">$say_vm</span><br />
						$say_reset &nbsp; $say_power &nbsp; $say_migrate ->
					</td>
					<td nowrap=\"nowrap\">
						<span class=\"highlight_unavailable\">--</span>
					</td>
				</tr>
";
		}
		else
		{
			print "
				<tr>
					<td nowrap=\"nowrap\">
						<span class=\"highlight_unavailable\">--</span>
					</td>
					<td nowrap=\"nowrap\">
						<span class=\"fixed_width\">$say_vm</span><br />
						<- $say_migrate &nbsp; $say_power &nbsp; $say_reset
					</td>
				</tr>
";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say vm: [$say_vm]\n");
		
		# Use the node's short name for the buttons.
		my $say_start_target     =  $conf->{vm}{$vm}{boot_target};
		$say_start_target        =~ s/\..*?$//;
		my $start_target_long    = $node1_long =~ /$say_start_target/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		my $start_target_name    = $node1      =~ /$say_start_target/ ? $node1 : $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; say_start_target: [$say_start_target], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}], start_target_long: [$start_target_long]\n");
		
		$prefered_host           =  find_prefered_host($conf, $vm);
		$prefered_host           =~ s/\..*$//;
		if ($conf->{vm}{$vm}{boot_target})
		{
			$prefered_host = "<span class=\"highlight_ready\">$prefered_host</span>";
		}
		else
		{
			my $on_host =  $conf->{vm}{$vm}{host};
			   $on_host =~ s/\..*$//;
			if ($on_host eq $prefered_host)
			{
				$prefered_host = "<span class=\"highlight_good\">$prefered_host</span>";
			}
			else
			{
				$prefered_host = "<span class=\"highlight_warning\">$prefered_host</span>";
			}
		}
		
		my $say_migration_target =  $conf->{vm}{$vm}{migration_target};
		$say_migration_target    =~ s/\..*?$//;
		my $migrate_button = "<span class=\"disabled_button\">Migrate</span>";
		if ($conf->{vm}{$vm}{can_migrate})
		{
			$migrate_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=migrate_vm&target=$conf->{vm}{$vm}{migration_target}&vm_ram=$conf->{vm}{$vm}{details}{ram}\">Migrate to <span class=\"fixed_width_button\">$say_migration_target</span></a>";
		}
		my $host_node        = "$conf->{vm}{$vm}{host}";
		my $stop_button      = "<span class=\"disabled_button\">Power Off</span>";
		my $force_off_button = "<span class=\"disabled_button\">Force Off</span>";
		if ($conf->{vm}{$vm}{can_stop})
		{
			$host_node        = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host node: [$host_node], vm host: [$conf->{vm}{$vm}{host}]\n");
			$stop_button      = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=stop_vm&vm=$say_vm&node=$host_node\">Orderly Shut Down</a>";
			$force_off_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=force_off_vm&vm=$say_vm&node=$host_node&host=$conf->{vm}{$vm}{host}\" class=\"highlight_dangerous\">Force Off</a>";
		}
		my $start_button     = "<span class=\"disabled_button\">Boot Up</span>";
		if ($conf->{vm}{$vm}{boot_target})
		{
			$start_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=start_vm&vm=$say_vm&node=$start_target_name&node_cluster_name=$start_target_long\">Boot Up</a>";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; start_button:     [$start_button], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}]\n");
		
		# I need both nodes up to delete a VM.
		my $say_delete_button = "<span class=\"disabled_button\">Delete</span>";
		record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::daemon::cman::exit_code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], node::${node2}::daemon::cman::exit_code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
		if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0"))
		{
			$say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		}
		
		#record($conf, "$THIS_FILE ".__LINE__." > say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		if ($conf->{vm}{$vm}{node1_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node1_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_ready\">Ready</span>";
		}
		if ($conf->{vm}{$vm}{node2_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node2_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_ready\">Ready</span>";
		}
		#record($conf, "$THIS_FILE ".__LINE__." < say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
# 		print "
# 	<tr>
# 		<td>
# 			<span class=\"fixed_width\">$say_vm</span>
# 		</td>
# 		<td>
# 			$conf->{vm}{$vm}{say_node1}
# 		</td>
# 		<td>
# 			$conf->{vm}{$vm}{say_node2}
# 		</td>
# 		<td>
# 			<span class=\"fixed_width\">$prefered_host</span>
# 		</td>
# 		<td>
# 			$start_button
# 		</td>
# 		<td>
# 			$migrate_button
# 		</td>
# 		<td>
# 			$stop_button
# 		</td>
# 		<td>
# 			$force_off_button
# 		</td>
# 		<!-- Disabled in this release
# 		<td>
# 			&nbsp;
# 		</td>
# 		<td>
# 			$say_delete_button
# 		</td>
# 		-->
# 	</tr>
# ";
	}
	
	
	# Figure out which, if any, power buttons (boot, poweroff and fence) to enable.
	
	
	print "
			</table>
		</td>
	</tr>
</table>
<br />
";
	return(0);
}

# This creates the summary page after a cluster has been selected.
sub display_details
{
	my ($conf) = @_;
	
	print "
<table class=\"hidden_table\" align=\"center\" border=\"0\">
	<tr>
		<td class=\"td_hidden\">
";
	# Display the status of each node's daemons
	my $up_nodes = @{$conf->{up_nodes}};
	# TODO: Rework this, I always show nodes now so that the 'fence_...' 
	# calls are available. IE: enable this when the cache exists and the
	# fence command addresses are reachable.
	#record($conf, "$THIS_FILE ".__LINE__."; show nodes: [$conf->{'system'}{show_nodes}], up nodes: [$conf->{'system'}{up_nodes}] ($up_nodes)\n");
#	if ($conf->{'system'}{show_nodes})
	if (1)
	{
		display_node_controls($conf);

		# I don't show below here unless at least one node is up.
		#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}] ($up_nodes)\n");
		if ($conf->{'system'}{up_nodes} > 0)
		{
			# Show the user the current VM states and the control buttons.
			display_vm_state_and_controls($conf);
			
			# Show the state of the daemons.
			display_node_details($conf);
		
			# Show the details about each VM.
			display_vm_details($conf);
			
			# Show the status of each node's GFS2 share(s)
			display_gfs2_details($conf);
		
			# This shows the status of each DRBD resource in the cluster.
			display_drbd_details($conf);
		
			# Show the free resources available for new VMs.
			display_free_resources($conf);
			print "
</table>
<br />
";
		}
		else
		{
			# Was able to confirm the nodes are off.
			print "
<table width=\"100%\">
	<tr>
		<td colspan=\"2\">
			<b>Anvil Offline</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready_bold\">
			Offline
		</td>
		<td>
			Both physical nodes appear to be powered off. Anvil details are not available at this time.
		</td>
	</tr>
</table>
<!-- <meta http-equiv=\"refresh\" content=\"30\"> -->
<br />
";
		}
	}
	else
	{
		# No access to the cluster at all.
		print "
<table width=\"100%\">
	<tr>
		<td colspan=\"2\">
			<b>Cluster Offline</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_offline\">
			Offline
		</td>
		<td>
			Unable to connect to either cluster node. Cluster status is not available at this time.
		</td>
	</tr>
</table>
<br />
"
	}
	
	return (0);
}

# This shows the free resources available to be assigned to new VMs.
sub display_free_resources
{
	my ($conf) = @_;
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"12\">
			<b>Available Resources</b>
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<i>CPU Cores</i>
		</td>
		<td colspan=\"3\">
			<i>RAM</i>
		</td>
		<td colspan=\"6\">
			<i>Storage</i>
		</td>
	</tr>
	<tr>
		<td>
			Cores
		</td>
		<td>
			Threads
		</td>
		<td>
			Allocated
		</td>
		<td>
			Total
		</td>
		<td>
			Allocated
		</td>
		<td>
			Available
		</td>
		<td>
			VG
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			PV
		</td>
		<td>
			Size
		</td>
		<td>
			Used
		</td>
		<td>
			Free
		</td>
	</tr>
";	
	
	# I only show one row for CPU and RAM, but usually have two or more
	# VGs. So the first step is to put my VG info into an array.
	my $enough_storage = 0;
	my $available_ram  = 0;
	my $max_cpu_cores  = 0;
	my @vg;
	my @vg_size;
	my @vg_used;
	my @vg_free;
	my @pv_name;
	my $vg_link="";
	foreach my $vg (sort {$a cmp $b} keys %{$conf->{resources}{vg}})
	{
		# If it's not a clustered VG, I don't care about it.
		#record($conf, "$THIS_FILE ".__LINE__."; vg: [$vg], clustered: [$conf->{resources}{vg}{$vg}{clustered}]\n");
		next if not $conf->{resources}{vg}{$vg}{clustered};
		push @vg,      $vg;
		push @vg_size, $conf->{resources}{vg}{$vg}{size};
		push @vg_used, $conf->{resources}{vg}{$vg}{used_space};
		push @vg_free, $conf->{resources}{vg}{$vg}{free_space};
		push @pv_name, $conf->{resources}{vg}{$vg}{pv_name};
		#record($conf, "$THIS_FILE ".__LINE__."; vg: [$vg], size: [$conf->{resources}{vg}{$vg}{size}], used space: [$conf->{resources}{vg}{$vg}{used_space}], free space: [$conf->{resources}{vg}{$vg}{free_space}], pv name: [$conf->{resources}{vg}{$vg}{pv_name}]\n");
		
		# If there is at least a GiB free, mark free storage as
		# sufficient.
		if (not $conf->{'system'}{clvmd_down})
		{
			$enough_storage =  1 if $conf->{resources}{vg}{$vg}{free_space} > (2**30);
			$vg_link        .= "$vg:$conf->{resources}{vg}{$vg}{free_space},";
		}
	}
	$vg_link =~ s/,$//;
	
	# Count how much RAM and CPU cores have been allocated.
	my $allocated_cores = 0;
	my $allocated_ram   = 0;
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		# I check GFS2 because, without it, I can't read the VM's details.
		if ($conf->{'system'}{gfs2_down})
		{
			$allocated_ram   = "<span class=\"fixed_width\">--</span>";
			$allocated_cores = "<span class=\"fixed_width\">--</span>";
		}
		else
		{
			$allocated_ram   += $conf->{vm}{$vm}{details}{ram};
			#record($conf, "$THIS_FILE ".__LINE__."; allocated_ram: [$allocated_ram], vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
			$allocated_cores += $conf->{vm}{$vm}{details}{cpu_count};
		}
	}
	
	# Always knock off 2GB of RAM for the host OS.
	my $real_total_ram            =  bytes_to_hr($conf, $conf->{resources}{total_ram});
	$conf->{resources}{total_ram} -= $conf->{'system'}{unusable_ram};
	$conf->{resources}{total_ram} =  0 if $conf->{resources}{total_ram} < 0;
	my $free_ram                  =  $conf->{'system'}{gfs2_down}  ? 0    : $conf->{resources}{total_ram} - $allocated_ram;
	my $say_free_ram              =  $conf->{'system'}{gfs2_down}  ? "--" : bytes_to_hr($conf, $free_ram);
	my $say_total_ram             =  bytes_to_hr($conf, $conf->{resources}{total_ram});
	my $say_allocated_ram         =  $conf->{'system'}{gfs2_down}  ? "--" : bytes_to_hr($conf, $allocated_ram);
	my $say_vg_size               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_size[0]);
	my $say_vg_used               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_used[0]);
	my $say_vg_free               =  $conf->{'system'}{clvmd_down} ? "--" : bytes_to_hr($conf, $vg_free[0]);
	my $say_vg                    =  $conf->{'system'}{clvmd_down} ? "--" : $vg[0];
	my $say_pv_name               =  $conf->{'system'}{clvmd_down} ? "--" : $pv_name[0];
	
	# Show the main info.
	print "
	<tr>
		<td>
			$conf->{resources}{total_cores}
		</td>
		<td>
			$conf->{resources}{total_threads}
		</td>
		<td>
			$allocated_cores
		</td>
		<td>
			$real_total_ram ($say_total_ram)
		</td>
		<td>
			$say_allocated_ram
		</td>
		<td>
			$say_free_ram
		</td>
		<td>
			<span class=\"fixed_width\">$say_vg</span>
		</td>
		<td>
			on
		</td>
		<td>
			<span class=\"fixed_width\">$say_pv_name</span>
		</td>
		<td>
			$say_vg_size
		</td>
		<td>
			$say_vg_used
		</td>
		<td>
			$say_vg_free
		</td>
	</tr>
";
	if (@vg > 0)
	{
		for (my $i=1; $i < @vg; $i++)
		{
			my $say_vg_size = bytes_to_hr($conf, $vg_size[$i]);
			my $say_vg_used = bytes_to_hr($conf, $vg_used[$i]);
			my $say_vg_free = bytes_to_hr($conf, $vg_free[$i]);
			my $say_pv_name = $pv_name[$i];
			print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"fixed_width\">$vg[$i]</span>
		</td>
		<td>
			on
		</td>
		<td>
			<span class=\"fixed_width\">$pv_name[$i]</span>
		</td>
		<td>
			$say_vg_size
		</td>
		<td>
			$say_vg_used
		</td>
		<td>
			$say_vg_free
		</td>
	</tr>
";
		}
	}
	
	### NOTE: Disabled in this release.
	# If I found enough free disk space, have at least 1 GiB of free RAM 
	# and both nodes are up, enable the "provision new VM" button.
	my $node1   = $conf->{'system'}{cluster}{node1_name};
	my $node2   = $conf->{'system'}{cluster}{node2_name};
	my $say_bns = "<span class=\"disabled_button\">Build a New Server</span>";
	my $say_mc  = "<span class=\"disabled_button\">Media Connector</span>";
	
	#record($conf, "$THIS_FILE ".__LINE__."; in enough_storage: [$enough_storage], free_ram: [$free_ram], node1 cman: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], node2 cman: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && 
	($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0"))
	{
		# The cluster is running, so enable the media connector link.
		$say_mc = "<a href=\"/cgi-bin/an-mc?cluster=$conf->{cgi}{cluster}\" target=\"_new\">Media Connector</a>";
		
		# Enable the "New Server" button if there is enough free memory
		# and storage space.
		if (($enough_storage) && ($free_ram > 1073741824))
		{
			$say_bns = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=provision&max_ram=$free_ram&max_cores=$conf->{resources}{total_cores}&max_storage=$vg_link\">Build a New Server</a>";
		}
	}
	print "
	<tr>
		<td colspan=\"12\">
			<table class=\"hidden_table\" width=\"100%\">
				<tr>
					<td width=\"50%\" class=\"td_hidden\">
						$say_bns
					</td>
					<td width=\"50%\" class=\"td_hidden\">
						$say_mc
					</td>
				</tr>
			</table>
		</td>
	</tr>
";

	return (0);
}

# Simply converts a full domain name back to the node name used in the main hash.
sub long_host_name_to_node_name
{
	my ($conf, $host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in long_host_name_to_node_name(), host: [$host]\n");
	
	my $cluster   = $conf->{cgi}{cluster};
	my $node_name = "";
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster]\n");
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node]\n");
		my $short_host =  $host;
		   $short_host =~ s/\..*$//;
		my $short_node =  $node;
		   $short_node =~ s/\..*$//;
		#record($conf, "$THIS_FILE ".__LINE__."; short_host: [$short_host], short_node: [$short_node]\n");
		if ($short_host eq $short_node)
		{
			$node_name = $node;
			#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
			last;
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
	return ($node_name);
}

# Simply converts a node name to the full domain name.
sub node_name_to_long_host_name
{
	my ($conf, $host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in node_name_to_long_host_name(), host: [$host]\n");
	
	my $node_name = $conf->{node}{$host}{me}{name};

	#record($conf, "$THIS_FILE ".__LINE__."; node name: [$node_name]\n");
	return ($node_name);
}

# This just shows the details of the VM (no controls)
sub display_vm_details
{
	my ($conf) = @_;
	
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"6\">
			<b>Virtual Machines - Details</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<i>CPU</i>
		</td>
		<td>
			<i>RAM</i>
		</td>
		<td colspan=\"2\">
			<i>Storage</i>
		</td>
		<td>
			<i>Network</i>
		</td>
	</tr>
";
	
	# Pull up the VM details.
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		next if $vm !~ /^vm/;
		
		my $say_vm  = ($vm =~ /^vm:(.*)/)[0];
		my $say_ram = $conf->{'system'}{gfs2_down} ? "<span class=\"fixed_width\">--</span>" : bytes_to_hr($conf, $conf->{vm}{$vm}{details}{ram});
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_ram: [$say_ram], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		
		# Get the LV arrays populated.
		my @lv_path;
		my @lv_size;
		my $host = $conf->{vm}{$vm}{host};
		
		# If the host is "none", read the details from one of the "up"
		# nodes.
		if ($host eq "none")
		{
			# If the first node is running, use it. Otherwise use
			# the second node.
			my $node1_daemons_running = check_node_daemons($conf, $node1);
			my $node2_daemons_running = check_node_daemons($conf, $node2);
			if ($node1_daemons_running)
			{
				$host = $node1;
			}
			elsif ($node2_daemons_running)
			{
				$host = $node2;
			}
		}
		
		my @bridge;
		my @device;
		my @mac;
		my @type;
		my $node         = "--";
		my $say_net_host = ""; # Don't want anything printed when the VM is down
		my $say_host     = "--";
		if ($host)
		{
			$node = long_host_name_to_node_name($conf, $host);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$host], node: [$node]\n");
			
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$host], node: [$node], lv hash on node1: [$conf->{vm}{$vm}{node}{$node1}{lv}], lv hash on node2: [$conf->{vm}{$vm}{node}{$node2}{lv}]\n");
			foreach my $lv (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
			{
				#record ($conf, "$THIS_FILE ".__LINE__."; lv: [$lv], size: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}]\n");
				push @lv_path, $lv;
				push @lv_size, $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size};
			}
			
			# Get the network arrays built.
			foreach my $current_bridge (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{details}{bridge}})
			{
				push @bridge, $current_bridge;
				push @device, $conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device};
				push @mac,    uc($conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac});
				push @type,   $conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type};
			}
			
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
			if ($conf->{vm}{$vm}{host} ne "none")
			{
				$say_host  =  $conf->{vm}{$vm}{host};
				$say_host  =~ s/\..*//;
				$say_net_host = "<span class=\"highlight_detail\">$say_host</span> -> <span class=\"highlight_detail\">$bridge[0]</span> -> <span class=\"highlight_detail\">$device[0]</span> -> ";
			}
		}
		
		# If there is no host, only the device type and MAC address are valid.
		$conf->{vm}{$vm}{details}{cpu_count} = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$lv_path[0]                          = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$lv_size[0]                          = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$type[0]                             = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		$mac[0]                              = "<span class=\"fixed_width\">--</span>" if $conf->{'system'}{gfs2_down};
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$say_vm</span>
		</td>
		<td>
			$conf->{vm}{$vm}{details}{cpu_count}
		</td>
		<td>
			$say_ram
		</td>
		<td>
			<span class=\"fixed_width\">$lv_path[0]</span>
		</td>
		<td>
			$lv_size[0]
		</td>
		<td>
			$say_net_host <span class=\"highlight_detail\">$type[0]</span> / <span class=\"highlight_detail\">$mac[0]</span>
		</td>
	</tr>
";
		my $lv_count   = @lv_path;
		my $nic_count  = @bridge;
		my $loop_count = $lv_count >= $nic_count ? $lv_count : $nic_count;
		if ($loop_count > 0)
		{
			for (my $i=1; $loop_count > $i; $i++)
			{
				my $say_lv_path = $lv_path[$i] ? $lv_path[$i] : "&nbsp;";
				my $say_lv_size = $lv_size[$i] ? $lv_size[$i] : "&nbsp;";
				my $say_network = "&nbsp;";
				if ($bridge[$i])
				{
					my $say_net_host = "";
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
					if ($conf->{vm}{$vm}{host} ne "none")
					{
						my $say_host  =  $conf->{vm}{$vm}{host};
						$say_host  =~ s/\..*//;
						$say_net_host = "<span class=\"highlight_detail\">$say_host</span> -> <span class=\"highlight_detail\">$bridge[$i]</span> -> <span class=\"highlight_detail\">$device[$i]</span> -> ";
					}
					$say_network = "$say_net_host <span class=\"highlight_detail\">$type[$i]</span> / <span class=\"highlight_detail\">$mac[$i]</span>";
				}
				
				print "
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_lv_path
		</td>
		<td>
			$say_lv_size
		</td>
		<td>
			$say_network
		</td>
	</tr>
";
			}
		}
	}
	
	print "
</table>
<br />
";
	return (0);
}

# This checks the daemons running on a node and returns '1' if all are running.
sub check_node_daemons
{
	my ($conf, $node) = @_;
	if (not $node)
	{
		error($conf, "I was asked to check the daemons for a node, but was not passed a node name. This is likely a program error.\n");
	}
	#record($conf, "$THIS_FILE ".__LINE__."; in check_node_daemons(), node: [$node]\n");
	my $ready = 1;
	
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], cman exit_code:      [$conf->{node}{$node}{daemon}{cman}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rgmanager exit_code: [$conf->{node}{$node}{daemon}{rgmanager}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], drbd exit_code:      [$conf->{node}{$node}{daemon}{drbd}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], clvmd exit_code:     [$conf->{node}{$node}{daemon}{clvmd}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], gfs2 exit_code:      [$conf->{node}{$node}{daemon}{gfs2}{exit_code}]\n");
# 	record($conf, "$THIS_FILE ".__LINE__."; node: [$node], libvirtd exit_code:  [$conf->{node}{$node}{daemon}{libvirtd}{exit_code}]\n");
	
	if (($conf->{node}{$node}{daemon}{cman}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{rgmanager}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{drbd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{gfs2}{exit_code} ne "0") ||
	($conf->{node}{$node}{daemon}{libvirtd}{exit_code} ne "0"))
	{
		$ready = 0;
	}
	
	return($ready);
}

# This checks a node to see if it's ready to run a given VM.
sub check_node_readiness
{
	my ($conf, $vm, $node) = @_;
	if (not $node)
	{
		error($conf, "I was asked to check the node readiness to run the $vm VM, but was not passed a node name. This is likely a program error.\n");
	}

	#record($conf, "$THIS_FILE ".__LINE__."; in check_node_readiness(); vm: [$vm], node: [$node]\n");
	
	# This will get negated if something isn't ready.
	my $ready = check_node_daemons($conf, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; 1. vm: [$vm], node: [$node], ready: [$ready]\n");
	
	# TODO: Add split-brain detection. If both nodes are 
	# Primary/StandAlone, shut the whole cluster down.
	
	# Make sure the storage is ready.
	if ($ready)
	{
		# Still alive, find out what storage backs this VM and ensure
		# that the LV is 'active' and that the DRBD resource(s) they
		# sit on are Primary and UpToDate.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm]\n");
		read_vm_definition($conf, $node, $vm);
		
		foreach my $lv (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}})
		{
			# Make sure the LV is active.
			#record($conf, "$THIS_FILE ".__LINE__.";  - vm: [$vm], node: [$node], lv: [$lv]\n");
			#record($conf, "$THIS_FILE ".__LINE__.";    - active:           [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active}]\n");
			if ($conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active})
			{
				# It's active, so now check the backing storage.
				foreach my $res (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}})
				{
					# For easier reading...
					my $cs = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{connection_state};
					my $ro = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{role};
					my $ds = $conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$res}{disk_state};
					#record($conf, "$THIS_FILE ".__LINE__.";    - res:              [$res]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - connection state: [$cs]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - role:             [$ro]\n");
					#record($conf, "$THIS_FILE ".__LINE__.";    - disk state:       [$ds]\n");
					
					# I consider a node "ready" if it is UpToDate and Primary.
					if (($ro ne "Primary") || ($ds ne "UpToDate"))
					{
						$ready = 0;
						#record($conf, "$THIS_FILE ".__LINE__."; 2. ready: [$ready]\n");
					}
				}
			}
			else
			{
				# The LV is inactive.
				# TODO: Try to change the LV to active.
				$ready = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; 3. vm: [$vm], node: [$node], ready: [$ready]\n");
			}
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; 4. vm: [$vm], node: [$node], ready: [$ready]\n");
	
	return ($ready);
}

# This reads a VM's definition file and pulls out information about the system.
sub read_vm_definition
{
	my ($conf, $node, $vm) = @_;
	if (not $vm)
	{
		error($conf, "I was asked to look at a VM's definition file, but no VM was specified.", 1);
	}
	my $say_vm = $vm;
	if ($vm =~ /vm:(.*)/)
	{
		$say_vm = $1;
	}
	else
	{
		$vm = "vm:$vm";
	}
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_vm: [$say_vm]\n");
	$conf->{vm}{$vm}{definition_file} = "" if not defined $conf->{vm}{$vm}{definition_file};
	$conf->{vm}{$vm}{xml}             = "" if not defined $conf->{vm}{$vm}{xml};
	#record($conf, "$THIS_FILE ".__LINE__."; in read_vm_definition(); node: [$node], vm: [$vm], say_vm: [$say_vm], definition_file: [$conf->{vm}{$vm}{definition_file}], XML array? [".ref($conf->{vm}{$vm}{xml})."]\n");

	# Here I want to parse the VM definition XML. Hopefully it was already
	# read in, but if not, I'll make a specific SSH call to get it.
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], XML: [$conf->{vm}{$vm}{xml}], def: [$conf->{vm}{$vm}{definition_file}]\n");
	if ((not ref($conf->{vm}{$vm}{xml}) eq "ARRAY") && ($conf->{vm}{$vm}{definition_file}))
	{
		$conf->{vm}{$vm}{xml} = [];
		my $fh = IO::Handle->new();
		my $sc = "ssh root\@$node \"cat $conf->{vm}{$vm}{definition_file}\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			push @{$conf->{vm}{$vm}{xml}}, $line;
		}
		$fh->close();
	}
	
	my $in_disk      = 0;
	my $in_interface = 0;
	my $current_bridge;
	my $current_device;
	my $current_mac_address;
	my $current_interface_type;
	if (not $conf->{vm}{$vm}{xml})
	{
		record($conf, "$THIS_FILE ".__LINE__."; I was asked to look at: [$vm]'s definition file, it was not read or was not found.");
		return (0);
	}
	foreach my $line (@{$conf->{vm}{$vm}{xml}})
	{
		my $line=lc($line); # everything should be lower case already.
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], line: [$line]\n");
		
		# Pull out RAM amount.
		if ($line =~ /<memory>(\d+)<\/memory>/)
		{
			# Record the memory, multiple by 1024 to get bytes.
			$conf->{vm}{$vm}{details}{ram} =  $1;
			$conf->{vm}{$vm}{details}{ram} *= 1024;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		}
		if ($line =~ /<memory unit='(.*?)'>(\d+)<\/memory>/)
		{
			# Record the memory, multiple by 1024 to get bytes.
			my $units                      =  $1;
			my $ram                        =  $2;
			$conf->{vm}{$vm}{details}{ram} = hr_to_bytes($conf, $ram, $units, 1);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], ram: [$conf->{vm}{$vm}{details}{ram}]\n");
		}
		
		# TODO: Support pinned cores.
		# Pull out the CPU details
		if ($line =~ /<vcpu>(\d+)<\/vcpu>/)
		{
			$conf->{vm}{$vm}{details}{cpu_count} = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], cpu count: [$conf->{vm}{$vm}{details}{cpu_count}]\n");
		}
		if ($line =~ /<vcpu placement='(.*?)'>(\d+)<\/vcpu>/)
		{
			my $cpu_type                         = $1;
			$conf->{vm}{$vm}{details}{cpu_count} = $2;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], cpu count: [$conf->{vm}{$vm}{details}{cpu_count}], type: [$cpu_type]\n");
		}
		
		# Pull out network details.
		if (($line =~ /<interface/) && ($line =~ /type='bridge'/))
		{
			$in_interface = 1;
			next;
		}
		elsif ($line =~ /<\/interface/)
		{
			# Record the values I found
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device} = $current_device         ? $current_device         : "unknown";
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac}    = $current_mac_address    ? $current_mac_address    : "unknown";
			$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type}   = $current_interface_type ? $current_interface_type : "unknown";
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], bride: [$current_bridge], device: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{device}], mac: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{mac}], type: [$conf->{vm}{$vm}{details}{bridge}{$current_bridge}{type}]\n");
			$current_bridge         = "";
			$current_device         = "";
			$current_mac_address    = "";
			$current_interface_type = "";
			$in_interface           = 0;
			next;
		}
		if ($in_interface)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], interface line: [$line]\n");
			if ($line =~ /source bridge='(.*?)'/)
			{
				$current_bridge = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], bridge: [$current_bridge]\n");
			}
			if ($line =~ /mac address='(.*?)'/)
			{
				$current_mac_address = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], mac: [$current_mac_address]\n");
			}
			if ($line =~ /target dev='(.*?)'/)
			{
				$current_device = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], device: [$current_device]\n");
			}
			if ($line =~ /model type='(.*?)'/)
			{
				$current_interface_type = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], type: [$current_interface_type]\n");
			}
		}
		
		# Pull out disk info.
		if (($line =~ /<disk/) && ($line =~ /type='block'/) && ($line =~ /device='disk'/))
		{
			$in_disk = 1;
			next;
		}
		elsif ($line =~ /<\/disk/)
		{
			$in_disk = 0;
			next;
		}
		if ($in_disk)
		{
			if ($line =~ /source dev='(.*?)'/)
			{
				my $lv = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], checking LV: [$lv]\n");
				check_lv($conf, $node, $vm, $lv);
			}
		}
	}
	
	return (0);
}

# This takes a node name and an LV and checks the DRBD resources to see if they
# are Primary and UpToDate.
sub check_lv
{
	my ($conf, $node, $vm, $lv) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VM: [$vm], LV: [$lv]\n");
	
	# If this node is down, just return.
	if ($conf->{node}{$node}{daemon}{clvmd}{exit_code} ne "0")
	{
		#record($conf, "$THIS_FILE ".__LINE__."; The node: [$node] is down, skipping LV check for: [$lv] for VM: [$vm]\n");
		return(0);
	}
	
	$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{active} = $conf->{node}{$node}{lvm}{lv}{$lv}{active};
	$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}   = bytes_to_hr($conf, $conf->{node}{$node}{lvm}{lv}{$lv}{total_size});
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VM: [$vm], LV: [$lv], active: [$conf->{node}{$node}{lvm}{lv}{$lv}{active}], size: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{size}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$lv}{on_devices}]\n");
	
	# If there is a comman in the devices, the LV spans multiple devices.
	foreach my $device (split/,/, $conf->{node}{$node}{lvm}{lv}{$lv}{on_devices})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; device: [$device]\n");
		# Find the resource name.
		my $on_res;
		foreach my $res (sort {$a cmp $b} keys %{$conf->{drbd}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; res: [$res]\n");
			my $res_device = $conf->{drbd}{$res}{node}{$node}{device};
			#record($conf, "$THIS_FILE ".__LINE__."; res: [$res], device: [$device], res. device: [$res_device]\n");
			if ($device eq $res_device)
			{
				#record($conf, "$THIS_FILE ".__LINE__."; match! Recording res as: [$res]\n");
				$on_res = $res;
				last;
			}
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], on_res: [$on_res]\n");
		
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{connection_state} = $conf->{drbd}{$on_res}{node}{$node}{connection_state};
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{role}             = $conf->{drbd}{$on_res}{node}{$node}{role};
		$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{disk_state}       = $conf->{drbd}{$on_res}{node}{$node}{disk_state};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], cs: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{connection_state}]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], ro: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{role}]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], lv: [$lv], ds: [$conf->{vm}{$vm}{node}{$node}{lv}{$lv}{drbd}{$on_res}{disk_state}]\n");
	}
	
	return (0);
}

# Check the status of VMs.
sub check_vms
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	
	#record($conf, "$THIS_FILE ".__LINE__."; node 1: n[$node1] s[$conf->{node}{$node1}{info}{short_host_name}] l[$conf->{node}{$node1}{info}{host_name}], node 2: n[$node2] s[$conf->{node}{$node2}{info}{short_host_name}] l[$conf->{node}{$node2}{info}{host_name}]\n");
	my $short_node1 = "$conf->{node}{$node1}{info}{short_host_name}";
	my $short_node2 = "$conf->{node}{$node2}{info}{short_host_name}";
	my $long_node1  = "$conf->{node}{$node1}{info}{host_name}";
	my $long_node2  = "$conf->{node}{$node2}{info}{host_name}";
	my $say_node1   = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2   = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		my $say_vm;
		if ($vm =~ /^vm:(.*)/)
		{
			$say_vm = $1;
		}
		else
		{
			error($conf, "I was asked to check on a VM that didn't have the <span class=\"code\">vm:</span> prefix. I got the name: <span class=\"code\">$vm</span>. This is likely a programming error.\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say_vm: [$say_vm]\n");
		
		# This will control the buttons.
		$conf->{vm}{$vm}{can_start}        = 0;
		$conf->{vm}{$vm}{can_stop}         = 0;
		$conf->{vm}{$vm}{can_migrate}      = 0;
		$conf->{vm}{$vm}{current_host}     = 0;
		$conf->{vm}{$vm}{migration_target} = "";
		
		# Find out who, if anyone, is running this VM and who *can* run
		# it. 2 == Running, 1 == Can run, 0 == Can't run.
		$conf->{vm}{$vm}{say_node1}        = $conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0" ? "<span class=\"highlight_warning\">Not Ready</span>" : "<span class=\"code\">--</span>";
		$conf->{vm}{$vm}{node1_ready}      = 0;
		$conf->{vm}{$vm}{say_node2}        = $conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0" ? "<span class=\"highlight_warning\">Not Ready</span>" : "<span class=\"code\">--</span>";
		$conf->{vm}{$vm}{node2_ready}      = 0;
		
		# If a VM's XML definition file is found but there is no host,
		# the user probably forgot to define it.
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host: [$conf->{vm}{$vm}{host}]\n");
		if ((not $conf->{vm}{$vm}{host}) && (not $conf->{'system'}{ignore_missing_vm}))
		{
			# Pull the host node and current state out of the hash.
			my $host_node = "";
			my $vm_state  = "";
			foreach my $node (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}})
			{
				$host_node = $node;
				foreach my $key (sort {$a cmp $b} keys %{$conf->{vm}{$vm}{node}{$node}{virsh}})
				{
					if ($key eq "state") 
					{
						$vm_state = $conf->{vm}{$vm}{node}{$host_node}{virsh}{'state'};
					}
					#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node: [$node], virsh '$key': [$conf->{vm}{$vm}{node}{$node}{virsh}{$key}]\n");
				}
			}
			$conf->{vm}{$vm}{say_node1} = "--";
			$conf->{vm}{$vm}{say_node2} = "--";
			error($conf, "I found a server with the name: [<span class=\"highlight_detail\">$say_vm</span>] which is not managed by the Anvil! yet.<br /><b>If this is a new server that is still being installed, please ignore this message.</b><br />If you do not have the original dashboard install window open anymore, you can <a href=\"?cluster=$conf->{cgi}{cluster}&task=add_vm&name=$say_vm&node=$host_node&state=$vm_state\"><b>click here to add it</b></a> to this Anvil! now.", 0);
			next;
		}
		
		$conf->{vm}{$vm}{host} = "" if not defined $conf->{vm}{$vm}{host};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], current host: [$conf->{vm}{$vm}{host}], node1 / node2 short names: [$short_node1] / [$short_node2]\n");
		if ($conf->{vm}{$vm}{host} =~ /$short_node1/)
		{
			# Even though I know the host is ready, this function
			# loads some data, like LV details, which I will need
			# later.
			check_node_readiness($conf, $vm, $node1);
			$conf->{vm}{$vm}{can_start}     = 0;
			$conf->{vm}{$vm}{can_stop}      = 1;
			$conf->{vm}{$vm}{current_host}  = $node1;
			$conf->{vm}{$vm}{node1_ready}   = 2;
			($conf->{vm}{$vm}{node2_ready}) = check_node_readiness($conf, $vm, $node2);
			if ($conf->{vm}{$vm}{node2_ready})
			{
				$conf->{vm}{$vm}{migration_target} = $long_node2;
				$conf->{vm}{$vm}{can_migrate}      = 1;
			}
			# Disable cluster withdrawl of this node.
			$conf->{node}{$node1}{enable_withdraw} = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1: [$node1], node2 ready: [$conf->{vm}{$vm}{node2_ready}], can migrate: [$conf->{vm}{$vm}{can_migrate}], migration target: [$conf->{vm}{$vm}{migration_target}]\n");
		}
		elsif ($conf->{vm}{$vm}{host} =~ /$short_node2/)
		{
			# Even though I know the host is ready, this function
			# loads some data, like LV details, which I will need
			# later.
			check_node_readiness($conf, $vm, $node2);
			$conf->{vm}{$vm}{can_start}     = 0;
			$conf->{vm}{$vm}{can_stop}      = 1;
			$conf->{vm}{$vm}{current_host}  = $node2;
			($conf->{vm}{$vm}{node1_ready}) = check_node_readiness($conf, $vm, $node1);
			$conf->{vm}{$vm}{node2_ready}   = 2;
			if ($conf->{vm}{$vm}{node1_ready})
			{
				$conf->{vm}{$vm}{migration_target} = $long_node1;
				$conf->{vm}{$vm}{can_migrate}      = 1;
			}
			# Disable withdrawl of this node.
			$conf->{node}{$node2}{enable_withdraw} = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1: [$node1], node2 ready: [$conf->{vm}{$vm}{node2_ready}], can migrate: [$conf->{vm}{$vm}{can_migrate}], migration target: [$conf->{vm}{$vm}{migration_target}]\n");
		}
		else
		{
			$conf->{vm}{$vm}{can_stop}      = 0;
			($conf->{vm}{$vm}{node1_ready}) = check_node_readiness($conf, $vm, $node1);
			($conf->{vm}{$vm}{node2_ready}) = check_node_readiness($conf, $vm, $node2);
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1_ready: [$conf->{vm}{$vm}{node1_ready}], node2_ready: [$conf->{vm}{$vm}{node2_ready}]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], current host: [$conf->{vm}{$vm}{current_host}]\n");
		$conf->{vm}{$vm}{boot_target} = "";
		if ($conf->{vm}{$vm}{current_host})
		{
			# This is a bit expensive, but read the VM's running
			# definition.
			my $host   = $conf->{vm}{$vm}{current_host};
			my $say_vm = $vm;
			$say_vm =~ s/^vm://;
			#record($conf, "$THIS_FILE ".__LINE__."; Reading the XML for the VM: [$vm] which is currently running on: [$conf->{vm}{$vm}{current_host}]\n");
			my $fh = IO::Handle->new();
			my $sc = "ssh root\@$host \"virsh dumpxml $say_vm\"";
			#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
			while(<$fh>)
			{
				chomp;
				my $line = $_;
				$line =~ s/^\s+//;
				$line =~ s/\s+$//;
				$line =~ s/\s+/ /g;
				#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
				push @{$conf->{vm}{$vm}{xml}}, $line;
			}
			$fh->close();
		}
		else
		{
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], node1_ready: [$conf->{vm}{$vm}{node1_ready}], node2_ready: [$conf->{vm}{$vm}{node2_ready}]\n");
			if (($conf->{vm}{$vm}{node1_ready}) && ($conf->{vm}{$vm}{node2_ready}))
			{
				# I can boot on either node, so choose the 
				# first one in the VM's failover domain.
				$conf->{vm}{$vm}{boot_target} = find_prefered_host($conf, $vm);
				$conf->{vm}{$vm}{can_start}   = 1;
			}
			elsif ($conf->{vm}{$vm}{node1_ready})
			{
				$conf->{vm}{$vm}{boot_target} = $node1;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}]\n");
			}
			elsif ($conf->{vm}{$vm}{node2_ready})
			{
				$conf->{vm}{$vm}{boot_target} = $node2;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], boot target: [$conf->{vm}{$vm}{boot_target}]\n");
			}
			else
			{
				$conf->{vm}{$vm}{can_start} = 0;
				#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], can_start: [$conf->{vm}{$vm}{can_start}]\n");
			}
		}
	}
	
	return (0);
}

# This looks through the failover domain for a VM and returns the prefered host.
sub find_prefered_host
{
	my ($conf, $vm) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in find_prefered_host(), vm: [$vm]\n");
	my $prefered_host = "";
	
	my $failover_domain = $conf->{vm}{$vm}{failover_domain};
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], failover_domain: [$failover_domain]\n");
	if (not $failover_domain)
	{
		# Not yet defined in the cluster.
		return("--");
	}
	
	# TODO: Check to see if I need to use <=> instead of cmp.
	foreach my $priority (sort {$a cmp $b} keys %{$conf->{failoverdomain}{$failover_domain}{priority}})
	{
		# I only care about the first entry, so I will
		# exit the loop as soon as I analyze it.
		$prefered_host = $conf->{failoverdomain}{$failover_domain}{priority}{$priority}{node};
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], prefered host: [$prefered_host]\n");
		last;
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], prefered host: [$prefered_host]\n");
	return ($prefered_host);
}

# This function simply sets a couple variables using the node names as set in
# the $conf hash declaration
sub set_node_names
{
	my ($conf) = @_;
	
	# First pull the names into easier to follow variables.
	my $this_cluster = $conf->{cgi}{cluster};
	$conf->{'system'}{cluster}{node1_name} = $conf->{clusters}{$this_cluster}{nodes}[0];
	$conf->{'system'}{cluster}{node2_name} = $conf->{clusters}{$this_cluster}{nodes}[1];
	#record($conf, "$THIS_FILE ".__LINE__."; this_cluster: [$this_cluster], node1: [$conf->{'system'}{cluster}{node1_name}], node2: [$conf->{'system'}{cluster}{node2_name}]\n");
	
	return (0);
}

# This shows the current state of the VMs as well as the available control
# buttons.
sub display_vm_state_and_controls
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	#record($conf, "$THIS_FILE ".__LINE__."; node1: [$node1], node1_long: [$node1_long]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; node2: [$node2], node2_long: [$node2_long]\n");
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"10\">
			<b>Virtual Machines - Status and Control</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>
		</td>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>
		</td>
		<td>
			Prefered Host
		</td>
		<td colspan=\"6\">
			<i>Controls</i>
		</td>
	</tr>
";

	foreach my $vm (sort {$a cmp $b} keys %{$conf->{vm}})
	{
		# Break the name out of the hash key.
		my ($say_vm) = ($vm =~ /^vm:(.*)/);
		#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], say vm: [$say_vm]\n");
		
		# Use the node's short name for the buttons.
		my $say_start_target     =  $conf->{vm}{$vm}{boot_target} ? $conf->{vm}{$vm}{boot_target} : "--";
		$say_start_target        =~ s/\..*?$//;
		my $start_target_long    = $node1_long =~ /$say_start_target/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		my $start_target_name    = $node1      =~ /$say_start_target/ ? $node1 : $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; say_start_target: [$say_start_target], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}], start_target_long: [$start_target_long]\n");
		
		my $prefered_host        =  find_prefered_host($conf, $vm);
		$prefered_host           =~ s/\..*$//;
		if ($conf->{vm}{$vm}{boot_target})
		{
			$prefered_host = "<span class=\"highlight_ready\">$prefered_host</span>";
		}
		else
		{
			my $on_host =  $conf->{vm}{$vm}{host};
			   $on_host =~ s/\..*$//;
			#record($conf, "$THIS_FILE ".__LINE__."; on_host: [$on_host], prefered_host: [$prefered_host]\n");
			if (($on_host eq $prefered_host) || ($on_host eq "none"))
			{
				$prefered_host = "<span class=\"highlight_good\">$prefered_host</span>";
			}
			else
			{
				$prefered_host = "<span class=\"highlight_warning\">$prefered_host</span>";
			}
			#record($conf, "$THIS_FILE ".__LINE__."; prefered_host: [$prefered_host]\n");
		}
		
		my $say_migration_target =  $conf->{vm}{$vm}{migration_target};
		$say_migration_target    =~ s/\..*?$//;
		my $migrate_button = "<span class=\"disabled_button\">Migrate</span>";
		if ($conf->{vm}{$vm}{can_migrate})
		{
			$migrate_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=migrate_vm&target=$conf->{vm}{$vm}{migration_target}&vm_ram=$conf->{vm}{$vm}{details}{ram}\">Migrate to <span class=\"fixed_width_button\">$say_migration_target</span></a>";
		}
		my $host_node        = "$conf->{vm}{$vm}{host}";
		my $stop_button      = "<span class=\"disabled_button\">Shut Down</span>";
		my $force_off_button = "<span class=\"disabled_button\">Force Off</span>";
		if ($conf->{vm}{$vm}{can_stop})
		{
			$host_node        = long_host_name_to_node_name($conf, $conf->{vm}{$vm}{host});
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$vm], host node: [$host_node], vm host: [$conf->{vm}{$vm}{host}]\n");
			$stop_button      = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=stop_vm&vm=$say_vm&node=$host_node\">Orderly Shut Down</a>";
			$force_off_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=force_off_vm&vm=$say_vm&node=$host_node&host=$conf->{vm}{$vm}{host}\" class=\"highlight_dangerous\">Force Off</a>";
		}
		my $start_button     = "<span class=\"disabled_button\">Boot Up</span>";
		if ($conf->{vm}{$vm}{boot_target})
		{
			$start_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=start_vm&vm=$say_vm&node=$start_target_name&node_cluster_name=$start_target_long\">Boot Up</a>";
		}
		#record($conf, "$THIS_FILE ".__LINE__."; start_button:     [$start_button], vm::${vm}::boot_target: [$conf->{vm}{$vm}{boot_target}]\n");
		
		# I need both nodes up to delete a VM.
		#my $say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		# I need both nodes up to delete a VM.
		my $say_delete_button = "<span class=\"disabled_button\">Delete</span>";
		#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::daemon::cman::exit_code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], node::${node2}::daemon::cman::exit_code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}]\n");
		if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0"))
		{
			$say_delete_button = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$say_vm&task=delete_vm\"><span class=\"highlight_dangerous\">Delete</span></a>";
		}
		
		#record($conf, "$THIS_FILE ".__LINE__." > say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		if ($conf->{vm}{$vm}{node1_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node1_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node1} = "<span class=\"highlight_ready\">Ready</span>";
		}
		if ($conf->{vm}{$vm}{node2_ready} == 2)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_good\">Running</span>";
		}
		elsif ($conf->{vm}{$vm}{node2_ready} == 1)
		{
			$conf->{vm}{$vm}{say_node2} = "<span class=\"highlight_ready\">Ready</span>";
		}
		#record($conf, "$THIS_FILE ".__LINE__." < say_n1: [$conf->{vm}{$vm}{say_node1}], say_n2: [$conf->{vm}{$vm}{say_node2}]\n");
		
		# I don't want to make the VM editable until the cluster is
		# runnong on at least one node.
		my $dual_join   = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
		my $say_vm_link = "<span class=\"fixed_width\"><a href=\"?cluster=$conf->{cgi}{cluster}&vm=$vm&task=manage_vm\">$say_vm</a></span>";
		if ($dual_join)
		{
			$say_vm_link   = "<span class=\"highlight_unavailable\">$say_vm</span>";
		}
		
		print "
	<tr>
		<td>
			$say_vm_link
		</td>
		<td>
			$conf->{vm}{$vm}{say_node1}
		</td>
		<td>
			$conf->{vm}{$vm}{say_node2}
		</td>
		<td>
			<span class=\"fixed_width\">$prefered_host</span>
		</td>
		<td>
			$start_button
		</td>
		<td>
			$migrate_button
		</td>
		<td>
			$stop_button
		</td>
		<td>
			$force_off_button
		</td>
		<td>
			&nbsp;
		</td>
		<td>
			$say_delete_button
		</td>
	</tr>
";
	}
	
	# When enabling the "Start" button, be sure to start on the highest 
	# priority host in the failover domain, when possible.
	
	print "
</table>
<br />
";
	
	return (0);
}

# This shows the status of each DRBD resource in the cluster.
sub display_drbd_details
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $say_node1 = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2 = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"9\">
			<b>Replicated Storage</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"2\">
			<i>Device</i>
		</td>
		<td colspan=\"2\">
			<i>Connection</i>
		</td>
		<td colspan=\"2\">
			<i>Role</i>
		</td>
		<td colspan=\"2\">
			<i>Disk State</i>
		</td>
	</tr>
	<tr>
		<td>
			<i>Resource</i>
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
		<td>
			$say_node1
		</td>
		<td>
			$say_node2
		</td>
	</tr>
";

	foreach my $res (sort {$a cmp $b} keys %{$conf->{drbd}})
	{
		# If the DRBD daemon is stopped, I will use the values from the
		# resource files.
		my $say_n1_dev = "--";
		my $say_n2_dev = "--";
		my $say_n1_cs  = "--";
		my $say_n2_cs  = "--";
		my $say_n1_ro  = "--";
		my $say_n2_ro  = "--";
		my $say_n1_ds  = "--";
		my $say_n2_ds  = "--";
		
		# Check if node 1 is online.
		if ($conf->{node}{$node1}{up})
		{
			# It is, but is DRBD running?
			if ($conf->{node}{$node1}{daemon}{drbd}{exit_code} eq "0")
			{
				# It is. 
				$say_n1_dev = $conf->{drbd}{$res}{node}{$node1}{device};
				$say_n1_cs  = $conf->{drbd}{$res}{node}{$node1}{connection_state};
				$say_n1_ro  = $conf->{drbd}{$res}{node}{$node1}{role};
				$say_n1_ds  = $conf->{drbd}{$res}{node}{$node1}{disk_state};
			}
			else
			{
				# It is not, use the {res_file} values.
				$say_n1_dev = $conf->{drbd}{$res}{node}{$node1}{res_file}{device};
				$say_n1_cs  = $conf->{drbd}{$res}{node}{$node1}{res_file}{connection_state};
				$say_n1_ro  = $conf->{drbd}{$res}{node}{$node1}{res_file}{role};
				$say_n1_ds  = $conf->{drbd}{$res}{node}{$node1}{res_file}{disk_state};
			}
		}
		# Check if node 2 is online.
		if ($conf->{node}{$node2}{up})
		{
			# It is, but is DRBD running?
			if ($conf->{node}{$node2}{daemon}{drbd}{exit_code} eq "0")
			{
				# It is. 
				$say_n2_dev = $conf->{drbd}{$res}{node}{$node2}{device};
				$say_n2_cs  = $conf->{drbd}{$res}{node}{$node2}{connection_state};
				$say_n2_ro  = $conf->{drbd}{$res}{node}{$node2}{role};
				$say_n2_ds  = $conf->{drbd}{$res}{node}{$node2}{disk_state};
			}
			else
			{
				# It is not, use the {res_file} values.
				$say_n2_dev = $conf->{drbd}{$res}{node}{$node2}{res_file}{device};
				$say_n2_cs  = $conf->{drbd}{$res}{node}{$node2}{res_file}{connection_state};
				$say_n2_ro  = $conf->{drbd}{$res}{node}{$node2}{res_file}{role};
				$say_n2_ds  = $conf->{drbd}{$res}{node}{$node2}{res_file}{disk_state};
			}
		}
		
		my $class_n1_cs  = "highlight_unavailable";
		$class_n1_cs     = "highlight_good" if $say_n1_cs eq "Connected";
		$class_n1_cs     = "highlight_ready"if $say_n1_cs eq "WFConnection";
		my $class_n2_cs  = "highlight_unavailable";
		$class_n2_cs     = "highlight_good" if $say_n2_cs eq "Connected";
		$class_n2_cs     = "highlight_ready"if $say_n2_cs eq "WFConnection";
		my $class_n1_ro  = "highlight_unavailable";
		$class_n1_ro     = "highlight_good"    if $say_n1_ro eq "Primary";
		$class_n1_ro     = "highlight_warning" if $say_n1_ro eq "Secondary";
		my $class_n2_ro  = "highlight_unavailable";
		$class_n2_ro     = "highlight_good"    if $say_n2_ro eq "Primary";
		$class_n2_ro     = "highlight_warning" if $say_n2_ro eq "Secondary";
		my $class_n1_ds  = "highlight_unavailable";
		$class_n1_ds     = "highlight_good"    if $say_n1_ds eq "UpToDate";
		$class_n1_ds     = "highlight_warning" if $say_n1_ds eq "Inconsistent";
		$class_n1_ds     = "highlight_warning" if $say_n1_ds eq "Outdated";
		$class_n1_ds     = "highlight_bad"     if $say_n1_ds eq "Diskless";
		my $class_n2_ds  = "highlight_unavailable";
		$class_n2_ds     = "highlight_good"    if $say_n2_ds eq "UpToDate";
		$class_n2_ds     = "highlight_warning" if $say_n2_ds eq "Inconsistent";
		$class_n2_ds     = "highlight_warning" if $say_n2_ds eq "Outdated";
		$class_n2_ds     = "highlight_bad"     if $say_n2_ds eq "Diskless";
		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$res</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_n1_dev</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_n2_dev</span>
		</td>
		<td>
			<span class=\"$class_n1_cs\">$say_n1_cs</span>
		</td>
		<td>
			<span class=\"$class_n2_cs\">$say_n2_cs</span>
		</td>
		<td>
			<span class=\"$class_n1_ro\">$say_n1_ro</span>
		</td>
		<td>
			<span class=\"$class_n2_ro\">$say_n2_ro</span>
		</td>
		<td>
			<span class=\"$class_n1_ds\">$say_n1_ds</span>
		</td>
		<td>
			<span class=\"$class_n2_ds\">$say_n2_ds</span>
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";
	
	return (0);
}

# This shows the details on each node's GFS2 mount(s)
sub display_gfs2_details
{
	my ($conf) = @_;
	
	# Make it a little easier to print the name of each node
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $say_node1 = "<span class=\"fixed_width\">$conf->{node}{$node1}{info}{short_host_name}</span>";
	my $say_node2 = "<span class=\"fixed_width\">$conf->{node}{$node2}{info}{short_host_name}</span>";
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"6\">
			<b>Shared File Systems</b>
		</td>
	</tr>
	<tr>
		<td>
			<i>Mount Point</i>
		</td>
		<td>
			<i>$say_node1</i>
		</td>
		<td>
			<i>$say_node2</i>
		</td>
		<td>
			<i>Size</i>
		</td>
		<td>
			<i>Used</i>
		</td>
		<td>
			<i>Free</i>
		</td>
	</tr>
";
	my $gfs2_hash;
	my $node;
	#record($conf, "$THIS_FILE ".__LINE__."; node1 - cman exit code: [$conf->{node}{$node1}{daemon}{cman}{exit_code}], gfs2 exit code: [$conf->{node}{$node1}{daemon}{gfs2}{exit_code}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; node2 - cman exit code: [$conf->{node}{$node2}{daemon}{cman}{exit_code}], gfs2 exit code: [$conf->{node}{$node2}{daemon}{gfs2}{exit_code}]\n");
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node1}{daemon}{gfs2}{exit_code} eq "0") && (ref($conf->{node}{$node1}{gfs}) eq "HASH"))
	{
		$gfs2_hash = $conf->{node}{$node1}{gfs};
		$node      = $node1;
		#record($conf, "$THIS_FILE ".__LINE__."; using node1's gfs2 hash: [$gfs2_hash]\n");
	}
	elsif (($conf->{node}{$node2}{daemon}{cman}{exit_code} eq "0") && ($conf->{node}{$node2}{daemon}{gfs2}{exit_code} eq "0") && (ref($conf->{node}{$node2}{gfs}) eq "HASH"))
	{
		$gfs2_hash = $conf->{node}{$node2}{gfs};
		$node      = $node2;
		#record($conf, "$THIS_FILE ".__LINE__."; using node2's gfs2 hash: [$gfs2_hash]\n");
	}
	else
	{
		# Neither node has the GFS2 partition mounted. Use the data
		# from /etc/fstab. This is what will be stored in either node's
		# hash. So pick a node that's online and use it.
		#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
		if ($conf->{'system'}{up_nodes} == 1)
		{
			$node      = @{$conf->{up_nodes}}[0];
			record($conf, "$THIS_FILE ".__LINE__."; Neither node has the GFS2 partition mounted.\n");
			$gfs2_hash = $conf->{node}{$node}{gfs};
		}
		else
		{
			# Neither node is online at all.
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span> / <span class=\"highlight_unavailable\">--%</span>
		</td>
		<td>
			<span class=\"highlight_unavailable\">--</span>
		</td>
	</tr>
";
		}
	}
	#record($conf, "$THIS_FILE ".__LINE__."; gfs2_hash: [$gfs2_hash], node1 hash: [".(ref($conf->{node}{$node1}{gfs}))."], node2 hash: [".(ref($conf->{node}{$node2}{gfs}))."]\n");
	if (ref($gfs2_hash) eq "HASH")
	{
		foreach my $mount_point (sort {$a cmp $b} keys %{$gfs2_hash})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node::${node1}::gfs::${mount_point}::mounted: [$conf->{node}{$node1}{gfs}{$mount_point}{mounted}], node::${node2}::gfs::${mount_point}::mounted: [$conf->{node}{$node2}{gfs}{$mount_point}{mounted}]\n");
			my $say_node1_mounted = $conf->{node}{$node1}{gfs}{$mount_point}{mounted} ? "<span class=\"highlight_good\">Mounted</span>" : "<span class=\"highlight_bad\">Unmounted</span>";
			my $say_node2_mounted = $conf->{node}{$node2}{gfs}{$mount_point}{mounted} ? "<span class=\"highlight_good\">Mounted</span>" : "<span class=\"highlight_bad\">Unmounted</span>";
			#record($conf, "$THIS_FILE ".__LINE__."; say_node1_mounted: [$say_node1_mounted], say_node2_mounted: [$say_node2_mounted]\n");
			my $say_size         = "--";
			my $say_used         = "--";
			my $say_used_percent = "--%";
			my $say_free         = "--";
			
			# This is to avoid the "undefined variable" errors in
			# the log from when a node isn't online.
			$conf->{node}{$node1}{gfs}{$mount_point}{total_size} = "" if not defined $conf->{node}{$node1}{gfs}{$mount_point}{total_size};
			$conf->{node}{$node2}{gfs}{$mount_point}{total_size} = "" if not defined $conf->{node}{$node2}{gfs}{$mount_point}{total_size};
			#record($conf, "$THIS_FILE ".__LINE__."; node1 total size: [$conf->{node}{$node1}{gfs}{$mount_point}{total_size}]\n");
			#record($conf, "$THIS_FILE ".__LINE__."; node2 total size: [$conf->{node}{$node2}{gfs}{$mount_point}{total_size}]\n");
			if ($conf->{node}{$node1}{gfs}{$mount_point}{total_size} =~ /^\d/)
			{
				$say_size         = $conf->{node}{$node1}{gfs}{$mount_point}{total_size};
				$say_used         = $conf->{node}{$node1}{gfs}{$mount_point}{used_space};
				$say_used_percent = $conf->{node}{$node1}{gfs}{$mount_point}{percent_used};
				$say_free         = $conf->{node}{$node1}{gfs}{$mount_point}{free_space};
			}
			elsif ($conf->{node}{$node2}{gfs}{$mount_point}{total_size} =~ /^\d/)
			{
				$say_size         = $conf->{node}{$node2}{gfs}{$mount_point}{total_size};
				$say_used         = $conf->{node}{$node2}{gfs}{$mount_point}{used_space};
				$say_used_percent = $conf->{node}{$node2}{gfs}{$mount_point}{percent_used};
				$say_free         = $conf->{node}{$node2}{gfs}{$mount_point}{free_space};
			}
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$mount_point</span>
		</td>
		<td>
			$say_node1_mounted
		</td>
		<td>
			$say_node2_mounted
		</td>
		<td>
			$say_size
		</td>
		<td>
			$say_used / $say_used_percent
		</td>
		<td>
			$say_free
		</td>
	</tr>
";
		}
	}
	else
	{
		print "
	<tr>
		<td colspan=\"6\">
			<i>No shared file systems were found.</i>
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";

	return (0);
}

# This shows the user the state of the nodes and their daemons.
sub display_node_details
{
	my ($conf) = @_;
	
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"7\">
			<b>Cluster Nodes - Status</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<i>cman</i>
		</td>
		<td>
			<i>rgmanager</i>
		</td>
		<td>
			<i>drbd</i>
		</td>
		<td>
			<i>clvmd</i>
		</td>
		<td>
			<i>gfs2</i>
		</td>
		<td>
			<i>libvirtd</i>
		</td>
	</tr>
";
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$this_cluster}{nodes}})
	{
		# Get the cluster's node name.
		my $say_short_name =  $node;
		$say_short_name    =~ s/\..*//;
		my $node_long_name =  $node1_long =~ /$say_short_name/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};

		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node}{info}{host_name}</span> &nbsp;
			<!-- <img src=\"/img/icon_led_left.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_middle.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_middle.png\" border=\"0\"><img src=\"/img/icon_led_good.png\" border=\"0\"><img src=\"/img/icon_led_right.png\" border=\"0\"> -->
		</td>
		<td>
			$conf->{node}{$node}{daemon}{cman}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{rgmanager}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{drbd}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{clvmd}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{gfs2}{status}
		</td>
		<td>
			$conf->{node}{$node}{daemon}{libvirtd}{status}
		</td>
	</tr>
";
	}
	
	print "
</table>
<br />
";

	return (0);
}

# This shows the controls for the nodes.
sub display_node_controls
{
	my ($conf) = @_;
	
	print "
<table width=\"100%\">
	<tr>
		<td colspan=\"8\">
			<b>Cluster Nodes - Controls</b>
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td colspan=\"3\">
			<i>Power</i>
		</td>
		<td colspan=\"3\">
			<i>Membership</i>
		</td>
		<td colspan=\"1\">
			<i>Special</i>
		</td>
	</tr>
";
	
	# I want to map storage service to nodes for the "Withdraw" buttons.
	my $disable_join = 0;
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	my $rowspan    = 2;
	my $dual_boot  = (($conf->{node}{$node1}{enable_poweron}) && ($conf->{node}{$node2}{enable_poweron})) ? 1 : 0;
	my $dual_join  = (($conf->{node}{$node1}{enable_join})    && ($conf->{node}{$node2}{enable_join}))    ? 1 : 0;
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$this_cluster}{nodes}})
	{
		# Get the cluster's node name.
		my $say_short_name =  $node;
		$say_short_name    =~ s/\..*//;
		my $node_long_name =  $node1_long =~ /$say_short_name/ ? $conf->{node}{$node1}{info}{host_name} : $conf->{node}{$node2}{info}{host_name};
		$conf->{node}{$node}{enable_withdraw} = 0 if not defined $conf->{node}{$node}{enable_withdraw};
		
		my $say_join      = $conf->{node}{$node}{enable_join}     ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=join_cluster&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_ready_bold\">Join Cluster</span></a>" : "<span class=\"disabled_button\">Join Cluster</span>";
		   $say_join      = "<span class=\"disabled_button\">Join Cluster</span>" if $disable_join;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], enable_withdraw: [$conf->{node}{$node}{enable_withdraw}], node long name: [$node_long_name]\n");
		my $say_withdraw  = $conf->{node}{$node}{enable_withdraw} ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=withdraw&node=$node&node_cluster_name=$node_long_name\">Withdraw</a>"  : "<span class=\"disabled_button\">Withdraw</span>";
		#record($conf, "$THIS_FILE ".__LINE__."; node::${node}::enable_poweroff: [$conf->{node}{$node}{enable_poweroff}]\n");
		my $say_shutdown  = $conf->{node}{$node}{enable_poweroff} ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=poweroff_node&node=$node&node_cluster_name=$node_long_name\">Power Off</a>" : "<span class=\"disabled_button\">Shut Down</span>";
		my $say_boot      = $conf->{node}{$node}{enable_poweron}  ? "<a href=\"?cluster=$conf->{cgi}{cluster}&task=poweron_node&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_ready_bold\">Power On</span></a>"   : "<span class=\"disabled_button\">Power On</span>";
		
		# At all times, the option to fence the node is made available.
		my $say_fence     = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=fence_node&node=$node&node_cluster_name=$node_long_name\"><span class=\"highlight_dangerous\">Fence Node</span></a>";
		my $say_dual_boot = "<span class=\"highlight_unavailable\">Power On Both</span>";
		my $say_dual_join = "<span class=\"highlight_unavailable\">Start Cluster</span>";
		if ($rowspan)
		{
			# First row.
			if ($dual_boot)
			{
				$say_dual_boot = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=dual_boot\"><span class=\"highlight_ready_bold\">Power On Both</span></a>";
			}
			if ($dual_join)
			{
				$say_dual_join = "<a href=\"?cluster=$conf->{cgi}{cluster}&task=dual_join\"><span class=\"highlight_ready_bold\">Start Cluster</span></a>";
				# Disable the per-node "join" options".
				$say_join      = "<span class=\"disabled_button\">Join Cluster</span>";
				$disable_join  = 1;
			}
		}

		print "
	<tr>
		<td>
			<span class=\"fixed_width\">$conf->{node}{$node}{info}{host_name}</span>
		</td>
";
		if ($rowspan)
		{
			print "
		<td rowspan=\"2\">
			$say_dual_boot
		</td>
";
		}
		print "
		<td>
			$say_boot
		</td>
		<td>
			$say_shutdown
		</td>
";
		if ($rowspan)
		{
			print "
		<td rowspan=\"2\">
			$say_dual_join
		</td>
";
		}
		print "
		<td>
			$say_join
		</td>
		<td>
			$say_withdraw
		</td>
		<td>
			$say_fence
		</td>
	</tr>
";
		$rowspan = 0;
	}
	
	print "
</table>
<br />
";

	return (0);
}

1;
