#!/usr/bin/perl
# 
# AN!MediaConnector
# 
# This allows a mechanism for taking a CD or DVD, turning it into an ISO and
# pushing it to a cluster's /shared/files/ directory. It also allows for 
# connecting and disconnecting these ISOs to and from VMs.
# 

use strict;
use warnings;

use strict;
use warnings;
use CGI;
use Encode;
use IO::Handle;
use CGI::Carp "fatalsToBrowser";

# Setup for UTF-8 mode.
binmode STDOUT, ":utf8:";
$ENV{'PERL_UNICODE'}=1;
my $THIS_FILE = "an-mc.lib";


# This images and uploads a DVD or CD disc
sub image_and_upload
{
	my ($conf) = @_;
	
	# Let the user know that this might take a bit.
	print "
<div id=\"hide_when_loaded\">
<table align=\"center\">
	<tr>
		<td>
			<b>Please be patient.</b><br />
			Gathering information from $conf->{cgi}{cluster}.<br />
			This could take a minute to complete.
		</td>
		<td>
			<img src=\"/img/gather_info.gif\" border=\"0\">
		</td>
	</tr>
</table>
<br />
</div>
	";
	
	my $dev  = $conf->{cgi}{dev};
	my $name = $conf->{cgi}{name};
	
	my ($node) = read_files_on_shared($conf);
	if (exists $conf->{files}{shared}{$name})
	{
		print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_bad\">
			Name Conflict
		</td>
		<td>
			<br />
			There is a file on the cluster called <span class=\"fixed_width\">$name</span> on the cluster.<br />
			Please go back and give the file a different name.<br />
			<br />
		</td>
	</tr>
</table>
";
	}
	else
	{
		# Now make sure the disc is still in the drive.
		check_local_dvd($conf);
		
		if (not exists $conf->{drive}{$dev})
		{
			print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning\">
			Drive not found
		</td>
		<td>
			<br />
			The drive in <span class=\"fixed_width\">$dev</span> appears to no longer exist!<br />
			If this is a USB drive, it may have been unplugged.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}\"><b>Try Again</b></a></div>
		</td>
	</tr>
</table>
";
		}
		elsif ($conf->{drive}{$dev}{reload})
		{
			# Need to reload to catch the disc.
			print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning\">
			Reload needed
		</td>
		<td>
			<br />
			The drive in <span class=\"fixed_width\">$dev</span> appears to not be ready.<br />
			Please reload to try and read the disc again.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}\"><b>Try Again</b></a></div>
		</td>
	</tr>
</table>
";
		}
		elsif ($conf->{drive}{$dev}{no_disc})
		{
			print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning\">
			No Disc
		</td>
		<td>
			<br />
			The disc in <span class=\"fixed_width\">$dev</span> appears to have been removed.<br />
			Please reinsert the disc and then reload this page.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"2\">
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}\"><b>Try Again</b></a></div>
		</td>
	</tr>
</table>
";
		}
		else
		{
			# Finally...
			my $out_file = $conf->{path}{media}.$name;
			my $in_dev   = $dev;
			print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_ready\">
			Beginning image copy.
		</td>
	</tr>
	<tr>
		<td>
			Please be patient! This could take up to <i>ten minutes</i>.<br />
			<pre>
";
			my $sc = "$conf->{path}{do_dd} if=$in_dev of=$out_file bs=$conf->{'system'}{dd_block_size}";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			my $fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				print $_;
			}
			$fh->close;
			print "
			</pre>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Beginning upload. 
		</td>
	</tr>
	<tr>
		<td>
			Uploading image file: <span class=\"fixed_width\">$name</span> to the <span class=\"fixed_width\">$conf->{cgi}{cluster}</span> cluster.<br />
			This could take a long time, depending on the speed of the connection between the dashboard appliance and cluster.<br />
			<pre>
";
			$sc = "$conf->{path}{rsync} $conf->{args}{rsync} $out_file root\@$node:$conf->{path}{shared}";
			record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
			$fh = IO::Handle->new();
			open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
			while(<$fh>)
			{
				print $_;
			}
			$fh->close;
			unlink $out_file;
			print "
			</pre>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Done!<br />
		</td>
	</tr>
</table>
";
		}
	}
	
	return (0);
}

# This asks the user to confirm the image and upload task. It also gives a
# chance for the user to name the image before upload.
sub confirm_image_and_upload
{
	my ($conf) = @_;
	
	my $dev  = $conf->{cgi}{dev};
	my $name = $conf->{cgi}{name};
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"3\">
			<span class=\"highlight_ready\">About to create a disc image and upload it to the cluster: [$conf->{cgi}{cluster}].</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Caution!</b></span>
		</td>
		<td colspan=\"2\" align=\"left\">
			<br />
			This process could take quite some time to complete!<br />
			<br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Step 1</b></span>
		</td>
		<td colspan=\"2\">
			</br />
			The disc will be converted into an image file.<br >
			<i>For a DVD, this could take around 10 minutes to complete.</i><br />
			</br />
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_ready\"><b>Step 2</b></span>
		</td>
		<td colspan=\"2\">
			</br />
			The image will be uploaded to the cluster's <span class=\"fixed_width\">/shared/files/</span> directory.<br />
			<i>If the cluster is remote and your internet connection is slow, this could take a very long time.</i><br />
			<br />
		</td>
	</tr>
	<form method=\"get\">
	<tr>
		<td>
			Image Name:
		</td>
		<td>
				<input type=\"text\" name=\"name\" value=\"$name\" style=\"width: 250px;\">
		</td>
		<td class=\"subtle_text\" style=\"text-align: left;\">
			This is the name that will be given to the DVD or CD image.
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<input type=\"hidden\" name=\"dev\" value=\"$dev\">
			<input type=\"hidden\" name=\"cluster\" value=\"$conf->{cgi}{cluster}\">
			<input type=\"hidden\" name=\"task\" value=\"upload\">
			<input type=\"hidden\" name=\"confirm\" value=\"true\">
			<div class=\"align_right\"><input type=\"submit\" name=\"null\" value=\"Confirm\" class=\"button\"></div>
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# This asks the user to confirm that s/he wants to delete the image.
sub confirm_delete_file
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $name    = $conf->{cgi}{name};
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"3\">
			<span class=\"highlight_ready\">About to delete <span class=\"fixed_width\">$name</span> from the <span class=\"fixed_width\">$cluster</span> cluster!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Caution!</b></span>
		</td>
		<td colspan=\"2\" align=\"left\">
			<br />
			This will delete <span class=\"fixed_width\">$name</span> from the <span class=\"fixed_width\">$cluster</span> cluster!<br />
			<br />
			<i>This action can not be undone!</i><br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}&confirm=true\"><b>Confirm</b></a></div>
		</td>
	</tr>
	</form>
</table>
<br />
";
	
	return (0);
}

# This deletes a file from the cluster.
sub delete_file
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	my $name    = $conf->{cgi}{name};
	my ($node) = read_files_on_shared($conf);
	if (exists $conf->{files}{shared}{$name})
	{
		# Do the delete.
		print "
<table align=\"center\">
	<tr>
		<td colspan=\"3\">
			<span class=\"highlight_ready\">Deleting <span class=\"fixed_width\">$name</span>...</span>
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<br />
			Any output from the shell will be below (none expected):
			<pre>
";
		my $sc = "$conf->{path}{ssh} root\@$node \"rm -f /shared/files/$name\"";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh  = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			print $_;
		}
		$fh->close;
		print "
			</pre>
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			Done!
		</td>
	</tr>
</table>
<br />
";
	}
	else
	{
		print "
<table align=\"center\">
	<tr>
		<td colspan=\"3\">
			<span class=\"highlight_warning\">Deletion of <span class=\"fixed_width\">$name</span> from the <span class=\"fixed_width\">$cluster</span> cluster failed!</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"highlight_warning\"><b>Failed!</b></span>
		</td>
		<td colspan=\"2\" align=\"left\">
			<br />
			The file <span class=\"fixed_width\">$name</span> on the <span class=\"fixed_width\">$cluster</span> cluster is already gone.<br />
			It is possible that another user deleted this file already.<br />
			<br />
		</td>
	</tr>
	<tr>
		<td colspan=\"3\">
			<!-- <div class=\"align_left\"><a href=\"?cluster=$conf->{cgi}{cluster}\"><b>Back</b></a></div> -->
			&nbsp;
		</td>
	</tr>
	</form>
</table>
<br />
";
	}
	
	return (0);
}

# Do whatever the user has asked.
sub process_task
{
	my ($conf) = @_;
	
	if ($conf->{cgi}{task} eq "upload")
	{
		if ($conf->{cgi}{confirm})
		{
			# Proceed.
			image_and_upload($conf);
		}
		else
		{
			# Get the user to confirm.
			confirm_image_and_upload($conf);
		}
	}
	elsif ($conf->{cgi}{task} eq "delete")
	{
		if ($conf->{cgi}{confirm})
		{
			# Proceed.
			delete_file($conf);
		}
		else
		{
			# Get the user to confirm.
			confirm_delete_file($conf);
		}
	}
	
	return (0);
}

# This tries to see of there is a DVD or CD in the local drive (if there is a
# local drive at all).
sub check_local_dvd
{
	my ($conf) = @_;
	
	my $dev = "";
	my $sc  = "$conf->{path}{check_dvd} $conf->{args}{check_dvd}";
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh  = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		if ($line =~ /CD location\s+:\s+(.*)/i)
		{
			$dev = $1;
			record($conf, "$THIS_FILE ".__LINE__."; cd-info:device:$dev\n");
		}
		elsif ($line =~ /Volume\s+:\s+(.*)/i)
		{
			my $volume = $1;
			$conf->{drive}{$dev}{volume} = $volume;
			record($conf, "$THIS_FILE ".__LINE__."; cd-info:volume:$volume\n");
		}
		elsif ($line =~ /Volume Set\s+:\s+(.*)/i)
		{
			my $volume_set = $1;
			$conf->{drive}{$dev}{volume_set} = $volume_set;
			record($conf, "$THIS_FILE ".__LINE__."; cd-info:volume set:$volume_set\n");
		}
		elsif ($line =~ /No medium found/i)
		{
			record($conf, "$THIS_FILE ".__LINE__."; cd-info:no-disc:true\n");
			$conf->{drive}{$dev}{no_disc} = 1;
			last;
		}
		elsif ($line =~ /unknown filesystem/i)
		{
			record($conf, "$THIS_FILE ".__LINE__."; cd-info:reload needed:true\n");
			$conf->{drive}{$dev}{reload} = 1;
			last;
		}
		else
		{
			#record($conf, "$THIS_FILE ".__LINE__."; cd-info:$line\n");
		}
	}
	$fh->close;

	return(0);
}

# This prints a small header with the current status of any background running
# jobs
sub check_status
{
	my ($conf) = @_;
	
	if (not -e $conf->{path}{status})
	{
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\">Configuration Error</span>
		</td>
		<td>
			The directory: <span class=\"fixed_fidth\">$conf->{path}{status}</span> does not exist.
		</td>
	</tr>
</table>
";
	}
	elsif (not -r $conf->{path}{status})
	{
		my $user = getpwuid($<);
		print "
<table align=\"center\">
	<tr>
		<td>
			<span class=\"highlight_bad\">Configuration Error</span>
		</td>
		<td>
			The directory: <span class=\"fixed_fidth\">$conf->{path}{status}</span> is not readible by the <span class=\"fixed_fidth\">$user</span> user.
		</td>
	</tr>
</table>
";
	}
	
	return (0);
}

# This looks for a node we have access to and returns the first one available.
sub read_files_on_shared
{
	my ($conf) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster].\n");
	my $connected = "";
	my $cluster   = $conf->{cgi}{cluster};
	delete $conf->{files} if exists $conf->{files};
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		next if $connected;
		#record($conf, "$THIS_FILE ".__LINE__."; trying to connect to node: [$node].\n");
		my $fail = 0;
		my $sc   = "$conf->{path}{ssh} -o ConnectTimeout=10 root\@$node \"df -P && ls -l /shared/files/\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		my $raw;
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			$raw .= $_;
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			next if $fail;
			
			# This catches connectivity problems.
			if ($line =~ /No route to host/i)
			{
				my $local_access = on_same_network($conf, $node);
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">No Access</span>";
				if ($local_access)
				{
					$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. It is on an accessible subnet, so the node is likely off or there is a network problem.";
				}
				else
				{
					$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. The server running AN!CDB is not currently on the same subnet as the node.";
				}
				$fail = 1;
				next;
			}
			elsif ($line =~ /host key verification failed/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Verification Failed!</span>";
				$conf->{node}{$node}{info}{note}    = "SSH host key validation failed.<br />Have you saved <span class=\"fixed_width\">${node}</span>'s fingerprint in <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file?<br />If this is a new issue, the physical node may have changed, requiring the old fingerprint be deleted and the new fingerprint be saved.<br />If the machine has not changed, then this might be a sign of an attempt to intercept your connection to the node.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /could not resolve hostname/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Bad Hostname!</span>";
				$conf->{node}{$node}{info}{note}    = "Could not resolve the hostname: <span class=\"fixed_width\">$node</span>. Have you setup your <span class=\"fixed_width\">/etc/hosts</span> file or DNS server properly?";
				$fail = 1;
				next;
			}
			elsif ($line =~ /permission denied/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Permission Denied!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. Have you added <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/id_rsa.pub</span> public key to <span class=\"fixed_width\">$node</span>'s <span class=\"fixed_width\">/root/.ssh/authorized_keys</span> file? If so, check <span class=\"fixed_width\">/var/log/secure</span> on <span class=\"fixed_width\">$node</span> for errors.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /connection refused/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Refused!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />Either it is refusing incoming connections or this machine does not have access to the node's subnet.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /Connection timed out/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Timed Out</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The connection timed out.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /Network is unreachable/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Network Unreachable</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The network is not reachable. Is this machine hosting this program on the same subnet?";
				$fail = 1;
				next;
			}
			elsif ($line =~ /\@\@\@\@/)
			{
				# When the host-key fails to match, a box made
				# of '@@@@' is displayed, and is the entire 
				# first line.
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. It appears that the node has changed! If this node failed and was replaced, be sure to remove the old key from <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file. If the node has not been replaced, then someone might be trying to trick you into logging into it.";
				$fail = 1;
				next;
			}
			
			# If I made it this far, I've got a connection.
			$connected = $node;
			if ($line =~ /\s(\d+)-blocks\s/)
			{
				$conf->{partition}{shared}{block_size} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; block_size: [$conf->{partition}{shared}{block_size}]\n");
				next;
			}
			if ($line =~ /^\/.*?\s+(\d+)\s+(\d+)\s+(\d+)\s(\d+)%\s+\/shared/)
			{
				$conf->{partition}{shared}{total_space}  = $1;
				$conf->{partition}{shared}{used_space}   = $2;
				$conf->{partition}{shared}{free_space}   = $3;
				$conf->{partition}{shared}{used_percent} = $4;
				#record($conf, "$THIS_FILE ".__LINE__."; total_space: [$conf->{partition}{shared}{total_space}], used_space: [$conf->{partition}{shared}{used_space} / $conf->{partition}{shared}{used_percent}%], free_space: [$conf->{partition}{shared}{free_space}]\n");
				next;
			}
			if ($line =~ /^(\S)(\S+)\s+\d+\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(.*)$/)
			{
				my $type   = $1;
				my $mode   = $2;
				my $user   = $3;
				my $group  = $4;
				my $size   = $5;
				my $month  = $6;
				my $day    = $7;
				my $time   = $8; # might be a year, look for '\d+:\d+'.
				my $file   = $9;
				my $target = "";
				if ($type eq "l")
				{
					# It's a symlink, strip off the destination.
					($file, $target) = ($file =~ /^(.*?) -> (.*)$/);
				}
				$conf->{files}{shared}{$file}{type}   = $type;
				$conf->{files}{shared}{$file}{mode}   = $mode;
				$conf->{files}{shared}{$file}{user}   = $user;
				$conf->{files}{shared}{$file}{group}  = $group;
				$conf->{files}{shared}{$file}{size}   = $size;
				$conf->{files}{shared}{$file}{month}  = $month;
				$conf->{files}{shared}{$file}{day}    = $day;
				$conf->{files}{shared}{$file}{'time'} = $time; # might be a year, look for '\d+:\d+'.
				$conf->{files}{shared}{$file}{target} = $target;
				#record($conf, "$THIS_FILE ".__LINE__."; file: [$file], mode: [$conf->{files}{shared}{$file}{type}, $conf->{files}{shared}{$file}{mode}], owner: [$conf->{files}{shared}{$file}{user} / $conf->{files}{shared}{$file}{group}], size: [$conf->{files}{shared}{$file}{size}], modified: [$conf->{files}{shared}{$file}{month} $conf->{files}{shared}{$file}{day} $conf->{files}{shared}{$file}{'time'}], target: [$conf->{files}{shared}{$file}{target}]\n");
				next;
			}
		}
	}
	
	if (not $connected)
	{
		print "
<table width=\"100%\">
	<tr>
		<td colspan=\"3\">
			Unable to connect to the <span class=\"highlight_detail\">${cluster}</span> cluster!
		</td>
	</tr>
";
		foreach my $node (sort {$a cmp $b} keys %{$conf->{node}})
		{
			my $state = $conf->{node}{$node}{info}{'state'};
			my $note  = $conf->{node}{$node}{info}{note};
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$node</span>
		</td>
		<td>
			<span class=\"fixed_width\">$state</span>
		</td>
		<td>
			$note
		</td>
	</tr>
";
		}
		print "
	<tr>
		<td colspan=\"3\">
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}\"><b>Try Again</b></a></div>
		</td>
	</tr>
";
	}
		print "
</table>
<br />
";
	
	return ($connected);
}

# This tries to log into each node in the cluster. The first one it connects to
# which has /shared/files mounted is the one it will use to up upload the ISO
# and generate the list of available media. It also compiles a list of which 
# VMs are on each node.
sub read_shared
{
	my ($conf) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; In read_shared().\n");
	
	check_status($conf);
	
	# Let the user know that this might take a bit.
	print "
<div id=\"hide_when_loaded\">
<table align=\"center\">
	<tr>
		<td>
			<b>Please be patient.</b><br />
			Gathering information from $conf->{cgi}{cluster}.<br />
			This could take a minute to complete.
		</td>
		<td>
			<img src=\"/img/gather_info.gif\" border=\"0\">
		</td>
	</tr>
</table>
<br />
</div>
	";
	
	my $cluster      = $conf->{cgi}{cluster};
	my $connected    = 0;
	
	# This returns the name of the node used to read /shared/files/. If no
	# node was available, it returns an empty string.
	my ($node) = read_files_on_shared($conf);
	
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster].\n");
	
	print "
<table class=\"hidden_table\" align=\"center\" border=\"0\">
	<tr>
		<td class=\"td_hidden\">
";
	if ($node)
	{
		my $block_size       = $conf->{partition}{shared}{block_size};
		my $total_space      = ($conf->{partition}{shared}{total_space} * $block_size);
		my $say_total_space  = bytes_to_hr($conf, $total_space);
		my $used_space       = ($conf->{partition}{shared}{used_space} * $block_size);
		my $say_used_space   = bytes_to_hr($conf, $used_space);
		my $free_space       = ($conf->{partition}{shared}{free_space} * $block_size);
		my $say_free_space   = bytes_to_hr($conf, $free_space);
		my $say_used_percent = $conf->{partition}{shared}{used_percent}."%";
		print "
<table width=\"100%\">
	<tr>
		<td colspan=\"3\" class=\"highlight_good\">
			Cluster <span class=\"fixed_width\">${cluster}</span>'s <span class=\"fixed_width\">/shared</span> details:
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"table_header\">Total Space</span>
		</td>
		<td>
			<span class=\"table_header\">Used Space</span>
		</td>
		<td>
			<span class=\"table_header\">Free Space</span>
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"fixed_width\">$say_total_space</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_used_space</span>
		</td>
		<td>
			<span class=\"fixed_width\">$say_free_space</span>
		</td>
	</tr>
</table>
<br />
<table width=\"100%\">
	<tr>
		<td colspan=\"3\" class=\"highlight_good\">
			Existing File(s)
		</td>
	</tr>
	<tr>
		<td>
			&nbsp;
		</td>
		<td>
			<span class=\"table_header\">File Name</span>
		</td>
		<td>
			<span class=\"table_header\">Size</span>
		</td>
	</tr>
";
		
		# Show existing files.
		foreach my $file (sort {$a cmp $b} keys %{$conf->{files}{shared}})
		{
			next if $conf->{files}{shared}{$file}{type} ne "-";
			my $say_size = bytes_to_hr($conf, $conf->{files}{shared}{$file}{size});
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$say_size</span>
		</td>
		<td>
			<span class=\"fixed_width\">$file</span>
		</td>
		<td>
			<a href=\"?cluster=$cluster&task=delete&name=$file\"><span class=\"highlight_bad\">Delete</span></a>
		</td>
	</tr>
";
		}
		
		print "
	<tr>
</table>
<br />
<table width=\"100%\">
	<tr>
		<td colspan=\"3\" class=\"highlight_good\">
			Optical Drive(s)
		</td>
	</tr>
	<tr>
		<td>
			<span class=\"table_header\">Device</span>
		</td>
		<td>
			<span class=\"table_header\">Disc Name</span>
		</td>
		<td>
			&nbsp;
		</td>
	</tr>
";
		check_local_dvd($conf);
		foreach my $dev (sort {$a cmp $b} keys %{$conf->{drive}})
		{
			my $cluster   = $conf->{cgi}{cluster};
			my $disc_name = "";
			my $upload    = "--";
			if ($conf->{drive}{$dev}{reload})
			{
				$disc_name = "Disc read failed, please reload to try again.";
			}
			elsif ($conf->{drive}{$dev}{no_disc})
			{
				$disc_name = "No disc found.";
			}
			elsif ($conf->{drive}{$dev}{volume})
			{
				$disc_name = "<span class=\"fixed_width\">$conf->{drive}{$dev}{volume}</span>";
				$upload    = "<a href=\"?cluster=$cluster&task=upload&dev=$dev&name=$conf->{drive}{$dev}{volume}.iso\">Upload</a>";
			}
			elsif ($conf->{drive}{$dev}{volume_set})
			{
				$disc_name = "<span class=\"fixed_width\">$conf->{drive}{$dev}{volume_set}</span>";
				$upload    = "<a href=\"?cluster=$cluster&task=upload&dev=$dev&name=$conf->{drive}{$dev}{volume_set}.iso\">Upload</a>";
			}
			else
			{
				$disc_name = "Unknown problem reading drive: [$dev]";
			}
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$dev</span>
		</td>
		<td>
			$disc_name
		</td>
		<td>
			$upload
		</td>
	</tr>
";
		}
		print "
</table>
</br />
";
	}
	else
	{
		print "
<table>
	<tr>
		<td>
			<span class=\"highlight_warning\">Inaccessible</span>
		</td>
		<td>
			I am sorry, but I can not connect to either node in the <span class=\"fixed_width\">$cluster</span> cluster.
		</td>
	<tr>
</table>
<br />
";
	}
	print "
		</td>
	</tr>
</table>
<br />
";
	return($connected);
}

1;
