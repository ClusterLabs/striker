#!/usr/bin/perl
#
# AN!CDB - Alteeve's Niche! Cluster Dashboard
# 
# This software is released under the GNU GPL v2+ license.
# 
# No warranty is provided. Do not use this software unless you are willing and
# able to take full liability for it's use. The authors take care to prevent
# unexpected side effects when using this program. However, no software is
# perfect and bugs may exist which could lead to hangs or crashes in the
# program, in your cluster and possibly even data loss.
# 
# If you are concerned about these risks, please stick to command line tools.
# 
# This program is designed to extend clusters built according to this tutorial:
# - https://alteeve.ca/w/2-Node_Red_Hat_KVM_Cluster_Tutorial
#
# This program's source code and updates are available on Github:
# - https://github.com/digimer/an-cdb
#
# Author;
# Alteeve's Niche!  -  https://alteeve.ca
# Madison Kelly     -  mkelly@alteeve.ca
# 

use strict;
use warnings;
use IO::Handle;

# Email stuff
use Email::Sender::Simple qw(sendmail);
use Email::Sender::Transport::SMTP::TLS;
use Try::Tiny;
use Email::Simple::Creator;

# Setup for UTF-8 mode.
binmode STDOUT, ":utf8:";
$ENV{'PERL_UNICODE'}=1;
my $THIS_FILE = "an-cluster.lib";
our $VERSION  = "1.0.2";

# This reads in /etc/hosts and later will try to match host names to IPs
sub read_hosts
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; read_hosts()\n");
	
	$conf->{raw}{hosts} = [];
	my $fh = IO::Handle->new();
	my $sc = "/etc/hosts";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		push @{$conf->{raw}{hosts}}, $line;
		$line =~ s/#.*$//;
		$line =~ s/\s+$//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		my ($this_ip, $these_hosts);
		if ($line =~ /^(\d+\.\d+\.\d+\.\d+)\s+(.*)/)
		{
			$this_ip     = $1;
			$these_hosts = $2;
			foreach my $this_host (split/ /, $these_hosts)
			{
				$conf->{hosts}{$this_host}{ip} = $this_ip;
				if (not exists $conf->{hosts}{by_ip}{$this_ip})
				{
					$conf->{hosts}{by_ip}{$this_ip} = "";
				}
				$conf->{hosts}{by_ip}{$this_ip} .= "$this_host,";
				#record($conf, "$THIS_FILE ".__LINE__."; this_host: [$this_host] -> this_ip: [$conf->{hosts}{$this_host}{ip}] ($conf->{hosts}{by_ip}{$this_ip})\n");
			}
		}
	}
	$fh->close();
	
	return(0);
}

# This reads /etc/ssh/ssh_config and later will try to match host names to
# port forwards.
sub read_ssh_config
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; read_ssh_config()\n");
	
	$conf->{raw}{ssh_config} = [];
	my $this_host;
	my $fh = IO::Handle->new();
	my $sc = "/etc/ssh/ssh_config";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		push @{$conf->{raw}{ssh_config}}, $line;
		$line =~ s/#.*$//;
		$line =~ s/\s+$//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		if ($line =~ /^host (.*)/i)
		{
			$this_host = $1;
			next;
		}
		next if not $this_host;
		if ($line =~ /port (\d+)/i)
		{
			my $port = $1;
			$conf->{hosts}{$this_host}{port} = $port;
			#record($conf, "$THIS_FILE ".__LINE__."; this_host: [$this_host] -> port: [$conf->{hosts}{$this_host}{port}]\n");
		}
	}
	$fh->close();
	
	return(0);
}

# This allows the user to configure their dashboard.
sub configure_dashboard
{
	my ($conf) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; configure_dashboard()\n");
	
	read_hosts($conf);
	read_ssh_config($conf);
	
	if ($conf->{cgi}{save})
	{
		my $save = 1;
		print "
<table align=\"center\">
	<tr>
		<td colspan=\"1\">
			<b>Saving Changes...</b>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good\">
			Validating
		</td>
		<td style=\"text-align: left;\">
			Making sure things look ok.
		</td>
	</tr>
";
		# Make sure email addresses are.
		if (($conf->{cgi}{smtp__username}) && ($conf->{cgi}{smtp__username} !~ /^\w[\w\.\-]*\w\@\w[\w\.\-]*\w(\.\w+)$/))
		{
			$save = 0;
			print "
	<tr>
		<td class=\"highlight_warning\">
			Mail Server User
		</td>
		<td style=\"text-align: left;\">
			The email address: [$conf->{cgi}{smtp__username}] does not appear to be valid.
		</td>
	</tr>
";
		}
		if ($conf->{cgi}{mail_data__to})
		{
			foreach my $email (split /,/, $conf->{cgi}{mail_data__to})
			{
				next if not $email;
				if ($email !~ /^\w[\w\.\-]*\w\@\w[\w\.\-]*\w(\.\w+)$/)
				{
					$save = 0;
					print "
	<tr>
		<td class=\"highlight_warning\">
			Alert Recipient
		</td>
		<td style=\"text-align: left;\">
			The email address: [$email] does not appear to be valid.
		</td>
	</tr>
";
				}
			}
		}
		
		# Make sure values that should be numerical are.
		
		if ($conf->{cgi}{smtp__port})
		{
			$conf->{cgi}{smtp__port} =~ s/,//;
			if (($conf->{cgi}{smtp__port} =~ /\D/) || ($conf->{cgi}{smtp__port} < 1) || ($conf->{cgi}{smtp__port} > 65535))
			{
				$save = 0;
				print "
	<tr>
		<td class=\"highlight_warning\">
			Mail Server Port
		</td>
		<td style=\"text-align: left;\">
			The mail server port needs to be a number between '1' and '65535'.
		</td>
	</tr>
";
			}
		}
		elsif ($conf->{cgi}{smtp__server})
		{
			$save = 0;
			print "
	<tr>
		<td class=\"highlight_warning\">
			Mail Server Port
		</td>
		<td style=\"text-align: left;\">
			You need to specify what TCP your mail server is listening on.<br />
			Usually this is either '25' or '587'.
		</td>
	</tr>
";
		}
		if ($conf->{cgi}{smtp__timeout})
		{
		}
		else
		{
			$conf->{cgi}{smtp__port} = 60;
		}
		
		# Now validate Anvil! entries.
		foreach my $this_id (split/,/, $conf->{cgi}{ids})
		{
			next if not $this_id;
			my $name_key         = "cluster__${this_id}__name";
			my $description_key  = "cluster__${this_id}__description";
			my $company_key      = "cluster__${this_id}__company";
			my $ricci_pw_key     = "cluster__${this_id}__ricci_pw";
			my $url_key          = "cluster__${this_id}__url";
			my $nodes_1_name_key = "cluster__${this_id}__nodes_1_name";
			my $nodes_1_ip_key   = "cluster__${this_id}__nodes_1_ip";
			my $nodes_1_port_key = "cluster__${this_id}__nodes_1_port";
			my $nodes_2_name_key = "cluster__${this_id}__nodes_2_name";
			my $nodes_2_ip_key   = "cluster__${this_id}__nodes_2_ip";
			my $nodes_2_port_key = "cluster__${this_id}__nodes_2_port";
			
			my $this_name         =  $conf->{cgi}{$name_key};
			my $this_description  =  $conf->{cgi}{$description_key};
			my $this_company      =  $conf->{cgi}{$company_key};
			my $this_ricci_pw     =  $conf->{cgi}{$ricci_pw_key};
			my $this_url          =  $conf->{cgi}{$url_key};
			my $this_nodes_1_name =  $conf->{cgi}{$nodes_1_name_key};
			my $this_nodes_1_ip   =  $conf->{cgi}{$nodes_1_ip_key};
			my $this_nodes_1_port =  $conf->{cgi}{$nodes_1_port_key};
			   $this_nodes_1_port =~ s/,//;
			my $this_nodes_2_name =  $conf->{cgi}{$nodes_2_name_key};
			my $this_nodes_2_ip   =  $conf->{cgi}{$nodes_2_ip_key};
			my $this_nodes_2_port =  $conf->{cgi}{$nodes_2_port_key};
			   $this_nodes_2_port =~ s/,//;
			
			# If everything is empty, that's fine.
			if ((not $this_name) && 
			    (not $this_description) && 
			    (not $this_company) && 
			    (not $this_ricci_pw) && 
			    (not $this_url) && 
			    (not $this_nodes_1_name) && 
			    (not $this_nodes_1_ip) && 
			    (not $this_nodes_1_port) && 
			    (not $this_nodes_2_name) && 
			    (not $this_nodes_2_ip) && 
			    (not $this_nodes_2_port))
			{
				next if $this_id eq "new";
				# Using the values found in the existing config
				# as these values do not exist in the CGI 
				# variables.
				record($conf, "$THIS_FILE ".__LINE__."; Deleting Anvil!: [$conf->{cluster}{$this_id}{name}], company: [$conf->{cluster}{$this_id}{company} ($conf->{cluster}{$this_id}{description})]\n");
			}
			else
			{
				# Something is defined, make sure it's sane.
				if ((not $this_name) || (not $this_nodes_1_name) || (not $this_nodes_2_name))
				{
					$save = 0;
					print "
	<tr>
		<td class=\"highlight_warning\">
			Anvil! Data Incomplete
		</td>
		<td style=\"text-align: left;\">
			The <i>Anvil!</i> with ID: [<span class=\"highlight_note\" class=\"fixed_width\">$this_id</span>] is missing some data.<br />
			At minimum, the '<span class=\"highlight_ready\">Anvil! Name</span>', '<span class=\"highlight_ready\">Node 1 Name</span> and '<span class=\"highlight_ready\">Node 2 Name</span>' must be specified.
		</td>
	</tr>
";
				}
				else
				{
					# The minimum information is present,
					# now make sure the set values are
					# sane.
					# IPs sane?
					if (($this_nodes_1_ip) && ($this_nodes_1_ip !~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/))
					{
						$save = 0;
						print "
	<tr>
		<td class=\"highlight_warning\">
			Node 1 IP Address
		</td>
		<td style=\"text-align: left;\">
			The IP address assigned to <i>Anvil!</i>: [$this_name]'s node named: [$this_nodes_1_name] appears to be invalid.<br />
		</td>
	</tr>
";
					}
					if (($this_nodes_2_ip) && ($this_nodes_2_ip !~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/))
					{
						$save = 0;
						print "
	<tr>
		<td class=\"highlight_warning\">
			Node 2 IP Address
		</td>
		<td style=\"text-align: left;\">
			The IP address assigned to <i>Anvil!</i>: [$this_name]'s node named: [$this_nodes_1_name] appears to be invalid.<br />
		</td>
	</tr>
";
					}
					# Ports sane?
					if (($this_nodes_1_port =~ /\D/) || ($this_nodes_1_port < 1) || ($this_nodes_1_port > 65535))
					{
						$save = 0;
						print "
	<tr>
		<td class=\"highlight_warning\">
			Node 1 TCP Port
		</td>
		<td style=\"text-align: left;\">
			The TCP port assigned to <i>Anvil!</i>: [$this_name]'s node named: [$this_nodes_1_name] appears to be invalid.<br />
			A TCP port needs to be a number between '1' and '65535'.
		</td>
	</tr>
";
					}
					if (($this_nodes_2_port =~ /\D/) || ($this_nodes_2_port < 2) || ($this_nodes_2_port > 65535))
					{
						$save = 0;
						print "
	<tr>
		<td class=\"highlight_warning\">
			Node 2 TCP Port
		</td>
		<td style=\"text-align: left;\">
			The TCP port assigned to <i>Anvil!</i>: [$this_name]'s node named: [$this_nodes_2_name] appears to be invalid.<br />
			A TCP port needs to be a number between '2' and '65535'.
		</td>
	</tr>
";
					}
					# If there is an IP or Port, but no 
					# node name, well that's just not good.
					if ((not $this_nodes_1_name) && (($this_nodes_1_ip) || ($this_nodes_1_port)))
					{
						$save = 0;
						print "
	<tr>
		<td class=\"highlight_warning\">
			Missing Node Name
		</td>
		<td style=\"text-align: left;\">
			Node 1 in <i>Anvil!</i>: [$this_name] appears to be missing.
		</td>
	</tr>
";
					}
					if ((not $this_nodes_2_name) && (($this_nodes_2_ip) || ($this_nodes_2_port)))
					{
						$save = 0;
						print "
	<tr>
		<td class=\"highlight_warning\">
			Missing Node Name
		</td>
		<td style=\"text-align: left;\">
			Node 2 in <i>Anvil!</i>: [$this_name] appears to be missing.
		</td>
	</tr>
";
					}
				}
			}
		}
		
		if ($save)
		{
			print "
	<tr>
		<td class=\"highlight_good\">
			Sanity Checks Passed!
		</td>
		<td style=\"text-align: left;\">
			Everything seems sensible, ready to save.
		</td>
	</tr>
";
		}
		else
		{
			print "
	<tr>
		<td class=\"highlight_warning\">
			Problems Found
		</td>
		<td style=\"text-align: left;\">
			Please fix the issues found above. Once ready, please try again.
		</td>
	</tr>
";
		}
		
		print "
</table>
<br />
";
	}
	
	# If this is the first time the page is loaded, populate the values
	# with whatever was already in an.conf.
	#record($conf, "$THIS_FILE ".__LINE__."; cgi::reload: [$conf->{cgi}{reload}]\n");
	if (not $conf->{cgi}{reload})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; cgi}{smtp__server: [$conf->{cgi}{cgi}{smtp__server}], smtp::server: [$conf->{smtp}{server}]\n");
		$conf->{cgi}{smtp__server}              = $conf->{smtp}{server}              if not $conf->{cgi}{smtp__server};
		$conf->{cgi}{smtp__port}                = $conf->{smtp}{port}                if not $conf->{cgi}{smtp__port};
		$conf->{cgi}{smtp__timeout}             = $conf->{smtp}{timeout}             if not $conf->{cgi}{smtp__timeout};
		$conf->{cgi}{smtp__username}            = $conf->{smtp}{username}            if not $conf->{cgi}{smtp__username};
		$conf->{cgi}{smtp__password}            = $conf->{smtp}{password}            if not $conf->{cgi}{smtp__password};
		$conf->{cgi}{smtp__security}            = $conf->{smtp}{security}            if not $conf->{cgi}{smtp__security};
		$conf->{cgi}{smtp__encrypt_pass}        = $conf->{smtp}{encrypt_pass}        if not $conf->{cgi}{smtp__encrypt_pass};
		$conf->{cgi}{smtp__helo_domain}         = $conf->{smtp}{helo_domain}         if not $conf->{cgi}{smtp__helo_domain};
		$conf->{cgi}{mail_data__to}             = $conf->{mail_data}{to}             if not $conf->{cgi}{mail_data__to};
		$conf->{cgi}{mail_data__sending_domain} = $conf->{mail_data}{sending_domain} if not $conf->{cgi}{mail_data__sending_domain};
	}
	
	# Build the security select box.
	my $say_security        =  $conf->{cgi}{smtp__security};
	my $say_security_select =  "<select name=\"smtp__security\" style=\"width: 300px;\">\n";
	   $say_security_select .= "<option value=\"None\">None</option>\n";
	   $say_security_select .= "<option value=\"SSL/TLS\">SSL/TLS</option>\n";
	   $say_security_select .= "<option value=\"STARTTLS\">STARTTLS</option>\n";
	   $say_security_select .= "</select>\n";
	   $say_security_select =~ s/$say_security\">/$say_security\" selected>/g;
	# Build the encrypt password select box.
	my $say_encrypt_pass        =  $conf->{cgi}{smtp__encrypt_pass};
	my $say_encrypt_pass_select =  "<select name=\"smtp__encrypt_pass\" style=\"width: 300px;\">\n";
	   $say_encrypt_pass_select .= "<option value=\"1\">Yes</option>\n";
	   $say_encrypt_pass_select .= "<option value=\"0\">No</option>\n";
	   $say_encrypt_pass_select .= "</select>\n";
	   $say_encrypt_pass_select =~ s/$say_encrypt_pass\">/$say_encrypt_pass\" selected>/g;
	
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"4\">
			<b>Configure your dashboard.</b>
		</td>
	</tr>
	<tr>
		<td colspan=\"4\">
			&nbsp;
		</td>
	</tr>
	<form action=\"/cgi-bin/an-cdb\" method=\"post\" name=\"config\">
";
	# Mail settings.
	print "
	<tr>
		<td class=\"highlight_good\" style=\"white-space: nowrap;\">
			Mail Settings
		</td>
		<td colspan=\"3\" style=\"text-align: left;\">
			The dashboard does not send email, but your <i>Anvil!</i> nodes will.<br />
			The <span class=\"code\">$conf->{path}{an_conf}</span> that this section manages is designed to be copied unchanged to your nodes, so this information is needed to send alert emails later.
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Mail Server Address
		</td>
		<td>
			<input type=\"text\" name=\"smtp__server\" value=\"$conf->{cgi}{smtp__server}\" style=\"width: 300px;\" />
		</td>
		<td style=\"text-align: left;\">
			This is the mail server that your node will connect to in order to send email.<br />
			Your Internet service provider will give you this address, often called an \"<i>SMTP Server</i>\".
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<!-- These two sections are not shown to the user, but it will persist if the user changes the config file. -->
	<!-- If not set, this will be set to the same address as set in 'smtp__server' -->
	<input type=\"hidden\" name=\"mail_data__sending_domain\" value=\"$conf->{cgi}{mail_data__sending_domain}\">
	<!-- If not set, this will be set to the short version of address as set in 'smtp__server' -->
	<input type=\"hidden\" name=\"smtp__helo_domain\" value=\"$conf->{cgi}{smtp__helo_domain}\">
	<tr>
		<td class=\"highlight_ready\">
			Mail Server Port
		</td>
		<td>
			<input type=\"text\" name=\"smtp__port\" value=\"$conf->{cgi}{smtp__port}\" style=\"width: 300px;\" />
		</td>
		<td style=\"text-align: left;\">
			When connecting to the mail server address above, a specific \"port\" number must be specified.<br />
			Your ISP should mention what this port number along with the address.<br />
			Typically, this is \"25\" for unencrypted connections and \"587\" for encrypted connections.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol#Ports\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Mail Server Timeout
		</td>
		<td>
			<input type=\"text\" name=\"smtp__timeout\" value=\"$conf->{cgi}{smtp__timeout}\" style=\"width: 300px;\" />
		</td>
		<td style=\"text-align: left;\">
			This is how long, in seconds, we will wait for a response from the mail server.<br />
			If there is no answer after this time, the connection will be considered failed.<br />
			Generally speaking, 60 seconds is a good number.
		</td>
		<td style=\"white-space: nowrap;\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Mail Server User
		</td>
		<td>
			<input type=\"text\" name=\"smtp__username\" value=\"$conf->{cgi}{smtp__username}\" style=\"width: 300px;\" />
		</td>
		<td style=\"text-align: left;\">
			Some mail server require a user name and password. Usually, the user name will be you email address.<br />
			Some ISPs do not require authentication, and in those cases, this can be left blank.<br />
			Please check the information given to you by your ISP to see if this is needed and, if so, what user name to user here.
		</td>
		<td style=\"white-space: nowrap;\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Mail Server Password
		</td>
		<td>
			<input type=\"password\" name=\"smtp__password\" value=\"$conf->{cgi}{smtp__password}\" style=\"width: 300px;\" />
		</td>
		<td style=\"text-align: left;\">
			If you entered a user name above, please enter it's password here.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Mail Security
		</td>
		<td>
			$say_security_select
		</td>
		<td style=\"text-align: left;\">
			This controls how, if at all, to encrypt the email traffic between you and the mail server.<br />
			As with the other mail settings, which to use will depends on your Internet service provider.<br />
			If in doubt, try 'STARTTLS'. If that doesn't work, try 'SSL/TLS'. If that still doesn't work, try 'None'.
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"http://en.wikipedia.org/wiki/STARTTLS\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Encrypt Password
		</td>
		<td>
			$say_encrypt_pass_select
		</td>
		<td style=\"text-align: left;\">
			This controls whether your password is sent to the mail server in plain text or encrypted.<br />
			Most modern mail servers support encrypted passwords, so 'Yes' should work here.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"http://en.wikipedia.org/wiki/Crypt_(C)#MD5-based_scheme\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_ready\">
			Alert Recipient(s)
		</td>
		<td>
			<input type=\"text\" name=\"mail_data__to\" value=\"$conf->{cgi}{mail_data__to}\" style=\"width: 300px;\" />
		</td>
		<td style=\"text-align: left;\">
			This is the person or list of people who will get alert emails. Please enter just the email address. <br />
			Separate multiple email addresses with a comma please.<br />
			Example: '<span class=\"code\">foo\@example.com, bar\@example.com</span>'.
		</td>
		<td style=\"white-space: nowrap;\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td colspan=\"4\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_good\" style=\"white-space: nowrap;\">
			Anvil! Systems
		</td>
		<td colspan=\"3\" style=\"text-align: left;\">
			Here you can add, edit or delete <i>Anvil!</i> systems you manage. This section requires a little more technical knowledge. <br />
			If you have any trouble with this section, please don't hesitate to <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact us</a>.<br />
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note\" style=\"white-space: nowrap;\">
			Anvil! Name
		</td>
		<td colspan=\"2\" style=\"text-align: left;\">
			This is the name of your <i>Anvil!</i>'s cluster name.<br />
			This is set in <span class=\"code\">cluster.conf</span> in the <span class=\"code\"><cluster ...></span> element's <span class=\"code\">name=\"...\"</span> attribute.
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"https://alteeve.ca/w/AN!Cluster_Tutorial_2#The_First_cluster.conf_Foundation_Configuration\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note\" style=\"white-space: nowrap;\">
			Description
		</td>
		<td colspan=\"2\" style=\"text-align: left;\">
			This is a free-form text field where you can put in any description you would like for the give <i>Anvil!</i>.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note\" style=\"white-space: nowrap;\">
			Owner
		</td>
		<td colspan=\"2\" style=\"text-align: left;\">
			This is the name of the company, person or group that owns the specified <i>Anvil!</i>.<br />
			This is a purely descriptive field and you can set it to whatever you want.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"https://alteeve.ca/w/AN!Cluster_Tutorial_2#The_First_cluster.conf_Foundation_Configuration\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note\" style=\"white-space: nowrap;\">
			Anvil! Password
		</td>
		<td colspan=\"2\" style=\"text-align: left;\">
			When your <i>Anvil!</i> was built, a '<span class=\"code\">ricci</span>' password was set.<br />
			Your dashboard needs this password in order to add, edit and remove servers from the given <i>Anvil!</i>.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			<a href=\"https://alteeve.ca/w/AN!Cluster_Tutorial_2#Setting_up_ricci\" target=\"_new\">More Info<a>
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note\" style=\"white-space: nowrap;\">
			Tracking URL
		</td>
		<td colspan=\"2\" style=\"text-align: left;\">
			If you have an internal tracking or documentation system, and if you track the given <i>Anvil!</i> there, you can enter the URL for it here.<br />
		</td>
		<td style=\"white-space: nowrap;\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td class=\"highlight_note\" style=\"white-space: nowrap;\">
			Node 1 &amp; 2
		</td>
		<td colspan=\"3\" style=\"text-align: left;\">
			This section has three fields per node.<br />
			<table width=\"100%\" class=\"hidden_table\">
				<tr>
					<td class=\"highlight_note\" style=\"border: 0px; text-align: right;\">
						Node Name:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						The host name of the node. Generally, this is <span class=\"code\">xx-cYYnZZ</span>.
					</td>
					<td style=\"white-space: nowrap;\">
						<a href=\"https://alteeve.ca/w/AN!Cluster_Tutorial_2#Node_Host_Names\" target=\"_new\">More Info<a>
					</td>
				</tr>
				<tr>
					<td class=\"highlight_note\" style=\"border: 0px; text-align: right;\">
						IP Address:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						Generally, if this machine is in the same place as the the <i>Anvil!</i>, the name you set here will resolve to the 'Back-Channel Network' of the node.<br />
						If the nodes are on a remote network, and if you (or the owner's admin) setup port forwarding, you will enter their external IP address for both nodes and use different ports.<br />
						If you use DNS (or similar) to do name to IP translation, leave this blank.
					</td>
					<td style=\"white-space: nowrap;\">
						<a href=\"https://alteeve.ca/w/AN!Cluster_Tutorial_2#Subnets\" target=\"_new\">More Info<a>
					</td>
				</tr>
				<tr>
					<td class=\"highlight_note\" style=\"border: 0px; text-align: right;\">
						TCP Port:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						This is the TCP port used to connect to the node over SSH, usually this is <span class=\"code\">22</span>.<br />
						If the nodes are behind a firewall though, you may need to specify specific port numbers in order to reach each node.<br />
						When in doubt, leave this blank.<br />
					</td>
					<td style=\"white-space: nowrap;\">
						<a href=\"http://en.wikipedia.org/wiki/Port_forwarding\" target=\"_new\">More Info<a>
					</td>
				</tr>
			</table>
		</td>
	</tr>
";
	my $ids = "";
	foreach my $this_cluster ((sort {$a cmp $b} keys %{$conf->{clusters}}), "new")
	{
		my $this_id          = defined $conf->{clusters}{$this_cluster}{id}          ? $conf->{clusters}{$this_cluster}{id}          : "new";
		my $this_name        = defined $conf->{clusters}{$this_cluster}{name}        ? $conf->{clusters}{$this_cluster}{name}        : "";
		my $this_company     = defined $conf->{clusters}{$this_cluster}{company}     ? $conf->{clusters}{$this_cluster}{company}     : "";
		   $this_company     = convert_text_to_html($conf, $this_company);
		my $this_description = defined $conf->{clusters}{$this_cluster}{description} ? $conf->{clusters}{$this_cluster}{description} : "";
		   $this_description = convert_text_to_html($conf, $this_description);
		my $this_url         = defined $conf->{clusters}{$this_cluster}{url}         ? $conf->{clusters}{$this_cluster}{url}         : "";
		my $this_ricci_pw    = defined $conf->{clusters}{$this_cluster}{ricci_pw}    ? $conf->{clusters}{$this_cluster}{ricci_pw}    : "";
		my $this_node_1_name = defined $conf->{clusters}{$this_cluster}{nodes}[0]    ? $conf->{clusters}{$this_cluster}{nodes}[0]    : "";
		my $this_node_1_ip   = defined $conf->{hosts}{$this_node_1_name}{ip}         ? $conf->{hosts}{$this_node_1_name}{ip}         : "";
		my $this_node_1_port = defined $conf->{hosts}{$this_node_1_name}{port}       ? $conf->{hosts}{$this_node_1_name}{port}       : "";
		my $this_node_2_name = defined $conf->{clusters}{$this_cluster}{nodes}[1]    ? $conf->{clusters}{$this_cluster}{nodes}[1]    : "";
		my $this_node_2_ip   = defined $conf->{hosts}{$this_node_2_name}{ip}         ? $conf->{hosts}{$this_node_2_name}{ip}         : "";
		my $this_node_2_port = defined $conf->{hosts}{$this_node_2_name}{port}       ? $conf->{hosts}{$this_node_2_name}{port}       : "";
		
		my $say_this_cluster = $this_cluster;
		my $clear_icon       = "<img onclick=\"\$('#cluster__${this_id}__name, #cluster__${this_id}__description, #cluster__${this_id}__company, #cluster__${this_id}__ricci_pw, #cluster__${this_id}__url, #cluster__${this_id}__nodes_1_name, #cluster__${this_id}__nodes_1_ip, #cluster__${this_id}__nodes_1_port, #cluster__${this_id}__nodes_2_name, #cluster__${this_id}__nodes_2_ip, #cluster__${this_id}__nodes_2_port').val('')\" src=\"/img/icon_clear-fields_16x16.png\">";
		
		print "
	<tr>
		<td colspan=\"4\">
			&nbsp;
		</td>
	</tr>";
		#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$id]\n");
		if ($ids)
		{
			print "
	<tr>
		<td colspan=\"4\">
			<b>Existing <i>Anvil!</i> Systems</b>
		</td>
	</tr>
";
		}
		elsif ($this_cluster eq "new")
		{
			$say_this_cluster = "";
			$clear_icon       = "";
			print "
	<tr>
		<td colspan=\"4\">
			<b>Add a new <i>Anvil!</i> System</b>
		</td>
	</tr>
";
		}
		$ids .= "$this_id,";
		print "
	<tr>
		<td colspan=\"4\" style=\"text-align: left;\">
			<table width=\"100%\" class=\"hidden_table\">
				<tr>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Anvil! Name:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__name\" id=\"cluster__${this_id}__name\" value=\"$say_this_cluster\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Description:
					</td>
					<td style=\"border: 0px; text-align: left;\" colspan=\"3\">
						<input type=\"text\" name=\"cluster__${this_id}__description\" id=\"cluster__${this_id}__description\" value=\"$this_description\" style=\"width: 600px;\"> <span class=\"subtle_text_fixed_width\">(id: $this_id)</span> &nbsp; &nbsp; $clear_icon
					</td>
				</tr>
				<tr>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Owner:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__company\" id=\"cluster__${this_id}__company\" value=\"$this_company\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Anvil! Password:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"password\" name=\"cluster__${this_id}__ricci_pw\" id=\"cluster__${this_id}__ricci_pw\" value=\"$this_ricci_pw\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Tracking URL:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__url\" id=\"cluster__${this_id}__url\" value=\"$this_url\" style=\"width: 300px;\">
					</td>
				</tr>
				<tr>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Node 1 Name:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__nodes_1_name\" id=\"cluster__${this_id}__nodes_1_name\" value=\"$this_node_1_name\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						IP Address:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__nodes_1_ip\" id=\"cluster__${this_id}__nodes_1_ip\" value=\"$this_node_1_ip\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						TCP Port:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__nodes_1_port\" id=\"cluster__${this_id}__nodes_1_port\" value=\"$this_node_1_port\" style=\"width: 300px;\">
					</td>
				</tr>
				<tr>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						Node 2 Name:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__nodes_2_name\" id=\"cluster__${this_id}__nodes_2_name\" value=\"$this_node_2_name\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						IP Address:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__nodes_2_ip\" id=\"cluster__${this_id}__nodes_2_ip\" value=\"$this_node_2_ip\" style=\"width: 300px;\">
					</td>
					<td class=\"highlight_ready\" style=\"border: 0px; text-align: right;\">
						TCP Port:
					</td>
					<td style=\"border: 0px; text-align: left;\">
						<input type=\"text\" name=\"cluster__${this_id}__nodes_2_port\" id=\"cluster__${this_id}__nodes_2_port\" value=\"$this_node_2_port\" style=\"width: 300px;\">
					</td>
				</tr>
			</table>
		</td>
	</tr>
";
	}
	$ids =~ s/,$//;
	
	print "
	<tr>
		<td colspan=\"4\">
			&nbsp;
		</td>
	</tr>
	<tr>
		<td colspan=\"4\">
			<input type=\"hidden\" name=\"ids\" value=\"$ids\">
			<input type=\"hidden\" name=\"config\" value=\"true\">
			<input type=\"submit\" name=\"save\" value=\"Save\" class=\"button\">
		</td>
	</tr>
</table>
<br />
";
	
	return(1);
}

# This takes a plain text string and escapes special characters for displaying
# in HTML.
sub convert_text_to_html
{
	my ($conf, $string) = @_;
	$string = "" if not defined $string;

	$string =~ s/;/&#59;/g;		# Semi-colon - Must be first!  \
	$string =~ s/&/&amp;/g;		# Ampersand - Must be second!  |- These three are used in other escape codes
	$string =~ s/#/&#35;/g;		# Number sign - Must be third! /
	$string =~ s/\t/&#09;/g;	# Horizontal tab
	$string =~ s/\n/&#10;/g;	# Line feed
	$string =~ s/\r/&#13;/g;	# Carriage Return
	$string =~ s/\s/&#32;/g;	# Space
	$string =~ s/!/&#33;/g;		# Exclamation mark
	$string =~ s/"/&#34;/g;		# Quotation mark
	$string =~ s/\$/&#36;/g;	# Dollar sign
	$string =~ s/\%/&#37;/g;	# Percent sign
# 	$string =~ s/'/&#39;/g;		# Apostrophe
	$string =~ s/'/&rsquo;/g;	# Apostrophe - But in a JS-friendly format.
	$string =~ s/\(/&#40;/g;	# Left parenthesis
	$string =~ s/\)/&#41;/g;	# Right parenthesis
	$string =~ s/\*/&#42;/g;	# Asterisk
	$string =~ s/\+/&#43;/g;	# Plus sign
	$string =~ s/,/&#44;/g;		# Comma
	$string =~ s/-/&#45;/g;		# Hyphen
	$string =~ s/\./&#46;/g;	# Period (fullstop)
	$string =~ s/\//&#47;/g;	# Solidus (slash)
	$string =~ s/:/&#58;/g;		# Colon
	$string =~ s/</&lt;/g;		# Less than
	$string =~ s/=/&#61;/g;		# Equals sign
	$string =~ s/>/&gt;/g;		# Greater than
	$string =~ s/\?/&#63;/g;	# Question mark
	$string =~ s/\@/&#64;/g;	# Commercial at
	$string =~ s/\[/&#91;/g;	# Left square bracket
	$string =~ s/\\/&#92;/g;	# Reverse solidus (backslash)
	$string =~ s/\]/&#93;/g;	# Right square bracket
	$string =~ s/\^/&#94;/g;	# Caret
	$string =~ s/_/&#95;/g;		# Horizontal bar (underscore)
	$string =~ s/`/&#96;/g;		# Acute accent# 	if ($string =~/^Qu/ ) { print $log "=2 string: [$string]<br />\n"; }
	$string =~ s/{/&#123;/g;	# Left curly brace
	$string =~ s/\|/&#124;/g;	# Vertical bar
	$string =~ s/}/&#125;/g;	# Right curly brace
	$string =~ s/~/&#126;/g;	# Tilde
	$string =~ s/\s/&nbsp;/g;	# Non-breaking Space
	$string =~ s/¡/&#161;/g;	# Inverted exclamation
	$string =~ s/¢/&#162;/g;	# Cent sign
	$string =~ s/£/&#163;/g;	# Pound sterling
	$string =~ s/¤/&#164;/g;	# General currency sign
	$string =~ s/¥/&#165;/g;	# Yen sign
	$string =~ s/¦/&#166;/g;	# Broken vertical bar
	$string =~ s/§/&#167;/g;	# Section sign
	$string =~ s/¨/&#168;/g;	# Umlaut (dieresis)
	$string =~ s/©/&copy;/g;	# Copyright
	$string =~ s/ª/&#170;/g;	# Feminine ordinal
	$string =~ s/«/&#171;/g;	# Left angle quote, guillemotleft
	$string =~ s/¬/&#172;/g;	# Not sign
	$string =~ s/­/&#173;/g;		# Soft hyphen
	$string =~ s/®/&#174;/g;	# Registered trademark
	$string =~ s/¯/&#175;/g;	# Macron accent
	$string =~ s/°/&#176;/g;	# Degree sign
	$string =~ s/±/&#177;/g;	# Plus or minus
	$string =~ s/²/&#178;/g;	# Superscript two
	$string =~ s/³/&#179;/g;	# Superscript three
	$string =~ s/´/&#180;/g;	# Acute accent
	$string =~ s/µ/&#181;/g;	# Micro sign
	$string =~ s/¶/&#182;/g;	# Paragraph sign
	$string =~ s/·/&#183;/g;	# Middle dot
	$string =~ s/¸/&#184;/g;	# Cedilla
	$string =~ s/¹/&#185;/g;	# Superscript one
	$string =~ s/º/&#186;/g;	# Masculine ordinal
	$string =~ s/»/&#187;/g;	# Right angle quote, guillemotright
	$string =~ s/¼/&frac14;/g;	# Fraction one-fourth
	$string =~ s/½/&frac12;/g;	# Fraction one-half
	$string =~ s/¾/&frac34;/g;	# Fraction three-fourths
	$string =~ s/¿/&#191;/g;	# Inverted question mark
	$string =~ s/À/&#192;/g;	# Capital A, grave accent
	$string =~ s/Á/&#193;/g;	# Capital A, acute accent
	$string =~ s/Â/&#194;/g;	# Capital A, circumflex accent
	$string =~ s/Ã/&#195;/g;	# Capital A, tilde
	$string =~ s/Ä/&#196;/g;	# Capital A, dieresis or umlaut mark
	$string =~ s/Å/&#197;/g;	# Capital A, ring
	$string =~ s/Æ/&#198;/g;	# Capital AE dipthong (ligature)
	$string =~ s/Ç/&#199;/g;	# Capital C, cedilla
	$string =~ s/È/&#200;/g;	# Capital E, grave accent
	$string =~ s/É/&#201;/g;	# Capital E, acute accent
	$string =~ s/Ê/&#202;/g;	# Capital E, circumflex accent
	$string =~ s/Ë/&#203;/g;	# Capital E, dieresis or umlaut mark
	$string =~ s/Ì/&#204;/g;	# Capital I, grave accent
	$string =~ s/Í/&#205;/g;	# Capital I, acute accent
	$string =~ s/Î/&#206;/g;	# Capital I, circumflex accent
	$string =~ s/Ï/&#207;/g;	# Capital I, dieresis or umlaut mark
	$string =~ s/Ð/&#208;/g;	# Capital Eth, Icelandic
	$string =~ s/Ñ/&#209;/g;	# Capital N, tilde
	$string =~ s/Ò/&#210;/g;	# Capital O, grave accent
	$string =~ s/Ó/&#211;/g;	# Capital O, acute accent
	$string =~ s/Ô/&#212;/g;	# Capital O, circumflex accent
	$string =~ s/Õ/&#213;/g;	# Capital O, tilde
	$string =~ s/Ö/&#214;/g;	# Capital O, dieresis or umlaut mark
	$string =~ s/×/&#215;/g;	# Multiply sign
	$string =~ s/Ø/&#216;/g;	# Capital O, slash
	$string =~ s/Ù/&#217;/g;	# Capital U, grave accent
	$string =~ s/Ú/&#218;/g;	# Capital U, acute accent
	$string =~ s/Û/&#219;/g;	# Capital U, circumflex accent
	$string =~ s/Ü/&#220;/g;	# Capital U, dieresis or umlaut mark
	$string =~ s/Ý/&#221;/g;	# Capital Y, acute accent
	$string =~ s/Þ/&#222;/g;	# Capital THORN, Icelandic
	$string =~ s/ß/&#223;/g;	# Small sharp s, German (sz ligature)
	$string =~ s/à/&#224;/g;	# Small a, grave accent
	$string =~ s/á/&#225;/g;	# Small a, acute accent
	$string =~ s/â/&#226;/g;	# Small a, circumflex accent
	$string =~ s/ã/&#227;/g;	# Small a, tilde
	$string =~ s/ä/&#228;/g;	# Small a, dieresis or umlaut mark
	$string =~ s/å/&#229;/g;	# Small a, ring
	$string =~ s/æ/&#230;/g;	# Small ae dipthong (ligature)
	$string =~ s/ç/&#231;/g;	# Small c, cedilla
	$string =~ s/è/&#232;/g;	# Small e, grave accent
	$string =~ s/é/&#233;/g;	# Small e, acute accent
	$string =~ s/ê/&#234;/g;	# Small e, circumflex accent
	$string =~ s/ë/&#235;/g;	# Small e, dieresis or umlaut mark
	$string =~ s/ì/&#236;/g;	# Small i, grave accent
	$string =~ s/í/&#237;/g;	# Small i, acute accent
	$string =~ s/î/&#238;/g;	# Small i, circumflex accent
	$string =~ s/ï/&#239;/g;	# Small i, dieresis or umlaut mark
	$string =~ s/ð/&#240;/g;	# Small eth, Icelandic
	$string =~ s/ñ/&#241;/g;	# Small n, tilde
	$string =~ s/ò/&#242;/g;	# Small o, grave accent
	$string =~ s/ó/&#243;/g;	# Small o, acute accent
	$string =~ s/ô/&#244;/g;	# Small o, circumflex accent
	$string =~ s/õ/&#245;/g;	# Small o, tilde
	$string =~ s/ö/&#246;/g;	# Small o, dieresis or umlaut mark
	$string =~ s/÷/&#247;/g;	# Division sign
	$string =~ s/ø/&#248;/g;	# Small o, slash
	$string =~ s/ù/&#249;/g;	# Small u, grave accent
	$string =~ s/ú/&#250;/g;	# Small u, acute accent
	$string =~ s/û/&#251;/g;	# Small u, circumflex accent
	$string =~ s/ü/&#252;/g;	# Small u, dieresis or umlaut mark
	$string =~ s/ý/&#253;/g;	# Small y, acute accent
	$string =~ s/þ/&#254;/g;	# Small thorn, Icelandic
	$string =~ s/ÿ/&#255;/g;	# Small y, dieresis or umlaut mark

	# These are a few special ones.
	$string =~ s/\t/&nbsp; &nbsp; &nbsp; &nbsp;/g;
	$string =~ s/  /&nbsp; /g;

	# Make sure no control characters were double-encoded
	$string =~ s/&lt;br \/&gt;/<br>/g;
	
	return ($string);
}

# This takes a string with (possible) HTML escape codes and converts them to
# plain-text.
sub convert_html_to_text
{
	my ($conf, $string) = @_;
	$string = "" if not defined $string;

	$string =~ s/&quot;/"/g;
	$string =~ s/&#09;/\t/g;	# Horizontal tab
	$string =~ s/&#10;/\n/g;	# Line feed
	$string =~ s/&#13;/\r/g;	# Carriage Return
	$string =~ s/&#32;/ /g;		# Space
	$string =~ s/&#33;/!/g;		# Exclamation mark
	$string =~ s/&#34;/"/g;		# Quotation mark
	$string =~ s/&#36;/\$/g;	# Dollar sign
	$string =~ s/&#37;/\%/g;	# Percent sign
	$string =~ s/&#38;/&/g;		# (Alt) Ampersand
	$string =~ s/&#39;/'/g;		# Apostrophe
	$string =~ s/&#40;/\(/g;	# Left parenthesis
	$string =~ s/&#41;/\)/g;	# Right parenthesis
	$string =~ s/&#42;/\*/g;	# Asterisk
	$string =~ s/&#43;/\+/g;	# Plus sign
	$string =~ s/&#44;/,/g;		# Comma
	$string =~ s/&#45;/-/g;		# Hyphen
	$string =~ s/&#46;/\./g;	# Period (fullstop)
	$string =~ s/&#47;/\//g;	# Solidus (slash)
	$string =~ s/&#58;/:/g;		# Colon
	$string =~ s/&lt;/</g;		# Less than
	$string =~ s/&#60;/</g;		# (Alt) Less than
	$string =~ s/&#61;/=/g;		# Equals sign
	$string =~ s/&gt;/>/g;		# Greater than
	$string =~ s/&#62;/>/g;		# (Alt) Greater than
	$string =~ s/&#63;/\?/g;	# Question mark
	$string =~ s/&#64;/\@/g;	# Commercial at
	$string =~ s/&#91;/\[/g;	# Left square bracket
	$string =~ s/&#92;/\\/g;	# Reverse solidus (backslash)
	$string =~ s/&#93;/\]/g;	# Right square bracket
	$string =~ s/&#94;/\^/g;	# Caret
	$string =~ s/&#95;/_/g;		# Horizontal bar (underscore)
	$string =~ s/&#96;/`/g;		# Acute accent
	$string =~ s/&#123;/{/g;	# Left curly brace
	$string =~ s/&#124;/\|/g;	# Vertical bar
	$string =~ s/&#125;/}/g;	# Right curly brace
	$string =~ s/&#126;/~/g;	# Tilde
	$string =~ s/&nbsp;/ /g;	# Non-breaking Space
	$string =~ s/&#160;/ /g;	# (Alt) Non-breaking Space
	$string =~ s/&#161;/¡/g;	# Inverted exclamation
	$string =~ s/&#162;/¢/g;	# Cent sign
	$string =~ s/&#163;/£/g;	# Pound sterling
	$string =~ s/&#164;/¤/g;	# General currency sign
	$string =~ s/&#165;/¥/g;	# Yen sign
	$string =~ s/&#166;/¦/g;	# Broken vertical bar
	$string =~ s/&#167;/§/g;	# Section sign
	$string =~ s/&#168;/¨/g;	# Umlaut (dieresis)
	$string =~ s/&copy;/©/g;	# Copyright
	$string =~ s/&#169;/©/g;	# (Alt) Copyright
	$string =~ s/&#170;/ª/g;	# Feminine ordinal
	$string =~ s/&#171;/«/g;	# Left angle quote, guillemotleft
	$string =~ s/&#172;/¬/g;	# Not sign
	$string =~ s/&#173;/­/g;		# Soft hyphen
	$string =~ s/&#174;/®/g;	# Registered trademark
	$string =~ s/&#175;/¯/g;	# Macron accent
	$string =~ s/&#176;/°/g;	# Degree sign
	$string =~ s/&#177;/±/g;	# Plus or minus
	$string =~ s/&#178;/²/g;	# Superscript two
	$string =~ s/&#179;/³/g;	# Superscript three
	$string =~ s/&#180;/´/g;	# Acute accent
	$string =~ s/&#181;/µ/g;	# Micro sign
	$string =~ s/&#182;/¶/g;	# Paragraph sign
	$string =~ s/&#183;/·/g;	# Middle dot
	$string =~ s/&#184;/¸/g;	# Cedilla
	$string =~ s/&#185;/¹/g;	# Superscript one
	$string =~ s/&#186;/º/g;	# Masculine ordinal
	$string =~ s/&#187;/»/g;	# Right angle quote, guillemotright
	$string =~ s/&frac14;/¼/g;	# Fraction one-fourth
	$string =~ s/&#188;/¼/g;	# (Alt) Fraction one-fourth
	$string =~ s/&frac12;/½/g;	# Fraction one-half
	$string =~ s/&#189;/½/g;	# (Alt) Fraction one-half
	$string =~ s/&frac34;/¾/g;	# Fraction three-fourths
	$string =~ s/&#190;/¾/g;	# (Alt) Fraction three-fourths
	$string =~ s/&#191;/¿/g;	# Inverted question mark
	$string =~ s/&#192;/À/g;	# Capital A, grave accent
	$string =~ s/&#193;/Á/g;	# Capital A, acute accent
	$string =~ s/&#194;/Â/g;	# Capital A, circumflex accent
	$string =~ s/&#195;/Ã/g;	# Capital A, tilde
	$string =~ s/&#196;/Ä/g;	# Capital A, dieresis or umlaut mark
	$string =~ s/&#197;/Å/g;	# Capital A, ring
	$string =~ s/&#198;/Æ/g;	# Capital AE dipthong (ligature)
	$string =~ s/&#199;/Ç/g;	# Capital C, cedilla
	$string =~ s/&#200;/È/g;	# Capital E, grave accent
	$string =~ s/&#201;/É/g;	# Capital E, acute accent
	$string =~ s/&#202;/Ê/g;	# Capital E, circumflex accent
	$string =~ s/&#203;/Ë/g;	# Capital E, dieresis or umlaut mark
	$string =~ s/&#204;/Ì/g;	# Capital I, grave accent
	$string =~ s/&#205;/Í/g;	# Capital I, acute accent
	$string =~ s/&#206;/Î/g;	# Capital I, circumflex accent
	$string =~ s/&#207;/Ï/g;	# Capital I, dieresis or umlaut mark
	$string =~ s/&#208;/Ð/g;	# Capital Eth, Icelandic
	$string =~ s/&#209;/Ñ/g;	# Capital N, tilde
	$string =~ s/&#210;/Ò/g;	# Capital O, grave accent
	$string =~ s/&#211;/Ó/g;	# Capital O, acute accent
	$string =~ s/&#212;/Ô/g;	# Capital O, circumflex accent
	$string =~ s/&#213;/Õ/g;	# Capital O, tilde
	$string =~ s/&#214;/Ö/g;	# Capital O, dieresis or umlaut mark
	$string =~ s/&#215;/×/g;	# Multiply sign
	$string =~ s/&#216;/Ø/g;	# Capital O, slash
	$string =~ s/&#217;/Ù/g;	# Capital U, grave accent
	$string =~ s/&#218;/Ú/g;	# Capital U, acute accent
	$string =~ s/&#219;/Û/g;	# Capital U, circumflex accent
	$string =~ s/&#220;/Ü/g;	# Capital U, dieresis or umlaut mark
	$string =~ s/&#221;/Ý/g;	# Capital Y, acute accent
	$string =~ s/&#222;/Þ/g;	# Capital THORN, Icelandic
	$string =~ s/&#223;/ß/g;	# Small sharp s, German (sz ligature)
	$string =~ s/&#224;/à/g;	# Small a, grave accent
	$string =~ s/&#225;/á/g;	# Small a, acute accent
	$string =~ s/&#226;/â/g;	# Small a, circumflex accent
	$string =~ s/&#227;/ã/g;	# Small a, tilde
	$string =~ s/&#228;/ä/g;	# Small a, dieresis or umlaut mark
	$string =~ s/&#229;/å/g;	# Small a, ring
	$string =~ s/&#230;/æ/g;	# Small ae dipthong (ligature)
	$string =~ s/&#231;/ç/g;	# Small c, cedilla
	$string =~ s/&#232;/è/g;	# Small e, grave accent
	$string =~ s/&#233;/é/g;	# Small e, acute accent
	$string =~ s/&#234;/ê/g;	# Small e, circumflex accent
	$string =~ s/&#235;/ë/g;	# Small e, dieresis or umlaut mark
	$string =~ s/&#236;/ì/g;	# Small i, grave accent
	$string =~ s/&#237;/í/g;	# Small i, acute accent
	$string =~ s/&#238;/î/g;	# Small i, circumflex accent
	$string =~ s/&#239;/ï/g;	# Small i, dieresis or umlaut mark
	$string =~ s/&#240;/ð/g;	# Small eth, Icelandic
	$string =~ s/&#241;/ñ/g;	# Small n, tilde
	$string =~ s/&#242;/ò/g;	# Small o, grave accent
	$string =~ s/&#243;/ó/g;	# Small o, acute accent
	$string =~ s/&#244;/ô/g;	# Small o, circumflex accent
	$string =~ s/&#245;/õ/g;	# Small o, tilde
	$string =~ s/&#246;/ö/g;	# Small o, dieresis or umlaut mark
	$string =~ s/&#247;/÷/g;	# Division sign
	$string =~ s/&#248;/ø/g;	# Small o, slash
	$string =~ s/&#249;/ù/g;	# Small u, grave accent
	$string =~ s/&#250;/ú/g;	# Small u, acute accent
	$string =~ s/&#251;/û/g;	# Small u, circumflex accent
	$string =~ s/&#252;/ü/g;	# Small u, dieresis or umlaut mark
	$string =~ s/&#253;/ý/g;	# Small y, acute accent
	$string =~ s/&#254;/þ/g;	# Small thorn, Icelandic
	$string =~ s/&#255;/ÿ/g;	# Small y, dieresis or umlaut mark
	$string =~ s/&#35;/#/g;		# Number sign - Must be third to last! \
	$string =~ s/&amp;/&/g;		# Ampersand - Must be second to last!   |- These are used in other escape codes.
	$string =~ s/&#59;/;/g;		# Semi-colon - Must be last!            /
	
	return ($string);
}

# This asks the user which cluster they want to work with.
sub ask_which_cluster
{
	my ($conf) = @_;
	
	print "
<table align=\"center\">
	<tr>
		<td colspan=\"4\">
			<b>Please choose an <i>Anvil!</i></b>
		</td>
	</tr>
	";
	
	my $anvil_count = 0;
	foreach my $cluster (sort {$a cmp $b} keys %{$conf->{clusters}})
	{
		$anvil_count++;
	}

	if (not $anvil_count)
	{
		print "
	<tr>
		<td class=\"highlight_warning\">
			Woops!
		</td>
		<td colspan=\"3\">
			No <i>Anvil!</i> yet configured in <span class=\"code\">$conf->{path}{an_conf}</span> yet.
		</td>
	</tr>
";
	}
	else
	{
		foreach my $cluster (sort {$a cmp $b} keys %{$conf->{clusters}})
		{
			next if not $cluster;
			my $say_url = "&nbsp;";
			if ($conf->{clusters}{$cluster}{url})
			{
				$say_url = "<a href=\"$conf->{clusters}{$cluster}{url}\" target=\"_new\"><img src=\"/img/anvil-url_16x16.png\"></a>";
			}
			print "
	<tr>
		<td>
			<a href=\"?cluster=$cluster\">$cluster</a>
		</td>
		<td>
			$conf->{clusters}{$cluster}{company}
		</td>
		<td>
			$conf->{clusters}{$cluster}{description}
		</td>
		<td>
			$say_url
		</td>
	</tr>
";
		}
	}
	print "
	<tr>
		<td>
			<a href=\"?config=true\">Manage</a>
		</td>
		<td colspan=\"3\">
			Configure the <i>Anvil!</i> systems managed by this dashboard.
		</td>
	</tr>
	<tr>
		<td colspan=\"4\">
			&nbsp;
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# I need to convert the global configuration of the clusters to the format I use here.
sub convert_cluster_config
{
	my ($conf) = @_;
	
	foreach my $id (sort {$a cmp $b} keys %{$conf->{cluster}})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$id]\n");
		my $name = $conf->{cluster}{$id}{name};
		$conf->{clusters}{$name}{nodes}       = [split/,/, $conf->{cluster}{$id}{nodes}];
		$conf->{clusters}{$name}{company}     = $conf->{cluster}{$id}{company};
		$conf->{clusters}{$name}{description} = $conf->{cluster}{$id}{description};
		$conf->{clusters}{$name}{url}         = $conf->{cluster}{$id}{url};
		$conf->{clusters}{$name}{ricci_pw}    = $conf->{cluster}{$id}{ricci_pw};
		$conf->{clusters}{$name}{id}          = $id;
		#record($conf, "$THIS_FILE ".__LINE__."; ID: [$id], name: [$name], company: [$conf->{clusters}{$name}{company}], description: [$conf->{clusters}{$name}{description}], ricci_pw: [$conf->{clusters}{$name}{ricci_pw}]\n");
		
		for (my $i = 0; $i< @{$conf->{clusters}{$name}{nodes}}; $i++)
		{
			@{$conf->{clusters}{$name}{nodes}}[$i] =~ s/^\s+//;
			@{$conf->{clusters}{$name}{nodes}}[$i] =~ s/\s+$//;
			#record($conf, "$THIS_FILE ".__LINE__."; $i - node: [@{$conf->{clusters}{$name}{nodes}}[$i]]\n");
		}
	}
	
	return (0);
}

# This prints an error and exits.
sub error
{
	my ($conf, $message, $fatal) = @_;
	$fatal = 1 if not defined $fatal;
	
	footer($conf) if $fatal;
	
	print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning_bold\">
			Note
		</td>
		<td>
			$message
		</td>
	</tr>
</table>
<br />
";
	exit(1) if $fatal;
	
	return(1);
}

sub header
{
	my ($conf, $short_name, $program_name, $logo) = @_;
	
	print "Content-type: text/html; charset=utf-8\n";
	
	# Header buttons.
	my $say_back    = "&nbsp;";
	my $say_refresh = "&nbsp;";
	#if ($conf->{'system'}{show_refresh})
	if ($conf->{cgi}{task})
	{
		#$say_back = "<a href=\"?cluster=$conf->{cgi}{cluster}\"><img src=\"/img/back.png\" alt=\"back\" id=\"show_when_loaded\" style=\"display: none\"></a>";
		$say_back = "<a href=\"?cluster=$conf->{cgi}{cluster}\"><img src=\"/img/back.png\" alt=\"back\"></a>";
		if ($conf->{cgi}{task} eq "manage_vm")
		{
			$say_refresh = "<a href=\"?cluster=$conf->{cgi}{cluster}&vm=$conf->{cgi}{vm}&task=manage_vm\"><img src=\"/img/refresh.png\" alt=\"refresh\"></a>";
		}
		elsif ($conf->{cgi}{task} eq "display_health")
		{
			$say_refresh = "<a href=\"?cluster=$conf->{cgi}{cluster}&node=$conf->{cgi}{node}&node_cluster_name=$conf->{cgi}{node_cluster_name}&task=display_health\"><img src=\"/img/refresh.png\" alt=\"refresh\"></a>";
		}
	}
	else
	{
		$say_refresh = "<a href=\"$conf->{'system'}{cgi_string}\"><img src=\"/img/refresh.png\" alt=\"refresh\"></a>";
	}
	print "
<head>
	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />
	<title>$short_name - Alteeve's Niche! $program_name</title>
	<link rel=\"stylesheet\" href=\"/an-cdb.css\" media=\"screen\" />
	<script type=\"text/javascript\" src=\"/an-cdb.js\"></script>
	<script type=\"text/javascript\" src=\"/jquery-latest.js\"></script>
</head>
<body>
<br />
<table class=\"hidden_table\" align=\"center\">
	<tr>
		<td width=\"100px\" class=\"td_hidden\">
			<table align=\"left\" class=\"hidden_table\">
				<tr>
					<td class=\"td_hidden\">
						$say_back
					</td>
				</tr>
			</table>
		</td>
		<td class=\"td_hidden\">
			<table align=\"center\">
				<tr>
					<td>
						<a href=\"/cgi-bin/an-cdb?logo=true\"><img src=\"/img/$logo\" alt=\"$short_name - $program_name\"></a>
					</td>
				</tr>
			</table>
		</td>
		<td width=\"100px\" class=\"td_hidden\">
			<table align=\"right\" class=\"hidden_table\">
				<tr>
					<td class=\"td_hidden\">
						$say_refresh
					</td>
				</tr>
			</table>
		</td>
	</tr>
</table>
<br />
";
	
	return (0);
}

# This looks for an executable.
sub find_executables
{
	my ($conf) = @_;
	
	my $search = $ENV{'PATH'};
	#print "Searching in: [$search] for programs.\n";
	foreach my $prog (keys %{$conf->{path}})
	{
		#print "Seeing if: [$prog] is really at: [$conf->{path}{$prog}]: ";
		if ( -e $conf->{path}{$prog} )
		{
			#print "Found it.\n";
		}
		else
		{
			#print "Not found, searching for it now.\n";
			foreach my $dir (split /:/, $search)
			{
				my $full_path = "$dir/$prog";
				if ( -e $full_path )
				{
					$conf->{path}{$prog} = $full_path;
					#print "Found it in: [$full_path]\n";
				}
			}
		}
	}
	
	return (0);
}

sub footer
{
	my ($conf) = @_;
	
	return(0) if $conf->{'system'}{footer_printed}; 
	$conf->{'system'}{footer_printed} = 1;
	
	print "
<table align=\"center\" class=\"hidden_table\">
	<tr>
		<td class=\"td_hidden\">
			<span class=\"legal\">
			&copy; <a href=\"https://alteeve.com\" target=\"_new\">Alteeve's Niche! Inc.</a> 1997 - 2014<br />
			This program is released under the <a href=\"http://www.gnu.org/licenses/gpl-2.0.html\" target=\"_new\">GNU GPL v2</a><br />
			Release version $VERSION<br />
			</span>
		</td>
	</tr>
</table>
</body>
<img src=\"/img/t.png\" onload=\"show_on_load();\" border=\"0\" />
<img src=\"/img/t.png\" onload=\"hide_on_load();\" border=\"0\" />";
	
	return (0);
}

# This returns a 'YY-MM-DD_hh:mm:ss' formatted string based on the given time
# stamp
sub get_date
{
	my ($conf, $time) = @_;
	$time = time if not defined $time;
	
	my @time   = localtime($time);
	my $year   = ($time[5] + 1900);
	my $month  = sprintf("%.2d", ($time[4] + 1));
	my $day    = sprintf("%.2d", $time[3]);
	my $hour   = sprintf("%.2d", $time[2]);
	my $minute = sprintf("%.2d", $time[1]);
	my $second = sprintf("%.2d", $time[0]);
	
	# this returns "yyyy-mm-dd_hh:mm:ss".
	my $date = "$year-$month-$day $hour:$minute:$second";
	
	return ($date);
}

# The reads in any passed CGI variables
sub get_cgi_vars
{
	my ($conf, $vars) = @_;
	
	my $cgi = new CGI;
	
	$conf->{'system'}{cgi_string} = "?";
	foreach my $var (@{$vars})
	{
		# A stray comma will cause a loop with no var name
		next if not $var;
		
		# I auto-select the 'cluster' variable if only one is checked.
		# Because of this, I don't want to overwrite the empty CGI 
		# value. This prevents that.
		if (($var eq "cluster") && ($conf->{cgi}{cluster}))
		{
			$conf->{'system'}{cgi_string} .= "$var=$conf->{cgi}{$var}&";
			next;
		}
		
		# Avoid "uninitialized" warning messages.
		$conf->{cgi}{$var}="";
		if (defined $cgi->param($var))
		{
			if ($var eq "file")
			{
				$conf->{cgi_fh}{$var} = $cgi->upload($var);
				record($conf, "$THIS_FILE ".__LINE__."; cgi FH: [$var] -> [$conf->{cgi_fh}{$var}]\n");
			}
			$conf->{cgi}{$var} = $cgi->param($var);
			# Make this UTF8 if it isn't already.
			if (not Encode::is_utf8( $conf->{cgi}{$var} ))
			{
				$conf->{cgi}{$var} = Encode::decode_utf8( $conf->{cgi}{$var} );
			}
			$conf->{'system'}{cgi_string} .= "$var=$conf->{cgi}{$var}&";
		}
		record($conf, "$THIS_FILE ".__LINE__."; var: [$var] -> [$conf->{cgi}{$var}]\n") if $conf->{cgi}{$var};
	}
	$conf->{'system'}{cgi_string} =~ s/&$//;
	record($conf, "$THIS_FILE ".__LINE__."; system::cgi_string: [$conf->{'system'}{cgi_string}]\n");
	
	return (0);
}

# This reads in the configuration file.
sub read_conf
{
	my ($conf) = @_;
	
	my $fh = IO::Handle->new();
	my $sc = "$conf->{path}{an_conf}";
	open ($fh, "<$sc") or die "Failed to read: [$sc], error was: $!\n";
	while (<$fh>)
	{
		chomp;
		my $line = $_;
		next if not $line;
		next if $line !~ /=/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		next if $line =~ /^#/;
		next if not $line;
		my ($var, $val) = (split/=/, $line, 2);
		$var =~ s/^\s+//;
		$var =~ s/\s+$//;
		$val =~ s/^\s+//;
		$val =~ s/\s+$//;
		next if (not $var);
		_make_hash_reference($conf, $var, $val);
	}
	$fh->close();
	
	return(0);
}

# This builds an HTML select field.
sub build_select
{
	my ($conf, $name, $sort, $blank, $width, $selected, $options) = @_;
	
	my $select = "<select name=\"$name\">\n";
	if ($width)
	{
		$select = "<select name=\"$name\" style=\"width: ${width}px;\">\n";
	}
	
	# Insert a blank line.
	if ($blank)
	{
		$select .= "<option value=\"\"></option>\n";
	}
	
	# This needs to be smarter.
	if ($sort)
	{
		foreach my $entry (sort {$a cmp $b} @{$options})
		{
			next if not $entry;
			if ($entry =~ /^(.*?)#!#(.*)$/)
			{
				my $value = $1;
				my $desc  = $2;
				$select .= "<option value=\"$value\">$desc</option>\n";
			}
			else
			{
				$select .= "<option value=\"$entry\">$entry</option>\n";
			}
		}
	}
	else
	{
		foreach my $entry (@{$options})
		{
			next if not $entry;
			if ($entry =~ /^(.*?)#!#(.*)$/)
			{
				my $value = $1;
				my $desc  = $2;
				$select .= "<option value=\"$value\">$desc</option>\n";
			}
			else
			{
				$select .= "<option value=\"$entry\">$entry</option>\n";
			}
		}
	}
	
	if ($selected)
	{
		$select =~ s/value=\"$selected\">/value=\"$selected\" selected>/m;
	}
	
	$select .= "</select>\n";
	
	return ($select);
}

# This looks for a node we have access to and returns the first one available.
sub read_files_on_shared
{
	my ($conf) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster].\n");
	my $connected = "";
	my $cluster   = $conf->{cgi}{cluster};
	delete $conf->{files} if exists $conf->{files};
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		next if $connected;
		#record($conf, "$THIS_FILE ".__LINE__."; trying to connect to node: [$node].\n");
		my $fail = 0;
		my $sc   = "$conf->{path}{ssh} -o ConnectTimeout=10 root\@$node \"df -P && ls -l /shared/files/\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		my $raw;
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			$raw .= $_;
			chomp;
			my $line = $_;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			next if $fail;
			
			# This catches connectivity problems.
			if ($line =~ /No route to host/i)
			{
				my $local_access = on_same_network($conf, $node);
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">No Access</span>";
				if ($local_access)
				{
					$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. It is on an accessible subnet, so the node is likely off or there is a network problem.";
				}
				else
				{
					$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. The server running AN!CDB is not currently on the same subnet as the node.";
				}
				$fail = 1;
				next;
			}
			elsif ($line =~ /host key verification failed/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Verification Failed!</span>";
				$conf->{node}{$node}{info}{note}    = "SSH host key validation failed.<br />Have you saved <span class=\"fixed_width\">${node}</span>'s fingerprint in <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file?<br />If this is a new issue, the physical node may have changed, requiring the old fingerprint be deleted and the new fingerprint be saved.<br />If the machine has not changed, then this might be a sign of an attempt to intercept your connection to the node.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /could not resolve hostname/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Bad Hostname!</span>";
				$conf->{node}{$node}{info}{note}    = "Could not resolve the hostname: <span class=\"fixed_width\">$node</span>. Have you setup your <span class=\"fixed_width\">/etc/hosts</span> file or DNS server properly?";
				$fail = 1;
				next;
			}
			elsif ($line =~ /permission denied/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Permission Denied!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. Have you added <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/id_rsa.pub</span> public key to <span class=\"fixed_width\">$node</span>'s <span class=\"fixed_width\">/root/.ssh/authorized_keys</span> file? If so, check <span class=\"fixed_width\">/var/log/secure</span> on <span class=\"fixed_width\">$node</span> for errors.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /connection refused/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Refused!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />Either it is refusing incoming connections or this machine does not have access to the node's subnet.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /Connection timed out/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Timed Out</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The connection timed out.";
				$fail = 1;
				next;
			}
			elsif ($line =~ /Network is unreachable/i)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Network Unreachable</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The network is not reachable. Is this machine hosting this program on the same subnet?";
				$fail = 1;
				next;
			}
			elsif ($line =~ /\@\@\@\@/)
			{
				# When the host-key fails to match, a box made
				# of '@@@@' is displayed, and is the entire 
				# first line.
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. It appears that the node has changed! If this node failed and was replaced, be sure to remove the old key from <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file. If the node has not been replaced, then someone might be trying to trick you into logging into it.";
				$fail = 1;
				next;
			}
			
			# If I made it this far, I've got a connection.
			$connected = $node;
			if ($line =~ /\s(\d+)-blocks\s/)
			{
				$conf->{partition}{shared}{block_size} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; block_size: [$conf->{partition}{shared}{block_size}]\n");
				next;
			}
			if ($line =~ /^\/.*?\s+(\d+)\s+(\d+)\s+(\d+)\s(\d+)%\s+\/shared/)
			{
				$conf->{partition}{shared}{total_space}  = $1;
				$conf->{partition}{shared}{used_space}   = $2;
				$conf->{partition}{shared}{free_space}   = $3;
				$conf->{partition}{shared}{used_percent} = $4;
				#record($conf, "$THIS_FILE ".__LINE__."; total_space: [$conf->{partition}{shared}{total_space}], used_space: [$conf->{partition}{shared}{used_space} / $conf->{partition}{shared}{used_percent}%], free_space: [$conf->{partition}{shared}{free_space}]\n");
				next;
			}
			if ($line =~ /^(\S)(\S+)\s+\d+\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(.*)$/)
			{
				my $type   = $1;
				my $mode   = $2;
				my $user   = $3;
				my $group  = $4;
				my $size   = $5;
				my $month  = $6;
				my $day    = $7;
				my $time   = $8; # might be a year, look for '\d+:\d+'.
				my $file   = $9;
				my $target = "";
				if ($type eq "l")
				{
					# It's a symlink, strip off the destination.
					($file, $target) = ($file =~ /^(.*?) -> (.*)$/);
				}
				$conf->{files}{shared}{$file}{type}   = $type;
				$conf->{files}{shared}{$file}{mode}   = $mode;
				$conf->{files}{shared}{$file}{user}   = $user;
				$conf->{files}{shared}{$file}{group}  = $group;
				$conf->{files}{shared}{$file}{size}   = $size;
				$conf->{files}{shared}{$file}{month}  = $month;
				$conf->{files}{shared}{$file}{day}    = $day;
				$conf->{files}{shared}{$file}{'time'} = $time; # might be a year, look for '\d+:\d+'.
				$conf->{files}{shared}{$file}{target} = $target;
				#record($conf, "$THIS_FILE ".__LINE__."; file: [$file], mode: [$conf->{files}{shared}{$file}{type}, $conf->{files}{shared}{$file}{mode}], owner: [$conf->{files}{shared}{$file}{user} / $conf->{files}{shared}{$file}{group}], size: [$conf->{files}{shared}{$file}{size}], modified: [$conf->{files}{shared}{$file}{month} $conf->{files}{shared}{$file}{day} $conf->{files}{shared}{$file}{'time'}], target: [$conf->{files}{shared}{$file}{target}]\n");
				next;
			}
		}
	}
	
	if (not $connected)
	{
		print "
<table align=\"center\">
	<tr>
		<td colspan=\"3\">
			Unable to connect to the <span class=\"highlight_detail\">${cluster}</span> cluster!
		</td>
	</tr>
";
		foreach my $node (sort {$a cmp $b} keys %{$conf->{node}})
		{
			my $state = $conf->{node}{$node}{info}{'state'};
			my $note  = $conf->{node}{$node}{info}{note};
			print "
	<tr>
		<td>
			<span class=\"fixed_width\">$node</span>
		</td>
		<td>
			<span class=\"fixed_width\">$state</span>
		</td>
		<td>
			$note
		</td>
	</tr>
";
		}
		print "
	<tr>
		<td colspan=\"3\">
			<div class=\"align_right\"><a href=\"$conf->{'system'}{cgi_string}\"><b>Try Again</b></a></div>
		</td>
	</tr>
";
	}
		print "
</table>
<br />
";
	
	return ($connected);
}

# Record a message to the log file.
sub record
{
	my ($conf, $message)=@_;

	my $fh = $conf->{handles}{'log'};
	if (not $fh)
	{
		$fh = IO::Handle->new();
		$conf->{handles}{'log'} = $fh;
		open ($fh, ">>$conf->{path}{'log'}") or die "$THIS_FILE ".__LINE__."; Can't write to: [$conf->{path}{'log'}], error: $!\n";
		print $fh "======\nOpening AN!CM - Cluster Monitor log at ".time."\n";
	}
	print $fh $message;
	
	return (0);
}

# This gathers details on the cluster.
sub scan_cluster
{
	my ($conf) = @_;
	
	set_node_names ($conf);
	check_nodes    ($conf);
	#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
	if ($conf->{'system'}{up_nodes} > 0)
	{
		check_vms($conf);
	}

	return(0);
}

sub check_nodes
{
	my ($conf) = @_;
	
	print "
<div id=\"hide_when_loaded\">
<table align=\"center\">
	<tr>
		<td>
			<b>Please be patient.</b><br />
			Gathering information from $conf->{cgi}{cluster}.<br />
			This could take a minute to complete.
		</td>
		<td>
			<img src=\"/img/gather_info.gif\" border=\"0\">
		</td>
	</tr>
</table>
<br />
</div>
	";
	
	# Start your engines!
	check_node_status($conf);
	
	return (0);
}

# This attempts to gather all information about a node in one SSH call. It's
# done to minimize the ssh overhead on slow links.
sub check_node_status
{
	my ($conf) = @_;
	
	my $cluster = $conf->{cgi}{cluster};
	#record($conf, "$THIS_FILE ".__LINE__."; In check_node_status() checking nodes in cluster: [$cluster].\n");
	foreach my $node (sort {$a cmp $b} @{$conf->{clusters}{$cluster}{nodes}})
	{
		set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		#record($conf, "$THIS_FILE ".__LINE__."; Gathering details on: [$node].\n");
		gather_node_details($conf, $node);
		push @{$conf->{online_nodes}}, $node if check_node_daemons($conf, $node);
	}
	
	# If I have no nodes up, exit.
	$conf->{'system'}{up_nodes}     = @{$conf->{up_nodes}};
	$conf->{'system'}{online_nodes} = @{$conf->{online_nodes}};
	#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}], online nodes: [$conf->{'system'}{online_nodes}]\n");
	if ($conf->{'system'}{up_nodes} < 1)
	{
		# Neither node is up. If I can power them on, then I will show
		# the node section to enable power up.
		if (not $conf->{'system'}{show_nodes})
		{
			print "
<table align=\"center\">
	<tr>
		<td>
			I could not reach either node in this cluster.
		</td>
	</tr>
</table>
<br />
";
		}
	}
	else
	{
		post_scan_calculations($conf);
	}
	
	return (0);
}

# This sorts out some stuff after both nodes have been scanned.
sub post_scan_calculations
{
	my ($conf) = @_;
	
	$conf->{resources}{total_ram}     = 0;
	$conf->{resources}{total_cores}   = 0;
	$conf->{resources}{total_threads} = 0;
	foreach my $node (sort {$a cmp $b} @{$conf->{up_nodes}})
	{
		# Record this node's RAM and CPU as the maximum available if
		# the max cores and max ram is 0 or greater than that on this
		# node.
		#record($conf, "$THIS_FILE ".__LINE__."; >> node: [$node], res. total RAM: [$conf->{resources}{total_ram}], hardware total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
		if ((not $conf->{resources}{total_ram}) || ($conf->{node}{$node}{hardware}{total_memory} < $conf->{resources}{total_ram}))
		{
			$conf->{resources}{total_ram} = $conf->{node}{$node}{hardware}{total_memory};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res. total RAM: [$conf->{resources}{total_ram}]\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; << node: [$node], res. total RAM: [$conf->{resources}{total_ram}]\n");
		
		# Set by meminfo, if less (needed to catch mirrored RAM)
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], meminfo total memory: [$conf->{node}{$node}{hardware}{meminfo}{memtotal}]\n");
		if ($conf->{node}{$node}{hardware}{meminfo}{memtotal} < $conf->{resources}{total_ram})
		{
			$conf->{resources}{total_ram} = $conf->{node}{$node}{hardware}{meminfo}{memtotal};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res. total RAM: [$conf->{resources}{total_ram}]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res. total cores: [$conf->{resources}{total_cores}], hardware total node cores: [$conf->{node}{$node}{hardware}{total_node_cores}]\n");
		if ((not $conf->{resources}{total_cores}) || ($conf->{node}{$node}{hardware}{total_node_cores} < $conf->{resources}{total_cores}))
		{
			$conf->{resources}{total_cores} = $conf->{node}{$node}{hardware}{total_node_cores};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res. total cores: [$conf->{resources}{total_cores}]\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res. total threads: [$conf->{resources}{total_threads}], hardware total node threads: [$conf->{node}{$node}{hardware}{total_node_cores}]\n");
		if ((not $conf->{resources}{total_threads}) || ($conf->{node}{$node}{hardware}{total_node_threads} < $conf->{resources}{total_threads}))
		{
			$conf->{resources}{total_threads} = $conf->{node}{$node}{hardware}{total_node_threads};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res. total threads: [$conf->{resources}{total_threads}]\n");
		}
		
		# Record the VG info. I only record the first node I see as I
		# only care about clustered VGs and they are, by definition,
		# identical.
		foreach my $vg (sort {$a cmp $b} keys %{$conf->{node}{$node}{hardware}{lvm}{vg}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VG: [$vg], clustered: [$conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{clustered}], size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{size}], used: [$conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{used_space}], free: [$conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{free_space}], PV: [$conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{pv_name}]\n");
			$conf->{resources}{vg}{$vg}{clustered}  = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{clustered}  if not $conf->{resources}{vg}{$vg}{clustered};
			$conf->{resources}{vg}{$vg}{pe_size}    = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{pe_size}    if not $conf->{resources}{vg}{$vg}{pe_size};
			$conf->{resources}{vg}{$vg}{total_pe}   = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{total_pe}   if not $conf->{resources}{vg}{$vg}{total_pe};
			$conf->{resources}{vg}{$vg}{pe_size}    = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{pe_size}    if not $conf->{resources}{vg}{$vg}{pe_size};
			$conf->{resources}{vg}{$vg}{size}       = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{size}       if not $conf->{resources}{vg}{$vg}{size};
			$conf->{resources}{vg}{$vg}{used_pe}    = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{used_pe}    if not $conf->{resources}{vg}{$vg}{used_pe};
			$conf->{resources}{vg}{$vg}{used_space} = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{used_space} if not $conf->{resources}{vg}{$vg}{used_space};
			$conf->{resources}{vg}{$vg}{free_pe}    = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{free_pe}    if not $conf->{resources}{vg}{$vg}{free_pe};
			$conf->{resources}{vg}{$vg}{free_space} = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{free_space} if not $conf->{resources}{vg}{$vg}{free_space};
			$conf->{resources}{vg}{$vg}{pv_name}    = $conf->{node}{$node}{hardware}{lvm}{vg}{$vg}{pv_name}    if not $conf->{resources}{vg}{$vg}{pv_name};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VG: [$vg], clustered: [$conf->{resources}{vg}{$vg}{clustered}], size: [$conf->{resources}{vg}{$vg}{size}], used: [$conf->{resources}{vg}{$vg}{used_space}], free: [$conf->{resources}{vg}{$vg}{free_space}], PV: [$conf->{resources}{vg}{$vg}{pv_name}]\n");
		}
	}
	
	# If both nodes have a given daemon down, then some data may be
	# unavailable. This saves logic when such checks are needed.
	my $this_cluster = $conf->{cgi}{cluster};
	my $node1 = $conf->{'system'}{cluster}{node1_name};
	my $node2 = $conf->{'system'}{cluster}{node2_name};
	my $node1_long = $conf->{node}{$node1}{info}{host_name};
	my $node2_long = $conf->{node}{$node2}{info}{host_name};
	$conf->{'system'}{gfs2_down} = 0;
	if (($conf->{node}{$node1}{daemon}{gfs2}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{gfs2}{exit_code} ne "0"))
	{
		$conf->{'system'}{gfs2_down} = 1;
	}
	$conf->{'system'}{clvmd_down} = 0;
	if (($conf->{node}{$node1}{daemon}{clvmd}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{clvmd}{exit_code} ne "0"))
	{
		$conf->{'system'}{clvmd_down} = 1;
	}
	$conf->{'system'}{drbd_down} = 0;
	if (($conf->{node}{$node1}{daemon}{drbd}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{drbd}{exit_code} ne "0"))
	{
		$conf->{'system'}{drbd_down} = 1;
	}
	$conf->{'system'}{rgmanager_down} = 0;
	if (($conf->{node}{$node1}{daemon}{rgmanager}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{rgmanager}{exit_code} ne "0"))
	{
		$conf->{'system'}{rgmanager_down} = 1;
	}
	$conf->{'system'}{cman_down} = 0;
	if (($conf->{node}{$node1}{daemon}{cman}{exit_code} ne "0") && ($conf->{node}{$node2}{daemon}{cman}{exit_code} ne "0"))
	{
		$conf->{'system'}{cman_down} = 1;
	}
	
	# I want to map storage service to nodes for the "Withdraw" buttons.
# 	foreach my $service (sort {$a cmp $b} keys %{$conf->{service}})
# 	{
# 		#record($conf, "$THIS_FILE ".__LINE__."; service: [$service]\n");
# 		my $service_host  = $conf->{service}{$service}{host};
# 		my $service_state = $conf->{service}{$service}{'state'};
# 		next if $service !~ /storage/;
# 		#record($conf, "$THIS_FILE ".__LINE__."; service_host: [$service_host], service_state: [$service_state]\n");
# 
# 		my $short_host_name =  $service_host;
# 		   $short_host_name =~ s/\..*?//;
# 		#record($conf, "$THIS_FILE ".__LINE__."; short_host_name: [$short_host_name]\n");
# 		#record($conf, "$THIS_FILE ".__LINE__."; node1:           [$conf->{node}{$node1}{info}{short_host_name}]\n");
# 		#record($conf, "$THIS_FILE ".__LINE__."; node2:           [$conf->{node}{$node2}{info}{short_host_name}]\n");
# 		if ($short_host_name eq $conf->{node}{$node1}{info}{short_host_name})
# 		{
# 			$conf->{node}{$node1}{storage_service_name}  = $service;
# 			$conf->{node}{$node1}{storage_service_state} = $service_state;
# 			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node1], storage service: [$conf->{node}{$node1}{storage_service_name}], state: [$conf->{node}{$node1}{storage_service_state}]\n");
# 		}
# 		elsif ($short_host_name eq $conf->{node}{$node2}{info}{short_host_name})
# 		{
# 			$conf->{node}{$node2}{storage_service_name}  = $service;
# 			$conf->{node}{$node2}{storage_service_state} = $service_state;
# 			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node1], storage service: [$conf->{node}{$node2}{storage_service_name}], state: [$conf->{node}{$node2}{storage_service_state}]\n");
# 		}
# 	}

	return (0);
}

# This sorts out some values once the parsing is collected.
sub post_node_calculations
{
	my ($conf, $node) = @_;
	
	# If I have no $conf->{node}{$node}{hardware}{total_memory} value, use the 'meminfo' size.
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], hardware total memory: [$conf->{node}{$node}{hardware}{total_memory}], meminfo total memory: [$conf->{node}{$node}{hardware}{meminfo}{memtotal}]\n");
	#if ((not $conf->{node}{$node}{hardware}{total_memory}) || ($conf->{node}{$node}{hardware}{total_memory} > $conf->{node}{$node}{hardware}{meminfo}{memtotal}))
	if (not $conf->{node}{$node}{hardware}{total_memory})
	{
		$conf->{node}{$node}{hardware}{total_memory} = $conf->{node}{$node}{hardware}{meminfo}{memtotal};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	}
	
	return (0);
}

# This takes a large number and inserts commas every three characters left of
# the decimal place. This method doesn't take a parameter hash reference.
sub comma
{
	my ($conf, $number) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; >> comma(); number: [$number]\n");
	
	# Return if nothing passed.
	return undef if not defined $number;

	# Strip out any existing commas.
	$number =~ s/,//g;
	$number =~ s/^\+//g;
	#record($conf, "$THIS_FILE ".__LINE__."; 1. number: [$number]\n");

	# Split on the left-most period.
	my ($whole, $decimal) = split/\./, $number, 2;
	#record($conf, "$THIS_FILE ".__LINE__."; >> whole: [$whole], decimal: [$decimal]\n");
	$whole   = "" if not defined $whole;
	$decimal = "" if not defined $decimal;
	#record($conf, "$THIS_FILE ".__LINE__."; << whole: [$whole], decimal: [$decimal]\n");

	# Now die if either number has a non-digit character in it.
	if (($whole =~ /\D/) || ($decimal =~ /\D/))
	{
		my $message = "The number: [$number] passed into the 'AN::Tools::Readable' module's 'comma' method contains a non-digit character or too many decimals.";
		error($conf, $message, 1);
	}

	local($_) = $whole ? $whole : "";

	1 while s/^(-?\d+)(\d{3})/$1,$2/;
	$whole = $_;

	my $return = $decimal ? "$whole.$decimal" : $whole;

	#record($conf, "$THIS_FILE ".__LINE__."; << comma(); number: [$number]\n");
	return ($return);
}

# This takes a raw number of bytes and returns a base-2 human-readible value.
# Takes a raw number of bytes (whole integer).
sub bytes_to_hr
{
	my ($conf, $size) = @_;

	# Expand exponential numbers.
	if ($size =~ /(\d+)e\+(\d+)/)
	{
		my $base = $1;
		my $exp  = $2;
		$size    = $base;
		for (1..$exp)
		{
			$size .= "0";
		}
	}

	# Setup my variables.
	my $suffix  = "";
	my $hr_size = $size;

	# Store and strip the sign
	my $sign = "";
	if ( $hr_size =~ /^-/ )
	{
		$sign    =  "-";
		$hr_size =~ s/^-//;
	}
	$hr_size =~ s/,//g;
	$hr_size =~ s/^\+//g;

	# Die if either the 'time' or 'float' has a non-digit character in it.  
	if ($hr_size =~ /\D/)
	{
		my $message = "The passed byte size: [$size] contains an illegal value. Byte sizes can only be signed integers. It may also have commas in it which will be removed automatically.";
		error($conf, $message, 1);
	}
	
	# Do the math.
	if ( $hr_size >= (2 ** 80) )
	{
		# Yebibyte
		$hr_size = sprintf("%.3f", ($hr_size /= (2 ** 80)));
		$hr_size = comma($conf, $hr_size);
		$suffix  = "YiB";
	}
	elsif ( $hr_size >= (2 ** 70) )
	{
		# Zebibyte
		$hr_size = sprintf("%.3f", ($hr_size /= (2 ** 70)));
		$suffix  = "ZiB";
	}
	elsif ( $hr_size >= (2 ** 60) )
	{
		# Exbibyte
		$hr_size = sprintf("%.3f", ($hr_size /= (2 ** 60)));
		$suffix  = "EiB";
	}
	elsif ( $hr_size >= (2 ** 50) )
	{
		# Pebibyte
		$hr_size = sprintf("%.3f", ($hr_size /= (2 ** 50)));
		$suffix  = "PiB";
	}
	elsif ( $hr_size >= (2 ** 40) )
	{
		# Tebibyte
		$hr_size = sprintf("%.2f", ($hr_size /= (2 ** 40)));
		$suffix  = "TiB";
	}
	elsif ( $hr_size >= (2 ** 30) )
	{
		# Gibibyte
		$hr_size = sprintf("%.2f", ($hr_size /= (2 ** 30)));
		$suffix  = "GiB";
	}
	elsif ( $hr_size >= (2 ** 20) )
	{
		# Mebibyte
		$hr_size = sprintf("%.2f", ($hr_size /= (2 ** 20)));
		$suffix  = "MiB";
	}
	elsif ( $hr_size >= (2 ** 10) )
	{
		# Kibibyte
		$hr_size = sprintf("%.1f", ($hr_size /= (2 ** 10)));
		$suffix  = "KiB";
	}
	else
	{
		### TODO: I don't know why, but $hr_size is being set to "" 
		###       when comma() returns 0. Fix this.
		#record($conf, "$THIS_FILE ".__LINE__."; >> bytes_to_hr; hr_size: [$hr_size]\n");
		$hr_size = comma($conf, $hr_size);
		$hr_size = 0 if $hr_size eq "";
		#record($conf, "$THIS_FILE ".__LINE__."; << bytes_to_hr; hr_size: [$hr_size]\n");
		$suffix  = "bytes";
	}

	# Restore the sign.
	if ( $sign eq "-" )
	{
		$hr_size = $sign.$hr_size;
	}
	$hr_size .= " $suffix";

	return($hr_size);
}

# This takes a "human readable" size with an ISO suffix and converts it back to
# a base byte size as accurately as possible.
sub hr_to_bytes
{
	my ($conf, $size, $type, $use_base2) = @_;
	# use_base2 will be set automatically *if* not passed by the caller.
	
	$size    =~ s/ //g;
	$type    =~ s/ //g;
	#record($conf, "$THIS_FILE ".__LINE__."; size: [$size], type: [$type], use_base2: [$use_base2]\n");
	
	# Store and strip the sign
	my $sign = "";
	if ( $size =~ /^-/ )
	{
		$sign =  "-";
		$size =~ s/^-//;
	}
	$size =~ s/,//g;
	$size =~ s/^\+//g;
	
	# If I don't have a passed type, see if there is a letter or letters
	# after the size to hack off.
	if ((not $type) && ($size =~ /[a-zA-Z]$/))
	{
		($size, $type) = ($size =~ /^(.*\d)(\D+)/);
	}
	$type = lc($type);
	#record($conf, "$THIS_FILE ".__LINE__."; size: [$size], type: [$type], use_base2: [$use_base2]\n");
	
	# Make sure that 'size' is now an integer or float.
	if ($size !~ /\d+[\.\d+]?/)
	{
		my $line = __LINE__;
		print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_bad\">
			Error in <span class=\"code\">hr_to_bytes()</span>
		</td>
	</tr>
	<tr>
		<td>
			The passed byte size: [<span class=\"code\">$size</span>] in the string: [sign: <span class=\"code\">$sign</span>, size: <span class=\"code\">$size</span>, type: <span class=\"code\">$type</span>] contains an illegal value.<br />
			Sizes can only be integers or real numbers. It may also have commas in it which will be removed automatically.<br />
			This is probably a program error ($THIS_FILE, line $line)<br />
		</td>
	</tr>
</table>
<br />
";
		return (undef);
	}

	# If 'type' is still blank, set it to 'b'.
	$type = "b" if not $type;
	
	# If the "type" is "Xib", make sure we're running in Base2 notation.
	# Conversly, if the type is "Xb", make sure that we're running in
	# Base10 notation. In either case, shorten the 'type' to just the first
	# letter to make the next sanity check simpler.
	if ($type =~ /^(\w)ib$/)
	{
		# Make sure we're running in Base2.
		$use_base2 = 1 if not defined $use_base2;
		$type      = $1;
	}
	elsif ($type =~ /^(\w)b$/)
	{
		# Make sure we're running in Base2.
		$use_base2 = 0 if not defined $use_base2;
		$type      = $1;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; size: [$size], type: [$type], use_base2: [$use_base2]\n");
	
	# Check if we have a valid '$type' and that 'Math::BigInt' is loaded,
	# if the size is big enough to require it.
	if (( $type eq "p" ) || ( $type eq "e" ) || ( $type eq "z" ) || ( $type eq "y" ))
	{
		# If this is a big size needing "Math::BigInt", check if it's loaded
		# yet and load it, if not.
		record($conf, "$THIS_FILE ".__LINE__."; Large number, loading Math::BigInt.\n");
		use Math::BigInt;
	}
	elsif (( $type ne "t" ) && ( $type ne "g" ) && ( $type ne "m" ) && ( $type ne "k" ))
	{
		# If we're here, we didn't match one of the large sizes or any
		# of the other sizes, so die.
		my $line = __LINE__;
		print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_bad\">
			Error in <span class=\"code\">hr_to_bytes()</span>
		</td>
	</tr>
	<tr>
		<td>
			The passed: [size: <span class=\"code\">$size</span>, type: <span class=\"code\">$type</span>] is not recognized.<br />
			Either an invalid size type was passed or I failed to properly parse the size type.<br />
			Valid size types are: '<span class=\"code\">b</span>', '<span class=\"code\">k</span>', '<span class=\"code\">m</span>', '<span class=\"code\">g</span>', '<span class=\"code\">t</span>', '<span class=\"code\">p</span>', '<span class=\"code\">e</span>', '<span class=\"code\">z</span>' or '<span class=\"code\">y</span>'.<br />
			This is probably a program error ($THIS_FILE, line $line)<br />
		</td>
	</tr>
</table>
<br />
";
		return (undef);
	}
	
	# Now the magic... lame magic, true, but still.
	my $bytes;
	if ($use_base2)
	{
		#record($conf, "$THIS_FILE ".__LINE__."; << type: [$type], size:  [$size].\n");
		if ( $type eq "y" ) { $bytes=Math::BigInt->new('2')->bpow('80')->bmul($size); }		# Yobibyte
		elsif ( $type eq "z" ) { $bytes=Math::BigInt->new('2')->bpow('70')->bmul($size); }	# Zibibyte
		elsif ( $type eq "e" ) { $bytes=Math::BigInt->new('2')->bpow('60')->bmul($size); }	# Exbibyte
		elsif ( $type eq "p" ) { $bytes=Math::BigInt->new('2')->bpow('50')->bmul($size); }	# Pebibyte
		elsif ( $type eq "t" ) { $bytes=($size*(2**40)) }					# Tebibyte
		elsif ( $type eq "g" ) { $bytes=($size*(2**30)) }					# Gibibyte
		elsif ( $type eq "m" ) { $bytes=($size*(2**20)) }					# Mebibyte
		elsif ( $type eq "k" ) { $bytes=($size*(2**10)) }					# Kibibyte
		#record($conf, "$THIS_FILE ".__LINE__."; >> type: [$type], bytes: [$bytes].\n");
	}
	else
	{
		if ( $type eq "y" ) { $bytes=Math::BigInt->new('10')->bpow('24')->bmul($size); }	# Yottabyte
		elsif ( $type eq "z" ) { $bytes=Math::BigInt->new('10')->bpow('21')->bmul($size); }	# Zettabyte
		elsif ( $type eq "e" ) { $bytes=Math::BigInt->new('10')->bpow('18')->bmul($size); }	# Exabyte
		elsif ( $type eq "p" ) { $bytes=Math::BigInt->new('10')->bpow('15')->bmul($size); }	# Petabyte
		elsif ( $type eq "t" ) { $bytes=($size*(10**12)) }					# Terabyte
		elsif ( $type eq "g" ) { $bytes=($size*(10**9)) }					# Gigabyte
		elsif ( $type eq "m" ) { $bytes=($size*(10**6)) }					# Megabyte
		elsif ( $type eq "k" ) { $bytes=($size*(10**3)) }					# Kilobyte
	}
	
	# Last, round off the byte size if it's a float.
	if ( $bytes =~ /\./ )
	{
		$bytes =~ s/\..*$//;
	}
	
	return ($sign.$bytes);
}

# This tries to ping a node given it's name. If it doesn't answer, it tries 
# again after adding/subtracting the '.remote' suffix. If that works, it will
# change the node name.
sub ping_node
{
	my ($conf, $node) = @_;
	
	my $exit;
	my $fh = IO::Handle->new;
	my $sc = "$conf->{path}{ping} -c 1 $node; echo ping:\$?";
	record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^ping:(\d+)/)
		{
			$exit = $1;
		}
	}
	$fh->close();
	record($conf, "$THIS_FILE ".__LINE__."; exit: [$exit]\n");
	
	if ($exit)
	{
		my $old_node = $node;
		if ($node =~ /\.remote/)
		{
			$node =~ s/\.remote//;
		}
		else
		{
			$node .= ".remote";
		}
		my $sc = "$conf->{path}{ping} -c 1 $node; echo ping:\$?";
		record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc], error was: $!\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /^ping:(\d+)/)
			{
				$exit = $1;
			}
		}
		$fh->close();
		record($conf, "$THIS_FILE ".__LINE__."; exit: [$exit]\n");
		
		if ($exit)
		{
			record($conf, "$THIS_FILE ".__LINE__."; Unable to ping the node: [$old_node] at alternate name: [$node]\n");
			$node = $old_node;
		}
		else
		{
			record($conf, "$THIS_FILE ".__LINE__."; The node: [$old_node] appears to be available at: [$node], renaming.\n");
		}
	}
	else
	{
		record($conf, "$THIS_FILE ".__LINE__."; The node: [$node] is ping-able.\n");
	}
	
	record($conf, "$THIS_FILE ".__LINE__."; Returning node: [$node].\n");
	return ($node);
}

# This does the actual call out to get the data and parse the returned data.
sub gather_node_details
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in gather_node_details() for node: [$node]\n");
	
	# This will flip true if I see 'start dmidecode' (the first line to
	# return from the client).
	$conf->{node}{$node}{connected}      = 0;
	$conf->{node}{$node}{info}{'state'}  = "<span class=\"highlight_unavailable\">Unknown</span>";
	$conf->{node}{$node}{info}{note}     = "";
	$conf->{node}{$node}{up}             = 0;
	$conf->{node}{$node}{enable_poweron} = 0;
	
	# Check to see if I can ping the nodes as they're named.
	#($node) = ping_node($conf, $node);
	
	# I echo 'start purpose:' before each call so that I know for
	# sure when I am switching between shell calls.
	my $sc =  "$conf->{path}{ssh} -o ConnectTimeout=10 root\@$node \"";
	   $sc .= "echo \\\"start dmidecode:\\\"; dmidecode -t 4,16,17; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start meminfo:\\\"; cat /proc/meminfo; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start drbd-status:\\\"; drbdadm status; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start drbd-res-file:\\\"; cat /etc/drbd.d/r?.res; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start clustat:\\\"; clustat; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start cluster.conf:\\\"; cat /etc/cluster/cluster.conf; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start daemons:\\\"; ";
	   $sc .= "/etc/init.d/rgmanager status; echo an-sve:rgmanager:\\\$?; ";
	   $sc .= "/etc/init.d/cman status; echo an-sve:cman:\\\$?; ";
	   $sc .= "/etc/init.d/drbd status; echo an-sve:drbd:\\\$?; ";
	   $sc .= "/etc/init.d/clvmd status; echo an-sve:clvmd:\\\$?; ";
	   $sc .= "/etc/init.d/gfs2 status; echo an-sve:gfs2:\\\$?; ";
	   $sc .= "/etc/init.d/libvirtd status; echo an-sve:libvirtd:\\\$?; ";
	   $sc .= "echo \\\"lvm-scan start:\\\"; pvscan; vgscan; lvscan; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"lvm-data start:\\\"; ";
	   $sc .= "pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid; ";
	   $sc .= "vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name; ";
	   $sc .= "lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices; ";
	   $sc .= "echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start gfs2:\\\"; cat /etc/fstab | grep gfs2 && df -hP; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start virsh:\\\"; virsh list --all; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start vm defs:\\\"; cat /shared/definitions/*; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond0:\\\"; cat /proc/net/bonding/bond0; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond1:\\\"; cat /proc/net/bonding/bond1; echo \\\"#!end!#\\\"; ";
	   $sc .= "echo \\\"start bond2:\\\"; cat /proc/net/bonding/bond2; echo \\\"#!end!#\\\"; ";
	   $sc .= "\"";
	   #$sc = "./data_${node}.txt";
	# These keep track of where I am.
	my $in_dmidecode     = 0;
	my $in_meminfo       = 0;
	my $in_drbd_status   = 0;
	my $in_drbd_res_file = 0;
	my $in_clustat       = 0;
	my $in_cluster_conf  = 0;
	my $in_daemons       = 0;
	my $in_lvm_scan      = 0;
	my $in_lvm_data      = 0;
	my $in_gfs2          = 0;
	my $in_virsh         = 0;
	my $in_vm_defs       = 0;
	my $in_bond          = 0;
	
	# This is used to track the bond I am reading.
	my $bond = "";
	
	# These store the data read.
	my @dmidecode;
	my @meminfo;
	my @drbd_status;
	my @drbd_res_file;
	my @clustat;
	my @cluster_conf;
	my @daemons;
	my @lvm_scan;
	my @lvm_data;
	my @gfs2;
	my @virsh;
	my @vm_defs;
	my @bond;
	
	# If I run into a long string of @, I need to read the next line to see
	# what ssh is complaining about.
	my $read_next = 0;
	
	### NOTE: This is over 1 KiB long and causes some IDEs, like 'kate', to
	### flip the file into read-only mode. Enable only when needed.
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	my $raw;
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	#open ($fh, "<$sc") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		#$raw .= $_;
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], read_next: [$read_next], line: [$line]\n");
		
		# If I was asked to read the next line, I am dead but I need
		# details.
		if ($read_next)
		{
			if ($line =~ /UNPROTECTED PRIVATE KEY FILE/)
			{
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />It appears that there is a file permission issue in the dashboard.<br />The server's <span class=\"fixed_width\">$conf->{'system'}{username}</span> user's <span class=\"fixed_width\">~/.ssh/id_rsa</span> file is bad.<br />Please set the permissions to <span class=\"fixed_width\">600</span> (only readable by <span class=\"fixed_width\">$conf->{'system'}{username}</span>).<br />Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a> if you would like assistance with this issue.";
				set_daemons($conf, $node, "Unknown", "highlight_unavailable");
				record($conf, "$THIS_FILE ".__LINE__."; Note: [$conf->{node}{$node}{info}{note}]\n");
				last;
			}
			else
			{
				record($conf, "$THIS_FILE ".__LINE__."; Other issue.\n");
				$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">No Access!</span>";
				$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. It appears that the node has changed!<br />If this node failed and was replaced, be sure to remove the old key from <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file.<br />If the node has not been replaced, then someone might be trying to trick you into logging into it.";
				record($conf, "$THIS_FILE ".__LINE__."; Note: [$conf->{node}{$node}{info}{note}]\n");
				last;
			}
		}
		
		# This catches connectivity problems.
		if ($line =~ /No route to host/i)
		{
			my $local_access = on_same_network($conf, $node);
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">No Access</span>";
			if ($local_access)
			{
				$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. It is on an accessible subnet, so the node is likely off or there is a network problem.";
			}
			else
			{
				$conf->{node}{$node}{info}{note} = "Unable to connect to <span class=\"fixed_width\">$node</span>. The server running AN!CDB is not currently on the same subnet as the node.";
			}
			last;
		}
		elsif ($line =~ /host key verification failed/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Verification Failed!</span>";
			$conf->{node}{$node}{info}{note}    = "SSH host key validation failed.<br />Have you saved <span class=\"fixed_width\">${node}</span>'s fingerprint in <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/known_hosts</span> file?<br />If this is a new issue, the physical node may have changed, requiring the old fingerprint be deleted and the new fingerprint be saved.<br />If the machine has not changed, then this might be a sign of an attempt to intercept your connection to the node.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /could not resolve hostname/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Bad Hostname!</span>";
			$conf->{node}{$node}{info}{note}    = "Could not resolve the hostname: <span class=\"fixed_width\">$node</span>. Have you setup your <span class=\"fixed_width\">/etc/hosts</span> file or DNS server properly?";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /permission denied/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Permission Denied!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>. Have you added <span class=\"fixed_width\">$conf->{'system'}{username}</span>'s <span class=\"fixed_width\">~/.ssh/id_rsa.pub</span> public key to <span class=\"fixed_width\">$node</span>'s <span class=\"fixed_width\">/root/.ssh/authorized_keys</span> file? If so, check <span class=\"fixed_width\">/var/log/secure</span> on <span class=\"fixed_width\">$node</span> for errors.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /connection refused/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Refused!</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />Either it is refusing incoming connections or this machine does not have access to the node's subnet.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /Connection timed out/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Connection Timed Out</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The connection timed out.";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /Network is unreachable/i)
		{
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_bad\">Network Unreachable</span>";
			$conf->{node}{$node}{info}{note}    = "I could not log into: <span class=\"fixed_width\">$node</span>.<br />The network is not reachable. Is this machine hosting this program on the same subnet?";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
			last;
		}
		elsif ($line =~ /\@\@\@\@/)
		{
			# When the host-key fails to match, a box made
			# of '@@@@' is displayed, and is the entire 
			# first line.
			$read_next = 1;
			next;
		}
		
		# Catch the end of sections
		if ($line =~ /#!end!#/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; end\n");
			$in_dmidecode    = 0;
			$in_meminfo      = 0;
			$in_drbd_status  = 0;
			$in_clustat      = 0;
			$in_cluster_conf = 0;
			$in_daemons      = 0;
			$in_lvm_scan     = 0;
			$in_lvm_data     = 0;
			$in_gfs2         = 0;
			$in_virsh        = 0;
			$in_vm_defs      = 0;
			$in_bond         = 0;
			$bond            = "";
		}
		#if ($line =~ /^start (.*?):/) { record($conf, "$THIS_FILE ".__LINE__."; start: [$line]\n"); }
		
		# Figure out where I am.
		if ($line =~ /^start dmidecode:/)
		{
			$conf->{node}{$node}{connected}     = 1;
			$in_dmidecode                       = 1;
			$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_good\">Up!</span>";
			next;
		}
		if ($line =~ /^start meminfo:/)       { $in_meminfo       = 1; next; }
		if ($line =~ /^start drbd-status:/)   { $in_drbd_status   = 1; next; }
		if ($line =~ /^start drbd-res-file:/) { $in_drbd_res_file = 1; next; }
		if ($line =~ /^start clustat:/)       { $in_clustat       = 1; next; }
		if ($line =~ /^start cluster.conf:/)  { $in_cluster_conf  = 1; next; }
		if ($line =~ /^start daemons:/)       { $in_daemons       = 1; next; }
		if ($line =~ /^lvm-scan start:/)      { $in_lvm_scan      = 1; next; }
		if ($line =~ /^lvm-data start:/)      { $in_lvm_data      = 1; next; }
		if ($line =~ /^start gfs2:/)          { $in_gfs2          = 1; next; }
		if ($line =~ /^start virsh:/)         { $in_virsh         = 1; next; }
		if ($line =~ /^start vm defs:/)       { $in_vm_defs       = 1; next; }
		if ($line =~ /^start vm defs:/)       { $in_vm_defs       = 1; next; }
		if ($line =~ /^start bond(\d+):/)
		{
			$bond       = $1;
			$in_vm_defs = 1;
			next;
		}
		
		# If I am in a section, push the lines into the
		# appropriate array.
		if ($in_dmidecode)     { push @dmidecode,     $line; }
		if ($in_meminfo)       { push @meminfo,       $line; }
		if ($in_drbd_status)   { push @drbd_status,   $line; }
		if ($in_drbd_res_file) { push @drbd_res_file, $line; }
		if ($in_clustat)       { push @clustat,       $line; }
		if ($in_cluster_conf)  { push @cluster_conf,  $line; }
		if ($in_daemons)       { push @daemons,       $line; }
		if ($in_lvm_scan)      { push @lvm_scan,      $line; }
		if ($in_lvm_data)      { push @lvm_data,      $line; }
		if ($in_gfs2)          { push @gfs2,          $line; }
		if ($in_virsh)         { push @virsh,         $line; }
		if ($in_vm_defs)       { push @vm_defs,       $line; }
		if ($in_bond)
		{
			push @bond, "$bond:$line";
		}
	}
	$fh->close();
	#record($conf, "$THIS_FILE ".__LINE__."; raw $node:\n===========================\n$raw\n===========================\n");
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], connected: [$conf->{node}{$node}{connected}], state: [$conf->{node}{$node}{info}{'state'}], note: [$conf->{node}{$node}{info}{note}]\n");
	if ($conf->{node}{$node}{connected})
	{
		$conf->{'system'}{show_nodes} = 1;
		$conf->{node}{$node}{up}      = 1;
		push @{$conf->{up_nodes}}, $node;
		parse_dmidecode    ($conf, $node, \@dmidecode);
		parse_meminfo      ($conf, $node, \@meminfo);
		parse_drbd_status  ($conf, $node, \@drbd_status);
		parse_drbd_res_file($conf, $node, \@drbd_res_file);
		parse_clustat      ($conf, $node, \@clustat);
		parse_cluster_conf ($conf, $node, \@cluster_conf);
		parse_daemons      ($conf, $node, \@daemons);
		parse_lvm_scan     ($conf, $node, \@lvm_scan);
		parse_lvm_data     ($conf, $node, \@lvm_data);
		parse_gfs2         ($conf, $node, \@gfs2);
		parse_virsh        ($conf, $node, \@virsh);
		parse_vm_defs      ($conf, $node, \@vm_defs);
		parse_bonds        ($conf, $node, \@bond);
		# Some stuff, like setting the system memory, needs some
		# post-scan math.
		post_node_calculations($conf, $node);
	}
	else
	{
		check_if_on($conf, $node);
		record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
		if ($conf->{node}{$node}{is_on} == 0)
		{
			$conf->{'system'}{show_nodes}         = 1;
			$conf->{node}{$node}{enable_poweron}  = 1;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{enable_fence}    = 0;
			#$conf->{node}{$node}{info}{'state'} = "<span class=\"highlight_warning\">Powered Off</span>";
			#$conf->{node}{$node}{info}{note}    = "The node <span class=\"fixed_width\">$node</span> is powered down.";
		}
		elsif ($conf->{node}{$node}{is_on} == 1)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 1;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 1;
			# Disable poweroff if I wasn't able to SSH into the
			# node.
			if (not $conf->{node}{$node}{connected})
			{
				$conf->{node}{$node}{enable_poweroff} = 0;
			}
			$conf->{node}{$node}{enable_fence}    = 1;
			if ((not $conf->{node}{$node}{info}{'state'}) or (not $conf->{node}{$node}{info}{note}))
			{
				$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">No Access</span>";
				$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, but it is reported as being powered on.<br />If you just powered on this system, please wait a moment for it to boot.<br />If you just powered off this node, it might still be shutting down.<br /> Otherwise, the node may have crashed.";
			}
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		elsif ($conf->{node}{$node}{is_on} == 2)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 0;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">Inaccesible</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />The out of band management interface's address, user name or password may have changed since it was last cached.<br />Please manually check the Anvil's cluster and update the cluster's fencing information if needed.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		elsif ($conf->{node}{$node}{is_on} == 3)
		{
			# The node is on but unreachable.
			$conf->{'system'}{show_nodes}         = 0;
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">Inaccesible</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />The machine running the dashboard is not on the same subnet as the out of band management, so the node's current state is unknown.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		else
		{
			# Unable to determine node state.
			$conf->{node}{$node}{enable_poweron}  = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
			$conf->{node}{$node}{enable_fence}    = 0;
			$conf->{node}{$node}{info}{'state'}   = "<span class=\"highlight_warning\">No Access</span>";
			$conf->{node}{$node}{info}{note}      = "I was unable to talk to: <span class=\"fixed_width\">$node</span>, nor can I contact it's out of band management interface to determine it's current power state.<br />Please check the network connections between this machine and the nodes.<br />If the power feeding the node was cut at the PDUs, fencing the node may restore access.<br />";
			set_daemons($conf, $node, "Unknown", "highlight_unavailable");
		}
		
		# If I have confirmed the node is powered off, don't display this.
		#record($conf, "$THIS_FILE ".__LINE__."; enable power on: [$conf->{node}{$node}{enable_poweron}], task: [$conf->{cgi}{task}]\n");
		if ((not $conf->{node}{$node}{enable_poweron}) && (not $conf->{cgi}{task}))
		{
			print "
<table align=\"center\">
	<tr>
		<td>
			$conf->{node}{$node}{info}{'state'}
		</td>
		<td>
			$conf->{node}{$node}{info}{note}
		</td>
	</tr>
</table>
<br />
";
		}
	}
	
	return (0);
}

# This parse bond data
sub parse_bonds
{
	my ($conf, $node, $array) = @_;
	
	
	return (0);
}

# This (tries to) parse the VM definitions files.
sub parse_vm_defs
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_vm_defs() for node: [$node]\n");
	my $this_vm    = "";
	my $in_domain  = 0;
	my $this_array = [];
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		# Find the start of a domain.
		if ($line =~ /<domain/)
		{
			$in_domain = 1;
		}
		
		# Get this name of the current domain
		if ($line =~ /<name>(.*?)<\/name>/)
		{
			$this_vm = $1;
		}
		
		# Push all lines into the current domain array.
		if ($in_domain)
		{
			push @{$this_array}, $line;
		}
		
		# When the end of a domain is found, push the array over to
		# $conf.
		if ($line =~ /<\/domain>/)
		{
			my $vm_key = "vm:$this_vm";
			#record($conf, "$THIS_FILE ".__LINE__."; vm: [$this_vm], array: [$this_array], lines: [".@{$this_array}."]\n");
			$conf->{vm}{$vm_key}{xml} = $this_array;
			$in_domain  = 0;
			$this_array = [];
		}
	}
	
	return (0);
}

# Parse the dmidecode data.
sub parse_dmidecode
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_dmidecode() for node: [$node]\n");
	#foreach my $line (@{$array}) { record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n"); }
	
	# Some variables I will need.
	my $in_cpu           = 0;
	my $in_system_ram    = 0;
	my $in_dimm_module   = 0;
	
	# On SMP machines, the CPU socket becomes important. This 
	# tracks which CPU I am looking at.
	my $this_socket      = "";
	
	# Same deal with volume groups.
	my $this_vg          = "";
	
	# RAM is all over the place, so I need to record all the bits
	# in strings and push to the hash when I see a blank line.
	my $dimm_locator     = "";
	my $dimm_bank        = "";
	my $dimm_size        = "";
	my $dimm_type        = "";
	my $dimm_speed       = "";
	my $dimm_form_factor = "";
	
	# This will be set to the values I find on this node.
	$conf->{node}{$node}{hardware}{total_node_cores}   = 0;
	$conf->{node}{$node}{hardware}{total_node_threads} = 0;
	$conf->{node}{$node}{hardware}{total_memory}       = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	
	# These will be set to the lowest available RAM, and CPU core
	# available.
	$conf->{resources}{total_cores}   = 0;
	$conf->{resources}{total_threads} = 0;
	$conf->{resources}{total_ram}     = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; Cluster; total cores: [$conf->{resources}{total_cores}], total threads: [$conf->{resources}{total_threads}], total memory: [$conf->{resources}{total_ram}]\n");
	
	foreach my $line (@{$array})
	{
		if ($line =~ /dmidecode: command not found/)
		{
			die "Unable to read system information on node: [$node]. Is 'dmidecode' installed?";
		}
		
		# Find out what I am looking at.
		if (not $line)
		{
			# Blank lines break sections.
			# If I had been reading DIMM info, push it into
			# the hash.
			if ($in_dimm_module)
			{
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{bank}        = $dimm_bank;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{size}        = $dimm_size;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{type}        = $dimm_type;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{speed}       = $dimm_speed;
				$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{form_factor} = $dimm_form_factor;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], dimm: [$dimm_locator], bank: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{bank}], size: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{size}], type: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{type}], speed: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{speed}], form factor: [$conf->{node}{$node}{hardware}{dimm}{$dimm_locator}{form_factor}]\n");
			}
			$in_cpu         = 0;
			$in_system_ram  = 0;
			$in_dimm_module = 0;
			$this_socket    = "";
			$this_vg        = "";
			next;
		}
		if ($line =~ /Processor Information/)
		{
			$in_cpu         = 1;
			next;
		}
		if ($line =~ /Physical Memory Array/)
		{
			$in_system_ram  = 1;
			next;
		}
		if ($line =~ /Memory Device/)
		{
			$in_dimm_module = 1;
			next;
		}
		if ((not $in_cpu) && (not $in_system_ram) && (not $in_dimm_module))
		{
			next;
		}
		
		# Now pull out data based on where I am.
		if ($in_cpu)
		{
			# The socket is the first line, so I can safely
			# assume that 'this_socket' will be populated
			# after this.
			if ($line =~ /Socket Designation: (.*)/)
			{
				$this_socket = $1;
				next;
			}
			
			# Grab some deets!
			if ($line =~ /Family: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{family}    = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu family: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{family}]\n");
			}
			if ($line =~ /Manufacturer: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{oem}       = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu oem: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{oem}]\n");
			}
			if ($line =~ /Version: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{version}   = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu version: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{version}]\n");
			}
			if ($line =~ /Max Speed: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{max_speed} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu max speed: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{max_speed}]\n");
			}
			if ($line =~ /Status: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{status}    = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], cpu status: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{status}]\n");
			}
			if ($line =~ /Core Count: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores} =  $1;
				$conf->{node}{$node}{hardware}{total_node_cores}         += $conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores};
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], socket cores: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{cores}], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}]\n");
			}
			if ($line =~ /Thread Count: (.*)/)
			{
				$conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads} =  $1;
				$conf->{node}{$node}{hardware}{total_node_threads}         += $conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads};
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], socket: [$this_socket], socket threads: [$conf->{node}{$node}{hardware}{cpu}{$this_socket}{threads}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}]\n");
			}
		}
		if ($in_system_ram)
		{
			# Not much in system RAM, but good to know stuff.
			if ($line =~ /Error Correction Type: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{ecc_support} = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], RAM ECC: [$conf->{node}{$node}{hardware}{ram}{ecc_support}]\n");
			}
			if ($line =~ /Number Of Devices: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{slots}       = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], RAM slots: [$conf->{node}{$node}{hardware}{ram}{slots}]\n");
			}
			# This needs to be converted to bytes.
			if ($line =~ /Maximum Capacity: (\d+) (.*)$/)
			{
				my $size   = $1;
				my $suffix = $2;
				$conf->{node}{$node}{hardware}{ram}{max_support} = hr_to_bytes($conf, $size, $suffix, 1);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], max. supported RAM: [$conf->{node}{$node}{hardware}{ram}{max_support}]\n");
			}
			if ($line =~ /Maximum Capacity: (.*)/)
			{
				$conf->{node}{$node}{hardware}{ram}{max_support} = $1;
				$conf->{node}{$node}{hardware}{ram}{max_support} = hr_to_bytes($conf, $conf->{node}{$node}{hardware}{ram}{max_support}, "", 1);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], max. supported RAM: [$conf->{node}{$node}{hardware}{ram}{max_support}]\n");
			}
		}
		if ($in_dimm_module)
		{
			if ($line =~ /Locator: (.*)/)      { $dimm_locator     = $1; }
			if ($line =~ /Bank Locator: (.*)/) { $dimm_bank        = $1; }
			if ($line =~ /Type: (.*)/)         { $dimm_type        = $1; }
			if ($line =~ /Speed: (.*)/)        { $dimm_speed       = $1; }
			if ($line =~ /Form Factor: (.*)/)  { $dimm_form_factor = $1; }
			if ($line =~ /Size: (.*)/)
			{
				$dimm_size = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size]\n");
				# If the DIMM couldn't be read, it will
				# show "Unknown". I set this to 0 in 
				# that case.
				if ($dimm_size !~ /^\d/)
				{
					$dimm_size = 0;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size]\n");
				}
				else
				{
					$dimm_size                                   =  hr_to_bytes($conf, $dimm_size, "", 1);
					$conf->{node}{$node}{hardware}{total_memory} += $dimm_size;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], DIMM Size: [$dimm_size], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
				}
			}
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], total cores: [$conf->{node}{$node}{hardware}{total_node_cores}], total threads: [$conf->{node}{$node}{hardware}{total_node_threads}], total memory: [$conf->{node}{$node}{hardware}{total_memory}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; Cluster; total cores: [$conf->{resources}{total_cores}], total threads: [$conf->{resources}{total_threads}], total memory: [$conf->{resources}{total_ram}]\n");
	return(0);
}

# Parse the memory information.
sub parse_meminfo
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_meminfo() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /MemTotal:\s+(.*)/)
		{
			$conf->{node}{$node}{hardware}{meminfo}{memtotal} = $1;
			$conf->{node}{$node}{hardware}{meminfo}{memtotal} = hr_to_bytes($conf, $conf->{node}{$node}{hardware}{meminfo}{memtotal}, "", 1);
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], meminfo total memory: [$conf->{node}{$node}{hardware}{meminfo}{memtotal}]\n");
		}
	}
	
	return(0);
}

# Parse the DRBD status.
sub parse_drbd_status
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_drbd_status() for node: [$node]\n");
	my $resources = 0;
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if $line !~ /^<resource /;
		$resources++;
		
		# Make sure I only display "unknown" or the read value.
		my $minor = "--";
		my $res   = "--";
		my $cs    = "--";
		my $ro    = "--";
		my $ds    = "--";
		my $dev   = "--";
		($minor) = ($line =~ /minor="(.*?)"/);
		($res)   = ($line =~ /name="(.*?)"/);
		($cs)    = ($line =~ /cs="(.*?)"/);
		($ro)    = ($line =~ /ro1="(.*?)"/);
		($ds)    = ($line =~ /ds1="(.*?)"/);
		$dev = "/dev/drbd$minor" if $minor =~ /^\d+$/;
		
		# This is the new way of recording.
		$conf->{drbd}{$res}{node}{$node}{minor}            = $minor ? $minor : "--";
		$conf->{drbd}{$res}{node}{$node}{connection_state} = $cs    ? $cs    : "--";
		$conf->{drbd}{$res}{node}{$node}{role}             = $ro    ? $ro    : "--";
		$conf->{drbd}{$res}{node}{$node}{disk_state}       = $ds    ? $ds    : "--";
		$conf->{drbd}{$res}{node}{$node}{device}           = $dev   ? $dev   : "--";
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], New - res: [$res], minor: [$conf->{drbd}{$res}{node}{$node}{minor}], cs: [$conf->{drbd}{$res}{node}{$node}{connection_state}], ro: [$conf->{drbd}{$res}{node}{$node}{role}], ds: [$conf->{drbd}{$res}{node}{$node}{disk_state}], dev: [$conf->{drbd}{$res}{node}{$node}{device}]\n");
	}
	if (not $resources)
	{
		# DRBD isn't running.
		#record($conf, "$THIS_FILE ".__LINE__."; DRBD does not appear to be running on node: [$node]\n");
	}
	
	return(0);
}

# This reads the DRBD resource details from the resource definition files.
sub parse_drbd_res_file
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_drbd_res_file() for node: [$node]\n");
	
	my $in_res      = "";
	my $in_on       = "";
	my $this_device = "--";
	
	my $resources = 0;
	foreach my $line (@{$array})
	{
		$line =~ s/#.*//;
		next if not $line;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		if ($line =~ /^resource (.*?) {/)
		{
			$in_res = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res]\n");
			next;
		}
		
		if ($in_res)
		{
			if ($line =~ /on (.*?) {/)
			{
				$in_on = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res], on: [$in_on]\n");
				next;
			}
			if ($in_on)
			{
				# I don't want the closing brace of an 
				# "on ... {" directive closing "in_res" early.
				if ($line eq "}")
				{
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], closing 'on': [$in_on]\n");
					$in_on = "";
					next;
				}
			}
			else
			{
				if ($line eq "}")
				{
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], closing 'res': [$in_res]\n");
					$conf->{node}{$node}{drbd}{res_file}{$in_res}{device}           = $this_device;
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{device}           = $this_device;
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{connection_state} = "--";
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{role}             = "--";
					$conf->{drbd}{$in_res}{node}{$node}{res_file}{disk_state}       = "--";
					
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], res: [$in_res], device: [$conf->{node}{$node}{drbd}{res_file}{$in_res}{device}]\n");
					$in_res      = "";
					$this_device = "--";
				}
				if ($line =~ /device\s+(.*?);/)
				{
					$this_device = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], device: [$this_device]\n");
				}
			}
		}
	}
	
	return(0);
}

# Parse the cluster status.
sub parse_clustat
{
	my ($conf, $node, $array) = @_;
	
	# Setup some variables.
	my $in_member  = 0;
	my $in_service = 0;
	my $line_num   = 0;
	
	my $host_name                         = "unknown";
	my $storage_name                      = "unknown";
	my $storage_state                     = "unknown";
	$conf->{node}{$node}{me}{cman}        = 0;
	$conf->{node}{$node}{me}{rgmanager}   = 0;
	$conf->{node}{$node}{peer}{cman}      = 0;
	$conf->{node}{$node}{peer}{rgmanager} = 0;
	$conf->{node}{$node}{enable_join}     = 0;
	$conf->{node}{$node}{get_host_from_cluster_conf} = 0;

	### NOTE: This check seems odd, but I've run intp cases where a node,
	###       otherwise behaving fine, simple returns nothing when cman is
	###       off. Couldn't reproduce on the command line.
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_clustat() for node: [$node]\n");
	my $line_count = @{$array};
	if (not $line_count)
	{
		# CMAN isn't running.
		record($conf, "$THIS_FILE ".__LINE__."; The cluster manager, cman, does not appear to be running on node: [$node] (nothing returned by the 'clustat' call).\n");
		$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
		$conf->{node}{$node}{enable_join}                = 1;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; Will parse: [$line_count] lines.\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Could not connect to CMAN/i)
		{
			# CMAN isn't running.
			#record($conf, "$THIS_FILE ".__LINE__."; CMAN does not appear to be running on node: [$node]\n");
			$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
			$conf->{node}{$node}{enable_join}                = 1;
		}
		next if not $line;
		next if $line =~ /^-/;
		
		if ($line =~ /^Member Name/)
		{
			$in_member  = 1;
			$in_service = 0;
			next;
		}
		elsif ($line =~ /^Service Name/)
		{
			$in_member  = 0;
			$in_service = 1;
			next;
		}
		if ($in_member)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			if ($line =~ /Local/)
			{
				($conf->{node}{$node}{me}{name}, undef, my $services) = (split/ /, $line, 3);
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - me: [$conf->{node}{$node}{me}{name}], services: [$services]\n");
				$services =~ s/local//;
				$services =~ s/ //g;
				$services =~ s/,,/,/g;
				$conf->{node}{$node}{me}{cman}      =  1 if $services =~ /Online/;
				$conf->{node}{$node}{me}{rgmanager} =  1 if $services =~ /rgmanager/;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - Me   -> [$conf->{node}{$node}{me}{name}]; cman: [$conf->{node}{$node}{me}{cman}], rgmanager: [$conf->{node}{$node}{me}{rgmanager}]\n");
			}
			else
			{
				($conf->{node}{$node}{peer}{name}, undef, my $services) = split/ /, $line, 3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - peer: [$conf->{node}{$node}{peer}{name}], services: [$services]\n");
				$services =~ s/ //g;
				$services =~ s/,,/,/g;
				$conf->{node}{peer}{cman}      = 1 if $services =~ /Online/;
				$conf->{node}{peer}{rgmanager} = 1 if $services =~ /rgmanager/;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - Peer -> [$conf->{node}{$node}{peer}{name}]; cman: [$conf->{node}{peer}{cman}], rgmanager: [$conf->{node}{peer}{rgmanager}]\n");
			}
		}
		elsif ($in_service)
		{
			if ($line =~ /^vm:/)
			{
				my ($vm, $host, $state) = split/ /, $line, 3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$host], state: [$state]\n");
				if (($state eq "disabled") || ($state eq "stopped"))
				{
					$host = "none";
				}
				if ($state eq "failed")
				{
					# Disable the VM.
					my $sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -d $vm\"";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						$line =~ s/^\s+//;
						$line =~ s/\s+$//;
						$line =~ s/\s+/ /g;
						record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					}
					$fh->close();
				}
				
				# If the service is disabled, it will 
				# have '()' which I need to remove.
				$host =~ s/\(//g;
				$host =~ s/\)//g;
				
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$host]\n");
				$host = "none" if not $host;
				$conf->{vm}{$vm}{host}    = $host;
				$conf->{vm}{$vm}{'state'} = $state;
				# TODO: If the state is "failed", call 
				# 'virsh list --all' against both nodes. If the
				# VM is found, try to recover the service.
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], host: [$conf->{vm}{$vm}{host}], state: [$conf->{vm}{$vm}{'state'}]\n");
				
				# Pick out who the peer node is.
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host: [$host], me: [$conf->{node}{$node}{me}{name}]\n");
				if ($host eq $conf->{node}{$node}{me}{name})
				{
					$conf->{vm}{$vm}{peer} = $conf->{node}{$node}{peer}{name};
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], peer: [$conf->{vm}{$vm}{peer}]\n");
				}
				else
				{
					$conf->{vm}{$vm}{peer} = $conf->{node}{$node}{me}{name};
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm: [$vm], peer: [$conf->{vm}{$vm}{peer}]\n");
				}
			}
			elsif ($line =~ /^service:(.*?)\s+(.*?)\s+(.*)$/)
			{
				my $name  = $1;
				my $host  = $2;
				my $state = $3;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name], host: [$host], state: [$state]\n");
				
				if ($state eq "failed")
				{
					# Disable the service and then call a
					# start against it.
					# Disable the VM.
					my $sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -d service:$name\"";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					my $fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						$line =~ s/^\s+//;
						$line =~ s/\s+$//;
						$line =~ s/\s+/ /g;
						record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					}
					$fh->close();
					sleep 5;
					$sc = "$conf->{path}{ssh} root\@$node \"clusvcadm -e service:$name\"";
					record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
					$fh = IO::Handle->new();
					open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
					while(<$fh>)
					{
						chomp;
						my $line = $_;
						$line =~ s/^\s+//;
						$line =~ s/\s+$//;
						$line =~ s/\s+/ /g;
						record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
					}
					$fh->close();
				}
				
				# If the service is disabled, it will 
				# have '()' which I need to remove.
				$host =~ s/\(//g;
				$host =~ s/\)//g;
				
				$conf->{service}{$name}{host}    = $host;
				$conf->{service}{$name}{'state'} = $state;
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name], host: [$conf->{service}{$name}{host}], state: [$conf->{service}{$name}{'state'}]\n");
			}
		}
	}
	
	# If this is set, the cluster isn't running.
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
	if (not $conf->{node}{$node}{get_host_from_cluster_conf})
	{
		$host_name = $conf->{node}{$node}{me}{name};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host name: [$host_name]\n");
		foreach my $name (sort {$a cmp $b} keys %{$conf->{service}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - service name: [$name]\n");
			next if $conf->{service}{$name}{host} ne $host_name;
			next if $name !~ /storage/;
			$storage_name  = $name;
			$storage_state = $conf->{service}{$name}{'state'};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - storage name: [$storage_name], storage state: [$storage_state]\n");
		}
		
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], host name: [$host_name]\n");
		if ($host_name)
		{
			$conf->{node}{$node}{info}{host_name}            =  $host_name;
			$conf->{node}{$node}{info}{short_host_name}      =  $host_name;
			$conf->{node}{$node}{info}{short_host_name}      =~ s/\..*$//;
			$conf->{node}{$node}{get_host_from_cluster_conf} = 0;
		}
		else
		{
			$conf->{node}{$node}{get_host_from_cluster_conf} = 1;
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
		$conf->{node}{$node}{info}{storage_name}    = $storage_name;
		$conf->{node}{$node}{info}{storage_state}   = $storage_state;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node] - host name: [$conf->{node}{$node}{info}{host_name}], short host name: [$conf->{node}{$node}{info}{short_host_name}], storage name: [$conf->{node}{$node}{info}{storage_name}], storage state: [$conf->{node}{$node}{info}{storage_state}]\n");
	}
	
	return(0);
}

# Parse the cluster configuration.
sub parse_cluster_conf
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_cluster_conf(); node: [$node]\n");
	
	my $in_fod          = 0;
	my $current_fod     = "";
	my $in_node         = "";
	my $in_fence        = 0;
	my $in_method       = "";
	my $device_count    = 0;
	my $in_fence_device = 0;
	my $this_host_name  = "";
	my $this_node       = "";
	my $method_counter  = 0;
	
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
		
		# Find failover domains.
		if ($line =~ /<failoverdomain /)
		{
			$current_fod = ($line =~ /name="(.*?)"/)[0];
			#record($conf, "$THIS_FILE ".__LINE__."; current_fod: [$current_fod]\n");
			$in_fod      = 1;
			next;
		}
		if ($line =~ /<\/failoverdomain>/)
		{
			$current_fod = "";
			$in_fod      = 0;
			next;
		}
		if ($in_fod)
		{
			next if $line !~ /failoverdomainnode/;
			my $node     = ($line =~ /name="(.*?)"/)[0];
			my $priority = ($line =~ /priority="(.*?)"/)[0] ? $1 : 0;
			$conf->{failoverdomain}{$current_fod}{priority}{$priority}{node} = $node;
			#record($conf, "$THIS_FILE ".__LINE__."; failover domain: [$current_fod], node: [$conf->{failoverdomain}{$current_fod}{priority}{$priority}{node}], priority: [$priority]\n");
		}
		
		# If I didn't get the hostname from clustat, try to find it here.
		if ($line =~ /<clusternode.*?name="(.*?)"/)
		{
			   $this_host_name  =  $1;
			my $short_host_name =  $this_host_name;
			   $short_host_name =~ s/\..*$//;
			my $short_node_name =  $node;
			   $short_node_name =~ s/\..*$//;
			   
			# If I need to record the host name from cluster.conf,
			# do so here.
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], short host name: [$short_host_name], short node name: [$short_node_name], get host from cluster.conf: [$conf->{node}{$node}{get_host_from_cluster_conf}]\n");
			if ($short_host_name eq $short_node_name)
			{
				# Found it.
				if ($conf->{node}{$node}{get_host_from_cluster_conf})
				{
					$conf->{node}{$node}{info}{host_name}            = $this_host_name;
					$conf->{node}{$node}{info}{short_host_name}      = $short_host_name;
					$conf->{node}{$node}{get_host_from_cluster_conf} = 0;
				}
				$this_node = $node;
			}
			else
			{
				$this_node = get_peer_node($conf, $node);
				if (not $conf->{node}{$this_node}{host_name})
				{
					$conf->{node}{$this_node}{info}{host_name}       = $this_host_name;
					$conf->{node}{$this_node}{info}{short_host_name} = $short_host_name;
				}
			}
			
			# Mark that I am in a node child element.
			$in_node = $node;
		}
		if ($line =~ /<\/clusternode>/)
		{
			# Record my fence findings.
			$in_node        = "";
			$this_node      = "";
			$method_counter = 0;
		}
		
		if (($in_node) && ($line =~ /<fence>/))
		{
			$in_fence = 1;
		}
		if ($line =~ /<\/fence>/)
		{
			$in_fence = 0;
		}
		if (($in_fence) && ($line =~ /<method.*name="(.*?)"/))
		{
			# The method counter ensures ordered use of the fence
			# devices.
			$in_method = "$method_counter:$1";
			$method_counter++;
		}
		if ($line =~ /<\/method>/)
		{
			$in_method    = "";
			$device_count = 0;
		}
		if (($in_method) && ($line =~ /<device\s/))
		{
			my $name   = $line =~ /name="(.*?)"/   ? $1 : "";
			my $port   = $line =~ /port="(.*?)"/   ? $1 : "";
			my $action = $line =~ /action="(.*?)"/ ? $1 : "";
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}   = $name;
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}   = $port;
			$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action} = $action;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node], method: [$in_method], method count: [$device_count], name: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}], port: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}], action: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}]\n");
			$device_count++;
		}
		
		# Parse out the fence device details.
		if ($line =~ /<fencedevices>/)
		{
			$in_fence_device = 1;
		}
		if ($line =~ /<\/fencedevices>/)
		{
			$in_fence_device = 0;
		}
		# This could be duplicated, but I don't care as cluster.conf
		# has to be the same on both nodes, anyway.
		if ($in_fence_device)
		{
			my $name     = $line =~ /name="(.*?)"/   ? $1 : "";
			my $agent    = $line =~ /agent="(.*?)"/  ? $1 : "";
			my $address  = $line =~ /ipaddr="(.*?)"/ ? $1 : "";
			my $login    = $line =~ /login="(.*?)"/  ? $1 : "";
			my $password = $line =~ /passwd="(.*?)"/ ? $1 : "";
			# If the password has a single-quote, ricci changes it to &apos;. We need to change it back.
			$password =~ s/&apos;/'/g;
			$conf->{fence}{$name}{agent}    = $agent;
			$conf->{fence}{$name}{address}  = $address;
			$conf->{fence}{$name}{login}    = $login;
			$conf->{fence}{$name}{password} = $password;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], fence name: [$name], agent: [$conf->{fence}{$name}{agent}], address: [$conf->{fence}{$name}{address}], login: [$conf->{fence}{$name}{login}], password: [$conf->{fence}{$name}{password}]\n");
		}
		
		# Find VMs.
		if ($line =~ /<vm.*?name="(.*?)"/)
		{
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			my $vm     = $1;
			my $vm_key = "vm:$vm";
			my $def    = ($line =~ /path="(.*?)"/)[0].$vm.".xml";
			my $domain = ($line =~ /domain="(.*?)"/)[0];
			# I need to set the host to 'none' to avoid triggering
			# the error caused by seeing and foo.xml VM def outside
			# of here.
			#record($conf, "$THIS_FILE ".__LINE__."; vm_key: [$vm_key], def: [$def], domain: [$domain]\n");
			$conf->{vm}{$vm_key}{definition_file} = $def;
			$conf->{vm}{$vm_key}{failover_domain} = $domain;
			$conf->{vm}{$vm_key}{host}            = "none" if not $conf->{vm}{$vm_key}{host};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], vm_key: [$vm_key], definition: [$conf->{vm}{$vm_key}{definition_file}], host: [$conf->{vm}{$vm_key}{host}]\n");
		}
	}
	
	# See if I got the fence details for both nodes.
	my $peer = get_peer_node($conf, $node);
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
	foreach my $this_node ($node, $peer)
	{
		# This will contain possible fence methods.
		$conf->{node}{$this_node}{info}{fence_methods} = "";
		
		# This will contain the command needed to check the node's
		# power.
		$conf->{node}{$this_node}{info}{power_check_command} = "";
		
		#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node]\n");
		foreach my $in_method (sort {$a cmp $b} keys %{$conf->{node}{$this_node}{fence}{method}})
		{
			#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node], method: [$in_method]\n");
			my $fence_command = "$in_method: ";
			foreach my $device_count (sort {$a cmp $b} keys %{$conf->{node}{$this_node}{fence}{method}{$in_method}{device}})
			{
				#$fence_command .= " [$device_count]";
				#record($conf, "$THIS_FILE ".__LINE__."; this node: [$this_node], method: [$in_method], method count: [$device_count], name: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name}], port: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port}], action: [$conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action}]\n");
				#Find the matching fence device entry.
				foreach my $name (sort {$a cmp $b} keys %{$conf->{fence}})
				{
					if ($name eq $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{name})
					{
						my $agent    = $conf->{fence}{$name}{agent};
						my $address  = $conf->{fence}{$name}{address};
						my $login    = $conf->{fence}{$name}{login};
						my $password = $conf->{fence}{$name}{password};
						my $port     = $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{port};
						#my $action   = $conf->{node}{$this_node}{fence}{method}{$in_method}{device}{$device_count}{action};
						#   $action   = "reboot" if not $action;
						my $command  = "$agent -a $address ";
						   $command .= "-l $login "        if $login;
						   $command .= "-p \"$password\" " if $password;	# quote the password in case it has spaces in it.
						   $command .= "-n $port "         if $port;
						   $command =~ s/ $//;
						$conf->{node}{$this_node}{fence_method}{$in_method}{device}{$device_count}{command} = $command;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node], fence command: [$conf->{node}{$this_node}{fence_method}{$in_method}{device}{$device_count}{command}]\n");
						if ($agent eq "fence_ipmilan")
						{
							$conf->{node}{$this_node}{info}{power_check_command} = $command;
							#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: power check command: [$conf->{node}{$this_node}{info}{power_check_command}]\n");
						}
						$fence_command .= "$command -o #!action!#; ";
					}
				}
			}
			# Record the fence command.
			$fence_command =~ s/ $/. /;
			if ($node eq $this_node)
			{
				$conf->{node}{$node}{info}{fence_methods} .= "$fence_command";
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: fence command: $conf->{node}{$node}{info}{fence_methods}\n");
			}
			else
			{
				$conf->{node}{$peer}{info}{fence_methods} .= "$fence_command";
				#record($conf, "$THIS_FILE ".__LINE__."; node: [$this_node]: peer: [$peer], fence command: $conf->{node}{$peer}{info}{fence_methods}\n");
			}
		}
		$conf->{node}{$this_node}{info}{fence_methods} =~ s/\s+$//;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], fence command: [$conf->{node}{$node}{info}{fence_methods}]\n");
	#record($conf, "$THIS_FILE ".__LINE__."; peer: [$peer], fence command: [$conf->{node}{$peer}{info}{fence_methods}]\n");
	
	# If the host name was set, then I can trust that I had good data.
	if ($conf->{node}{$node}{info}{host_name})
	{
		# Find out if the nodes are powered up or not.
		write_node_cache($conf, $node);
	}
	
	return(0);
}

# Parse the daemon statuses.
sub parse_daemons
{
	my ($conf, $node, $array) = @_;
	
	# If all daemons are down, record here that I can shut down
	# this VM. If any are up, enable withdrawl.
	$conf->{node}{$node}{enable_poweroff} = 0;
	$conf->{node}{$node}{enable_withdraw} = 0;
	
	# I need to preset the services as stopped because the little
	# hack I have below doesn't echo when a service isn't running.
	set_daemons($conf, $node, "Stopped", "highlight_bad");
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_daemons() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		next if $line !~ /^an-sve:/;
		my ($daemon, $exit_code) = ($line =~ /^.*?:(.*?):(.*?)$/);
		$exit_code = "" if not defined $exit_code;
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], exit_code: [$exit_code]\n");
		if ($exit_code eq "0")
		{
			$conf->{node}{$node}{daemon}{$daemon}{status} = "<span class=\"highlight_good\">Running</span>";
			$conf->{node}{$node}{enable_poweroff}         = 0;
		}
		$conf->{node}{$node}{daemon}{$daemon}{exit_code} = defined $exit_code ? $exit_code : "";
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], exit code: [$conf->{node}{$node}{daemon}{$daemon}{exit_code}], status: [$conf->{node}{$node}{daemon}{$daemon}{status}]\n");
	}
	
	# If cman is running, enable withdrawl. If not, enable shut down.
	my $cman_exit      = $conf->{node}{$node}{daemon}{cman}{exit_code};
	my $rgmanager_exit = $conf->{node}{$node}{daemon}{rgmanager}{exit_code};
	my $drbd_exit      = $conf->{node}{$node}{daemon}{drbd}{exit_code};
	my $clvmd_exit     = $conf->{node}{$node}{daemon}{clvmd}{exit_code};
	my $gfs2_exit      = $conf->{node}{$node}{daemon}{gfs2}{exit_code};
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], cman_exit:      [$cman_exit]\n");
	if ($cman_exit eq "0")
	{
		$conf->{node}{$node}{enable_withdraw} = 1;
	}
	else
	{
		# If something went wrong, one of the storage resources might still be running.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], rgmanager_exit: [$rgmanager_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], drbd_exit:      [$drbd_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], clvmd_exit:     [$clvmd_exit]\n");
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], gfs2_exit:      [$gfs2_exit]\n");
		if (($rgmanager_exit eq "0") ||
		($drbd_exit eq "0") ||
		($clvmd_exit eq "0") ||
		($gfs2_exit eq "0"))
		{
			# Uh oh...
			error($conf, "One of more of the storage daemons are running on $node while the Anvil's cluster is down. This is generally the sign of an unclean withdrawl of a node from the cluster! Please <a href=\"https://alteeve.com/w/Support\">call support immediately</a>.\n"); 
		}
		else
		{
			# Ready to power off the node, if I was actually able
			# to connect to the node.
			if ($conf->{node}{$node}{connected})
			{
				$conf->{node}{$node}{enable_poweroff} = 1;
			}
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], enable poweroff: [$conf->{node}{$node}{enable_poweroff}], enable withdrawl: [$conf->{node}{$node}{enable_withdraw}]\n");
	#foreach my $daemon (@daemons) { record($conf, "$THIS_FILE ".__LINE__."; node: [$node], daemon: [$daemon], status: [$conf->{node}{$node}{daemon}{$daemon}{status}], exit_code: [$conf->{node}{$node}{daemon}{$daemon}{exit_code}]\n"); }
	
	return(0);
}

# Parse the LVM scan output.
sub parse_lvm_scan
{
	my ($conf, $node, $array) = @_;
	
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_lvm_scan() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /(.*?)\s+'(.*?)'\s+\[(.*?)\]/)
		{
			my $state     = $1;
			my $lv        = $2;
			my $size      = $3;
			my $bytes     = hr_to_bytes($conf, $size);
			my $vg        = ($lv =~ /^\/dev\/(.*?)\//)[0];
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], state: [$state], vg: [$vg], lv: [$lv], size: [$size], bytes: [$bytes]\n");
			
			if (lc($state) eq "inactive")
			{
				print "
<table align=\"center\">
	<tr>
		<td class=\"highlight_warning_bold\">
			Inactive LV!
		</td>
		<td>
			The logical volume: [<span class=\"fixed_width\">$lv</span>] on node: [<span class=\"fixed_width\">$node</span>] is inactive!<br />
			Please <a href=\"https://alteeve.ca/w/Support\" target=\"_new\">contact support</a>, or if you are comfortable, active the LV as soon as possible.<br />
		</td>
	</tr>
</table>
<br />
";
			}
			
			if (exists $conf->{resources}{lv}{$lv})
			{
				if (($conf->{resources}{lv}{$lv}{on_vg} ne $vg) || ($conf->{resources}{lv}{$lv}{size} ne $bytes))
				{
					error($conf, "There was a problem when scanning the storage. The nodes report different sizes and/or volume groups for the logical volume: [$lv]. Saw sizes: [$conf->{resources}{lv}{$lv}{size}] vs. [$bytes] and the backing volume group is: [$conf->{resources}{lv}{$lv}{on_vg}] vs [$vg]", 1);
				}
				
			}
			else
			{
				$conf->{resources}{lv}{$lv}{on_vg} = $vg;
				$conf->{resources}{lv}{$lv}{size}  = $bytes;
				#record($conf, "$THIS_FILE ".__LINE__."; lv: [$lv], vg: [$conf->{resources}{lv}{$lv}{on_vg}], size: [$conf->{resources}{lv}{$lv}{size}]\n");
			}
		}
	}
	
	return(0);
}

# Parse the LVM data.
sub parse_lvm_data
{
	my ($conf, $node, $array) = @_;
	
	my $in_pvs = 0;
	my $in_vgs = 0;
	my $in_lvs = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_lvm_data() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^PV/)
		{
			$in_pvs = 1;
			$in_vgs = 0;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^VG/)
		{
			$in_pvs = 0;
			$in_vgs = 1;
			$in_lvs = 0;
			next;
		}
		if ($line =~ /^LV/)
		{
			$in_pvs = 0;
			$in_vgs = 0;
			$in_lvs = 1;
			next;
		}
		
		if ($in_pvs)
		{
			# pvs --units b --separator \\\#\\\!\\\# -o pv_name,vg_name,pv_fmt,pv_attr,pv_size,pv_free,pv_used,pv_uuid
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			#   pv_name,  vg_name,     pv_fmt,  pv_attr,     pv_size,     pv_free,   pv_used,     pv_uuid
			my ($this_pv, $used_by_vg, $format, $attributes, $total_size, $free_size, $used_size, $uuid) = (split /#!#/, $line);
			$total_size =~ s/B$//;
			$free_size  =~ s/B$//;
			$used_size  =~ s/B$//;
			#record($conf, "$THIS_FILE ".__LINE__."; PV: [$this_pv], used by VG: [$used_by_vg], format: [$format], attributes: [$attributes], total size: [$total_size], free size: [$free_size], used size: [$used_size], uuid: [$uuid]\n");
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_by_vg} = $used_by_vg;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{attributes} = $attributes;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{total_size} = $total_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{free_size}  = $free_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_size}  = $used_size;
			$conf->{node}{$node}{lvm}{pv}{$this_pv}{uuid}       = $uuid;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], PV: [$this_pv], used by VG: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_by_vg}], attributes: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{attributes}], total size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{total_size}], free size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{free_size}], used size: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{used_size}], uuid: [$conf->{node}{$node}{lvm}{pv}{$this_pv}{uuid}]\n");
		}
		elsif ($in_vgs)
		{
			# vgs --units b --separator \\\#\\\!\\\# -o vg_name,vg_attr,vg_extent_size,vg_extent_count,vg_uuid,vg_size,vg_free_count,vg_free,pv_name
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			#   vg_name,  vg_attr,     vg_extent_size, vg_extent_count, vg_uuid, vg_size,  vg_free_count, vg_free,  pv_name
			my ($this_vg, $attributes, $pe_size,       $total_pe,       $uuid,   $vg_size, $free_pe,      $vg_free, $pv_name) = split /#!#/, $line;
			$pe_size    = "" if not defined $pe_size;
			$vg_size    = "" if not defined $vg_size;
			$vg_free    = "" if not defined $vg_free;
			$attributes = "" if not defined $attributes;
			$pe_size =~ s/B$//;
			$vg_size =~ s/B$//;
			$vg_free =~ s/B$//;
			my $used_pe    = $total_pe - $free_pe if (($total_pe) && ($free_pe));
			my $used_space = $vg_size - $vg_free  if (($vg_size) && ($vg_free));
			#record($conf, "$THIS_FILE ".__LINE__."; VG: [$this_vg], attributes: [$attributes], PE size: [$pe_size], total PE: [$total_pe], uuid: [$uuid], VG size: [$vg_size], used PE: [$used_pe], used space: [$used_space], free PE: [$free_pe], free space: [$vg_free], VG free: [$vg_free], pv_name: [$pv_name]\n");
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{clustered}  = $attributes =~ /c$/ ? 1 : 0;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pe_size}    = $pe_size;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{total_pe}   = $total_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{uuid}       = $uuid;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{size}       = $vg_size;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_pe}    = $used_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_space} = $used_space;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_pe}    = $free_pe;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_space} = $vg_free;
			$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pv_name}    = $pv_name;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], VG: [$this_vg], clustered: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{clustered}], pe size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pe_size}], total pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{total_pe}], uuid: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{uuid}], size: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{size}], used pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_pe}], used space: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{used_space}], free pe: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_pe}], free space: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{free_space}], PV name: [$conf->{node}{$node}{hardware}{lvm}{vg}{$this_vg}{pv_name}]\n");
		}
		elsif ($in_lvs)
		{
			# lvs --units b --separator \\\#\\\!\\\# -o lv_name,vg_name,lv_attr,lv_size,lv_uuid,lv_path,devices
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			my ($lv_name, $on_vg, $attributes, $total_size, $uuid, $path, $devices) = (split /#!#/, $line);
			#record($conf, "$THIS_FILE ".__LINE__."; LV name: [$lv_name], on VG: [$on_vg], attributes: [$attributes], total size: [$total_size], uuid: [$uuid], path: [$path], device(s): [$devices]\n");
			$total_size =~ s/B$//;
			$devices    =~ s/\(\d+\)//g;	# Strip the starting PE number
			$conf->{node}{$node}{lvm}{lv}{$path}{name}       = $lv_name;
			$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}      = $on_vg;
			$conf->{node}{$node}{lvm}{lv}{$path}{active}     = ($attributes =~ /.{4}(.{1})/)[0] eq "a" ? 1 : 0;
			$conf->{node}{$node}{lvm}{lv}{$path}{attributes} = $attributes;
			$conf->{node}{$node}{lvm}{lv}{$path}{total_size} = $total_size;
			$conf->{node}{$node}{lvm}{lv}{$path}{uuid}       = $uuid;
			$conf->{node}{$node}{lvm}{lv}{$path}{on_devices} = $devices;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], path: [$path], name: [$conf->{node}{$node}{lvm}{lv}{$path}{name}], on VG: [$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}], active: [$conf->{node}{$node}{lvm}{lv}{$path}{active}], attribute: [$conf->{node}{$node}{lvm}{lv}{$path}{attributes}], total size: [$conf->{node}{$node}{lvm}{lv}{$path}{total_size}], uuid: [$conf->{node}{$node}{lvm}{lv}{$path}{uuid}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$path}{on_devices}]\n");
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], path: [$path], name: [$conf->{node}{$node}{lvm}{lv}{$path}{name}], on VG: [$conf->{node}{$node}{lvm}{lv}{$path}{on_vg}], total size: [$conf->{node}{$node}{lvm}{lv}{$path}{total_size}], on device(s): [$conf->{node}{$node}{lvm}{lv}{$path}{on_devices}]\n");
		}
	}
	
	return(0);
}

# Parse the virsh data.
sub parse_virsh
{
	my ($conf, $node, $array) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_virsh(), node: [$node]\n");
	
	foreach my $line (@{$array})
	{
		next if $line !~ /^\d/;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		
		my ($id, $say_vm, $state) = split/ /, $line, 3;
		#record($conf, "$THIS_FILE ".__LINE__."; id: [$id], saw vm: [$say_vm], state: [$state]\n");
		
		my $vm = "vm:$say_vm";
		$conf->{vm}{$vm}{node}{$node}{virsh}{'state'} = $state;
		if ($state eq "paused")
		{
			# This VM is being migrated here, disable withdrawl of
			# this node and migration of this VM.
			$conf->{node}{$node}{enable_withdraw} = 0;
			$conf->{vm}{$vm}{can_migrate}         = 0;
			$conf->{node}{$node}{enable_poweroff} = 0;
		}
	}
	
	return(0);
}

# Parse the GFS2 data.
sub parse_gfs2
{
	my ($conf, $node, $array) = @_;
	
	my $in_fs = 0;
	#record($conf, "$THIS_FILE ".__LINE__."; in parse_gfs2() for node: [$node]\n");
	foreach my $line (@{$array})
	{
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /Filesystem/)
		{
			$in_fs = 1;
			next;
		}
		
		if ($in_fs)
		{
			next if $line !~ /^\//;
			my ($device_path, $total_size, $used_space, $free_space, $percent_used, $mount_point) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)$/);
			next if not $mount_point;
			$total_size   = "" if not defined $total_size;
			$used_space   = "" if not defined $used_space;
			$free_space   = "" if not defined $free_space;
			$percent_used = "" if not defined $percent_used;
			next if not exists $conf->{node}{$node}{gfs}{$mount_point};
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], device path: [$device_path], total size: [$total_size], used space: [$used_space], free space: [$free_space], percent used: [$percent_used], mount point: [$mount_point]\n");
			$conf->{node}{$node}{gfs}{$mount_point}{device_path}  = $device_path;
			$conf->{node}{$node}{gfs}{$mount_point}{total_size}   = $total_size;
			$conf->{node}{$node}{gfs}{$mount_point}{used_space}   = $used_space;
			$conf->{node}{$node}{gfs}{$mount_point}{free_space}   = $free_space;
			$conf->{node}{$node}{gfs}{$mount_point}{percent_used} = $percent_used;
			$conf->{node}{$node}{gfs}{$mount_point}{mounted}      = 1;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], device path: [$conf->{node}{$node}{gfs}{$mount_point}{device_path}], total size: [$conf->{node}{$node}{gfs}{$mount_point}{total_size}], used space: [$conf->{node}{$node}{gfs}{$mount_point}{used_space}], free space: [$conf->{node}{$node}{gfs}{$mount_point}{free_space}], percent used: [$conf->{node}{$node}{gfs}{$mount_point}{percent_used}], mounted: [$conf->{node}{$node}{gfs}{$mount_point}{mounted}]\n");
		}
		else
		{
			# Read the GFS info.
			next if $line !~ /gfs2/;
			my (undef, $mount_point, $fs) = ($line =~ /^(.*?)\s+(.*?)\s+(.*?)\s/);
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], fs: [$fs]\n");
			$conf->{node}{$node}{gfs}{$mount_point}{device_path}  = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{total_size}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{used_space}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{free_space}   = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{percent_used} = "--";
			$conf->{node}{$node}{gfs}{$mount_point}{mounted}      = 0;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], mount point: [$mount_point], device path: [$conf->{node}{$node}{gfs}{$mount_point}{device_path}], total size: [$conf->{node}{$node}{gfs}{$mount_point}{total_size}], used space: [$conf->{node}{$node}{gfs}{$mount_point}{used_space}], free space: [$conf->{node}{$node}{gfs}{$mount_point}{free_space}], percent used: [$conf->{node}{$node}{gfs}{$mount_point}{percent_used}], mounted: [$conf->{node}{$node}{gfs}{$mount_point}{mounted}]\n");
		}
	}
	
	return(0);
}

# This sets all of the daemons to a given state.
sub set_daemons
{
	my ($conf, $node, $state, $class) = @_;
	
	my @daemons = ("cman", "rgmanager", "drbd", "clvmd", "gfs2", "libvirtd");
	foreach my $daemon (@daemons)
	{
		$conf->{node}{$node}{daemon}{$daemon}{status}    = "<span class=\"$class\">$state</span>";
		$conf->{node}{$node}{daemon}{$daemon}{exit_code} = "";
	}
	return(0);
}

# This checks to see if the node's power is on, when possible.
sub check_if_on
{
	my ($conf, $node) = @_;
	record($conf, "$THIS_FILE ".__LINE__."; in check_if_on(); node: [$node]\n");
	
	# If the peer is on, use it to check the power.
	my $peer                    = "";
	$conf->{node}{$node}{is_on} = 9;
	#record($conf, "$THIS_FILE ".__LINE__."; up nodes: [$conf->{'system'}{up_nodes}]\n");
	### TODO: This fails when node 1 is down because it has not yet looked
	###       for node 2 to see if it is on or not. Check manually.
	if ($conf->{'system'}{up_nodes} == 1)
	{
		# It has to be the peer of this node.
		$peer = @{$conf->{up_nodes}}[0];
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], peer: [$peer]\n");
	if ($peer)
	{
		# Check the power state using the peer node.
		if (not $conf->{node}{$node}{info}{power_check_command})
		{
			error($conf, "I was asked to check the power staus of: [$node] via it's peer: [$peer], but the power check command is empty.<br />\nThis is likely a program error.\n");
		}
		else
		{
			# Escape out password double-quotes.
			$conf->{node}{$node}{info}{power_check_command} =~ s/-p \"(.*?)\"/-p \\\"$1\\\"/g;
			#record($conf, "$THIS_FILE ".__LINE__."; node::${node}::info::power_check_command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		}
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		my $sc = "$conf->{path}{ssh} root\@$peer \"$conf->{node}{$node}{info}{power_check_command} -o status\"";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
			if ($line =~ / On$/i)
			{
				$conf->{node}{$node}{is_on} = 1;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
			}
			if ($line =~ / Off$/i)
			{
				$conf->{node}{$node}{is_on} = 0;
				record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
			}
		}
		$fh->close();
	}
	else
	{
		# Read the cache and check the power directly, if possible.
		read_node_cache($conf, $node);
		$conf->{node}{$node}{info}{power_check_command} = "" if not defined $conf->{node}{$node}{info}{power_check_command};
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		if ($conf->{node}{$node}{info}{power_check_command})
		{
			# Get the address from the command and see if it's in
			# one of my subnet.
			my ($target_host) = ($conf->{node}{$node}{info}{power_check_command} =~ /-a\s(.*?)\s/)[0];
			my $local_access = on_same_network($conf, $target_host);
			
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], local_access: [$local_access]\n");
			if ($local_access)
			{
				# I can reach it directly
				my $sc = "$conf->{node}{$node}{info}{power_check_command} -o status";
				#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
				my $fh = IO::Handle->new();
				open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
				while(<$fh>)
				{
					chomp;
					my $line = $_;
					#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], line: [$line]\n");
					if ($line =~ / On$/i)
					{
						$conf->{node}{$node}{is_on} = 1;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
					}
					if ($line =~ / Off$/i)
					{
						$conf->{node}{$node}{is_on} = 0;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
					}
					if ($line =~ / Unknown$/i)
					{
						$conf->{node}{$node}{is_on} = 2;
						#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}] - Failed to get info from IPMI!\n");
					}
				}
				$fh->close();
			}
			else
			{
				# I can't reach it from here.
				#record($conf, "$THIS_FILE ".__LINE__."; This machine is not on the same network out of band management interface: [$target_host] for node: [$node], unable to check power state.\n");
				$conf->{node}{$node}{is_on} = 3;
			}
		}
		else
		{
			# No power-check command
			$conf->{node}{$node}{is_on} = 4;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}] - Unable to find power check command!\n");
		}
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], is on: [$conf->{node}{$node}{is_on}]\n");
	if ($conf->{node}{$node}{is_on} == 0)
	{
		# I need to preset the services as stopped because the little
		# hack I have below doesn't echo when a service isn't running.
		$conf->{node}{$node}{enable_poweron} = 1;
		set_daemons($conf, $node, "Offline", "highlight_unavailable");
	}
	
	return(0);
}

# This takes a host name (or IP) and sees if it's reachable from the machine
# running this program.
sub on_same_network
{
	my ($conf, $target_host) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in on_same_network(); target host: [$target_host]\n");
	
	my $local_access = 0;
	my $target_ip;
	
	my $sc = "$conf->{path}{gethostip} -d $target_host";
	#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
	my $fh = IO::Handle->new();
	open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
	while(<$fh>)
	{
		chomp;
		my $line = $_;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
		if ($line =~ /^(\d+\.\d+\.\d+\.\d+)$/)
		{
			$target_ip = $1;
			#record($conf, "$THIS_FILE ".__LINE__."; target_ip: [$target_ip]\n");
		}
		elsif ($line =~ /Unknown host/i)
		{
			#Failed to resolve
			error($conf, "I was trying to resolve the host name: [$target_host] but was unable to do so. Is this a valid host name? If so, do you have an entry in DNS or in your /etc/hosts file?\n");
		}
		elsif ($line =~ /Usage: gethostip/i)
		{
			#No hostname parsed out.
			error($conf, "I was trying to resolve a host name, but no name was given. This is likely a program error.\n");
		}
	}
	$fh->close();
	
	#record($conf, "$THIS_FILE ".__LINE__."; target_ip: [$target_ip]\n");
	if ($target_ip)
	{
		# Find out my own IP(s) and subnet(s).
		my $in_dev       = "";
		my $this_ip      = "";
		my $this_nm      = "";
		
		my $sc           = "$conf->{path}{ifconfig}";
		#record($conf, "$THIS_FILE ".__LINE__."; Calling: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "$sc 2>&1 |") or die "Failed to call: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			if ($line =~ /^(.*?)\s+Link encap/)
			{
				$in_dev = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; in_dev: [$in_dev]\n");
				next;
			}
			elsif ($line =~ /^(.*?): flags/)
			{
				$in_dev = $1;
				#record($conf, "$THIS_FILE ".__LINE__."; in_dev: [$in_dev]\n");
				next;
			}
			if (not $line)
			{
				# See if this network gives me access 
				# to the power check device.
				my $target_ip_range = $target_ip;
				my $this_ip_range   = $this_ip;
				#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip: [$this_ip]\n");
				if ($this_nm eq "255.255.255.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+$//;
					$this_ip_range   =~ s/.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				if ($this_nm eq "255.255.0.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+.\d+$//;
					$this_ip_range   =~ s/.\d+.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				if ($this_nm eq "255.0.0.0")
				{
					# Match the first three octals.
					$target_ip_range =~ s/.\d+.\d+.\d+$//;
					$this_ip_range   =~ s/.\d+.\d+.\d+$//;
					#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				}
				#record($conf, "$THIS_FILE ".__LINE__."; target_ip_range: [$target_ip_range], this_ip_range: [$this_ip_range]\n");
				if ($this_ip_range eq $target_ip_range)
				{
					# Match! I can reach it directly.
					$local_access = 1;
					#record($conf, "$THIS_FILE ".__LINE__."; local_access: [$local_access]\n");
					last;
				}
				
				$in_dev = "";
				$this_ip = "";
				$this_nm = "";
				next;
			}
			
			if ($in_dev)
			{
				next if $line !~ /inet /;
				if ($line =~ /inet addr:(\d+\.\d+\.\d+\.\d+) /)
				{
					$this_ip = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_ip: [$this_ip]\n");
				}
				elsif ($line =~ /inet (\d+\.\d+\.\d+\.\d+) /)
				{
					$this_ip = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_ip: [$this_ip]\n");
				}
				
				if ($line =~ /Mask:(\d+\.\d+\.\d+\.\d+)/i)
				{
					$this_nm = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_nm: [$this_nm]\n");
				}
				elsif ($line =~ /netmask (\d+\.\d+\.\d+\.\d+) /)
				{
					$this_nm = $1;
					#record($conf, "$THIS_FILE ".__LINE__."; this_nm: [$this_nm]\n");
				}
			}
		}
		$fh->close();
	}
	
	#record($conf, "$THIS_FILE ".__LINE__."; local_access: [$local_access]\n");
	return($local_access);
}

# This records this scan's data to the cache file.
sub write_node_cache
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in write_node_cache(); node: [$node]\n");
	
	# It's a program error to try and write the cache file when the node
	# is down.
	my $cluster    = $conf->{cgi}{cluster};
	my $cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".an-cdb";
	if (($conf->{node}{$node}{info}{host_name}) && ($conf->{node}{$node}{info}{power_check_command}))
	{
		# Write the command to disk so that I can check the power state
		# in the future when both nodes are offline.
		#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
		my $fh         = IO::Handle->new();
		#record($conf, "$THIS_FILE ".__LINE__."; writting: [$cache_file]\n");
		open ($fh, "> $cache_file") or error($conf, "Failed to write: [<span class=\"fixed_width\">$cache_file</span>] as UID: [<span class=\"fixed_width\">$<</span>].<br />The error was: <span class=\"fixed_width\">$!</span>\n");
		
		print $fh "host_name = $conf->{node}{$node}{info}{host_name}\n";
		print $fh "power_check_command = $conf->{node}{$node}{info}{power_check_command}\n";
		print $fh "fence_methods = $conf->{node}{$node}{info}{fence_methods}\n";
		
		$fh->close();
	}
	elsif (not -e $cache_file)
	{
		# I've probably never seen the cache file before, so don't
		# error out.
	}
	else
	{
		#error($conf, "I was asked to write the cache file for: [$node], but I didn't have all the cache data.<br />\nI was passed; host name: [$conf->{node}{$node}{info}{host_name}], power check command: [$conf->{node}{$node}{info}{power_check_command}].<br />\nThis is likely a program error.\n");
	}
	
	return(0);
}

# This reads the cached data for this node, if available.
sub read_node_cache
{
	my ($conf, $node) = @_;
	#record($conf, "$THIS_FILE ".__LINE__."; in read_node_cache(); node: [$node]\n");
	
	# Write the command to disk so that I can check the power state
	# in the future when both nodes are offline.
	my $cluster    = $conf->{cgi}{cluster};
	my $cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".an-cdb";
	#record($conf, "$THIS_FILE ".__LINE__."; cluster: [$cluster], cache file: [$cache_file]\n");
	if (not -e $cache_file)
	{
		# See if there is a version with or without '<node>.remote'
		if ($node =~ /\.remote/)
		{
			# Strip it off
			$cache_file =~ s/\.remote//;
		}
		else
		{
			# Add the .remote suffix.
			$cache_file = "$conf->{path}{'an-cdb_files'}/cache_".$cluster."_".$node.".remote.an-cdb";
		}
	}
	if (-e $cache_file)
	{
		# It exists! Read it.
		my $sc = $cache_file;
		#record($conf, "$THIS_FILE ".__LINE__."; Reading: [$sc]\n");
		my $fh = IO::Handle->new();
		open ($fh, "<$sc") or die "Failed to read: [$sc]\n";
		while(<$fh>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\s+/ /g;
			#record($conf, "$THIS_FILE ".__LINE__."; line: [$line]\n");
			next if $line !~ /=/;
			my ($var, $val) = (split/=/, $line, 2);
			$var =~ s/^\s+//;
			$var =~ s/\s+$//;
			$val =~ s/^\s+//;
			$val =~ s/\s+$//;
			#record($conf, "$THIS_FILE ".__LINE__."; var: [$var], val: [$val]\n");
			
			$conf->{node}{$node}{info}{$var} = $val;
			#record($conf, "$THIS_FILE ".__LINE__."; node: [$node], var: [$var] -> [$conf->{node}{$node}{info}{$var}]\n");
		}
		$fh->close();
	}
	else
	{
		$conf->{node}{$node}{info}{host_name} = $node;
	}
	#record($conf, "$THIS_FILE ".__LINE__."; host name: [$conf->{node}{$node}{info}{host_name}], power check command: [$conf->{node}{$node}{info}{power_check_command}]\n");
	
	return(0);
}

###############################################################################
# Sssh, there are private functions                                           #
###############################################################################

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This is a helper to the below '_make_hash_reference' function. It is called
# each time a new string is to be created as a new hash key in the passed hash
# reference.
sub _add_hash_reference
{
	my ($href1, $href2) = @_;

	for my $key (keys %$href2)
	{
		if (ref $href1->{$key} eq 'HASH')
		{
			_add_hash_reference($href1->{$key}, $href2->{$key});
		}
		else
		{
			$href1->{$key} = $href2->{$key};
		}
	}
}

### Contributed by Shaun Fryer and Viktor Pavlenko by way of TPM.
# This takes a string with double-colon seperators and divides on those
# double-colons to create a hash reference where each element is a hash key.
sub _make_hash_reference
{
	my ($href, $key_string, $value) = @_;

	my @keys            = split /::/, $key_string;
	my $last_key        = pop @keys;
	my $_href           = {};
	$_href->{$last_key} = $value;
	while (my $key = pop @keys)
	{
		my $elem      = {};
		$elem->{$key} = $_href;
		$_href        = $elem;
	}
	_add_hash_reference($href, $_href);
}

1;
