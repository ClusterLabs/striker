#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# ScanCore Scan Agent for 'ipmitool' to query IPMI data.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - Passed in host name was not found in the database.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# TODO:
# - Decide if we should parse 'ipmitool sel list'
# - Detect a hung BMC by trying to talk to ourselves and, if that fails, send 'ipmitool bmc reset cold'. 
#   Possibly try pinging the IPMI from the peer as it's not always possible to ping our own interface when
#   the IPMI and eth device share the same physical connector.
# - Update the string processing from the '!!x!name=a,value=b,units=c!!' method to the new method here:
#   https://alteeve.ca/w/ScanCore#Unit_Parsing
# 
=pod

A Hung/crashed BMC will fail to reset with this:
====
[root@nr-c03n01 ~]# time ipmitool bmc reset cold
Get Device ID command failed: 0xff Unspecified error
Sent cold reset command to MC

real	3m52.860s
user	0m0.000s
sys	0m0.002s
====

Seeing this, we need to ask the peer to power-cycle us (/shared/status/.node.helpme -> 'task = power_cycle')
and set the health to 'warning'. We will call anvil-safe-stop.

The peer, on seeing (/shared/status/.node.helpme -> 'task = power_cycle'), will start pinging the peer on the
BCN and SN. Once there is no response, we will start a 60 second counter, then cut power to the PDUs for 60
seconds, then restore power. We will then start pinging the IPMI interface. Once it responds, we will wait 60
seconds and then try to power it back on.

---------

Change/set thresholds:

From: https://forums.freenas.org/index.php?threads/how-to-change-sensor-thresholds-with-ipmi-using-ipmitool.23571/

Lower Non-Recoverable
Lower Critical
Lower Non-Critical

Upper Non-Critical
Upper Critical
Upper Non-Recoverable

ipmitool sensor thresh "*sensor name*" lower *lnr* *lcr* *lnc*

ipmitool sensor thresh "*sensor name*" upper *unc* *ucr* *unr*
=cut

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
use Socket;
#use utf8;
#binmode STDOUT, 'encoding(utf8)';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

### TODO: Rework this whole agent...
# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		sys			=>	{
			sql			=>	[],
		},
		# These are values the user might set in striker.conf
		'scan-ipmitool'		=>	{
			language			=>	"en_CA",
			log_file			=>	"/var/log/ScanCore.log",
			log_level			=>	1,
			log_language			=>	"en_CA",
			log_db_transactions		=>	0,
			# It will be marked as 'clear' when the temperature drops this many Â°C below the 
			# critical temperature.
			machine				=>	{},
			# These are used when no other limits are set for a given sensor.
			thresholds			=>	{
				'default'			=>	{
					high_warning			=>	50,
					high_critical			=>	55,
					low_warning			=>	5,
					low_critical			=>	0,
					jump				=>	5,
					### TODO: Some sensors define their hysteresis which we can read 
					###       using: 
					###       ipmitool ... sensor get "Ambient"
					buffer				=>	2,
				},
				# If the user wants to assign manual values for a given sensor, they can do 
				# so by creating an entry hear where the key is the IPMI-returned sensor 
				# name.
				#ie:
				# ===========================================================================
				#'Ambient'			=>	{
				#	high_warning			=>	50,
				#	high_critical			=>	55,
				#	low_warning			=>	5,
				#	low_critical			=>	0,
				#	jump				=>	5,
				#	buffer				=>	2,
				#	weight				=>	1,
				#},
				# ===========================================================================
				# CPUs tend to jump around wildly under sudden load, so we extend their jump
				# range so we don't get spurious warnings all the time.
				'CPU1'				=>	{
					jump				=>	10,
				},
				'CPU2'				=>	{
					jump				=>	10,
				},
				'CPU3'				=>	{
					jump				=>	10,
				},
				'CPU4'				=>	{
					jump				=>	10,
				},
				'CPU5'				=>	{
					jump				=>	10,
				},
				'CPU6'				=>	{
					jump				=>	10,
				},
				'CPU7'				=>	{
					jump				=>	10,
				},
				'CPU8'				=>	{
					jump				=>	10,
				},
			},
			# TODO: Remove this and have Striker pull the list of thermal sensors read in the 
			#       last $timestamp.
			offline_sensor_list		=>	"Ambient,Systemboard",
		},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-ipmitool'}{language});
$an->default_log_language($an->data->{'scan-ipmitool'}{log_language});
$an->default_log_file    ($an->data->{'scan-ipmitool'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-ipmitool'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-ipmitool'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

print $an->String->get({key => "scan_ipmitool_message_0001"})."\n";

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "notice_message_0013", message_variables => {
	connections => $connections,
}, file => $THIS_FILE, line => __LINE__});

# This calls anvil-report-ipmi-details to find IPMI devices to scan. It also handles any user-defined IPMI 
# devices set in striker.conf.
if (not find_ipmi_targets($an))
{
	# No targets found, exit.
	nice_exit($an, 1);
}

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { 
		uuid => $an->data->{sys}{host_uuid},
	}, code => 255, file => "$THIS_FILE", line => __LINE__});
}

# Query IPMI targets. Unreachable targets will simply be ignored.
query_ipmi_targets($an);

# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
nice_exit($an);


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through each machine
	foreach my $machine (sort {$a cmp $b} keys %{$an->data->{ipmi}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "machine", value1 => $machine, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# This returns the number of read sensors already in the DB for this machine recorded by us 
		# previously.
		if (read_last_scan($an, $machine))
		{
			### Existing machine, UPDATE or INSERT as needed.
			foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{ipmi}{$machine}{ipmitool_sensor_name}})
			{
				# Put the new values into variables
				my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
				my $new_ipmitool_sensor_units         = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
				my $new_ipmitool_sensor_status        = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
				my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
				my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
				my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
				my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
					name1 => "new_ipmitool_value_sensor_value",   value1 => $new_ipmitool_value_sensor_value, 
					name2 => "new_ipmitool_sensor_units",         value2 => $new_ipmitool_sensor_units, 
					name3 => "new_ipmitool_sensor_status",        value3 => $new_ipmitool_sensor_status, 
					name4 => "new_ipmitool_sensor_high_critical", value4 => $new_ipmitool_sensor_high_critical, 
					name5 => "new_ipmitool_sensor_high_warning",  value5 => $new_ipmitool_sensor_high_warning, 
					name6 => "new_ipmitool_sensor_low_critical",  value6 => $new_ipmitool_sensor_low_critical, 
					name7 => "new_ipmitool_sensor_low_warning",   value7 => $new_ipmitool_sensor_low_warning, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Have I seen this sensor before?
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "ref(sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name})", value1 => ref($an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}), 
				}, file => $THIS_FILE, line => __LINE__});
				if (ref($an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}))
				{
					### Existing record, update it if needed.
					# Put the old values into variables
					my $ipmitool_uuid                     = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid};
					my $old_ipmitool_value_sensor_value   = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
					my $old_ipmitool_sensor_units         = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
					my $old_ipmitool_sensor_status        = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
					my $old_ipmitool_sensor_high_critical = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
					my $old_ipmitool_sensor_high_warning  = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
					my $old_ipmitool_sensor_low_critical  = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
					my $old_ipmitool_sensor_low_warning   = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
						name1 => "ipmitool_uuid",                     value1 => $ipmitool_uuid, 
						name2 => "old_ipmitool_value_sensor_value",   value2 => $old_ipmitool_value_sensor_value, 
						name3 => "old_ipmitool_sensor_units",         value3 => $old_ipmitool_sensor_units, 
						name4 => "old_ipmitool_sensor_status",        value4 => $old_ipmitool_sensor_status, 
						name5 => "old_ipmitool_sensor_high_critical", value5 => $old_ipmitool_sensor_high_critical, 
						name6 => "old_ipmitool_sensor_high_warning",  value6 => $old_ipmitool_sensor_high_warning, 
						name7 => "old_ipmitool_sensor_low_critical",  value7 => $old_ipmitool_sensor_low_critical, 
						name8 => "old_ipmitool_sensor_low_warning",   value8 => $old_ipmitool_sensor_low_warning, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# These will be used in alert messages, if needed.
					my $sensor_name      = "name=$ipmitool_sensor_name:units=$new_ipmitool_sensor_units";
					my $new_sensor_value = "value=$new_ipmitool_value_sensor_value:units=$new_ipmitool_sensor_units";
					my $old_sensor_value = "value=$old_ipmitool_value_sensor_value:units=$old_ipmitool_sensor_units";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
						name1 => "ipmitool_sensor_name", value1 => $ipmitool_sensor_name, 
						name2 => "sensor_name",          value2 => $sensor_name, 
						name3 => "new_sensor_value",     value3 => $new_sensor_value, 
						name4 => "old_sensor_value",     value4 => $old_sensor_value, 
					}, file => $THIS_FILE, line => __LINE__});
					
					### Look for changes
					# Sensor value:
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_ipmitool_value_sensor_value", value1 => $new_ipmitool_value_sensor_value,
						name2 => "old_ipmitool_value_sensor_value", value2 => $old_ipmitool_value_sensor_value, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($new_ipmitool_value_sensor_value ne $old_ipmitool_value_sensor_value)
					{
						# Update (no surprise ...)
						$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
							name1 => "machine",                         value1 => $machine,
							name2 => "sensor_name",                     value2 => $sensor_name, 
							name3 => "new_ipmitool_value_sensor_value", value3 => $new_ipmitool_value_sensor_value, 
							name4 => "old_ipmitool_value_sensor_value", value4 => $old_ipmitool_value_sensor_value, 
						}, file => $THIS_FILE, line => __LINE__});
						my $query = "
UPDATE 
    ipmitool_value 
SET
    ipmitool_value_sensor_value = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_value_sensor_value).", 
    modified_date               = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid)."
;
";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
						
						### NOTE: These are set in 'process_temperature_change()' as 
						###       well, so change the values there if you change it 
						###       here, too.
						# This is an info-level alert, provided it's not gone above
						# or below tolerances.
						my $level       = "info";
						my $title_key   = "an_alert_title_0002";
						my $message_key = "scan_ipmitool_message_0013";
						
						# If this is a temperature, see if we need to 
						# trigger an alarm and set/clear the 'temperature'
						# table entry. 
						# TODO: For the rest of the sensors, we just log 
						#       the changes. If a sensor goes bad, for now
						#       we'll catch errors on the sensor status 
						#       change. We'll add better checks later.
						if ($new_ipmitool_sensor_units eq "C")
						{
							$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
								name1 => "machine",                         value1 => $machine,
								name2 => "sensor_name",                     value2 => $sensor_name, 
								name3 => "new_ipmitool_value_sensor_value", value3 => $new_ipmitool_value_sensor_value, 
								name4 => "old_ipmitool_value_sensor_value", value4 => $old_ipmitool_value_sensor_value, 
							}, file => $THIS_FILE, line => __LINE__});
							($level, $title_key, $message_key) = process_temperature_change($an, $machine, $ipmitool_sensor_name);
							$an->Alert->register_alert({
								alert_level		=>	$level, 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	$title_key,
								alert_message_key	=>	$message_key,
								alert_message_variables	=>	{
									sensor_name		=>	$sensor_name,
									new_sensor_value	=>	$new_sensor_value,
									new_sensor_status	=>	$new_ipmitool_sensor_status,
									new_high_critical	=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : $new_ipmitool_sensor_high_critical,
									new_low_critical	=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : $new_ipmitool_sensor_low_critical,
									new_high_warning	=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : $new_ipmitool_sensor_high_warning,
									new_low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : $new_ipmitool_sensor_low_warning,
									old_sensor_value	=>	$old_sensor_value, 
									old_sensor_status	=>	$old_ipmitool_sensor_status,
									old_high_critical	=>	$old_ipmitool_sensor_high_critical eq "NULL" ? "--" : $old_ipmitool_sensor_high_critical,
									old_low_critical	=>	$old_ipmitool_sensor_low_critical  eq "NULL" ? "--" : $old_ipmitool_sensor_low_critical,
									old_high_warning	=>	$old_ipmitool_sensor_high_warning  eq "NULL" ? "--" : $old_ipmitool_sensor_high_warning,
									old_low_warning		=>	$old_ipmitool_sensor_low_warning   eq "NULL" ? "--" : $old_ipmitool_sensor_low_warning,
								},
							});
						}
						else
						{
							# TODO: Add the checks of variables against
							#       the high/low warning/critical 
							#       thresholds here.
							$an->Alert->register_alert({
								alert_level		=>	$level, 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	$title_key,
								alert_message_key	=>	$message_key,
								alert_message_variables	=>	{
									sensor_name		=>	$sensor_name,
									new_sensor_value	=>	$new_sensor_value,
									old_sensor_value	=>	$old_sensor_value
								},
							});
						}
					}
					else
					{
						# No change.
						$an->Log->entry({log_level => 2, message_key => "scancore_log_0047", file => $THIS_FILE, line => __LINE__});
					}
					
					# Everything else
					if (($new_ipmitool_sensor_units         ne $old_ipmitool_sensor_units) or 
					    ($new_ipmitool_sensor_status        ne $old_ipmitool_sensor_status) or 
					    ($new_ipmitool_sensor_high_critical ne $old_ipmitool_sensor_high_critical) or 
					    ($new_ipmitool_sensor_high_warning  ne $old_ipmitool_sensor_high_warning) or 
					    ($new_ipmitool_sensor_low_critical  ne $old_ipmitool_sensor_low_critical) or 
					    ($new_ipmitool_sensor_low_warning   ne $old_ipmitool_sensor_low_warning))
					{
						# Huh, interesting. Well, update
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_units", value1 => $new_ipmitool_sensor_units, 
							name2 => "old_ipmitool_sensor_units", value2 => $old_ipmitool_sensor_units, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_status", value1 => $new_ipmitool_sensor_status, 
							name2 => "old_ipmitool_sensor_status", value2 => $old_ipmitool_sensor_status, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_high_critical", value1 => $new_ipmitool_sensor_high_critical, 
							name2 => "old_ipmitool_sensor_high_critical", value2 => $old_ipmitool_sensor_high_critical, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_high_warning", value1 => $new_ipmitool_sensor_high_warning, 
							name2 => "old_ipmitool_sensor_high_warning", value2 => $old_ipmitool_sensor_high_warning, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_low_critical", value1 => $new_ipmitool_sensor_low_critical, 
							name2 => "old_ipmitool_sensor_low_critical", value2 => $old_ipmitool_sensor_low_critical, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_low_warning", value1 => $new_ipmitool_sensor_low_warning, 
							name2 => "old_ipmitool_sensor_low_warning", value2 => $old_ipmitool_sensor_low_warning, 
						}, file => $THIS_FILE, line => __LINE__});
						my $query = "
UPDATE 
    ipmitool 
SET
    ipmitool_sensor_units         = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_units).", 
    ipmitool_sensor_status        = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_status).", 
    ipmitool_sensor_high_critical = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_critical).", 
    ipmitool_sensor_high_warning  = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_warning).", 
    ipmitool_sensor_low_critical  = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_critical).", 
    ipmitool_sensor_low_warning   = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_warning).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    ipmitool_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine).";
AND 
    ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid)."
;";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
						
						# If this is a status change, set a 'warning' level alert 
						# unless the change is to/from 'ns'.
						my $level       = "notice";
						my $title_key   = "an_alert_title_0003";
						my $message_key = "scan_ipmitool_message_0012";
						if (($new_ipmitool_sensor_status ne $old_ipmitool_sensor_status) && 
						    ($new_ipmitool_sensor_status ne "ns") &&
						    ($old_ipmitool_sensor_status ne "ns"))
						{
							$level       = "warning";
							$title_key   = "an_alert_title_0004";
							$message_key = "scan_ipmitool_message_0012";
						}
						$an->Alert->register_alert({
							alert_level		=>	$level, 
							alert_agent_name	=>	"$THIS_FILE",
							alert_title_key		=>	$title_key,
							alert_message_key	=>	$message_key,
							alert_message_variables	=>	{
								sensor_name		=>	$sensor_name,
								new_sensor_value	=>	$new_sensor_value,
								old_sensor_value	=>	$old_sensor_value, 
								new_sensor_status	=>	$new_ipmitool_sensor_status, 
								old_sensor_status	=>	$old_ipmitool_sensor_status, 
								new_high_critical	=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$new_ipmitool_sensor_high_critical $new_ipmitool_sensor_units",
								new_high_warning	=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$new_ipmitool_sensor_high_warning $new_ipmitool_sensor_units", 
								new_low_critical	=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$new_ipmitool_sensor_low_critical $new_ipmitool_sensor_units", 
								new_low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$new_ipmitool_sensor_low_warning $new_ipmitool_sensor_units", 
								old_high_critical	=>	$old_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$old_ipmitool_sensor_high_critical $old_ipmitool_sensor_units",
								old_high_warning	=>	$old_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$old_ipmitool_sensor_high_warning $old_ipmitool_sensor_units", 
								old_low_critical	=>	$old_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$old_ipmitool_sensor_low_critical $old_ipmitool_sensor_units", 
								old_low_warning		=>	$old_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$old_ipmitool_sensor_low_warning $old_ipmitool_sensor_units", 
							},
						});
					}
					
					# Delete the old key so that I can check to see what sensors 
					# vanished.
					delete $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name};
				}
				else
				{
					### New record, INSERT it and sent an 'notice' level alert.
					# Generate a new UUID for this ipmi target.
					my $ipmitool_uuid = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
					$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid} = $ipmitool_uuid;
					my $query = "
INSERT INTO 
    ipmitool 
(
    ipmitool_uuid, 
    ipmitool_host_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($machine).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_units).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_status).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query, 
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
					
					# Now INSERT the sensor value.
					$query = "
INSERT INTO 
    ipmitool_value 
(
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_value_sensor_value).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query, 
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
					
					# TODO: Use the following variable/value pairs to have the sensor 
					#       name and value translated/converted to imperial as needed.
					my $sensor_name  = "name=$ipmitool_sensor_name:units=$new_ipmitool_sensor_units";
					my $sensor_value = "value=$new_ipmitool_value_sensor_value:units=$new_ipmitool_sensor_units";
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"scan_ipmitool_title_0001",
						alert_title_variables	=>	{
							machine			=>	$machine,
						},
						alert_message_key	=>	"scan_ipmitool_message_0003",
						alert_message_variables	=>	{
							sensor_name		=>	$sensor_name,
							sensor_value		=>	$sensor_value
						},
					});
					
					# If the sensor is not 'ok', set a warning level alert.
					my $level       = "notice";
					my $title_key   = "an_alert_title_0003";
					my $message_key = "scan_ipmitool_message_0013";
					if ($new_ipmitool_sensor_status ne "ok")
					{
						$level       = "warning";
						$title_key   = "an_alert_title_0004";
						$message_key = "scan_ipmitool_message_0013";
					}
					$an->Alert->register_alert({
						alert_level		=>	$level, 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	$title_key,
						alert_message_key	=>	$message_key,
						alert_message_variables	=>	{
							sensor_name		=>	$sensor_name,
							sensor_value		=>	$sensor_value,
							sensor_status		=>	$new_ipmitool_sensor_status, 
							high_critical		=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$new_ipmitool_sensor_high_critical $new_ipmitool_sensor_units",
							high_warning		=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$new_ipmitool_sensor_high_warning $new_ipmitool_sensor_units", 
							low_critical		=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$new_ipmitool_sensor_low_critical $new_ipmitool_sensor_units", 
							low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$new_ipmitool_sensor_low_warning $new_ipmitool_sensor_units", 
						},
					});
				}
			}
		}
		else
		{
			# New machine, INSERT everything.
			foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{ipmi}{$machine}{ipmitool_sensor_name}})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "ipmitool_sensor_name", value1 => $ipmitool_sensor_name, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Generate and record the UUID
				my $ipmitool_uuid                     = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});
				$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid} = $ipmitool_uuid;
				
				my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
				my $new_ipmitool_sensor_units         = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
				my $new_ipmitool_sensor_status        = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
				my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
				my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
				my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
				my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
					name1 => "ipmitool_uuid",                     value1 => $ipmitool_uuid, 
					name2 => "new_ipmitool_sensor_units",         value2 => $new_ipmitool_sensor_units, 
					name3 => "new_ipmitool_sensor_status",        value3 => $new_ipmitool_sensor_status, 
					name4 => "new_ipmitool_sensor_high_critical", value4 => $new_ipmitool_sensor_high_critical, 
					name5 => "new_ipmitool_sensor_high_warning",  value5 => $new_ipmitool_sensor_high_warning, 
					name6 => "new_ipmitool_sensor_low_critical",  value6 => $new_ipmitool_sensor_low_critical, 
					name7 => "new_ipmitool_sensor_low_warning",   value7 => $new_ipmitool_sensor_low_warning, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $query = "
INSERT INTO 
    ipmitool 
(
    ipmitool_uuid, 
    ipmitool_host_uuid, 
    ipmitool_sensor_name, 
    ipmitool_sensor_host, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).",  
    ".$an->data->{sys}{use_db_fh}->quote($machine).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_units).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_status).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# Now INSERT the sensor value.
				$query = "
INSERT INTO 
    ipmitool_value 
(
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_value_sensor_value).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# We need to let ScanCore translate the sensor data into a string for each 
				# user and their prefered language and units. As such, we're going to use a 
				# couple special variable strings for this.
				my $sensor_name  = "name=$ipmitool_sensor_name:units=$new_ipmitool_sensor_units";
				my $sensor_value = "value=$new_ipmitool_value_sensor_value:units=$new_ipmitool_sensor_units";
				
				# If the sensor is not 'ok', set a warning level alert.
				my $level       = "notice";
				my $title_key   = "an_alert_title_0003";
				my $message_key = "scan_ipmitool_message_0013";
				if ($new_ipmitool_sensor_status ne "ok")
				{
					$level       = "warning";
					$title_key   = "an_alert_title_0004";
					$message_key = "scan_ipmitool_message_0013";
				}
				$an->Alert->register_alert({
					alert_level		=>	$level, 
					alert_agent_name	=>	"$THIS_FILE",
					alert_title_key		=>	$title_key,
					alert_message_key	=>	$message_key,
					alert_message_variables	=>	{
						sensor_name		=>	$sensor_name,
						sensor_value		=>	$sensor_value,
						sensor_status		=>	$new_ipmitool_sensor_status, 
						high_critical		=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$new_ipmitool_sensor_high_critical $new_ipmitool_sensor_units",
						high_warning		=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$new_ipmitool_sensor_high_warning $new_ipmitool_sensor_units", 
						low_critical		=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$new_ipmitool_sensor_low_critical $new_ipmitool_sensor_units", 
						low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$new_ipmitool_sensor_low_warning $new_ipmitool_sensor_units", 
					},
				});
			}
		}
		
		### Now add, update and delete 'temperature' entries.
		process_temperature($an, $machine);
	}
	
	# Now commit the changes.
	commit_sql($an);
	
	return(0);
}

# This takes the temperature sensors and feeds them into the 'temperature' table, deleting stale entries as needed.
sub process_temperature
{
	my ($an, $machine) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_temperature" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "machine", value1 => $machine, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, read in all existing entries. We'll compare and UPDATE or INSERT as needed and DELETE any 
	# stale entries.
	my $query = "
SELECT 
    temperature_uuid, 
    temperature_sensor_name, 
    temperature_celsius,
    temperature_state,
    temperature_is
FROM 
    temperature 
WHERE 
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)." 
AND
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $temperature_uuid     = $row->[0]; 
		my $ipmitool_sensor_name = $row->[1];
		my $temperature_celsius  = $row->[2];
		my $temperature_state    = $row->[3];
		my $temperature_is       = $row->[4];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "temperature_uuid",     value1 => $temperature_uuid,
			name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name,
			name3 => "temperature_celsius",  value3 => $temperature_celsius,
			name4 => "temperature_state",    value4 => $temperature_state,
			name5 => "temperature_is",       value5 => $temperature_is,
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_uuid	=>	$temperature_uuid, 
			temperature_celsius	=>	$temperature_celsius,
			temperature_state	=>	$temperature_state,
			temperature_is		=>	$temperature_is,
		};
	}
	
	# Look at the new values.
	foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{new}{$machine}{temperature}})
	{
		my $new_temperature_uuid    = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_uuid};
		my $new_temperature_celsius = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius};
		my $new_temperature_state   = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state};
		my $new_temperature_is      = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "ipmitool_sensor_name",    value1 => $ipmitool_sensor_name,
			name2 => "new_temperature_uuid",    value2 => $new_temperature_uuid, 
			name3 => "new_temperature_celsius", value3 => $new_temperature_celsius,
			name4 => "new_temperature_state",   value4 => $new_temperature_state,
			name5 => "new_temperature_is",      value5 => $new_temperature_is,
		}, file => $THIS_FILE, line => __LINE__});
		
		if (ref($an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}))
		{
			# Update the existing entry, if needed.
			my $old_temperature_uuid    = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_uuid};
			my $old_temperature_celsius = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius};
			my $old_temperature_state   = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state};
			my $old_temperature_is      = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "old_temperature_uuid",     value1 => $old_temperature_uuid,
				name2 => "old_temperature_celsius",  value2 => $old_temperature_celsius,
				name3 => "old_temperature_state",    value3 => $old_temperature_state,
				name4 => "old_temperature_is",       value4 => $old_temperature_is,
			}, file => $THIS_FILE, line => __LINE__});
			
			if (($new_temperature_celsius ne $old_temperature_celsius) || 
			    ($new_temperature_state   ne $old_temperature_state)   ||
			    ($new_temperature_is      ne $old_temperature_is))
			{
				my $query = "
UPDATE 
    temperature 
SET 
    temperature_celsius = ".$an->data->{sys}{use_db_fh}->quote($new_temperature_celsius).", 
    temperature_state   = ".$an->data->{sys}{use_db_fh}->quote($new_temperature_state).", 
    temperature_is      = ".$an->data->{sys}{use_db_fh}->quote($new_temperature_is).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    temperature_uuid = ".$an->data->{sys}{use_db_fh}->quote($old_temperature_uuid).";
";
				push @{$an->data->{sys}{sql}}, $query;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# No change.
				$an->Log->entry({log_level => 2, message_key => "scan_ipmitool_log_0004", message_variables => {
					sensor_name => $ipmitool_sensor_name,
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# We still want this value, so delete it from the hash so it doesn't get deleted in 
			# the next step.
			delete $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name};
		}
		else
		{
			### New entry
			# Generate and store the UUID.
			my $ipmitool_uuid = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
			$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{ipmitool_uuid} = $ipmitool_uuid;
			my $query         = "
INSERT INTO 
    temperature 
(
    temperature_uuid, 
    temperature_host_uuid, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_agent_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($machine).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_temperature_celsius).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_temperature_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_temperature_is).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
			push @{$an->data->{sys}{sql}}, $query;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
		}
	}

	# Now, if any undeleted old entries remain, delete them from the database.
	foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{old}{$machine}{temperature}})
	{
		my $old_temperature_celsius = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius};
		my $old_temperature_state   = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state};
		my $old_temperature_is      = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is};
		
		# Mark the sensor as DELETEd.
		my $query = "
UPDATE 
    temperature 
SET 
    temperature_state = 'DELETED', 
    modified_date     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND
    temperature_sensor_name = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name)."
AND
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)." 
AND
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine).";
";
		push @{$an->data->{sys}{sql}}, $query;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$query = "
DELETE FROM 
    temperature 
WHERE
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND
    temperature_sensor_name = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name)." 
AND
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)."
AND
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine).";
";
		push @{$an->data->{sys}{sql}}, $query;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This logs thermal sensor values that are outside nominal ranges
sub log_abnormal_temperatures
{
	my ($an, $machine, $ipmitool_sensor_name) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "log_abnormal_temperatures" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "machine",              value1 => $machine, 
		name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
	my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
	my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
	my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
	my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
	
	### High Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning}, 
		name2 => "new_ipmitool_sensor_high_warning",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $high_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning} =~ /^\d/))
	{
		$high_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning};
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_warning = $new_ipmitool_sensor_high_critical;
	}
	
	### High Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical}, 
		name2 => "new_ipmitool_sensor_high_critical",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $high_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical} =~ /^\d/))
	{
		$high_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical};
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_critical = $new_ipmitool_sensor_high_critical;
	}
	
	### Low Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning}, 
		name2 => "new_ipmitool_sensor_low_warning",                                 value2 => $new_ipmitool_sensor_low_warning, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning} =~ /^\d/))
	{
		$low_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning};
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_warning = $new_ipmitool_sensor_low_critical;
	}
	
	### Low Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical}, 
		name2 => "new_ipmitool_sensor_low_critical",                                 value2 => $new_ipmitool_sensor_low_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical} =~ /^\d/))
	{
		$low_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical};
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_critical = $new_ipmitool_sensor_low_critical;
	}
	
	# Record the levels
	$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
		name1 => "machine",                         value1 => $machine,
		name2 => "ipmitool_sensor_name",            value2 => $ipmitool_sensor_name,
		name3 => "high_warning",                    value3 => $high_warning, 
		name4 => "high_critical",                   value4 => $high_critical, 
		name5 => "low_warning",                     value5 => $low_warning, 
		name6 => "low_critical",                    value6 => $low_critical, 
		name7 => "new_ipmitool_value_sensor_value", value7 => $new_ipmitool_value_sensor_value,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Record the temperatures that are outside their nominal range
	if ($new_ipmitool_value_sensor_value < $low_critical)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'critical',
			temperature_is		=>	'low',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_value_sensor_value < $low_warning)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'warning',
			temperature_is		=>	'low',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_value_sensor_value > $high_critical)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'critical',
			temperature_is		=>	'high',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_value_sensor_value > $high_warning)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'warning',
			temperature_is		=>	'high',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# When the dashboard scans a node, it needs to know about the Ambient and Systemboard temperatures in
	# order to device whether the node is safe too boot back up or not. So if this machine is a 
	# dashboard, log the 'Ambient' and 'Systemboard' temperatures (or whatever the user defined) as 
	# 'good', if they're not already in the 'new::temperature::x' hash.
	my $i_am_a = $an->Get->what_am_i();
	foreach my $sensor (split/,/, $an->data->{'scan-ipmitool'}{offline_sensor_list})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "sensor",               value1 => $sensor, 
			name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name, 
			name3 => "i_am_a",               value3 => $i_am_a, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($ipmitool_sensor_name eq $sensor) && 
		    ($i_am_a               eq "dashboard") && 
		    (not exists $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}))
		{
			$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
				temperature_celsius	=>	$new_ipmitool_value_sensor_value,
				temperature_state	=>	'ok',
				temperature_is		=>	'nominal',
			};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
				name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
				name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This processes a temperature sensor, handling changes and recording values that are in a warning or 
# critical state.
sub process_temperature_change
{
	my ($an, $machine, $ipmitool_sensor_name) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_temperature_change" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "machine",              value1 => $machine, 
		name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# This is a repeat of some variables set before this function was called, but setting them here again
	# saves passing in a pile of variables.
	my $level       = "info";
	my $title_key   = "an_alert_title_0002";
	my $message_key = "scan_ipmitool_message_0012";
	
	# New values
	my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
	my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
	my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
	my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
	my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
		name1 => "new_ipmitool_value_sensor_value",   value1 => $new_ipmitool_value_sensor_value, 
		name2 => "new_ipmitool_sensor_high_critical", value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "new_ipmitool_sensor_high_warning",  value3 => $new_ipmitool_sensor_high_warning, 
		name4 => "new_ipmitool_sensor_low_critical",  value4 => $new_ipmitool_sensor_low_critical, 
		name5 => "new_ipmitool_sensor_low_warning",   value5 => $new_ipmitool_sensor_low_warning, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Old value, if it exists.
	my $old_ipmitool_value_sensor_value = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value} ? $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value} : 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_value_sensor_value", value1 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value}, 
		name2 => "old_ipmitool_value_sensor_value",                                                             value2 => $old_ipmitool_value_sensor_value, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### Buffer, used for clearing all alerts.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::buffer",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{buffer}, 
		name2 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::buffer", value2 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{buffer}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $buffer = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{buffer} ? $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{buffer} : $an->data->{'scan-ipmitool'}{thresholds}{'default'}{buffer};
	
	### High Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning}, 
		name2 => "new_ipmitool_sensor_high_warning",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $high_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning};
	
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning} =~ /^\d/))
	{
		$high_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning};
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_warning = $new_ipmitool_sensor_high_critical;
	}
	
	### High Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical}, 
		name2 => "new_ipmitool_sensor_high_critical",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $high_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical} =~ /^\d/))
	{
		$high_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical};
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_critical = $new_ipmitool_sensor_high_critical;
	}
	
	### Low Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning}, 
		name2 => "new_ipmitool_sensor_low_warning",                                 value2 => $new_ipmitool_sensor_low_warning, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning} =~ /^\d/))
	{
		$low_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning};
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_warning = $new_ipmitool_sensor_low_critical;
	}
	
	### Low Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical}, 
		name2 => "new_ipmitool_sensor_low_critical",                                 value2 => $new_ipmitool_sensor_low_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical} =~ /^\d/))
	{
		$low_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical};
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_critical = $new_ipmitool_sensor_low_critical;
	}
	
	### Jump delta
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::jump",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{jump}, 
		name2 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::jump", value2 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{jump}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $jump = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{jump};
	if ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{jump})
	{
		$jump = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{jump};
	}
	
	# Final levels
	$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
		name1 => "machine",              value1 => $machine,
		name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name,
		name3 => "high_warning",         value3 => $high_warning, 
		name4 => "high_critical",        value4 => $high_critical, 
		name5 => "low_warning",          value5 => $low_warning, 
		name6 => "low_critical",         value6 => $low_critical, 
		name7 => "jump",                 value7 => $jump, 
		name8 => "buffer",               value8 => $buffer,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Now, has the value climbed, fallen or stayed the same? Pretend it's rising if it's a new sensor.
	if (($new_ipmitool_value_sensor_value > $old_ipmitool_value_sensor_value) || (not $old_ipmitool_value_sensor_value))
	{
		### Rising.
		# 
		# If it is over the high critical level, clear the 'warning', set the 'critical' and, if 
		# needed, add the entry to 'temperature'.
		# 
		# If it is over the high warning, check and set the warning.
		# 
		# If it's over the low warning, check and clear both critical and warning, and clear the
		# 'temperature' entry, if needed.
		#
		# If it's over the low critical, but not low warning, clear the critical and set the warning.
		# Clear the 'temperature' entry, if it exists.
		# 
		# If the temperature jumped above the set per-cycle change limit, trigger an alarm no matter
		# what.
		if ($new_ipmitool_value_sensor_value > $high_critical)
		{
			# We've gone critical. If it was previously 'warning', clear them.
			foreach my $type ("temperature_high_warning", "temperature_low_warning", "temperature_low_critical")
			{
				$an->Alert->check_alert_sent({
					type			=>	"clear",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
					alert_name		=>	$type,
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
			}
			
			# Set the critical warning.
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			
			# If set, alert the user and register with 'temperature'.
			if ($set)
			{
				# This is the first time we climbed. Send an alert and then register the 
				# entry in the database's 'temperature' table.
				$level       = "critical";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0004";
			}
		}
		elsif ($new_ipmitool_value_sensor_value > $high_warning)
		{
			# The temp is rising, so the 'high_critical' should not be set, but check/clear it 
			# anyway to be safe.
			$an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($set)
			{
				# Tell the user that the temperature is rising.
				$level       = "warning";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0005";
			}
		}
		elsif ($new_ipmitool_value_sensor_value > ($low_warning + $buffer))
		{
			# If there was a 'low_warning' or 'low_critical', clear it and tell the user that 
			# we're OK now.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $clear_warning = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if (($clear_critical) or ($clear_warning))
			{
				# Tell the user we're OK again. Whether this is a 'critical' or 'warning' 
				# level alert depends on what it was before. We want people who only get 
				# critical alerts to know we're OK if they got the critical alarm.
				$level       = $clear_critical ? "critical" : "warning";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0006";
			}
		}
		elsif ($new_ipmitool_value_sensor_value > ($low_critical + $buffer))
		{
			# It has risen above critically low levels.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($clear_critical)
			{
				# Tell the user we're getting better.
				$level       = "critical";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0010";
			}
		}
		else
		{
			# It's floating in the safe area.
		}
		
		# Check for a jump now, if we have an old value.
		if ($old_ipmitool_value_sensor_value)
		{
			my $delta = ($new_ipmitool_value_sensor_value - $old_ipmitool_value_sensor_value);
			if ($delta > $jump)
			{
				# Temperature jumped. This is a stand-alone 'warning' level alarm.
				my $sensor_name      = "name=$ipmitool_sensor_name:units=C";
				my $new_sensor_value = "value=$new_ipmitool_value_sensor_value:units=C";
				my $old_sensor_value = "value=$old_ipmitool_value_sensor_value:units=C";
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_agent_name	=>	"$THIS_FILE",
					alert_title_key		=>	"an_alert_title_0004",
					alert_message_key	=>	"scan_ipmitool_message_0007",
					alert_message_variables	=>	{
						sensor_name		=>	$sensor_name,
						new_sensor_value	=>	$new_sensor_value,
						old_sensor_value	=>	$old_sensor_value
					},
				});
			}
		}
	}
	elsif ($new_ipmitool_value_sensor_value < $old_ipmitool_value_sensor_value)
	{
		### Falling.
		#
		# If it's below the high critical, but not high warning, clear the critical and set the 
		# warning. Clear the 'temperature' entry, if it exists.
		# 
		# If it's below the high warning, check and clear both critical and warning, and clear the
		# 'temperature' entry, if needed.
		# 
		# If it is below the low critical level, clear the 'warning', set the 'critical' and, if 
		# needed, add the entry to 'temperature'.
		# 
		# If it is below the low warning, check and set the warning.
		if ($new_ipmitool_value_sensor_value < $low_critical)
		{
			# We've gone critical. Clear previous alerts...
			foreach my $type ("temperature_high_critical", "temperature_high_warning", "temperature_low_warning")
			{
				$an->Alert->check_alert_sent({
					type			=>	"clear",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
					alert_name		=>	$type,
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
			}
			
			# Now set the critical warning.
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			
			# If set, alert the user and register with 'temperature'.
			if ($set)
			{
				# This is the first time we climbed. Send an alert and then register the 
				# entry in the database's 'temperature' table.
				$level       = "critical";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0008";
			}
		}
		elsif ($new_ipmitool_value_sensor_value < $low_warning)
		{
			# The temp is dropping, so the 'low_critical' should not be set, but check/clear it 
			# anyway to be safe.
			$an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($set)
			{
				# Tell the user that the temperature is rising.
				$level       = "warning";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0009";
			}
		}
		elsif ($new_ipmitool_value_sensor_value < ($high_warning - $buffer))
		{
			# If there was a 'high_warning' or 'high_critical', clear it and tell the user that 
			# we're OK now.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $clear_warning = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if (($clear_critical) or ($clear_warning))
			{
				# Tell the user we're OK again. Whether this is a 'critical' or 'warning' 
				# level alert depends on what it was before. We want people who only get 
				# critical alerts to know we're OK if they got the critical alarm.
				$level       = $clear_critical ? "critical" : "warning";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0006";
			}
		}
		elsif ($new_ipmitool_value_sensor_value < ($high_critical - $buffer))
		{
			# It is below critically high levels.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($clear_critical)
			{
				# Tell the user we're OK again.
				$level       = "critical";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0011";
			}
		}
		else
		{
			# It's floating in the safe area.
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "title_key",   value1 => $title_key, 
		name2 => "message_key", value2 => $message_key, 
	}, file => $THIS_FILE, line => __LINE__});
	return($level, $title_key, $message_key);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an, $machine) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "machine", value1 => "$machine" 
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: This might be useful later
	# Make sure I don't have any stray data for this machine.
	#delete $an->data->{sql}{$machine};
	
	# Read in existing data, if any.
	my $query = "
SELECT 
    a.ipmitool_uuid, 
    a.ipmitool_sensor_name, 
    a.ipmitool_sensor_units, 
    a.ipmitool_sensor_status, 
    a.ipmitool_sensor_high_critical, 
    a.ipmitool_sensor_high_warning, 
    a.ipmitool_sensor_low_critical, 
    a.ipmitool_sensor_low_warning, 
    b.ipmitool_value_sensor_value 
FROM 
    ipmitool a, 
    ipmitool_value b 
WHERE 
    a.ipmitool_uuid = b.ipmitool_value_ipmitool_uuid
AND 
    a.ipmitool_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine)." 
AND 
    a.ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $ipmitool_uuid                 = $row->[0];
		my $ipmitool_sensor_name          = $row->[1];
		my $ipmitool_sensor_units         = $row->[2];
		my $ipmitool_sensor_status        = $row->[3];
		my $ipmitool_sensor_high_critical = $row->[4];
		my $ipmitool_sensor_high_warning  = $row->[5];
		my $ipmitool_sensor_low_critical  = $row->[6];
		my $ipmitool_sensor_low_warning   = $row->[7];
		my $ipmitool_value_sensor_value   = $row->[8];
		
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid}                 = $ipmitool_uuid;
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units}         = $ipmitool_sensor_units;
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status}        = $ipmitool_sensor_status;
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical} = $ipmitool_sensor_high_critical ? $ipmitool_sensor_high_critical : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning}  = $ipmitool_sensor_high_warning  ? $ipmitool_sensor_high_warning  : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical}  = $ipmitool_sensor_low_critical  ? $ipmitool_sensor_low_critical  : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning}   = $ipmitool_sensor_low_warning   ? $ipmitool_sensor_low_warning   : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value}   = $ipmitool_value_sensor_value;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_uuid",                 value1 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid}, 
			name2 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_units",         value2 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units}, 
			name3 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_status",        value3 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status}, 
			name4 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_high_critical", value4 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical}, 
			name5 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_high_warning",  value5 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning}, 
			name6 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_low_critical",  value6 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical}, 
			name7 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_low_warning",   value7 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning}, 
			name8 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_value_sensor_value",   value8 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return($count);
}

# This looks at each DB's 'updated' table entry to see if any tables are behind. If any are, it will update 
# the tables based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Update apc_ups and interfaces
		update_db_ipmitool($an);
		update_db_ipmitool_value($an);
	}
	
	return(0);
}

# Update the 'ipmitool_value' table.
sub update_db_ipmitool_value
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_ipmitool_value" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'ipmitool_value' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    a.ipmitool_value_ipmitool_uuid, 
    a.ipmitool_value_sensor_value, 
    a.modified_date 
FROM 
    history.ipmitool_value a, 
    ipmitool b 
WHERE 
    a.ipmitool_value_ipmitool_uuid = b.ipmitool_uuid 
AND 
    b.ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $ipmitool_value_ipmitool_uuid = $row->[0]; 
			my $ipmitool_value_sensor_value  = $row->[1]; 
			my $modified_date                = $row->[2];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "ipmitool_value_ipmitool_uuid", value1 => $ipmitool_value_ipmitool_uuid, 
				name2 => "ipmitool_value_sensor_value",  value2 => $ipmitool_value_sensor_value, 
				name3 => "modified_date",                value3 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid} = {
				ipmitool_value_sensor_value	=>	$ipmitool_value_sensor_value, 
			};
			$an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid} = {
				ipmitool_value_sensor_value	=>	$ipmitool_value_sensor_value, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{ipmitool_value}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $ipmitool_value_ipmitool_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}})
		{
			my $ipmitool_value_sensor_value = $an->data->{db_data}{unified}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{ipmitool_value_sensor_value}; 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "ipmitool_value_ipmitool_uuid", value1 => $ipmitool_value_ipmitool_uuid, 
				name2 => "ipmitool_value_sensor_value",  value2 => $ipmitool_value_sensor_value, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'ipmitool_value_ipmitool_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::ipmitool_value::ipmitool_value_ipmitool_uuid::${ipmitool_value_ipmitool_uuid}::seen", value1 => $an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::ipmitool_value::ipmitool_value_ipmitool_uuid::${ipmitool_value_ipmitool_uuid}::exists", value1 => $an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::ipmitool_value::modified_date::${modified_date}::ipmitool_value_ipmitool_uuid::${ipmitool_value_ipmitool_uuid}", value1 => $an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.ipmitool_value
SET
    ipmitool_value_sensor_value = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_sensor_value).", 
    modified_date               = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.ipmitool_value
(
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_sensor_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'ipmitool_value_ipmitool_uuid' before, so it's just
					# a question of whether the entry for the current timestamp exists in
					# the history schema.
					if (not $an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.ipmitool_value
(
    ipmitool_value_id, 
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date 
) VALUES (
    (
        SELECT 
            ipmitool_value_id 
        FROM 
            public.ipmitool_value 
        WHERE 
            ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid)."
    ), 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_sensor_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen ipmitool_value_ipmitool_uuid?
			} # foreach my $id 
		} # foreach my $ipmitool_value_ipmitool_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'ipmitool' DB table, if needed.
sub update_db_ipmitool
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_ipmitool" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'ipmitool' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    ipmitool_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date 
FROM 
    history.ipmitool 
WHERE
    ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $ipmitool_uuid                 = $row->[0];
			my $ipmitool_sensor_host          = $row->[1];
			my $ipmitool_sensor_name          = $row->[2];
			my $ipmitool_sensor_units         = $row->[3];
			my $ipmitool_sensor_status        = $row->[4];
			my $ipmitool_sensor_high_critical = $row->[5];
			my $ipmitool_sensor_high_warning  = $row->[6];
			my $ipmitool_sensor_low_critical  = $row->[7];
			my $ipmitool_sensor_low_warning   = $row->[8];
			my $modified_date                 = $row->[9];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "ipmitool_uuid",                 value1  => $ipmitool_uuid, 
				name2  => "ipmitool_sensor_host",          value2  => $ipmitool_sensor_host, 
				name3  => "ipmitool_sensor_name",          value3  => $ipmitool_sensor_name, 
				name4  => "ipmitool_sensor_units",         value4  => $ipmitool_sensor_units, 
				name5  => "ipmitool_sensor_status",        value5  => $ipmitool_sensor_status, 
				name6  => "ipmitool_sensor_high_critical", value6  => $ipmitool_sensor_high_critical, 
				name7  => "ipmitool_sensor_high_warning",  value7  => $ipmitool_sensor_high_warning, 
				name8  => "ipmitool_sensor_low_critical",  value8  => $ipmitool_sensor_low_critical, 
				name9  => "ipmitool_sensor_low_warning",   value9  => $ipmitool_sensor_low_warning, 
				name10 => "modified_date",                 value10 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid} = {
				ipmitool_uuid			=>	$ipmitool_uuid, 
				ipmitool_sensor_host		=>	$ipmitool_sensor_host, 
				ipmitool_sensor_name		=>	$ipmitool_sensor_name, 
				ipmitool_sensor_units		=>	$ipmitool_sensor_units, 
				ipmitool_sensor_status		=>	$ipmitool_sensor_status, 
				ipmitool_sensor_high_critical	=>	$ipmitool_sensor_high_critical, 
				ipmitool_sensor_high_warning	=>	$ipmitool_sensor_high_warning, 
				ipmitool_sensor_low_critical	=>	$ipmitool_sensor_low_critical, 
				ipmitool_sensor_low_warning	=>	$ipmitool_sensor_low_warning, 
			};
			$an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid} = {
				ipmitool_uuid			=>	$ipmitool_uuid, 
				ipmitool_sensor_host		=>	$ipmitool_sensor_host, 
				ipmitool_sensor_name		=>	$ipmitool_sensor_name, 
				ipmitool_sensor_units		=>	$ipmitool_sensor_units, 
				ipmitool_sensor_status		=>	$ipmitool_sensor_status, 
				ipmitool_sensor_high_critical	=>	$ipmitool_sensor_high_critical, 
				ipmitool_sensor_high_warning	=>	$ipmitool_sensor_high_warning, 
				ipmitool_sensor_low_critical	=>	$ipmitool_sensor_low_critical, 
				ipmitool_sensor_low_warning	=>	$ipmitool_sensor_low_warning, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{ipmitool}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $ipmitool_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}})
		{
			my $ipmitool_sensor_host          = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_host};
			my $ipmitool_sensor_name          = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_name};
			my $ipmitool_sensor_units         = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_units};
			my $ipmitool_sensor_status        = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_status};
			my $ipmitool_sensor_high_critical = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_high_critical};
			my $ipmitool_sensor_high_warning  = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_high_warning};
			my $ipmitool_sensor_low_critical  = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_low_critical};
			my $ipmitool_sensor_low_warning   = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_low_warning};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1  => "ipmitool_uuid",                 value1  => $ipmitool_uuid, 
				name2  => "ipmitool_sensor_host",          value2  => $ipmitool_sensor_host, 
				name3  => "ipmitool_sensor_name",          value3  => $ipmitool_sensor_name, 
				name4  => "ipmitool_sensor_units",         value4  => $ipmitool_sensor_units, 
				name5  => "ipmitool_sensor_status",        value5  => $ipmitool_sensor_status, 
				name6  => "ipmitool_sensor_high_critical", value6  => $ipmitool_sensor_high_critical, 
				name7  => "ipmitool_sensor_high_warning",  value7  => $ipmitool_sensor_high_warning, 
				name8  => "ipmitool_sensor_low_critical",  value8  => $ipmitool_sensor_low_critical, 
				name9  => "ipmitool_sensor_low_warning",   value9  => $ipmitool_sensor_low_warning, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'ipmitool_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::ipmitool::ipmitool_uuid::${ipmitool_uuid}::seen", value1 => $an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::ipmitool::ipmitool_uuid::${ipmitool_uuid}::exists", value1 => $an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::ipmitool::modified_date::${modified_date}::ipmitool_uuid::${ipmitool_uuid}", value1 => $an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.ipmitool
SET
    ipmitool_sensor_host          = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_host).", 
    ipmitool_sensor_name          = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ipmitool_sensor_units         = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_units).", 
    ipmitool_sensor_status        = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_status).", 
    ipmitool_sensor_high_critical = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_critical).", 
    ipmitool_sensor_high_warning  = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_warning).", 
    ipmitool_sensor_low_critical  = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_critical).", 
    ipmitool_sensor_low_warning   = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_warning).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    ipmitool_uuid      = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.ipmitool
(
    ipmitool_host_uuid, 
    ipmitool_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_units).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'ipmitool_uuid' before, so it's just a question of 
					# whether the entry for the current timestamp exists in the history 
					# schema.
					if (not $an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.ipmitool
(
    ipmitool_host_uuid, 
    ipmitool_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_units).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen ipmitool_uuid?
			} # foreach my $id 
		} # foreach my $ipmitool_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}

	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load the schema. If the schema gets
# loaded, we'll check other databases for older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => "$THIS_FILE" }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='ipmitool' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# Query IPMI targets. Unreachable targets will simply be ignored.
sub query_ipmi_targets
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "query_ipmi_targets" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	foreach my $machine (sort {$a cmp $b} keys %{$an->data->{'scan-ipmitool'}{machine}})
	{
		my $ipmitool_command = $an->data->{'scan-ipmitool'}{machine}{$machine}{ipmitool_command};
		my $ipmi_password    = $an->data->{'scan-ipmitool'}{machine}{$machine}{ipmi_password};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "machine",          value1 => $machine,
			name2 => "ipmitool_command", value2 => $ipmitool_command,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "ipmi_password", value1 => $ipmi_password, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# If there is a password, write it to a temp file.
		my $temp_file  = "";
		if ($ipmi_password)
		{
			# Write the password to a temp file.
			   $temp_file  = "/tmp/scan-ipmitool";
			my $shell_call = $temp_file;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, ">$shell_call") or $an->Alert->error({fatal => 0, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
			print $file_handle $ipmi_password;
			close $file_handle;
		}
		
		# Time the call.
		my $read_start_time = time;
		$an->Log->entry({log_level => 2, message_key => "scan_ipmitool_log_0001", message_variables => {
			machine => $machine, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Call!
		my $shell_call = "$ipmitool_command sensor list all";
		if ($ipmi_password)
		{
			$shell_call = "$ipmitool_command -f $temp_file sensor list all";
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call." 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+\|/|/g;
			   $line =~ s/\|\s+/|/g;
			   $line =~ s/na//g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Catch errors:
			if ($line =~ /Activate Session command failed/)
			{
				# Failed to connect.
				$an->Log->entry({log_level => 1, message_key => "scan_ipmitool_log_0003", message_variables => {
					machine	=> $machine, 
					call	=> $ipmitool_command, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			next if $line !~ /\|/;
			
			#     high fail -------------------------------------.
			# high critical ---------------------------------.   |
			#  high warning -----------------------------.   |   |
			#   low warning -------------------------.   |   |   |
			#  low critical ---------------------.   |   |   |   |
			#      low fail -----------------.   |   |   |   |   |
			#        status -------------.   |   |   |   |   |   |
			#         units ---------.   |   |   |   |   |   |   |
			# current value -----.   |   |   |   |   |   |   |   |
			#   sensor name -.   |   |   |   |   |   |   |   |   |
			# Columns:       |   |   |   |   |   |   |   |   |   |
			#                x | x | x | x | x | x | x | x | x | x 
			my ($sensor_name, 
				$current_value, 
				$units, 
				$status, 
				$low_fail, 
				$low_critical, 
				$low_warning, 
				$high_warning, 
				$high_critical, 
				$high_fail) = split /\|/, $line;
			
			next if not $sensor_name;
			next if not $status;
			next if not $status;
			next if $units =~ /discrete/;
			#next if $status =~ /^0x/;
			$units = "C" if $units =~ /degrees C/i;
			$units = "F" if $units =~ /degrees F/i;
			$units = "%" if $units =~ /percent/i;
			$units = "W" if $units =~ /watt/i;
			$units = "V" if $units =~ /volt/i;
			
			# Values in the DB that are 'double precision' must be 'NULL' if not set.
			$current_value = 'NULL' if not $current_value;
			$low_fail      = 'NULL' if not $low_fail;
			$low_critical  = 'NULL' if not $low_critical;
			$low_warning   = 'NULL' if not $low_warning;
			$high_warning  = 'NULL' if not $high_warning;
			$high_critical = 'NULL' if not $high_critical;
			$high_fail     = 'NULL' if not $high_fail;
			
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "sensor_name",   value1  => $sensor_name, 
				name2  => "current_value", value2  => $current_value, 
				name3  => "units",         value3  => $units, 
				name4  => "status",        value4  => $status, 
				name5  => "low_fail",      value5  => $low_fail, 
				name6  => "low_critical",  value6  => $low_critical, 
				name7  => "low_warning",   value7  => $low_warning, 
				name8  => "high_warning",  value8  => $high_warning, 
				name9  => "high_critical", value9  => $high_critical, 
				name10 => "high_fail",     value10 => $high_fail, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($units eq "F")
			{
				# Convert to 'C'
				$high_critical = $an->Convert->convert_to_celsius({temperature => $high_critical}) if $high_critical ne "";
				$high_warning  = $an->Convert->convert_to_celsius({temperature => $high_warning})  if $high_warning  ne "";
				$low_critical  = $an->Convert->convert_to_celsius({temperature => $low_critical})  if $low_critical  ne "";
				$low_warning   = $an->Convert->convert_to_celsius({temperature => $low_warning})   if $low_warning   ne "";
			}
			# Record
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_value_sensor_value}   = $current_value;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_units}         = $units;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_status}        = $status;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_critical} = $high_critical;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_warning}  = $high_warning;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_critical}  = $low_critical;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_warning}   = $low_warning;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_value_sensor_value",   value1 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_value_sensor_value}, 
				name2 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_units",         value2 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_units}, 
				name3 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_status",        value3 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_status}, 
				name4 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_high_critical", value4 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_critical}, 
				name5 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_high_warning",  value5 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_warning}, 
				name6 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_low_critical",  value6 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_critical}, 
				name7 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_low_warning",   value7 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_warning}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If this is a temperature, check to see if it is outside it's nominal range and, if
			# so, record it into a hash for loading into ScanCore's 'temperature' table.
			if ($units eq "C")
			{
				log_abnormal_temperatures($an, $machine, $sensor_name);
			}
		}
		close $file_handle;
		
		# Delete the temp file.
		unlink $temp_file;
		
		# Record how long it took.
		my $sensor_read_time = $an->Readable->time({'time' => (time - $read_start_time)});
		$an->Log->entry({log_level => 2, message_key => "scan_ipmitool_log_0002", message_variables => {
			machine	=>	$machine, 
			'time'	=>	$sensor_read_time
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

### TODO: This currently has no way of dealing with IPMI-equiped dashboards.
# This calls anvil-report-ipmi-details to find IPMI devices to scan. It also handles any user-defined IPMI 
# devices set in striker.conf.
sub find_ipmi_targets
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_ipmi_targets" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will keep track of how many IPMI targets we find.
	my $ipmi_targets = 0;

	# If I am a node, I will only scan myself.
	my $i_am_a   = $an->Get->what_am_i();
	my $hostname = $an->hostname();
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "i_am_a",   value1 => $i_am_a,
		name2 => "hostname", value2 => $hostname
	}, file => $THIS_FILE, line => __LINE__});
	
	# This returns an array of power_check commands that this machine knows about.
	my $power_check_data = $an->ScanCore->get_power_check_data();
	foreach my $hash_ref (@{$power_check_data})
	{
		my $node_name           = $hash_ref->{node_name};
		my $node_uuid           = $hash_ref->{node_uuid};
		my $power_check_command = $hash_ref->{power_check_command};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "node_name",           value1 => $node_name,
			name2 => "node_uuid",           value2 => $node_uuid, 
			name3 => "power_check_command", value3 => $power_check_command, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Get the ipaddress and see if I can ping the target. If I can't, there is no sense in 
		# recording this entry.
		my $access = 0;
		my $target = ($power_check_command =~ /-a (.*?) /)[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "target", value1 => $target,
		}, file => $THIS_FILE, line => __LINE__});
		if ($target)
		{
			$access = $an->Check->ping({ping => $target});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "access", value1 => $access,
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $access;
		$ipmi_targets++;
		
		# I need to remove the double-quotes from the '-p "<password>"'.
		$power_check_command =~ s/-p "(.*?)"/-p $1/;
		
		# Convert to an 'ipmitool' call.
		my $ipmitool_command = $an->data->{path}{ipmitool};
		my $ipmi_password    = "";
		if ($power_check_command =~ /-A (.*?) /) { $ipmitool_command .= " -A $1"; }	# IPMI Lan Auth type (md5, password, or none)
		if ($power_check_command =~ /-a (.*?) /) { $ipmitool_command .= " -H $1"; }	# IPMI Lan IP to talk to
		if ($power_check_command =~ /-P (.*?) /) { $ipmitool_command .= " -I $1"; }	# Use Lanplus to improve security of connection
		if ($power_check_command =~ /-l (.*?) /) { $ipmitool_command .= " -U $1"; }	# Username/Login (if required) to control power on IPMI device
		if ($power_check_command =~ /-C (.*?) /) { $ipmitool_command .= " -C $1"; }	# Ciphersuite to use (same as ipmitool -C parameter)
		if ($power_check_command =~ /-L (.*?) /) { $ipmitool_command .= " -L $1"; }	# Privilege level on IPMI device
		
		if ($power_check_command =~ /-p (.*?) /) { $ipmi_password .= "$1"; }	# Password (if required) to control power on IPMI device
		
		### TODO: Find a way to get this info... may need to add it to the cache.
		#if ($power_check_command =~ /-S (.*?) /) { $ipmi_password .= "$1"; }	# Script to retrieve password (if required)
		
		# Currently unsupported.
		#if ($power_check_command =~ /-t (.*?) /) { $ipmitool_command .= " - $1"; }	# Timeout (sec) for IPMI operation
		#if ($power_check_command =~ /-T (.*?) /) { $ipmitool_command .= " - $1"; }	# Wait X seconds after on/off operation (Default Value: 2)
		
		$an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command} = $power_check_command;
		$an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command}    = $ipmitool_command;
		$an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}       = $ipmi_password;
		$an->Log->entry({log_level => 4, message_key => "an_variables_0003", message_variables => {
			name1 => "scan-ipmitool::machine::${node_name}::power_check_command", value1 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command},
			name2 => "scan-ipmitool::machine::${node_name}::ipmitool_command",    value2 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command},
			name3 => "scan-ipmitool::machine::${node_name}::ipmi_password",       value3 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Do I have local IPMI access?
	my $shell_call = $an->data->{path}{ipmitool}." chassis power status; ".$an->data->{path}{echo}." rc:\$?";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, $shell_call." 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /rc:(\d+)/)
		{
			my $rc = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "rc", value1 => $rc, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($rc eq "0")
			{
				# We're good.
				   $ipmi_targets++;
				my $node_name                                                             = $an->hostname();
				   $an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command} = "";
				   $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command}    = $an->data->{path}{ipmitool};
				   $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}       = "";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "scan-ipmitool::machine::${node_name}::power_check_command", value1 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command},
					name2 => "scan-ipmitool::machine::${node_name}::ipmitool_command",    value2 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command},
					name3 => "scan-ipmitool::machine::${node_name}::ipmi_password",       value3 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	close $file_handle;
	
	return($ipmi_targets);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_ipmitool_message_0002"})."\n";

	return(0);
}
