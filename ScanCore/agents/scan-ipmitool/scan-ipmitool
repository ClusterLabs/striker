#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# ScanCore Scan Agent for 'ipmitool' to query IPMI data.
#
# https://alteeve.com
# 
# Exit Codes:
# 0   - Success
# 1   - Passed in host name was not found in the database.
# 2   - Bad number of ipmitool_value_id's returned for the given 
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# TODO:
# - Decide if we should parse 'ipmitool sel list'
# - Detect a hung BMC by trying to talk to ourselves and, if that fails, send 'ipmitool bmc reset cold'. 
#   Possibly try pinging the IPMI from the peer as it is not always possible to ping our own interface when
#   the IPMI and eth device share the same physical connector.
# - Update the string processing from the '!!x!name=a,value=b,units=c!!' method to the new method here:
#   https://alteeve.com/w/ScanCore#Unit_Parsing
# - Change 'ipmitool_value_id' to 'ipmitool_value_uuid'.
#
# - A PSU wattage dropping to '0 Watts', in conjunction with it's fan dropping to '0' RPMs, is the sign that 
#   input power was lost and should set a health score of ~5.
# 
# NOTE: 
# - Health values
#   - IPMI BMC    - Hung       = 10
#   - Temperature - Critical   = 2
#   - Temperature - Warning    = 1
#   - Fan         - Failed     = 5
#   - PSU         - Lost Input = 5
=pod

A Hung/crashed BMC will fail to reset with this:
====
[root@nr-c03n01 ~]# time ipmitool bmc reset cold
Get Device ID command failed: 0xff Unspecified error
Sent cold reset command to MC

real	3m52.860s
user	0m0.000s
sys	0m0.002s
====

Seeing this, we need to ask the peer to power-cycle us (/shared/status/.node.helpme -> 'task = power_cycle')
and set the health to 'warning'. We will call anvil-safe-stop.

The peer, on seeing (/shared/status/.node.helpme -> 'task = power_cycle'), will start pinging the peer on the
BCN and SN. Once there is no response, we will start a 60 second counter, then cut power to the PDUs for 60
seconds, then restore power. We will then start pinging the IPMI interface. Once it responds, we will wait 60
seconds and then try to power it back on.

---------

Change/set thresholds:

From: https://forums.freenas.org/index.php?threads/how-to-change-sensor-thresholds-with-ipmi-using-ipmitool.23571/

Lower Non-Recoverable
Lower Critical
Lower Non-Critical

Upper Non-Critical
Upper Critical
Upper Non-Recoverable

ipmitool sensor thresh "*sensor name*" lower *lnr* *lcr* *lnc*

ipmitool sensor thresh "*sensor name*" upper *unc* *ucr* *unr*
=cut

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
use Socket;
no warnings 'recursion';
#use utf8;
#binmode STDOUT, 'encoding(utf8)';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

### TODO: Rework this whole agent...
# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		health			=>	{
			old			=>	{},
			new			=>	{},
		},
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		sys			=>	{
			# When a lock is requested, this is set to the time the lock was set. 
			# DB->do_db_write() and DB->do_db_read() will check this and if its age is >50% of
			# scancore::locking::reap_age, it will renew the lock.
			local_lock_active	=>	0,
			scanning_myself		=>	0,
			sql			=>	[],
		},
		scancore		=>	{
			archive			=>	{
				directory		=>	"/var/ScanCore/archives/",
				division		=>	25000,
				trigger			=>	20000,
				count			=>	10000,
				dump_file_header	=>	"
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = history, pg_catalog;
",
			},
		},
		# These are values the user might set in striker.conf
		'scan-ipmitool'		=>	{
			disable			=>	0,
			language			=>	"en_CA",
			log_file			=>	"/var/log/ScanCore.log",
			log_level			=>	1,
			log_language			=>	"en_CA",
			log_db_transactions		=>	0,
			# It will be marked as 'clear' when the temperature drops this many Â°C below the 
			# critical temperature.
			machine				=>	{},
			# These are used when no other limits are set for a given sensor.
			thresholds			=>	{
				'default'			=>	{
					high_warning			=>	50,
					high_critical			=>	55,
					low_warning			=>	5,
					low_critical			=>	0,
					jump				=>	5,
					### TODO: Some sensors define their hysteresis which we can read 
					###       using: 
					###       ipmitool ... sensor get "Ambient"
					buffer				=>	2,
					weight				=>	1,
				},
				# If the user wants to assign manual values for a given sensor, they can do 
				# so by creating an entry hear where the key is the IPMI-returned sensor 
				# name.
				#ie:
				# ===========================================================================
				#'Ambient'			=>	{
				#	high_warning			=>	50,
				#	high_critical			=>	55,
				#	low_warning			=>	5,
				#	low_critical			=>	0,
				#	jump				=>	5,
				#	buffer				=>	2,
				#	weight				=>	1,
				#},
				# ===========================================================================
				# CPUs tend to jump around wildly under sudden load, so we extend their jump
				# range so we don't get spurious warnings all the time.
				'CPU'				=>	{
					jump				=>	35,
				},
				'CPU1'				=>	{
					jump				=>	10,
				},
				'CPU2'				=>	{
					jump				=>	10,
				},
				'CPU3'				=>	{
					jump				=>	10,
				},
				'CPU4'				=>	{
					jump				=>	10,
				},
				'CPU5'				=>	{
					jump				=>	10,
				},
				'CPU6'				=>	{
					jump				=>	10,
				},
				'CPU7'				=>	{
					jump				=>	10,
				},
				'CPU8'				=>	{
					jump				=>	10,
				},
				# The ROC on LSI controllers can just dramatically
				'RAID Controller'		=>	{
					jump				=>	15,
				},
			},
			# TODO: Remove this and have Striker pull the list of thermal sensors read in the 
			#       last $timestamp.
			offline_sensor_list		=>	"Ambient,Systemboard",
		},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-ipmitool'}{language});
$an->default_log_language($an->data->{'scan-ipmitool'}{log_language});
$an->default_log_file    ($an->data->{'scan-ipmitool'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-ipmitool'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-ipmitool'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

# Help?
if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or
    ($an->data->{switches}{help}))
{
	# Help!
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Exit if we're disabled.
if ($an->data->{'scan-ipmitool'}{disable})
{
	$an->nice_exit({exit_code => 1});
}

print $an->String->get({key => "scan_ipmitool_message_0001"})."\n";

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "notice_message_0013", message_variables => { connections => $connections }, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { uuid => $an->data->{sys}{host_uuid} }, code => 255, file => $THIS_FILE, line => __LINE__});
}

# This calls anvil-report-ipmi-details to find IPMI devices to scan. It also handles any user-defined IPMI 
# devices set in striker.conf.
if (not find_ipmi_targets($an))
{
	# No targets found. If we were called with '--prep-db', we'll prep the database schema regardless.
	if ($an->data->{switches}{'prep-db'})
	{
		if ($connections)
		{
			prep_databases($an);
		}
		else
		{
			# Failed
			$an->Log->entry({log_level => 1, message_key => "scancore_warning_0031", file => $THIS_FILE, line => __LINE__});
			print $an->String->get({key => "scancore_warning_0031"})."\n";
		}
	}
	$an->nice_exit({exit_code => 1});
}

# Query IPMI targets. Unreachable targets will simply be ignored.
query_ipmi_targets($an);

# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Archive, if needed.
archive_if_needed($an);

# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Finally, process health weights.
process_health($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This will archive stuff in the 'history' schema, if needed.
sub archive_if_needed
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "archive_if_needed" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If the 'trigger' is '0', archiving is disabled.
	if (not $an->data->{scancore}{archive}{trigger})
	{
		return(1);
	}
	
	### NOTE: If a ScanCore db server was offline when an archive ran, when it returns, it's records will
	###       sync back, triggering a sooner-than-expected subsequent archive. This shouldn't happen 
	###       often, and the complexity of tracking archive dates is such that we'll not try to account
	###       for these cases. 
	### TODO: What we can do later is, when we write the restore stuff, build in a dedupe function.
	
	### Process:
	# 1. Count the records in history for each table, restricting the results to those from this host 
	#    (save for special tables like 'server') and if the number of records is greater than 
	#    'scancore::archive::trigger', start an archive.
	# 2. Set/update the 'archive_date' state.
	# 3. Lock the database.
	# 4. Select 'modified_date' from history.foo, offset by 
	#    ('scancore::archive::trigger' - 'scancore::archive::count').
	# 5. Make sure the 'scancore::archive::directory' exists, creating it if needed.
	# 6. Select all records older that the 'modified_date', write them to a file and then DELETE those
	#    records from the database.
	
	# Update the archive path, if set by a user. Also verify that there are sane archive values.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "path::scancore_archive",       value1 => $an->data->{path}{scancore_archive}, 
		name2 => "scancore::archive::directory", value2 => $an->data->{scancore}{archive}{directory}, 
		name3 => "scancore::archive::trigger",   value3 => $an->data->{scancore}{archive}{trigger}, 
		name4 => "scancore::archive::count",     value4 => $an->data->{scancore}{archive}{count}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{archive}{directory} =~ /\/.*/)
	{
		$an->data->{path}{scancore_archive} = $an->data->{scancore}{archive}{directory};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::scancore_archive", value1 => $an->data->{path}{scancore_archive}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{trigger}) or ($an->data->{scancore}{archive}{trigger} =~ /\D/))
	{
		$an->data->{scancore}{archive}{trigger} = 100000;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::trigger", value1 => $an->data->{scancore}{archive}{trigger}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{count}) or ($an->data->{scancore}{archive}{count} =~ /\D/))
	{
		$an->data->{scancore}{archive}{count} = 50000;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::count", value1 => $an->data->{scancore}{archive}{count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	if (not -e $an->data->{path}{scancore_archive})
	{
		my $shell_call = $an->data->{path}{'mkdir'}." -p '".$an->data->{path}{scancore_archive}."'";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Did it work?
		if (not -e $an->data->{path}{scancore_archive})
		{
			# Nope. :(
			$an->Alert->warning({message_key => "scancore_warning_0030", message_variables => { directory => $an->data->{path}{scancore_archive} }, quiet => 1, file => $THIS_FILE, line => __LINE__});
			return(1);
		}
	}
	
	# Unlike ScanCore, matching 'ipmitool_value' to a host requires a join on 'ipmitool', so this is a 
	# bit more complex.
	$an->data->{archive}{table} = {
		ipmitool	=>	{
			archive_date	=>	"",
			offset		=>	0,
		},
		ipmitool_value	=>	{
			archive_date	=>	"",
			offset		=>	0,
		},
	};
	my $archive_needed = 0;
	foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "table", value1 => $table, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $query = "
SELECT 
    COUNT(*) 
FROM 
    history.$table 
WHERE 
    ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		if ($table eq "ipmitool_value")
		{
			$query = "
SELECT 
    COUNT(*) 
FROM 
    history.ipmitool_value a, 
    ipmitool b 
WHERE 
    a.ipmitool_value_ipmitool_uuid = b.ipmitool_uuid 
AND 
    b.ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $records = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		   $records = 0 if not defined $records;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "records", value1 => $records, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($records > $an->data->{scancore}{archive}{trigger})
		{
			   $archive_needed                             = 1;
			my $records_to_save                            = ($an->data->{scancore}{archive}{trigger} - $an->data->{scancore}{archive}{count});
			my $offset                                     = $records - $records_to_save;
			   $an->data->{archive}{table}{$table}{offset} = $offset;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "archive_needed",                   value1 => $archive_needed, 
				name2 => "records_to_save",                  value2 => $records_to_save, 
				name3 => "archive::table::${table}::offset", value3 => $an->data->{archive}{table}{$table}{offset}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I have something to archive, do so now.
	if ($archive_needed)
	{
		# This will store the files to compress after we release the locks.
		my $compress = [];
		
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Now loop through the table(s) that need to be archived.
		foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
		{
			next if not $an->data->{archive}{table}{$table}{offset};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "table", value1 => $table, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Now to do the archive.
			if ($table eq "ipmitool")
			{
				$an->DB->archive_table({
					table        => $table, 
					offset       => $an->data->{archive}{table}{$table}{offset}, 
					conditionals => { ipmitool_host_uuid => $an->data->{sys}{host_uuid} },
					columns      => ["ipmitool_uuid", "ipmitool_host_uuid", "ipmitool_sensor_host", "ipmitool_sensor_name", "ipmitool_sensor_units", "ipmitool_sensor_status", "ipmitool_sensor_high_critical", "ipmitool_sensor_high_warning", "ipmitool_sensor_low_critical", "ipmitool_sensor_low_warning"],
				});
			}
			elsif ($table eq "ipmitool_value")
			{
				### NOTE: The 'table' will use prefix '1.' and the 'join_table' will use 
				###       prefix 'b.', set the conditionals accordingly.
				$an->DB->archive_table({
					table        => $table, 
					offset       => $an->data->{archive}{table}{$table}{offset}, 
					conditionals => { 'a.ipmitool_value_ipmitool_uuid' => 'b.ipmitool_uuid', 'b.ipmitool_host_uuid' => $an->data->{sys}{host_uuid} },
					join_table   => "ipmitool", 
					columns      => [ "ipmitool_value_id", "ipmitool_value_ipmitool_uuid", "ipmitool_value_sensor_value" ],
				});
			}
		}
		
		### TODO: Make this less of a hackish mc-hackington...
		# VACUUM FULL, if the database is on this machine. I need to do this from the command line 
		# because the user we connect as isn't allowed to do it. We'll also only vacuum our DB.
		my $db_name = "";
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "id",                        value1 => $id, 
				name2 => "scancore::db::${id}::host", value2 => $an->data->{scancore}{db}{$id}{host}, 
				name3 => "hostname",                  value3 => $an->hostname, 
				name4 => "short_hostname",            value4 => $an->short_hostname, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($an->data->{scancore}{db}{$id}{host} eq $an->hostname) or ($an->data->{scancore}{db}{$id}{host} eq $an->short_hostname))
			{
				$db_name = $an->data->{scancore}{db}{$id}{name};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "db_name",                   value1 => $db_name, 
					name2 => "scancore::db::${id}::name", value2 => $an->data->{scancore}{db}{$id}{name}, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		if ($db_name)
		{
			my $start      = time;
			my $shell_call = $an->data->{path}{su}." - postgres -c \"".$an->data->{path}{psql}." $db_name -c 'VACUUM FULL;'\"";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "start",      value1 => $start, 
				name2 => "shell_call", value2 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			my $finished = time - $start;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "finished", value1 => $finished, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Release the lock
		$an->DB->locking({release => 1});
	}
	
	return(0);
}

# This reads in all health wieghts previously set, alters ones as needed, INSERTs new ones and DELETEs old
# ones.
sub process_health
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "process_health" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will hold our updates.
	$an->data->{sys}{sql} = [];
	
	# Read in previous health values.
	my $query = "
SELECT 
    health_uuid,
    health_source_name,
    health_source_weight 
FROM 
    health 
WHERE 
    health_host_uuid  = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    health_agent_name = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
		
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $health_uuid          = $row->[0]; 
		my $health_source_name   = $row->[1]; 
		my $health_source_weight = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "health_uuid",          value1 => $health_uuid, 
			name2 => "health_source_name",   value2 => $health_source_name, 
			name3 => "health_source_weight", value3 => $health_source_weight, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{health}{old}{$health_source_name}{uuid}  = $health_uuid;
		$an->data->{health}{old}{$health_source_name}{value} = $health_source_weight;
	}
	
	# Read in the new ones
	foreach my $health_source_name (sort {$a cmp $b} keys %{$an->data->{health}{new}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "health::new::$health_source_name", value1 => $an->data->{health}{new}{$health_source_name}, 
		}, file => $THIS_FILE, line => __LINE__});
		if (exists $an->data->{health}{old}{$health_source_name})
		{
			# We've seen this before. Has it changed?
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "health::old::${health_source_name}::value", value1 => $an->data->{health}{old}{$health_source_name}{value}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($an->data->{health}{new}{$health_source_name} ne $an->data->{health}{old}{$health_source_name}{value})
			{
				# It has changed, update it.
				my $query = "
UPDATE 
    health 
SET 
    health_source_weight = ".$an->data->{sys}{use_db_fh}->quote($an->data->{health}{new}{$health_source_name}).", 
    modified_date        = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    health_uuid          = ".$an->data->{sys}{use_db_fh}->quote($an->data->{health}{old}{$health_source_name}{uuid})."
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$an->data->{sys}{sql}}, $query;
			}
			
			# Delete the new old key, regardless of whether it has changed now.
			delete $an->data->{health}{old}{$health_source_name};
		}
		else
		{
			# New entry, INSERT it.
			my $query = "
INSERT INTO 
    health
(
    health_uuid,
    health_host_uuid,
    health_agent_name,
    health_source_name,
    health_source_weight,
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->Get->uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_source_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{health}{new}{$health_source_name}).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			
			push @{$an->data->{sys}{sql}}, $query;
		}
	}
	
	# Delete any old entries that are left.
	foreach my $health_source_name (sort {$a cmp $b} keys %{$an->data->{health}{old}})
	{
		# Well set the source name to 'DELETED'.
		my $query = "
UPDATE 
    health 
SET 
    health_source_name = 'DELETED', 
    modified_date      = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    health_uuid        = ".$an->data->{sys}{use_db_fh}->quote($an->data->{health}{old}{$health_source_name}{uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		push @{$an->data->{sys}{sql}}, $query;
		
		$query = "
DELETE FROM 
    health 
WHERE 
    health_uuid        = ".$an->data->{sys}{use_db_fh}->quote($an->data->{health}{old}{$health_source_name}{uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		push @{$an->data->{sys}{sql}}, $query;
	}
	
	# Now commit the changes.
	$an->DB->commit_sql({source => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through each machine
	foreach my $machine (sort {$a cmp $b} keys %{$an->data->{ipmi}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "machine", value1 => $machine, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# This returns the number of read sensors already in the DB for this machine recorded by us 
		# previously.
		if (read_last_scan($an, $machine))
		{
			### Existing machine, UPDATE or INSERT as needed.
			foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{ipmi}{$machine}{ipmitool_sensor_name}})
			{
				# Put the new values into variables
				my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
				my $new_ipmitool_sensor_units         = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
				my $new_ipmitool_sensor_status        = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
				my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
				my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
				my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
				my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
					name1 => "new_ipmitool_value_sensor_value",   value1 => $new_ipmitool_value_sensor_value, 
					name2 => "new_ipmitool_sensor_units",         value2 => $new_ipmitool_sensor_units, 
					name3 => "new_ipmitool_sensor_status",        value3 => $new_ipmitool_sensor_status, 
					name4 => "new_ipmitool_sensor_high_critical", value4 => $new_ipmitool_sensor_high_critical, 
					name5 => "new_ipmitool_sensor_high_warning",  value5 => $new_ipmitool_sensor_high_warning, 
					name6 => "new_ipmitool_sensor_low_critical",  value6 => $new_ipmitool_sensor_low_critical, 
					name7 => "new_ipmitool_sensor_low_warning",   value7 => $new_ipmitool_sensor_low_warning, 
				}, file => $THIS_FILE, line => __LINE__});
				
				### NOTE: These were added to debug duplicate ipmitool_value entries.
				if (not $new_ipmitool_sensor_units)
				{
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_ipmitool_message_0017",
						alert_message_variables	=>	{
							machine			=>	$machine,
							sensor			=>	$ipmitool_sensor_name,
						},
					});
					next;
				}
				if (not $new_ipmitool_value_sensor_value)
				{
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_ipmitool_message_0018",
						alert_message_variables	=>	{
							machine			=>	$machine,
							sensor			=>	$ipmitool_sensor_name,
						},
					});
					next;
				}
				
				# If the value is NULL and it's a digit-based value, switch it to '0'
				if ((($new_ipmitool_sensor_units eq "C") or ($new_ipmitool_sensor_units eq "F") or ($new_ipmitool_sensor_units eq "RPM")) && ($new_ipmitool_value_sensor_value eq "NULL"))
				{
					$new_ipmitool_value_sensor_value = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "new_ipmitool_value_sensor_value", value1 => $new_ipmitool_value_sensor_value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				# Have I seen this sensor before?
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "ref(sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name})", value1 => ref($an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}), 
				}, file => $THIS_FILE, line => __LINE__});
				if (ref($an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}))
				{
					### Existing record, update it if needed.
					# Put the old values into variables
					my $ipmitool_uuid                     = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid};
					my $old_ipmitool_value_sensor_value   = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
					my $old_ipmitool_sensor_units         = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
					my $old_ipmitool_sensor_status        = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
					my $old_ipmitool_sensor_high_critical = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
					my $old_ipmitool_sensor_high_warning  = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
					my $old_ipmitool_sensor_low_critical  = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
					my $old_ipmitool_sensor_low_warning   = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
						name1 => "ipmitool_uuid",                     value1 => $ipmitool_uuid, 
						name2 => "old_ipmitool_value_sensor_value",   value2 => $old_ipmitool_value_sensor_value, 
						name3 => "old_ipmitool_sensor_units",         value3 => $old_ipmitool_sensor_units, 
						name4 => "old_ipmitool_sensor_status",        value4 => $old_ipmitool_sensor_status, 
						name5 => "old_ipmitool_sensor_high_critical", value5 => $old_ipmitool_sensor_high_critical, 
						name6 => "old_ipmitool_sensor_high_warning",  value6 => $old_ipmitool_sensor_high_warning, 
						name7 => "old_ipmitool_sensor_low_critical",  value7 => $old_ipmitool_sensor_low_critical, 
						name8 => "old_ipmitool_sensor_low_warning",   value8 => $old_ipmitool_sensor_low_warning, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# If the value is NULL and it's a digit-based value, switch it to '0'
					if ((($old_ipmitool_sensor_units eq "C") or ($old_ipmitool_sensor_units eq "F") or ($old_ipmitool_sensor_units eq "RPM")) && ($old_ipmitool_value_sensor_value eq "NULL"))
					{
						$old_ipmitool_value_sensor_value = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "old_ipmitool_value_sensor_value", value1 => $old_ipmitool_value_sensor_value, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					
					# In some odd cases, there is no old sensor value
					$old_ipmitool_value_sensor_value = "NULL" if not defined $old_ipmitool_value_sensor_value;
					
					# These will be used in alert messages, if needed.
					my $sensor_name      = "name=$ipmitool_sensor_name:units=$new_ipmitool_sensor_units";
					my $new_sensor_value = "value=$new_ipmitool_value_sensor_value:units=$new_ipmitool_sensor_units";
					my $old_sensor_value = "value=$old_ipmitool_value_sensor_value:units=$old_ipmitool_sensor_units";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
						name1 => "ipmitool_sensor_name", value1 => $ipmitool_sensor_name, 
						name2 => "sensor_name",          value2 => $sensor_name, 
						name3 => "new_sensor_value",     value3 => $new_sensor_value, 
						name4 => "old_sensor_value",     value4 => $old_sensor_value, 
					}, file => $THIS_FILE, line => __LINE__});
					
					### Look for changes
					# NOTE: If the new sensor has a state of 'na' and the old state 
					#       wasn't 'na', we ignore it. It happens not uncommonly and it's
					#       never been an indication of a real problem before.
					if ($new_ipmitool_sensor_status eq "na")
					{
						# This is usually harmless, so we simple log this and move on
						$an->Log->entry({log_level => 1, message_key => "scan_ipmitool_log_0006", message_variables => { sensor_name => $ipmitool_sensor_name }, file => $THIS_FILE, line => __LINE__});
						
						# We loop out now because the rest of the values will look 
						# really bad (ie: temps down to 0c) and we don't want to 
						# trigger preventative actions on bad data.
						delete $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name};
						next;
					}
					elsif (($new_ipmitool_sensor_status ne "na") && ($old_ipmitool_sensor_status eq "na"))
					{
						# It disappeared in a previous sweep, now it's back. We 
						# continue normal processing to handle those rare occassions
						# where a sensor was lost back when we cared, and returned 
						# after updating to this version when we stopped caring.
						$an->Log->entry({log_level => 1, message_key => "scan_ipmitool_log_0007", message_variables => { sensor_name => $ipmitool_sensor_name }, file => $THIS_FILE, line => __LINE__});
					}
					
					# Sensor value:
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_ipmitool_value_sensor_value", value1 => $new_ipmitool_value_sensor_value,
						name2 => "old_ipmitool_value_sensor_value", value2 => $old_ipmitool_value_sensor_value, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($new_ipmitool_value_sensor_value ne $old_ipmitool_value_sensor_value)
					{
						# Update (no surprise ...)
						$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
							name1 => "machine",                         value1 => $machine,
							name2 => "sensor_name",                     value2 => $sensor_name, 
							name3 => "new_ipmitool_value_sensor_value", value3 => $new_ipmitool_value_sensor_value, 
							name4 => "old_ipmitool_value_sensor_value", value4 => $old_ipmitool_value_sensor_value, 
						}, file => $THIS_FILE, line => __LINE__});
						my $query = "
UPDATE 
    ipmitool_value 
SET
    ipmitool_value_sensor_value  = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_value_sensor_value).", 
    modified_date                = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid)."
;
";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
						
						### NOTE: These are set in 'process_temperature_change()' as 
						###       well, so change the values there if you change it 
						###       here, too.
						# This is an info-level alert, provided it is not gone above
						# or below tolerances.
						my $level       = "info";
						my $title_key   = "an_alert_title_0002";
						my $message_key = "scan_ipmitool_message_0014";
						
						# If this is a temperature, see if we need to 
						# trigger an alarm and set/clear the 'temperature'
						# table entry. 
						# TODO: For the rest of the sensors, we just log 
						#       the changes. If a sensor goes bad, for now
						#       we'll catch errors on the sensor status 
						#       change. We'll add better checks later.
						if ($new_ipmitool_sensor_units eq "C")
						{
							$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
								name1 => "machine",                         value1 => $machine,
								name2 => "sensor_name",                     value2 => $sensor_name, 
								name3 => "new_ipmitool_value_sensor_value", value3 => $new_ipmitool_value_sensor_value, 
								name4 => "old_ipmitool_value_sensor_value", value4 => $old_ipmitool_value_sensor_value, 
							}, file => $THIS_FILE, line => __LINE__});
							($level, $title_key, $message_key) = process_temperature_change($an, $machine, $ipmitool_sensor_name);
							$an->Alert->register_alert({
								alert_level		=>	$level, 
								alert_agent_name	=>	$THIS_FILE,
								alert_title_key		=>	$title_key,
								alert_message_key	=>	$message_key,
								alert_message_variables	=>	{
									sensor_name		=>	$sensor_name,
									new_sensor_value	=>	$new_sensor_value,
									new_sensor_status	=>	$new_ipmitool_sensor_status,
									new_high_critical	=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : $new_ipmitool_sensor_high_critical,
									new_low_critical	=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : $new_ipmitool_sensor_low_critical,
									new_high_warning	=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : $new_ipmitool_sensor_high_warning,
									new_low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : $new_ipmitool_sensor_low_warning,
									old_sensor_value	=>	$old_sensor_value, 
									old_sensor_status	=>	$old_ipmitool_sensor_status,
									old_high_critical	=>	$old_ipmitool_sensor_high_critical eq "NULL" ? "--" : $old_ipmitool_sensor_high_critical,
									old_low_critical	=>	$old_ipmitool_sensor_low_critical  eq "NULL" ? "--" : $old_ipmitool_sensor_low_critical,
									old_high_warning	=>	$old_ipmitool_sensor_high_warning  eq "NULL" ? "--" : $old_ipmitool_sensor_high_warning,
									old_low_warning		=>	$old_ipmitool_sensor_low_warning   eq "NULL" ? "--" : $old_ipmitool_sensor_low_warning,
								},
							});
						}
						else
						{
							# TODO: Add the checks of variables against
							#       the high/low warning/critical 
							#       thresholds here.
							$an->Alert->register_alert({
								alert_level		=>	$level, 
								alert_agent_name	=>	$THIS_FILE,
								alert_title_key		=>	$title_key,
								alert_message_key	=>	$message_key,
								alert_message_variables	=>	{
									sensor_name		=>	$sensor_name,
									new_sensor_value	=>	$new_sensor_value,
									old_sensor_value	=>	$old_sensor_value
								},
							});
						}
					}
					else
					{
						# No change.
						$an->Log->entry({log_level => 2, message_key => "scancore_log_0047", file => $THIS_FILE, line => __LINE__});
					}
					
					# Everything else
					if (($new_ipmitool_sensor_units         ne $old_ipmitool_sensor_units) or 
					    ($new_ipmitool_sensor_status        ne $old_ipmitool_sensor_status) or 
					    ($new_ipmitool_sensor_high_critical ne $old_ipmitool_sensor_high_critical) or 
					    ($new_ipmitool_sensor_high_warning  ne $old_ipmitool_sensor_high_warning) or 
					    ($new_ipmitool_sensor_low_critical  ne $old_ipmitool_sensor_low_critical) or 
					    ($new_ipmitool_sensor_low_warning   ne $old_ipmitool_sensor_low_warning))
					{
						# Huh, interesting. Well, update
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_units", value1 => $new_ipmitool_sensor_units, 
							name2 => "old_ipmitool_sensor_units", value2 => $old_ipmitool_sensor_units, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_status", value1 => $new_ipmitool_sensor_status, 
							name2 => "old_ipmitool_sensor_status", value2 => $old_ipmitool_sensor_status, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_high_critical", value1 => $new_ipmitool_sensor_high_critical, 
							name2 => "old_ipmitool_sensor_high_critical", value2 => $old_ipmitool_sensor_high_critical, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_high_warning", value1 => $new_ipmitool_sensor_high_warning, 
							name2 => "old_ipmitool_sensor_high_warning", value2 => $old_ipmitool_sensor_high_warning, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_low_critical", value1 => $new_ipmitool_sensor_low_critical, 
							name2 => "old_ipmitool_sensor_low_critical", value2 => $old_ipmitool_sensor_low_critical, 
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "new_ipmitool_sensor_low_warning", value1 => $new_ipmitool_sensor_low_warning, 
							name2 => "old_ipmitool_sensor_low_warning", value2 => $old_ipmitool_sensor_low_warning, 
						}, file => $THIS_FILE, line => __LINE__});
						
						### NOTE: These were added to debug duplicate ipmitool_value entries.
						if (not $new_ipmitool_sensor_units)
						{
							$an->Alert->register_alert({
								alert_level		=>	"notice", 
								alert_agent_name	=>	$THIS_FILE,
								alert_title_key		=>	"an_alert_title_0003",
								alert_message_key	=>	"scan_ipmitool_message_0017",
								alert_message_variables	=>	{
									machine			=>	$machine,
									sensor			=>	$ipmitool_sensor_name,
								},
							});
							next;
						}
						
						my $query = "
UPDATE 
    ipmitool 
SET
    ipmitool_sensor_units         = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_units).", 
    ipmitool_sensor_status        = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_status).", 
    ipmitool_sensor_high_critical = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_critical).", 
    ipmitool_sensor_high_warning  = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_warning).", 
    ipmitool_sensor_low_critical  = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_critical).", 
    ipmitool_sensor_low_warning   = ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_warning).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    ipmitool_sensor_host          = ".$an->data->{sys}{use_db_fh}->quote($machine)."
AND 
    ipmitool_uuid                 = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid)."
;";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
						
						# If this is a status change, set a 'warning' level alert 
						# unless the change is to/from 'ns'.
						my $level       = "notice";
						my $title_key   = "an_alert_title_0003";
						my $message_key = "scan_ipmitool_message_0012";
						$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
							name1 => "level",       value1 => $level, 
							name2 => "title_key",   value2 => $title_key, 
							name3 => "message_key", value3 => $message_key, 
						}, file => $THIS_FILE, line => __LINE__});
						if (($new_ipmitool_sensor_status ne $old_ipmitool_sensor_status) && 
						    ($new_ipmitool_sensor_status ne "ns") &&
						    ($old_ipmitool_sensor_status ne "ns"))
						{
							$level       = "warning";
							$title_key   = "an_alert_title_0004";
							$message_key = "scan_ipmitool_message_0012";
							$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
								name1 => "level",       value1 => $level, 
								name2 => "title_key",   value2 => $title_key, 
								name3 => "message_key", value3 => $message_key, 
							}, file => $THIS_FILE, line => __LINE__});
						}
						$an->Alert->register_alert({
							alert_level		=>	$level, 
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	$title_key,
							alert_message_key	=>	$message_key,
							alert_message_variables	=>	{
								sensor_name		=>	$sensor_name,
								new_sensor_value	=>	$new_sensor_value,
								old_sensor_value	=>	$old_sensor_value, 
								new_sensor_status	=>	$new_ipmitool_sensor_status, 
								old_sensor_status	=>	$old_ipmitool_sensor_status, 
								new_high_critical	=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$new_ipmitool_sensor_high_critical $new_ipmitool_sensor_units",
								new_high_warning	=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$new_ipmitool_sensor_high_warning $new_ipmitool_sensor_units", 
								new_low_critical	=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$new_ipmitool_sensor_low_critical $new_ipmitool_sensor_units", 
								new_low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$new_ipmitool_sensor_low_warning $new_ipmitool_sensor_units", 
								old_high_critical	=>	$old_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$old_ipmitool_sensor_high_critical $old_ipmitool_sensor_units",
								old_high_warning	=>	$old_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$old_ipmitool_sensor_high_warning $old_ipmitool_sensor_units", 
								old_low_critical	=>	$old_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$old_ipmitool_sensor_low_critical $old_ipmitool_sensor_units", 
								old_low_warning		=>	$old_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$old_ipmitool_sensor_low_warning $old_ipmitool_sensor_units", 
							},
						});
					}
					
					# Delete the old key so that I can check to see what sensors 
					# vanished.
					delete $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name};
				}
				else
				{
					### NOTE: If the new value is 'na', we ignore it as it is likely a 
					###       sensor that doesn't actually exist.
					if ($an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value} eq "NULL")
					{
						# Ignore it.
						$an->Log->entry({log_level => 3, message_key => "scan_ipmitool_log_0005", message_variables => { sensor_name => $ipmitool_sensor_name }, file => $THIS_FILE, line => __LINE__});
						delete $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name};
						next;
					}
					
					### New record, INSERT it and sent an 'notice' level alert.
					# Generate a new UUID for this ipmi target.
					my $ipmitool_uuid = $an->Get->uuid() or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => $THIS_FILE, line => __LINE__});;
					
					# Record the new UUID
					$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid} = $ipmitool_uuid;
					
					### NOTE: These were added to debug duplicate ipmitool_value entries.
					if (not $new_ipmitool_sensor_units)
					{
						$an->Alert->register_alert({
							alert_level		=>	"notice", 
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	"an_alert_title_0003",
							alert_message_key	=>	"scan_ipmitool_message_0017",
							alert_message_variables	=>	{
								machine			=>	$machine,
								sensor			=>	$ipmitool_sensor_name,
							},
						});
						next;
					}
					if (not $new_ipmitool_value_sensor_value)
					{
						$an->Alert->register_alert({
							alert_level		=>	"notice", 
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	"an_alert_title_0003",
							alert_message_key	=>	"scan_ipmitool_message_0018",
							alert_message_variables	=>	{
								machine			=>	$machine,
								sensor			=>	$ipmitool_sensor_name,
							},
						});
						next;
					}
					
					# Save the new sensor.
					my $query = "
INSERT INTO 
    ipmitool 
(
    ipmitool_uuid, 
    ipmitool_host_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($machine).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_units).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_status).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query, 
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
					
					# Now INSERT the sensor value.
					$query = "
INSERT INTO 
    ipmitool_value 
(
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_value_sensor_value).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query, 
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
					
					# TODO: Use the following variable/value pairs to have the sensor 
					#       name and value translated/converted to imperial as needed.
					my $sensor_name  = "name=$ipmitool_sensor_name:units=$new_ipmitool_sensor_units";
					my $sensor_value = "value=$new_ipmitool_value_sensor_value:units=$new_ipmitool_sensor_units";
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"scan_ipmitool_title_0001",
						alert_title_variables	=>	{
							machine			=>	$machine,
						},
						alert_message_key	=>	"scan_ipmitool_message_0003",
						alert_message_variables	=>	{
							sensor_name		=>	$sensor_name,
							sensor_value		=>	$sensor_value
						},
					});
					
					# If the sensor is not 'ok', set a warning level alert.
					my $level       = "notice";
					my $title_key   = "an_alert_title_0003";
					my $message_key = "scan_ipmitool_message_0013";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
						name1 => "level",       value1 => $level, 
						name2 => "title_key",   value2 => $title_key, 
						name3 => "message_key", value3 => $message_key, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($new_ipmitool_sensor_status eq "ok")
					{
						# Alert cleared.
						$title_key = "an_alert_title_0006";
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "title_key", value1 => $title_key, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					else
					{
						$level       = "warning";
						$title_key   = "an_alert_title_0004";
						$message_key = "scan_ipmitool_message_0015";
						$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
							name1 => "level",       value1 => $level, 
							name2 => "title_key",   value2 => $title_key, 
							name3 => "message_key", value3 => $message_key, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					$an->Alert->register_alert({
						alert_level		=>	$level, 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	$title_key,
						alert_message_key	=>	$message_key,
						alert_message_variables	=>	{
							sensor_name		=>	$sensor_name,
							sensor_value		=>	$sensor_value,
							sensor_status		=>	$new_ipmitool_sensor_status, 
							high_critical		=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$new_ipmitool_sensor_high_critical $new_ipmitool_sensor_units",
							high_warning		=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$new_ipmitool_sensor_high_warning $new_ipmitool_sensor_units", 
							low_critical		=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$new_ipmitool_sensor_low_critical $new_ipmitool_sensor_units", 
							low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$new_ipmitool_sensor_low_warning $new_ipmitool_sensor_units", 
						},
					});
				}
			}
		}
		else
		{
			# New machine, INSERT everything.
			foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{ipmi}{$machine}{ipmitool_sensor_name}})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "ipmitool_sensor_name", value1 => $ipmitool_sensor_name, 
				}, file => $THIS_FILE, line => __LINE__});
				
				### NOTE: If the new value is 'na', we ignore it as it is likely a 
				###       sensor that doesn't actually exist.
				if ($an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value} eq "NULL")
				{
					# Ignore it.
					$an->Log->entry({log_level => 3, message_key => "scan_ipmitool_log_0005", message_variables => { sensor_name => $ipmitool_sensor_name }, file => $THIS_FILE, line => __LINE__});
					delete $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name};
					next;
				}
				
				# Generate the UUID.
				my $ipmitool_uuid = $an->Get->uuid() or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => $THIS_FILE, line => __LINE__});
				
				# Record it.
				$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid} = $ipmitool_uuid;
				
				my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
				my $new_ipmitool_sensor_units         = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
				my $new_ipmitool_sensor_status        = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
				my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
				my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
				my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
				my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
					name1 => "ipmitool_uuid",                     value1 => $ipmitool_uuid, 
					name2 => "new_ipmitool_sensor_units",         value2 => $new_ipmitool_sensor_units, 
					name3 => "new_ipmitool_sensor_status",        value3 => $new_ipmitool_sensor_status, 
					name4 => "new_ipmitool_sensor_high_critical", value4 => $new_ipmitool_sensor_high_critical, 
					name5 => "new_ipmitool_sensor_high_warning",  value5 => $new_ipmitool_sensor_high_warning, 
					name6 => "new_ipmitool_sensor_low_critical",  value6 => $new_ipmitool_sensor_low_critical, 
					name7 => "new_ipmitool_sensor_low_warning",   value7 => $new_ipmitool_sensor_low_warning, 
				}, file => $THIS_FILE, line => __LINE__});
				
				die "No IPMI units for sensor: [$ipmitool_sensor_name]."            if not $new_ipmitool_sensor_units;
				die "No IPMI value for sensor: [$new_ipmitool_value_sensor_value]." if not $new_ipmitool_value_sensor_value;
				
				# If the value is NULL and it's a digit-based value, switch it to '0'
				if ((($new_ipmitool_sensor_units eq "C") or ($new_ipmitool_sensor_units eq "F") or ($new_ipmitool_sensor_units eq "RPM")) && ($new_ipmitool_value_sensor_value eq "NULL"))
				{
					$new_ipmitool_value_sensor_value = 0;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "new_ipmitool_value_sensor_value", value1 => $new_ipmitool_value_sensor_value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				my $query = "
INSERT INTO 
    ipmitool 
(
    ipmitool_uuid, 
    ipmitool_host_uuid, 
    ipmitool_sensor_name, 
    ipmitool_sensor_host, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).",  
    ".$an->data->{sys}{use_db_fh}->quote($machine).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_units).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_status).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_high_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_critical).",  
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_sensor_low_warning).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# Now INSERT the sensor value.
				$query = "
INSERT INTO 
    ipmitool_value 
(
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($new_ipmitool_value_sensor_value).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# We need to let ScanCore translate the sensor data into a string for each 
				# user and their prefered language and units. As such, we're going to use a 
				# couple special variable strings for this.
				my $sensor_name  = "name=$ipmitool_sensor_name:units=$new_ipmitool_sensor_units";
				my $sensor_value = "value=$new_ipmitool_value_sensor_value:units=$new_ipmitool_sensor_units";
				
				# If the sensor is not 'ok', set a warning level alert.
				my $level       = "notice";
				my $title_key   = "an_alert_title_0003";
				my $message_key = "scan_ipmitool_message_0013";
				if ($new_ipmitool_sensor_status ne "ok")
				{
					$level       = "warning";
					$title_key   = "an_alert_title_0004";
					$message_key = "scan_ipmitool_message_0015";
				}
				$an->Alert->register_alert({
					alert_level		=>	$level, 
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	$title_key,
					alert_message_key	=>	$message_key,
					alert_message_variables	=>	{
						sensor_name		=>	$sensor_name,
						sensor_value		=>	$sensor_value,
						sensor_status		=>	$new_ipmitool_sensor_status, 
						high_critical		=>	$new_ipmitool_sensor_high_critical eq "NULL" ? "--" : "$new_ipmitool_sensor_high_critical $new_ipmitool_sensor_units",
						high_warning		=>	$new_ipmitool_sensor_high_warning  eq "NULL" ? "--" : "$new_ipmitool_sensor_high_warning $new_ipmitool_sensor_units", 
						low_critical		=>	$new_ipmitool_sensor_low_critical  eq "NULL" ? "--" : "$new_ipmitool_sensor_low_critical $new_ipmitool_sensor_units", 
						low_warning		=>	$new_ipmitool_sensor_low_warning   eq "NULL" ? "--" : "$new_ipmitool_sensor_low_warning $new_ipmitool_sensor_units", 
					},
				});
			}
		}
		
		# If I am scanning myself and if I see problems, I will set the health accordingly.
		if (($machine eq $an->hostname) or ($machine eq $an->short_hostname))
		{
			$an->data->{sys}{scanning_myself} = 1;
		}
		else
		{
			$an->data->{sys}{scanning_myself} = 0;
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::scanning_myself", value1 => $an->data->{sys}{scanning_myself}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### Now add, update and delete 'temperature' entries.
		process_temperature($an, $machine);
		
		# Now look for any sensors that are in a bad state and set the health accordingly.
		check_sensor_health($an, $machine);
	}
	
	# Now commit the changes.
	$an->DB->commit_sql({source => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This looks at various sensors, except temperature (handled in process_temperature() below) and sets the 
# health table as needed for sensors out of scope.
sub check_sensor_health
{
	my ($an, $machine) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_sensor_health" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "machine", value1 => $machine, 
	}, file => $THIS_FILE, line => __LINE__});
	
	foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{ipmi}{$machine}{ipmitool_sensor_name}})
	{
		# Put the new values into variables
		my $ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
		my $ipmitool_sensor_units         = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units};
		my $ipmitool_sensor_status        = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status};
		my $ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
		my $ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
		my $ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
		my $ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "ipmitool_sensor_name",          value1 => $ipmitool_sensor_name, 
			name2 => "ipmitool_value_sensor_value",   value2 => $ipmitool_value_sensor_value, 
			name3 => "ipmitool_sensor_units",         value3 => $ipmitool_sensor_units, 
			name4 => "ipmitool_sensor_status",        value4 => $ipmitool_sensor_status, 
			name5 => "ipmitool_sensor_high_critical", value5 => $ipmitool_sensor_high_critical, 
			name6 => "ipmitool_sensor_high_warning",  value6 => $ipmitool_sensor_high_warning, 
			name7 => "ipmitool_sensor_low_critical",  value7 => $ipmitool_sensor_low_critical, 
			name8 => "ipmitool_sensor_low_warning",   value8 => $ipmitool_sensor_low_warning, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ((lc($ipmitool_sensor_units) eq "c") or (lc($ipmitool_sensor_units) eq "f"))
		{
			# Temperatures will be handled in process_temperature().
			next;
		}
		if ($ipmitool_sensor_status ne "ok")
		{
			my $health_source_name = $ipmitool_sensor_units.":".$ipmitool_sensor_name;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "health_source_name", value1 => $health_source_name, 
			}, file => $THIS_FILE, line => __LINE__});
			if (lc($ipmitool_sensor_units) eq "v")
			{
				$health_source_name = "voltage:".$ipmitool_sensor_name;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "health_source_name", value1 => $health_source_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif (lc($ipmitool_sensor_units) eq "w")
			{
				$health_source_name = "wattage:".$ipmitool_sensor_name;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "health_source_name", value1 => $health_source_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif (lc($ipmitool_sensor_units) eq "rpm")
			{
				$health_source_name = "fan:".$ipmitool_sensor_name;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "health_source_name", value1 => $health_source_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($ipmitool_sensor_units eq "%")
			{
				$health_source_name = "percentage:".$ipmitool_sensor_name;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "health_source_name", value1 => $health_source_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Record it, if we're scanning ourselves.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::scanning_myself", value1 => $an->data->{sys}{scanning_myself}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{sys}{scanning_myself})
			{
				# Set this to the user's requested weight, if set. Otherwise, use the default.
				my $weight = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{weight};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "weight", value1 => $weight, 
				}, file => $THIS_FILE, line => __LINE__});
				if (exists $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight})
				{
					# If it a number?
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::weight", value1 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight}, 
					}, file => $THIS_FILE, line => __LINE__});
					if (($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight} =~ /^\d+$/) or ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight} =~ /^\d+\.\d+$/))
					{
						$weight = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight};
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "weight", value1 => $weight, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
				
				# Default to '1' if not set.
				$weight = 1 if not $weight;
				
				$an->data->{health}{new}{$health_source_name} = $weight;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "health::new::$health_source_name", value1 => $an->data->{health}{new}{$health_source_name}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	return(0);
}

# This takes the temperature sensors and feeds them into the 'temperature' table, deleting stale entries as needed.
sub process_temperature
{
	my ($an, $machine) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_temperature" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "machine", value1 => $machine, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, read in all existing entries. We'll compare and UPDATE or INSERT as needed and DELETE any 
	# stale entries.
	my $query = "
SELECT 
    temperature_uuid, 
    temperature_sensor_name, 
    temperature_celsius,
    temperature_state,
    temperature_is
FROM 
    temperature 
WHERE 
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)." 
AND
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $temperature_uuid     = $row->[0]; 
		my $ipmitool_sensor_name = $row->[1];
		my $temperature_celsius  = $row->[2];
		my $temperature_state    = $row->[3];
		my $temperature_is       = $row->[4];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "temperature_uuid",     value1 => $temperature_uuid,
			name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name,
			name3 => "temperature_celsius",  value3 => $temperature_celsius,
			name4 => "temperature_state",    value4 => $temperature_state,
			name5 => "temperature_is",       value5 => $temperature_is,
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_uuid	=>	$temperature_uuid, 
			temperature_celsius	=>	$temperature_celsius,
			temperature_state	=>	$temperature_state,
			temperature_is		=>	$temperature_is,
		};
	}
	
	# Look at the new values.
	foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{new}{$machine}{temperature}})
	{
		my $new_temperature_uuid    = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_uuid};
		my $new_temperature_celsius = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius};
		my $new_temperature_state   = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state};
		my $new_temperature_is      = $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "ipmitool_sensor_name",    value1 => $ipmitool_sensor_name,
			name2 => "new_temperature_uuid",    value2 => $new_temperature_uuid, 
			name3 => "new_temperature_celsius", value3 => $new_temperature_celsius,
			name4 => "new_temperature_state",   value4 => $new_temperature_state,
			name5 => "new_temperature_is",      value5 => $new_temperature_is,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If the state is 'warning', set  a health weight of 1 and set critical to 2.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sys::scanning_myself", value1 => $an->data->{sys}{scanning_myself}, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($an->data->{sys}{scanning_myself})
		{
			# What weight will we apply to this sensor?
			my $weight  = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{weight};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "weight", value1 => $weight, 
			}, file => $THIS_FILE, line => __LINE__});
			if (exists $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight})
			{
				# If it a number?
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::weight", value1 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight} =~ /^\d+$/) or ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight} =~ /^\d+\.\d+$/))
				{
					$weight = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{weight};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "weight", value1 => $weight, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			# Default to '1' if not set.
			$weight = 1 if not $weight;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "weight", value1 => $weight, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If it's not OK, set the weight
			if ($new_temperature_state ne "ok")
			{
				my $health_source_name                           = "temperature:".$ipmitool_sensor_name;
				   $an->data->{health}{new}{$health_source_name} = $weight;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "health::new::$health_source_name", value1 => $an->data->{health}{new}{$health_source_name}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Now see if the variable was seen before and, if so, if it changed.
		if (ref($an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}))
		{
			# Update the existing entry, if needed.
			my $old_temperature_uuid    = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_uuid};
			my $old_temperature_celsius = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius};
			my $old_temperature_state   = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state};
			my $old_temperature_is      = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "old_temperature_uuid",     value1 => $old_temperature_uuid,
				name2 => "old_temperature_celsius",  value2 => $old_temperature_celsius,
				name3 => "old_temperature_state",    value3 => $old_temperature_state,
				name4 => "old_temperature_is",       value4 => $old_temperature_is,
			}, file => $THIS_FILE, line => __LINE__});
			
			if (($new_temperature_celsius ne $old_temperature_celsius) || 
				($new_temperature_state   ne $old_temperature_state)   ||
				($new_temperature_is      ne $old_temperature_is))
			{
				my $query = "
UPDATE 
    temperature 
SET 
    temperature_celsius = ".$an->data->{sys}{use_db_fh}->quote($new_temperature_celsius).", 
    temperature_state   = ".$an->data->{sys}{use_db_fh}->quote($new_temperature_state).", 
    temperature_is      = ".$an->data->{sys}{use_db_fh}->quote($new_temperature_is).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    temperature_uuid    = ".$an->data->{sys}{use_db_fh}->quote($old_temperature_uuid).";
";
				push @{$an->data->{sys}{sql}}, $query;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# No change.
				$an->Log->entry({log_level => 2, message_key => "scan_ipmitool_log_0004", message_variables => {
					sensor_name => $ipmitool_sensor_name,
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# We still want this value, so delete it from the hash so it doesn't get deleted in 
			# the next step.
			delete $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name};
		}
		else
		{
			### New entry
			# Generate and store the UUID.
			my $ipmitool_uuid = $an->Get->uuid() or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => $THIS_FILE, line => __LINE__});;
			$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{ipmitool_uuid} = $ipmitool_uuid;
			my $query         = "
INSERT INTO 
    temperature 
(
    temperature_uuid, 
    temperature_host_uuid, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_agent_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($machine).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_temperature_celsius).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_temperature_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_temperature_is).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
			push @{$an->data->{sys}{sql}}, $query;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
		}
	}

	# Now, if any undeleted old entries remain, delete them from the database.
	foreach my $ipmitool_sensor_name (sort {$a cmp $b} keys %{$an->data->{old}{$machine}{temperature}})
	{
		my $old_temperature_celsius = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius};
		my $old_temperature_state   = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state};
		my $old_temperature_is      = $an->data->{old}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is};
		
		# Mark the sensor as DELETEd.
		my $query = "
UPDATE 
    temperature 
SET 
    temperature_state = 'DELETED', 
    modified_date     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND
    temperature_sensor_name = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name)."
AND
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)." 
AND
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine).";
";
		push @{$an->data->{sys}{sql}}, $query;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$query = "
DELETE FROM 
    temperature 
WHERE
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND
    temperature_sensor_name = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name)." 
AND
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE)."
AND
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine).";
";
		push @{$an->data->{sys}{sql}}, $query;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This logs thermal sensor values that are outside nominal ranges
sub log_abnormal_temperatures
{
	my ($an, $machine, $ipmitool_sensor_name) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "log_abnormal_temperatures" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "machine",              value1 => $machine, 
		name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
	my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
	my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
	my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
	my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "machine",                         value1 => $machine, 
		name2 => "ipmitool_sensor_name",            value2 => $ipmitool_sensor_name, 
		name3 => "new_ipmitool_value_sensor_value", value3 => $new_ipmitool_value_sensor_value, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If the sensor value is 'na', ignore it.
	if ($new_ipmitool_value_sensor_value eq "NULL")
	{
		return(0);
	}
	
	### High Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning}, 
		name2 => "new_ipmitool_sensor_high_warning",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $high_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}) && 
	    (        $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning} =~ /^\d/))
	{
		$high_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "high_warning", value1 => $high_warning, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_warning = $new_ipmitool_sensor_high_critical;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "high_warning", value1 => $high_warning, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### High Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical}, 
		name2 => "new_ipmitool_sensor_high_critical",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $high_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}) && 
	    (        $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical} =~ /^\d/))
	{
		$high_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "high_critical", value1 => $high_critical, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_critical = $new_ipmitool_sensor_high_critical;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "high_critical", value1 => $high_critical, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### Low Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning}, 
		name2 => "new_ipmitool_sensor_low_warning",                                 value2 => $new_ipmitool_sensor_low_warning, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $low_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}) && 
	    (        $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning} =~ /^\d/))
	{
		$low_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "low_warning", value1 => $low_warning, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_warning = $new_ipmitool_sensor_low_critical;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "low_warning", value1 => $low_warning, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### Low Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical}, 
		name2 => "new_ipmitool_sensor_low_critical",                                 value2 => $new_ipmitool_sensor_low_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}) && 
	    (        $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical} =~ /^\d/))
	{
		$low_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "low_critical", value1 => $low_critical, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_critical = $new_ipmitool_sensor_low_critical;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "low_critical", value1 => $low_critical, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Record the levels
	$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
		name1 => "machine",                         value1 => $machine,
		name2 => "ipmitool_sensor_name",            value2 => $ipmitool_sensor_name,
		name3 => "high_warning",                    value3 => $high_warning, 
		name4 => "high_critical",                   value4 => $high_critical, 
		name5 => "low_warning",                     value5 => $low_warning, 
		name6 => "low_critical",                    value6 => $low_critical, 
		name7 => "new_ipmitool_value_sensor_value", value7 => $new_ipmitool_value_sensor_value,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Record the temperatures.
	if ($new_ipmitool_value_sensor_value < $low_critical)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'critical',
			temperature_is		=>	'low',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_value_sensor_value < $low_warning)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'warning',
			temperature_is		=>	'low',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_value_sensor_value > $high_critical)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'critical',
			temperature_is		=>	'high',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($new_ipmitool_value_sensor_value > $high_warning)
	{
		# Setup the 'temperature' entry.
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'warning',
			temperature_is		=>	'high',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
			temperature_celsius	=>	$new_ipmitool_value_sensor_value,
			temperature_state	=>	'ok',
			temperature_is		=>	'nominal',
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
			name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
			name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### NOTE: Recording all temps now, so this might not be needed
	# When the dashboard scans a node, it needs to know about the Ambient and Systemboard temperatures in
	# order to decide whether the node is safe too boot back up or not. So if this machine is a 
	# dashboard, log the 'Ambient' and 'Systemboard' temperatures (or whatever the user defined) as 
	# 'good', if they're not already in the 'new::temperature::x' hash.
	my $i_am_a = $an->Get->what_am_i();
	foreach my $sensor (split/,/, $an->data->{'scan-ipmitool'}{offline_sensor_list})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "sensor",               value1 => $sensor, 
			name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name, 
			name3 => "i_am_a",               value3 => $i_am_a, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($ipmitool_sensor_name eq $sensor)    && 
		    ($i_am_a               eq "dashboard") && 
		    (not exists $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}))
		{
			$an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name} = {
				temperature_celsius	=>	$new_ipmitool_value_sensor_value,
				temperature_state	=>	'ok',
				temperature_is		=>	'nominal',
			};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_celsius", value1 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_celsius}, 
				name2 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_state",   value2 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_state}, 
				name3 => "new::${machine}::temperature::${ipmitool_sensor_name}::temperature_is",      value3 => $an->data->{new}{$machine}{temperature}{$ipmitool_sensor_name}{temperature_is}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This processes a temperature sensor, handling changes and recording values that are in a warning or 
# critical state.
sub process_temperature_change
{
	my ($an, $machine, $ipmitool_sensor_name) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_temperature_change" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "machine",              value1 => $machine, 
		name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# This is a repeat of some variables set before this function was called, but setting them here again
	# saves passing in a pile of variables.
	my $level       = "info";
	my $title_key   = "an_alert_title_0002";
	my $message_key = "scan_ipmitool_message_0012";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "level",       value1 => $level, 
		name2 => "title_key",   value2 => $title_key, 
		name3 => "message_key", value3 => $message_key, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# New values
	my $new_ipmitool_value_sensor_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value};
	my $new_ipmitool_sensor_high_critical = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical};
	my $new_ipmitool_sensor_high_warning  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning};
	my $new_ipmitool_sensor_low_critical  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical};
	my $new_ipmitool_sensor_low_warning   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
		name1 => "new_ipmitool_value_sensor_value",   value1 => $new_ipmitool_value_sensor_value, 
		name2 => "new_ipmitool_sensor_high_critical", value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "new_ipmitool_sensor_high_warning",  value3 => $new_ipmitool_sensor_high_warning, 
		name4 => "new_ipmitool_sensor_low_critical",  value4 => $new_ipmitool_sensor_low_critical, 
		name5 => "new_ipmitool_sensor_low_warning",   value5 => $new_ipmitool_sensor_low_warning, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If the value is NULL and it's a digit-based value, switch it to '0'
	if ($new_ipmitool_value_sensor_value eq "NULL")
	{
		$new_ipmitool_value_sensor_value = 0;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "new_ipmitool_value_sensor_value", value1 => $new_ipmitool_value_sensor_value, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Old value, if it exists.
	my $old_ipmitool_value_sensor_value = $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value} ? $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value} : 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_value_sensor_value", value1 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value}, 
		name2 => "old_ipmitool_value_sensor_value",                                                             value2 => $old_ipmitool_value_sensor_value, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### Buffer, used for clearing all alerts.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::buffer",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{buffer}, 
		name2 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::buffer", value2 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{buffer}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $buffer = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{buffer} ? $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{buffer} : $an->data->{'scan-ipmitool'}{thresholds}{'default'}{buffer};
	
	### High Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning}, 
		name2 => "new_ipmitool_sensor_high_warning",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $high_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_warning};
	
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning} =~ /^\d/))
	{
		$high_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_warning};
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_warning = $new_ipmitool_sensor_high_critical;
	}
	
	### High Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::high_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical}, 
		name2 => "new_ipmitool_sensor_high_critical",                                 value2 => $new_ipmitool_sensor_high_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::high_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $high_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{high_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical} =~ /^\d/))
	{
		$high_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{high_critical};
	}
	elsif ($new_ipmitool_sensor_high_critical =~ /^\d/)
	{
		$high_critical = $new_ipmitool_sensor_high_critical;
	}
	
	### Low Warning
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_warning",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning}, 
		name2 => "new_ipmitool_sensor_low_warning",                                 value2 => $new_ipmitool_sensor_low_warning, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_warning", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_warning = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_warning};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning} =~ /^\d/))
	{
		$low_warning = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_warning};
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_warning = $new_ipmitool_sensor_low_critical;
	}
	
	### Low Critical
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::low_critical",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical}, 
		name2 => "new_ipmitool_sensor_low_critical",                                 value2 => $new_ipmitool_sensor_low_critical, 
		name3 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::low_critical", value3 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $low_critical = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{low_critical};
	if ((defined $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical}) && 
	    ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical} =~ /^\d/))
	{
		$low_critical = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{low_critical};
	}
	elsif ($new_ipmitool_sensor_low_critical =~ /^\d/)
	{
		$low_critical = $new_ipmitool_sensor_low_critical;
	}
	
	### Jump delta
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "scan-ipmitool::thresholds::defaults::jump",                value1 => $an->data->{'scan-ipmitool'}{thresholds}{'default'}{jump}, 
		name2 => "scan-ipmitool::thresholds::${ipmitool_sensor_name}::jump", value2 => $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{jump}, 
	}, file => $THIS_FILE, line => __LINE__});
	my $jump = $an->data->{'scan-ipmitool'}{thresholds}{'default'}{jump};
	if ($an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{jump})
	{
		$jump = $an->data->{'scan-ipmitool'}{thresholds}{$ipmitool_sensor_name}{jump};
	}
	
	# Final levels
	$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
		name1 => "machine",              value1 => $machine,
		name2 => "ipmitool_sensor_name", value2 => $ipmitool_sensor_name,
		name3 => "high_warning",         value3 => $high_warning, 
		name4 => "high_critical",        value4 => $high_critical, 
		name5 => "low_warning",          value5 => $low_warning, 
		name6 => "low_critical",         value6 => $low_critical, 
		name7 => "jump",                 value7 => $jump, 
		name8 => "buffer",               value8 => $buffer,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Now, has the value climbed, fallen or stayed the same? Pretend it is rising if it is a new sensor.
	if (($new_ipmitool_value_sensor_value > $old_ipmitool_value_sensor_value) || (not $old_ipmitool_value_sensor_value))
	{
		### Rising.
		# 
		# If it is over the high critical level, clear the 'warning', set the 'critical' and, if 
		# needed, add the entry to 'temperature'.
		# 
		# If it is over the high warning, check and set the warning.
		# 
		# If it is over the low warning, check and clear both critical and warning, and clear the
		# 'temperature' entry, if needed.
		#
		# If it is over the low critical, but not low warning, clear the critical and set the warning.
		# Clear the 'temperature' entry, if it exists.
		# 
		# If the temperature jumped above the set per-cycle change limit, trigger an alarm no matter
		# what.
		if ($new_ipmitool_value_sensor_value > $high_critical)
		{
			# We've gone critical. If it was previously 'warning', clear them.
			foreach my $type ("temperature_high_warning", "temperature_low_warning", "temperature_low_critical")
			{
				$an->Alert->check_alert_sent({
					type			=>	"clear",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
					alert_name		=>	$type,
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
			}
			
			# Set the critical warning.
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			
			# If set, alert the user and register with 'temperature'.
			if ($set)
			{
				# This is the first time we climbed. Send an alert and then register the 
				# entry in the database's 'temperature' table.
				$level       = "critical";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0004";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($new_ipmitool_value_sensor_value > $high_warning)
		{
			# The temp is rising, so the 'high_critical' should not be set, but check/clear it 
			# anyway to be safe.
			$an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($set)
			{
				# Tell the user that the temperature is rising.
				$level       = "warning";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0005";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($new_ipmitool_value_sensor_value > ($low_warning + $buffer))
		{
			# If there was a 'low_warning' or 'low_critical', clear it and tell the user that 
			# we're OK now.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $clear_warning = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if (($clear_critical) or ($clear_warning))
			{
				# Tell the user we're OK again. Whether this is a 'critical' or 'warning' 
				# level alert depends on what it was before. We want people who only get 
				# critical alerts to know we're OK if they got the critical alarm.
				$level       = $clear_critical ? "critical" : "warning";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0006";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($new_ipmitool_value_sensor_value > ($low_critical + $buffer))
		{
			# It has risen above critically low levels.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($clear_critical)
			{
				# Tell the user we're getting better.
				$level       = "critical";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0010";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		else
		{
			# it is floating in the safe area.
		}
		
		# Check for a jump now, if we have an old value.
		if ($old_ipmitool_value_sensor_value)
		{
			my $delta = ($new_ipmitool_value_sensor_value - $old_ipmitool_value_sensor_value);
			if ($delta > $jump)
			{
				# Temperature jumped. This is a stand-alone 'warning' level alarm.
				my $sensor_name      = "name=$ipmitool_sensor_name:units=C";
				my $new_sensor_value = "value=$new_ipmitool_value_sensor_value:units=C";
				my $old_sensor_value = "value=$old_ipmitool_value_sensor_value:units=C";
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0004",
					alert_message_key	=>	"scan_ipmitool_message_0007",
					alert_message_variables	=>	{
						sensor_name		=>	$sensor_name,
						new_sensor_value	=>	$new_sensor_value,
						old_sensor_value	=>	$old_sensor_value
					},
				});
			}
		}
	}
	elsif ($new_ipmitool_value_sensor_value < $old_ipmitool_value_sensor_value)
	{
		### Falling.
		#
		# If it is below the high critical, but not high warning, clear the critical and set the 
		# warning. Clear the 'temperature' entry, if it exists.
		# 
		# If it is below the high warning, check and clear both critical and warning, and clear the
		# 'temperature' entry, if needed.
		# 
		# If it is below the low critical level, clear the 'warning', set the 'critical' and, if 
		# needed, add the entry to 'temperature'.
		# 
		# If it is below the low warning, check and set the warning.
		if ($new_ipmitool_value_sensor_value < $low_critical)
		{
			# We've gone critical. Clear previous alerts...
			foreach my $type ("temperature_high_critical", "temperature_high_warning", "temperature_low_warning")
			{
				$an->Alert->check_alert_sent({
					type			=>	"clear",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
					alert_name		=>	$type,
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
			}
			
			# Now set the critical warning.
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			
			# If set, alert the user and register with 'temperature'.
			if ($set)
			{
				# This is the first time we climbed. Send an alert and then register the 
				# entry in the database's 'temperature' table.
				$level       = "critical";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0008";
			}
		}
		elsif ($new_ipmitool_value_sensor_value < $low_warning)
		{
			# The temp is dropping, so the 'low_critical' should not be set, but check/clear it 
			# anyway to be safe.
			$an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $set = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($set)
			{
				# Tell the user that the temperature is rising.
				$level       = "warning";
				$title_key   = "an_alert_title_0005";
				$message_key = "scan_ipmitool_message_0009";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($new_ipmitool_value_sensor_value < ($high_warning - $buffer))
		{
			# If there was a 'high_warning' or 'high_critical', clear it and tell the user that 
			# we're OK now.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			my $clear_warning = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_high_warning",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if (($clear_critical) or ($clear_warning))
			{
				# Tell the user we're OK again. Whether this is a 'critical' or 'warning' 
				# level alert depends on what it was before. We want people who only get 
				# critical alerts to know we're OK if they got the critical alarm.
				$level       = $clear_critical ? "critical" : "warning";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0006";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($new_ipmitool_value_sensor_value < ($high_critical - $buffer))
		{
			# It is below critically high levels.
			my $clear_critical = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$machine:$ipmitool_sensor_name",
				alert_name		=>	"temperature_low_critical",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			if ($clear_critical)
			{
				# Tell the user we're OK again.
				$level       = "critical";
				$title_key   = "an_alert_title_0006";
				$message_key = "scan_ipmitool_message_0011";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "title_key",   value2 => $title_key, 
					name3 => "message_key", value3 => $message_key, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		else
		{
			# it is floating in the safe area.
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "title_key",   value1 => $title_key, 
		name2 => "message_key", value2 => $message_key, 
	}, file => $THIS_FILE, line => __LINE__});
	return($level, $title_key, $message_key);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an, $machine) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "read_last_scan" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "machine", value1 => "$machine" 
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: This might be useful later
	# Make sure I don't have any stray data for this machine.
	#delete $an->data->{sql}{$machine};
	
	# Read in existing data, if any.
	my $query = "
SELECT 
    a.ipmitool_uuid, 
    a.ipmitool_sensor_name, 
    a.ipmitool_sensor_units, 
    a.ipmitool_sensor_status, 
    a.ipmitool_sensor_high_critical, 
    a.ipmitool_sensor_high_warning, 
    a.ipmitool_sensor_low_critical, 
    a.ipmitool_sensor_low_warning, 
    b.ipmitool_value_sensor_value 
FROM 
    ipmitool a, 
    ipmitool_value b 
WHERE 
    a.ipmitool_uuid = b.ipmitool_value_ipmitool_uuid
AND 
    a.ipmitool_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($machine)." 
AND 
    a.ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $ipmitool_uuid                 = $row->[0];
		my $ipmitool_sensor_name          = $row->[1];
		my $ipmitool_sensor_units         = $row->[2];
		my $ipmitool_sensor_status        = $row->[3];
		my $ipmitool_sensor_high_critical = $row->[4];
		my $ipmitool_sensor_high_warning  = $row->[5];
		my $ipmitool_sensor_low_critical  = $row->[6];
		my $ipmitool_sensor_low_warning   = $row->[7];
		my $ipmitool_value_sensor_value   = $row->[8];
		
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid}                 = $ipmitool_uuid;
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units}         = $ipmitool_sensor_units;
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status}        = $ipmitool_sensor_status;
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical} = $ipmitool_sensor_high_critical ? $ipmitool_sensor_high_critical : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning}  = $ipmitool_sensor_high_warning  ? $ipmitool_sensor_high_warning  : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical}  = $ipmitool_sensor_low_critical  ? $ipmitool_sensor_low_critical  : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning}   = $ipmitool_sensor_low_warning   ? $ipmitool_sensor_low_warning   : "NULL";
		$an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value}   = $ipmitool_value_sensor_value;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_uuid",                 value1 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_uuid}, 
			name2 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_units",         value2 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_units}, 
			name3 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_status",        value3 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_status}, 
			name4 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_high_critical", value4 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_critical}, 
			name5 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_high_warning",  value5 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_high_warning}, 
			name6 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_low_critical",  value6 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_critical}, 
			name7 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_sensor_low_warning",   value7 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_sensor_low_warning}, 
			name8 => "sql::${machine}::ipmitool_sensor_name::${ipmitool_sensor_name}::ipmitool_value_sensor_value",   value8 => $an->data->{sql}{$machine}{ipmitool_sensor_name}{$ipmitool_sensor_name}{ipmitool_value_sensor_value}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return($count);
}

# This looks at each DB's 'updated' table entry to see if any tables are behind. If any are, it will update 
# the tables based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Update apc_ups and interfaces
		update_db_ipmitool($an);
		update_db_ipmitool_value($an);
	
		# Release the lock
		$an->DB->locking({release => 1});
	}
	
	return(0);
}

# Update the 'ipmitool_value' table.
sub update_db_ipmitool_value
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_ipmitool_value" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'ipmitool_value' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    a.ipmitool_value_ipmitool_uuid, 
    a.ipmitool_value_sensor_value, 
    a.modified_date 
FROM 
    history.ipmitool_value a, 
    ipmitool b 
WHERE 
    a.ipmitool_value_ipmitool_uuid = b.ipmitool_uuid 
AND 
    b.ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "results", value1 => $results, 
			name2 => "count",   value2 => $count, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $ipmitool_value_ipmitool_uuid = $row->[0]; 
			my $ipmitool_value_sensor_value  = $row->[1]; 
			my $modified_date                = $row->[2];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "ipmitool_value_ipmitool_uuid", value1 => $ipmitool_value_ipmitool_uuid, 
				name2 => "ipmitool_value_sensor_value",  value2 => $ipmitool_value_sensor_value, 
				name3 => "modified_date",                value3 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid} = {
				ipmitool_value_sensor_value	=>	$ipmitool_value_sensor_value, 
			};
			$an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid} = {
				ipmitool_value_sensor_value	=>	$ipmitool_value_sensor_value, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{ipmitool_value}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $ipmitool_value_ipmitool_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}})
		{
			my $ipmitool_value_sensor_value = $an->data->{db_data}{unified}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{ipmitool_value_sensor_value}; 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "ipmitool_value_ipmitool_uuid", value1 => $ipmitool_value_ipmitool_uuid, 
				name2 => "ipmitool_value_sensor_value",  value2 => $ipmitool_value_sensor_value, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'ipmitool_value_ipmitool_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::ipmitool_value::ipmitool_value_ipmitool_uuid::${ipmitool_value_ipmitool_uuid}::seen", value1 => $an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::ipmitool_value::ipmitool_value_ipmitool_uuid::${ipmitool_value_ipmitool_uuid}::exists", value1 => $an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{ipmitool_value}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::ipmitool_value::modified_date::${modified_date}::ipmitool_value_ipmitool_uuid::${ipmitool_value_ipmitool_uuid}", value1 => $an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.ipmitool_value
SET
    ipmitool_value_sensor_value = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_sensor_value).", 
    modified_date               = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.ipmitool_value
(
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_sensor_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						
						# Because this is the old '_id' system, we need to do a 
						# sub-select to get the IDs from the UUIDs. To make sure this
						# can work, we need to INSERT these immediately and accept 
						# the performance hit.
						$an->DB->do_db_write({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
					}
				}
				else
				{
					# We've seen this 'ipmitool_value_ipmitool_uuid' before, so it is just
					# a question of whether the entry for the current timestamp exists in
					# the history schema.
					if (not $an->data->{db_data}{$id}{ipmitool_value}{modified_date}{$modified_date}{ipmitool_value_ipmitool_uuid}{$ipmitool_value_ipmitool_uuid})
					{
						# Get the ID for this.
						my $ipmitool_value_id = get_ipmitool_value_id($an, $ipmitool_value_ipmitool_uuid, $id);
						next if not $ipmitool_value_id;
						
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.ipmitool_value
(
    ipmitool_value_id, 
    ipmitool_value_ipmitool_uuid, 
    ipmitool_value_sensor_value, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_sensor_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen ipmitool_value_ipmitool_uuid?
			} # foreach my $id 
		} # foreach my $ipmitool_value_ipmitool_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This returns the ipmitool_value_id for a given ipmitool_value_ipmitool_uuid
sub get_ipmitool_value_id
{
	my ($an, $ipmitool_value_ipmitool_uuid, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_ipmitool_value_id" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "ipmitool_value_ipmitool_uuid", value1 => $ipmitool_value_ipmitool_uuid, 
		name2 => "id",                           value2 => $id, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $ipmitool_value_id = 'NULL';
	my $query             = "
SELECT 
    ipmitool_value_id 
FROM 
    public.ipmitool_value 
WHERE 
    ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "id",    value1 => $id, 
		name2 => "query", value2 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do the query against the source DB and loop through the results.
	my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# There should be only one result
	if ($count != 1)
	{
		### We need to fix this. So we'll register a notice level alert and then delete the entries.
		# Get the other details on this sensor.
		my $query = "
SELECT 
    a.ipmitool_sensor_host, 
    a.ipmitool_sensor_name, 
    a.ipmitool_sensor_units, 
    a.ipmitool_sensor_status, 
    b.ipmitool_value_id, 
    b.ipmitool_value_sensor_value, 
    b.modified_date 
FROM 
    ipmitool a, 
    ipmitool_value b 
WHERE 
    a.ipmitool_uuid = b.ipmitool_value_ipmitool_uuid 
AND 
    b.ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid)."
ORDER BY 
    b.ipmitool_value_id ASC
;";
		$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Delete
		my $alerted = 0;
		foreach my $row (@{$results})
		{
			my $ipmitool_sensor_host        = defined $row->[0] ? $row->[0] : "--";
			my $ipmitool_sensor_name        = defined $row->[1] ? $row->[1] : "--";
			my $ipmitool_sensor_units       = defined $row->[2] ? $row->[2] : "--";
			my $ipmitool_sensor_status      = defined $row->[3] ? $row->[3] : "--";
			my $this_ipmitool_value_id      = defined $row->[4] ? $row->[4] : "--";
			my $ipmitool_value_sensor_value = defined $row->[5] ? $row->[5] : "--";
			my $modified_date               = defined $row->[6] ? $row->[6] : "--";
			$an->Log->entry({log_level => 1, message_key => "an_variables_0007", message_variables => {
				name1 => "ipmitool_sensor_host",        value1 => $ipmitool_sensor_host, 
				name2 => "ipmitool_sensor_name",        value2 => $ipmitool_sensor_name, 
				name3 => "ipmitool_sensor_units",       value3 => $ipmitool_sensor_units, 
				name4 => "ipmitool_sensor_status",      value4 => $ipmitool_sensor_status, 
				name5 => "this_ipmitool_value_id",      value5 => $this_ipmitool_value_id, 
				name6 => "ipmitool_value_sensor_value", value6 => $ipmitool_value_sensor_value, 
				name7 => "modified_date",               value7 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (not $alerted)
			{
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_ipmitool_message_0016",
					alert_message_variables	=>	{
						sensor			=>	$ipmitool_sensor_name,
						host			=>	$ipmitool_sensor_host,
						value			=>	$ipmitool_value_sensor_value." ".$ipmitool_sensor_units." (".$ipmitool_sensor_status.")",
						count			=>	$count,
					},
				});
				$ipmitool_value_id = $this_ipmitool_value_id;
				$alerted           = 1;
				$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
					name1 => "ipmitool_value_id", value1 => $ipmitool_value_id, 
					name2 => "alerted",           value2 => $alerted, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# We kept the first one, now we'll delete the rest.
				my $query = "DELETE FROM ipmitool_value WHERE ipmitool_value_ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_ipmitool_uuid)." AND ipmitool_value_id = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_value_id);
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "done", value1 => "-----", 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	else
	{
		# Return only the first.
		$ipmitool_value_id = $results->[0]->[0]; 
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "ipmitool_value_id", value1 => $ipmitool_value_id, 
		}, file => $THIS_FILE, line => __LINE__});
	}

	return($ipmitool_value_id);
}

# Update the 'ipmitool' DB table, if needed.
sub update_db_ipmitool
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_ipmitool" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'ipmitool' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    ipmitool_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date 
FROM 
    history.ipmitool 
WHERE
    ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "results", value1 => $results, 
			name2 => "count",   value2 => $count, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $ipmitool_uuid                 = $row->[0];
			my $ipmitool_sensor_host          = $row->[1];
			my $ipmitool_sensor_name          = $row->[2];
			my $ipmitool_sensor_units         = $row->[3];
			my $ipmitool_sensor_status        = $row->[4];
			my $ipmitool_sensor_high_critical = $row->[5];
			my $ipmitool_sensor_high_warning  = $row->[6];
			my $ipmitool_sensor_low_critical  = $row->[7];
			my $ipmitool_sensor_low_warning   = $row->[8];
			my $modified_date                 = $row->[9];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "ipmitool_uuid",                 value1  => $ipmitool_uuid, 
				name2  => "ipmitool_sensor_host",          value2  => $ipmitool_sensor_host, 
				name3  => "ipmitool_sensor_name",          value3  => $ipmitool_sensor_name, 
				name4  => "ipmitool_sensor_units",         value4  => $ipmitool_sensor_units, 
				name5  => "ipmitool_sensor_status",        value5  => $ipmitool_sensor_status, 
				name6  => "ipmitool_sensor_high_critical", value6  => $ipmitool_sensor_high_critical, 
				name7  => "ipmitool_sensor_high_warning",  value7  => $ipmitool_sensor_high_warning, 
				name8  => "ipmitool_sensor_low_critical",  value8  => $ipmitool_sensor_low_critical, 
				name9  => "ipmitool_sensor_low_warning",   value9  => $ipmitool_sensor_low_warning, 
				name10 => "modified_date",                 value10 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid} = {
				ipmitool_uuid			=>	$ipmitool_uuid, 
				ipmitool_sensor_host		=>	$ipmitool_sensor_host, 
				ipmitool_sensor_name		=>	$ipmitool_sensor_name, 
				ipmitool_sensor_units		=>	$ipmitool_sensor_units, 
				ipmitool_sensor_status		=>	$ipmitool_sensor_status, 
				ipmitool_sensor_high_critical	=>	$ipmitool_sensor_high_critical, 
				ipmitool_sensor_high_warning	=>	$ipmitool_sensor_high_warning, 
				ipmitool_sensor_low_critical	=>	$ipmitool_sensor_low_critical, 
				ipmitool_sensor_low_warning	=>	$ipmitool_sensor_low_warning, 
			};
			$an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid} = {
				ipmitool_uuid			=>	$ipmitool_uuid, 
				ipmitool_sensor_host		=>	$ipmitool_sensor_host, 
				ipmitool_sensor_name		=>	$ipmitool_sensor_name, 
				ipmitool_sensor_units		=>	$ipmitool_sensor_units, 
				ipmitool_sensor_status		=>	$ipmitool_sensor_status, 
				ipmitool_sensor_high_critical	=>	$ipmitool_sensor_high_critical, 
				ipmitool_sensor_high_warning	=>	$ipmitool_sensor_high_warning, 
				ipmitool_sensor_low_critical	=>	$ipmitool_sensor_low_critical, 
				ipmitool_sensor_low_warning	=>	$ipmitool_sensor_low_warning, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{ipmitool}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $ipmitool_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}})
		{
			my $ipmitool_sensor_host          = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_host};
			my $ipmitool_sensor_name          = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_name};
			my $ipmitool_sensor_units         = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_units};
			my $ipmitool_sensor_status        = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_status};
			my $ipmitool_sensor_high_critical = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_high_critical};
			my $ipmitool_sensor_high_warning  = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_high_warning};
			my $ipmitool_sensor_low_critical  = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_low_critical};
			my $ipmitool_sensor_low_warning   = $an->data->{db_data}{unified}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}{ipmitool_sensor_low_warning};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1  => "ipmitool_uuid",                 value1  => $ipmitool_uuid, 
				name2  => "ipmitool_sensor_host",          value2  => $ipmitool_sensor_host, 
				name3  => "ipmitool_sensor_name",          value3  => $ipmitool_sensor_name, 
				name4  => "ipmitool_sensor_units",         value4  => $ipmitool_sensor_units, 
				name5  => "ipmitool_sensor_status",        value5  => $ipmitool_sensor_status, 
				name6  => "ipmitool_sensor_high_critical", value6  => $ipmitool_sensor_high_critical, 
				name7  => "ipmitool_sensor_high_warning",  value7  => $ipmitool_sensor_high_warning, 
				name8  => "ipmitool_sensor_low_critical",  value8  => $ipmitool_sensor_low_critical, 
				name9  => "ipmitool_sensor_low_warning",   value9  => $ipmitool_sensor_low_warning, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'ipmitool_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::ipmitool::ipmitool_uuid::${ipmitool_uuid}::seen", value1 => $an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::ipmitool::ipmitool_uuid::${ipmitool_uuid}::exists", value1 => $an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{ipmitool}{ipmitool_uuid}{$ipmitool_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::ipmitool::modified_date::${modified_date}::ipmitool_uuid::${ipmitool_uuid}", value1 => $an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.ipmitool
SET
    ipmitool_sensor_host          = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_host).", 
    ipmitool_sensor_name          = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ipmitool_sensor_units         = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_units).", 
    ipmitool_sensor_status        = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_status).", 
    ipmitool_sensor_high_critical = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_critical).", 
    ipmitool_sensor_high_warning  = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_warning).", 
    ipmitool_sensor_low_critical  = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_critical).", 
    ipmitool_sensor_low_warning   = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_warning).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ipmitool_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    ipmitool_uuid      = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.ipmitool
(
    ipmitool_host_uuid, 
    ipmitool_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_units).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						
						### NOTE: On some occasions, for as-yet unknown reasons, a 
						###       record can end up in the public schema while 
						###       nothing exists in the history schema (which is what
						###       we read during a resync). To deal with this, we'll 
						###       do an explicit check before confirming the INSERT).
						my $count_query = "SELECT COUNT(*) FROM public.ipmitool WHERE ipmitool_uuid = ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).";";
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "count_query", value1 => $count_query, 
						}, file => $THIS_FILE, line => __LINE__});
						my $count = $an->DB->do_db_query({id => $id, query => $count_query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "count", value1 => $count, 
						}, file => $THIS_FILE, line => __LINE__});
						if ($count)
						{
							# Already in, redirect to the history schema.
							$an->Log->entry({log_level => 1, message_key => "scancore_warning_0003", message_variables => {
								table  => "ipmitool", 
								id     => $id, 
								query  => $query, 
							}, file => $THIS_FILE, line => __LINE__});
							$query =~ s/ public.ipmitool/ history.ipmitool/gs;
							push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
						}
						else
						{
							# No problem, record the query in the array
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
				}
				else
				{
					# We've seen this 'ipmitool_uuid' before, so it is just a question of 
					# whether the entry for the current timestamp exists in the history 
					# schema.
					if (not $an->data->{db_data}{$id}{ipmitool}{modified_date}{$modified_date}{ipmitool_uuid}{$ipmitool_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.ipmitool
(
    ipmitool_host_uuid, 
    ipmitool_uuid, 
    ipmitool_sensor_host, 
    ipmitool_sensor_name, 
    ipmitool_sensor_units, 
    ipmitool_sensor_status, 
    ipmitool_sensor_high_critical, 
    ipmitool_sensor_high_warning, 
    ipmitool_sensor_low_critical, 
    ipmitool_sensor_low_warning, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_units).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_high_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_critical).", 
    ".$an->data->{sys}{use_db_fh}->quote($ipmitool_sensor_low_warning).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen ipmitool_uuid?
			} # foreach my $id 
		} # foreach my $ipmitool_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}

	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load the schema. If the schema gets
# loaded, we'll check other databases for older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => $THIS_FILE }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='ipmitool' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# Query IPMI targets. Unreachable targets will simply be ignored.
sub query_ipmi_targets
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "query_ipmi_targets" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	foreach my $machine (sort {$a cmp $b} keys %{$an->data->{'scan-ipmitool'}{machine}})
	{
		my $ipmitool_command = $an->data->{'scan-ipmitool'}{machine}{$machine}{ipmitool_command};
		my $ipmi_password    = $an->data->{'scan-ipmitool'}{machine}{$machine}{ipmi_password};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "machine",          value1 => $machine,
			name2 => "ipmitool_command", value2 => $ipmitool_command,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "ipmi_password", value1 => $ipmi_password, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# If there is a password, write it to a temp file.
		my $temp_file  = "";
		if ($ipmi_password)
		{
			# Write the password to a temp file.
			   $temp_file  = "/tmp/scan-ipmitool";
			my $shell_call = $temp_file;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			print $file_handle $ipmi_password;
			close $file_handle;
		}
		
		# Time the call.
		my $read_start_time = time;
		$an->Log->entry({log_level => 2, message_key => "scan_ipmitool_log_0001", message_variables => {
			machine => $machine, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Call with a timeout in case the call hangs.
		my $shell_call = $an->data->{path}{timeout}." 30 ".$ipmitool_command." sensor list all || ".$an->data->{path}{echo}." timeout";
		if ($ipmi_password)
		{
			$shell_call = $an->data->{path}{timeout}." 30 ".$ipmitool_command." -f ".$temp_file." sensor list all || ".$an->data->{path}{echo}." timeout";
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => ">> line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+\|/|/g;
			   $line =~ s/\|\s+/|/g;
			
			# This will change 'na' to NULL, but we don't want NULL for status, so we'll flip it 
			# back below.
			my $i = 0;
			while ($line =~ /\|na\|/)
			{
				$line =~ s/\|na\|/|NULL|/g;
				$line =~ s/\|na$/|NULL/g;
				$i++;
				die "Loop processing: [$line]\n" if $i > 20;
			}
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			### TODO: If we determine that the IPMI BMC is hung, set the health to '10'
			###       $an->data->{health}{new}{'ipmi:bmc_controller'} = 10;
			# Catch errors:
			if ($line =~ /Activate Session command failed/)
			{
				# Failed to connect.
				$an->Log->entry({log_level => 1, message_key => "scan_ipmitool_log_0003", message_variables => {
					machine => $machine, 
					call    => $ipmitool_command, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			next if $line !~ /\|/;
			
			#     high fail -------------------------------------.
			# high critical ---------------------------------.   |
			#  high warning -----------------------------.   |   |
			#   low warning -------------------------.   |   |   |
			#  low critical ---------------------.   |   |   |   |
			#      low fail -----------------.   |   |   |   |   |
			#        status -------------.   |   |   |   |   |   |
			#         units ---------.   |   |   |   |   |   |   |
			# current value -----.   |   |   |   |   |   |   |   |
			#   sensor name -.   |   |   |   |   |   |   |   |   |
			# Columns:       |   |   |   |   |   |   |   |   |   |
			#                x | x | x | x | x | x | x | x | x | x 
			my ($sensor_name, 
				$current_value, 
				$units, 
				$status, 
				$low_fail, 
				$low_critical, 
				$low_warning, 
				$high_warning, 
				$high_critical, 
				$high_fail) = split /\|/, $line;
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "sensor_name",   value1  => $sensor_name, 
				name2  => "current_value", value2  => $current_value, 
				name3  => "units",         value3  => $units, 
				name4  => "status",        value4  => $status, 
				name5  => "low_fail",      value5  => $low_fail, 
				name6  => "low_critical",  value6  => $low_critical, 
				name7  => "low_warning",   value7  => $low_warning, 
				name8  => "high_warning",  value8  => $high_warning, 
				name9  => "high_critical", value9  => $high_critical, 
				name10 => "high_fail",     value10 => $high_fail, 
			}, file => $THIS_FILE, line => __LINE__});
			
			next if not $sensor_name;
			next if not $status;
			next if not $units;
			next if $units =~ /discrete/;
			#next if $status =~ /^0x/;
			
			$units = "C" if $units =~ /degrees C/i;
			$units = "F" if $units =~ /degrees F/i;
			$units = "%" if $units =~ /percent/i;
			$units = "W" if $units =~ /watt/i;
			$units = "V" if $units =~ /volt/i;
			
			# The BBU and RAID Controller, as reported by IPMI, is flaky and redundant. We 
			# monitor it via storcli/hpacucli (or OEM variant of), so we ignore it here.
			next if $sensor_name eq "BBU";
			next if $sensor_name eq "RAID Controller";
			
			# The status line is NOT NULL, so I need to change it to 'na' (not available).
			$status = "na" if $status eq "NULL";
			
			# Values in the DB that are 'double precision' must be 'NULL' if not set.
			$current_value = 'NULL' if not $current_value;
			$low_fail      = 'NULL' if not $low_fail;
			$low_critical  = 'NULL' if not $low_critical;
			$low_warning   = 'NULL' if not $low_warning;
			$high_warning  = 'NULL' if not $high_warning;
			$high_critical = 'NULL' if not $high_critical;
			$high_fail     = 'NULL' if not $high_fail;
			
			# Some values list 'inf' on some machines (HP...). Convert these to NULL.
			$current_value = 'NULL' if $current_value eq "inf";
			$low_fail      = 'NULL' if $low_fail      eq "inf";
			$low_critical  = 'NULL' if $low_critical  eq "inf";
			$low_warning   = 'NULL' if $low_warning   eq "inf";
			$high_warning  = 'NULL' if $high_warning  eq "inf";
			$high_critical = 'NULL' if $high_critical eq "inf";
			$high_fail     = 'NULL' if $high_fail     eq "inf";
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "sensor_name",   value1  => $sensor_name, 
				name2  => "current_value", value2  => $current_value, 
				name3  => "units",         value3  => $units, 
				name4  => "status",        value4  => $status, 
				name5  => "low_fail",      value5  => $low_fail, 
				name6  => "low_critical",  value6  => $low_critical, 
				name7  => "low_warning",   value7  => $low_warning, 
				name8  => "high_warning",  value8  => $high_warning, 
				name9  => "high_critical", value9  => $high_critical, 
				name10 => "high_fail",     value10 => $high_fail, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($units eq "F")
			{
				# Convert to 'C'
				$high_critical = $an->Convert->convert_to_celsius({temperature => $high_critical}) if $high_critical ne "";
				$high_warning  = $an->Convert->convert_to_celsius({temperature => $high_warning})  if $high_warning  ne "";
				$low_critical  = $an->Convert->convert_to_celsius({temperature => $low_critical})  if $low_critical  ne "";
				$low_warning   = $an->Convert->convert_to_celsius({temperature => $low_warning})   if $low_warning   ne "";
				$units         = "C";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
					name1 => "low_critical",  value1 => $low_critical, 
					name2 => "low_warning",   value2 => $low_warning, 
					name3 => "high_warning",  value3 => $high_warning, 
					name4 => "high_critical", value4 => $high_critical, 
					name5 => "units",         value5 => $units, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			### TODO: It looks like the PSU state and the PSU temperature are called, simply, 
			###       'PSUx'... If so, change the temperature to 'PSUx Temperature'
			if (($units eq "C") && ($sensor_name =~ /^PSU\d/i))
			{
				$sensor_name .= " Temperature";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "sensor_name", value1 => $sensor_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Similarly, 'PSUx Power' is used for power status and wattage....
			if (($units eq "W") && ($sensor_name =~ /PSU\d Power/i))
			{
				$sensor_name =~ s/Power/Wattage/;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "sensor_name", value1 => $sensor_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# And again, 'FAN PSUx' is used for both RPM and state...
			if (($units eq "RPM") && ($sensor_name =~ /^FAN PSU\d/i))
			{
				$sensor_name .= " RPM";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "sensor_name", value1 => $sensor_name, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Record
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_value_sensor_value}   = $current_value;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_units}         = $units;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_status}        = $status;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_critical} = $high_critical;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_warning}  = $high_warning;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_critical}  = $low_critical;
			$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_warning}   = $low_warning;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
				name1 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_value_sensor_value",   value1 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_value_sensor_value}, 
				name2 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_units",         value2 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_units}, 
				name3 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_status",        value3 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_status}, 
				name4 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_high_critical", value4 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_critical}, 
				name5 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_high_warning",  value5 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_high_warning}, 
				name6 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_low_critical",  value6 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_critical}, 
				name7 => "ipmi::${machine}::ipmitool_sensor_name::${sensor_name}::ipmitool_sensor_low_warning",   value7 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$sensor_name}{ipmitool_sensor_low_warning}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If this is a temperature, check to see if it is outside its nominal range and, if
			# so, record it into a hash for loading into ScanCore's 'temperature' table.
			if ($units eq "C")
			{
				log_abnormal_temperatures($an, $machine, $sensor_name);
			}
		}
		close $file_handle;
		
		# Delete the temp file.
		unlink $temp_file;
		
		# Record how long it took.
		my $sensor_read_time = $an->Readable->time({'time' => (time - $read_start_time)});
		$an->Log->entry({log_level => 2, message_key => "scan_ipmitool_log_0002", message_variables => {
			machine => $machine, 
			'time'  => $sensor_read_time
		}, file => $THIS_FILE, line => __LINE__});
		
		# If a PSU is OK, but its wattage is 0, input power was lost. We'll switch the PSU state to 
		# ensure this sets a health value. We'll check for five PSUs, though very very few should 
		# have more than 2.
		foreach my $i (1..5)
		{
			my $psu_key = "PSU".$i;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "i",       value1 => $i, 
				name2 => "psu_key", value2 => $psu_key, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (exists $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$psu_key})
			{
				# TODO: Is this the key for HP machines, too?
				my $wattage_key = $psu_key." Power";
				my $psu_value   = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$psu_key}{ipmitool_value_sensor_value};
				my $psu_status  = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$psu_key}{ipmitool_sensor_status};
				my $psu_wattage = $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$wattage_key}{ipmitool_value_sensor_value};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
					name1 => "wattage_key", value1 => $wattage_key, 
					name2 => "psu_value",   value2 => $psu_value, 
					name3 => "psu_status",  value3 => $psu_status, 
					name4 => "psu_wattage", value4 => $psu_wattage, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ((lc($psu_status) eq "ok") && (lc($psu_wattage) eq "no reading"))
				{
					# Change the status to 'no signal'
					$an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$psu_key}{ipmitool_sensor_status} = "ns";
					$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
						name1 => "ipmi::${machine}::ipmitool_sensor_name::${psu_key}::ipmitool_sensor_status", value1 => $an->data->{ipmi}{$machine}{ipmitool_sensor_name}{$psu_key}{ipmitool_sensor_status}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			else
			{
				# This PSU doesn't exist, we're done.
				last;
			}
		}
	}
	
	return(0);
}

# This calls anvil-report-ipmi-details to find IPMI devices to scan. It also handles any user-defined IPMI 
# devices set in striker.conf.
sub find_ipmi_targets
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_ipmi_targets" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will keep track of how many IPMI targets we find.
	my $ipmi_targets = 0;

	# If I am a node, I will only scan myself.
	my $i_am_a   = $an->Get->what_am_i();
	my $hostname = $an->hostname();
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "i_am_a",   value1 => $i_am_a,
		name2 => "hostname", value2 => $hostname
	}, file => $THIS_FILE, line => __LINE__});
	
	# This returns an array reference of power_check commands that this machine knows about.
	my $power_check_data = $an->ScanCore->get_power_check_data();
	foreach my $hash_ref (@{$power_check_data})
	{
		my $node_name           = $hash_ref->{node_name};
		my $node_uuid           = $hash_ref->{node_uuid};
		my $power_check_command = $hash_ref->{power_check_command};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "node_name", value1 => $node_name,
			name2 => "node_uuid", value2 => $node_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "power_check_command", value1 => $power_check_command, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Get the ipaddress and see if I can ping the target. If I can't, there is no sense in 
		# recording this entry.
		my $access = 0;
		my $target = ($power_check_command =~ /-a (.*?) /)[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "target", value1 => $target,
		}, file => $THIS_FILE, line => __LINE__});
		if ($target)
		{
			($access) = $an->Check->ping({ping => $target});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "access", value1 => $access,
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $access;
		$ipmi_targets++;
		
		# I need to remove the double-quotes from the '-p "<password>"'.
		$power_check_command =~ s/-p "(.*?)"/-p $1/;
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "power_check_command", value1 => $power_check_command,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Convert to an 'ipmitool' call.
		my $ipmitool_command = $an->data->{path}{ipmitool};
		my $ipmi_password    = "";
		if ($power_check_command =~ /-A (.*?) /)
		{
			# IPMI Lan Auth type (md5, password, or none)
			$ipmitool_command .= " -A $1";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmitool_command", value1 => $ipmitool_command, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($power_check_command =~ /-a (.*?) /)
		{
			# IPMI Lan IP to talk to
			$ipmitool_command .= " -H $1";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmitool_command", value1 => $ipmitool_command, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($power_check_command =~ /-P /)
		{
			# Use Lanplus to improve security of connection
			$ipmitool_command .= " -I lanplus";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmitool_command", value1 => $ipmitool_command, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($power_check_command =~ /-l (.*?) /)
		{
			# Username/Login (if required) to control power on IPMI device
			$ipmitool_command .= " -U $1";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmitool_command", value1 => $ipmitool_command, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($power_check_command =~ /-C (.*?) /)
		{
			# Ciphersuite to use (same as ipmitool -C parameter)
			$ipmitool_command .= " -C $1";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmitool_command", value1 => $ipmitool_command, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($power_check_command =~ /-L (.*?) /)
		{
			# Privilege level on IPMI device
			$ipmitool_command .= " -L $1";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmitool_command", value1 => $ipmitool_command, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($power_check_command =~ /-p (.*?) -/)
		{
			# Password (if required) to control power on IPMI device
			$ipmi_password .= "$1";
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "ipmi_password", value1 => $ipmi_password, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		$an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command} = $power_check_command;
		$an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command}    = $ipmitool_command;
		$an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}       = $ipmi_password;
		$an->Log->entry({log_level => 4, message_key => "an_variables_0003", message_variables => {
			name1 => "scan-ipmitool::machine::${node_name}::power_check_command", value1 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command},
			name2 => "scan-ipmitool::machine::${node_name}::ipmitool_command",    value2 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command},
			name3 => "scan-ipmitool::machine::${node_name}::ipmi_password",       value3 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Do I have local IPMI access?
	if ((-e '/dev/ipmi0') or (-e '/dev/ipmi/0') or (-e '/dev/ipmidev/0'))
	{
		my $shell_call = $an->data->{path}{timeout}." 30 ".$an->data->{path}{ipmitool}." chassis power status; ".$an->data->{path}{echo}." rc:\$?";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /rc:(\d+)/)
			{
				my $rc = $1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "rc", value1 => $rc, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($rc eq "0")
				{
					# We're good.
					   $ipmi_targets++;
					my $node_name                                                             = $an->hostname();
					   $an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command} = "";
					   $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command}    = $an->data->{path}{ipmitool};
					   $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}       = "";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
						name1 => "scan-ipmitool::machine::${node_name}::power_check_command", value1 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{power_check_command},
						name2 => "scan-ipmitool::machine::${node_name}::ipmitool_command",    value2 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmitool_command},
						name3 => "scan-ipmitool::machine::${node_name}::ipmi_password",       value3 => $an->data->{'scan-ipmitool'}{machine}{$node_name}{ipmi_password}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		close $file_handle;
	}
	
	return($ipmi_targets);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_ipmitool_message_0002"})."\n";

	return(0);
}
