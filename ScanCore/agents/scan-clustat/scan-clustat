#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# - See: https://alteeve.ca/w/ScanCoreAPI#Agent_Exit_Codes
# - 
# 

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory  = ($0                 =~ /^(.*?)\/$THIS_FILE$/)[0];
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		clustat		=>	{
			cluster		=>	"",
			quorate		=>	"",
			node		=>	{},
			service		=>	{}
		},
		path		=>	{
			log_file		=>	"/var/log/striker.log",
			#log_file		=>	"/var/log/$THIS_FILE.log",
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"$scancore_directory/Data/strings.xml",
			clustat			=>	"/usr/sbin/clustat",
		},
		sys		=>	{
			log_level		=>	2,
			log_language		=>	"en_CA",
		},
	}
});

# Read my stuff
$an->Log->level($an->data->{sys}{log_level});
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
$an->String->read_words({file => $an->data->{path}{strings}});
$an->String->read_words({file => $an->data->{path}{core_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for
# help.
print $an->String->get({key => "scan_clustat_message_0001"}), "\n";
get_switches($an);

# Read in clustat. If it returns '1', then clustat wasn't found and we will
# exit.
if (parse_clustat($an))
{
	# Clustat not found, exit.
	nice_exit($an, 1);
}

# I'll need to loop through the DBs and ensure our schema is loaded for each
# one.
my $connections = $an->DB->connect_to_databases();
$an->Log->entry({
	log_level	=>	3,
	title_key	=>	"scancore_title_0001",
	message_key	=>	"scancore_log_0005",
	message_vars	=>	{
		connections	=>	$connections,
	},
	file		=>	$THIS_FILE,
	line		=>	__LINE__,
	language	=>	$an->data->{sys}{log_language},
	log_to		=>	$an->data->{path}{log_file},
});

# Do the loading of the schemas and copying data from more up to date DBs if
# the DB was loaded.
prep_databases($an);

# Look for changes.
find_changes($an);


# Clean up and go away.
nice_exit($an, 0);

###############################################################################
# Functions                                                                   #
###############################################################################

# This checks to see if this agent's databases tables exist and, if not, load
# the schema. If the schema gets loaded, we'll check other databases for
# older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_vars => { function => "prep_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0016", message_vars => { agent => "$THIS_FILE", db_id => $id }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file} });
		
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='clustat' AND schemaname='public';";
		my $count = $an->DB->db_do_query({id => $id, query => $query});
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => {name1 => "count", value1 => $count}, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file} });
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file} });
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file} });
		}
	}
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it
# against the just-read data. If anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_vars => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Pick a database to use. They should all be in sync so it doesn't
	# matter which.
	my $use_db_id = "";
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$use_db_id = $id;
		last;
	}
	
# 	$an->data->{clustat}{cluster}
# 	$an->data->{clustat}{quorate}
# 	$an->data->{clustat}{service}{$service}{host}
# 	$an->data->{clustat}{service}{$service}{status}
# 	$an->data->{clustat}{service}{$service}{is_server}
# 	$an->data->{clustat}{node}{$node}{id}
# 	$an->data->{clustat}{node}{$node}{status}
	
	#$an->DB->db_do_query({id => $use_db_id, query => $query});
	
	
	return(0);
}

# This looks rgmanager's 'clustat' and, if it is found, parse it.
sub parse_clustat
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_vars => { function => "parse_clustat", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	my $return_code  = 0;
	if (-e $an->data->{path}{clustat})
	{
=pod
 service:storage_an02           an-c01n02.alteeve.ca           started       
 vm:vm01-web01                  an-c01n02.alteeve.ca           started       
=cut
		# Found it!
		my $shell_call  = $an->data->{path}{clustat}." 2>&1 |";
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0007", message_vars => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
		open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "scancore_title_0003", message_key => "scancore_error_0006", message_vars => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__ });
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => { name1 => "line", value1 => "$line" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			
			if ($line =~ /Cluster Status for (.*?) /)
			{
				$an->data->{clustat}{cluster} = $1;
				$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => { name1 => "clustat::cluster", value1 => $an->data->{clustat}{cluster} }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			}
			elsif ($line =~ /Member Status: (.*)/)
			{
				my $quorum                       = $1;
				my $is_quorate                   = $quorum eq "Quorate" ? "TRUE" : "FALSE";
				   $an->data->{clustat}{quorate} = $is_quorate;
				$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => { name1 => "clustat::quorate", value1 => $an->data->{clustat}{quorate} }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			}
			# Pick out service lines
			elsif ($line =~ /^(.*?):(.*?) (.*?) (.*)/)
			{
				my $type      = $1;
				my $service   = $2;
				my $host      = $3;
				my $status    = $4;
				my $is_server = $type eq "vm" ? "TRUE" : "FALSE";
				
				# Record the node info.
				$an->data->{clustat}{service}{$service}{host}      = $host;
				$an->data->{clustat}{service}{$service}{status}    = $status;
				$an->data->{clustat}{service}{$service}{is_server} = $is_server;
				$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0019", message_vars => { 
					name1 => "clustat::service::${service}::host",      value1 => $an->data->{clustat}{service}{$service}{host},
					name2 => "clustat::service::${service}::status",    value2 => $an->data->{clustat}{service}{$service}{status},
					name3 => "clustat::service::${service}::is_server", value3 => $an->data->{clustat}{service}{$service}{is_server},
				}, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			}
			# Parse nodes. Note the '\d' to differentiate node
			# lines from service lines.
			elsif ($line =~ /^(.*?) (\d+) (.*)/)
			{
				my $node    = $1;
				my $node_id = $2;
				my $status  = $3;
				
				# I don't care about 'Local' in the status
				# string.
				$status =~ s/Local, //;
				
				# Now record the node info.
				$an->data->{clustat}{node}{$node}{id}     = $node_id;
				$an->data->{clustat}{node}{$node}{status} = $status;
				$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0006", message_vars => { 
					name1 => "clustat::node::${node}::id",     value1 => $an->data->{clustat}{node}{$node}{id},
					name2 => "clustat::node::${node}::status", value2 => $an->data->{clustat}{node}{$node}{status},
				}, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			}
		}
		close $file_handle;
	}
	else
	{
		# Not installed.
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0005", message_key => "scan_clustat_message_0003", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
		$return_code = 1;
	}
	
	return($return_code);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "scan_directory", }, message_key => "tools_log_0003", message_vars => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect;
	}
	
	exit($exit_code);
}

### TODO: Move this into AN::Tools
# This collects the command line switches
sub get_switches
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "get_switches", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$an->data->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$an->data->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument             = "raw";
				$an->data->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$an->data->{switches}{$last_argument} = $value;
				}
				else
				{
					$an->data->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$an->data->{switches}{$last_argument} = $argument;
				$last_argument                        = "";
			}
			else
			{
				# Got a value without an argument.
				$an->data->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($an->data->{switches}{raw})
	{
		$an->data->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	foreach my $variable (sort {$a cmp $b} keys %{$an->data->{switches}})
	{
		$an->Log->entry({
			log_level	=>	2,
			title_key	=>	"scancore_title_0001",
			message_key	=>	"scancore_log_0010",
			message_vars	=>	{
				variable	=>	$variable,
				value		=>	$an->data->{switches}{$variable},
			},
			file		=>	$THIS_FILE,
			line		=>	__LINE__,
			language	=>	$an->data->{sys}{log_language},
			log_to		=>	$an->data->{path}{log_file},
		});
	}
	
	# If the user has asked for help, print the usage info.
	if (($an->data->{switches}{h}) or ($an->data->{switches}{help}) or ($an->data->{switches}{'?'}))
	{
		print_usage($an);
		exit(0);
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	print $an->String->get({key => "${THIS_FILE}_message_0002"}), "\n";

	return(0);
}
