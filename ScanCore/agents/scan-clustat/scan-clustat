#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# - See: https://alteeve.ca/w/ScanCoreAPI#Agent_Exit_Codes
# - 
# 

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory  = ($0                 =~ /^(.*?)\/$THIS_FILE$/)[0];
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		clustat		=>	{
			cluster		=>	"",
			quorate		=>	"",
			node		=>	{},
			service		=>	{},
			# This holds the data read from the DB to compare when looking for changes.
			sql		=>	{
				clustat		=>	{
					clustat_id		=>	"", 
					clustat_quorate		=>	"",
					clustat_cluster_name	=>	"",
				},
				clustat_node		=>	{},
				service			=>	{},
			},
		},
		path		=>	{
			log_file		=>	"/var/log/striker.log",
			#log_file		=>	"/var/log/$THIS_FILE.log",
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"$scancore_directory/Data/strings.xml",
			clustat			=>	"/usr/sbin/clustat",
		},
		sys		=>	{
			# This will get set by AN::Tools::DB->connect_to_databases()
			host_id_query		=>	"",
			# This is set below after we connect to the databases 
			# because we need 'host_id_query' set.
			clustat_id_query	=>	"",
			language		=>	"en_CA",
			log_level		=>	2,
			log_language		=>	"en_CA",
			sql			=>	[],
		},
	}
});

# Set some defaults
$an->default_language($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});

# Set the log level.
$an->Log->level($an->data->{sys}{log_level});

# Read my stuff
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
$an->String->read_words({file => $an->data->{path}{strings}});
$an->String->read_words({file => $an->data->{path}{core_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for
# help.
print $an->String->get({key => "scan_clustat_message_0001"}), "\n";
get_switches($an);

# Read in clustat. If it returns '1', then clustat wasn't found and we will
# exit.
if (parse_clustat($an))
{
	# Clustat not found, exit.
	nice_exit($an, 1);
}

# I'll need to loop through the DBs and ensure our schema is loaded for each
# one.
my $connections = $an->DB->connect_to_databases();
$an->Log->entry({
	log_level	=>	3,
	message_key	=>	"scancore_log_0005",
	message_vars	=>	{
		connections	=>	$connections,
	},
	file		=>	$THIS_FILE,
	line		=>	__LINE__,
	log_to		=>	$an->data->{path}{log_file},
});

# Setup some repeatedly used subqueries for easier use later.
$an->data->{sys}{clustat_id_query}         = "SELECT clustat_id FROM clustat WHERE clustat_host_id = (".$an->data->{sys}{host_id_query}.")";
$an->data->{sys}{clustat_node_id_query}    = "SELECT clustat_node_id FROM clustat_node WHERE clustat_node_clustat_id = (".$an->data->{sys}{clustat_id_query}.")";
$an->data->{sys}{clustat_service_id_query} = "SELECT clustat_service_id FROM clustat_service WHERE clustat_service_clustat_id = (".$an->data->{sys}{clustat_id_query}.")";

# Do the loading of the schemas and copying data from more up to date DBs if
# the DB was loaded.
prep_databases($an);

# Look for changes.
find_changes($an);


# Clean up and go away.
nice_exit($an, 0);

###############################################################################
# Functions                                                                   #
###############################################################################

# This checks to see if this agent's databases tables exist and, if not, load
# the schema. If the schema gets loaded, we'll check other databases for
# older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "prep_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_vars => { agent => "$THIS_FILE" }, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='clustat' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_vars => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		}
	}
	
	# Now look at the various databases and see if any need to be updated.
	# TODO...
	#update_db($an);
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it
# against the just-read data. If anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	# Read in last scan data (if any).
	my $id               = $an->data->{sys}{read_db_id};
	my $host_name        = $an->hostname;
	my $say_cluster_name = $an->data->{clustat}{cluster_name};
	my $say_quorate      = $an->data->{clustat}{quorate};
	if (read_last_scan($an))
	{
		# No record found, INSERT everything.
		push @{$an->data->{sys}{sql}}, "
INSERT INTO 
    clustat 
(
    clustat_host_id, 
    clustat_quorate, 
    clustat_cluster_name, 
    modified_date
) VALUES (
    (".$an->data->{sys}{host_id_query}."),
    $say_quorate, 
    ".$an->data->{sys}{use_db_fh}->quote($say_cluster_name).", 
    ".$an->data->{sys}{db_timestamp}."
);
";
		# Now add the nodes.
		foreach my $node (sort {$a cmp $b} keys %{$an->data->{clustat}{node}})
		{
			insert_into_clustat_node($an, $node);
		}
		
		# And now the services.
		foreach my $service (sort {$a cmp $b} keys %{$an->data->{clustat}{service}})
		{
			insert_into_clustat_service($an, $service);
		}
	}
	else
	{
		### A record was found, so look for changes.
		# Look for changes in 'clustat'
		if (($an->data->{clustat}{cluster_name} ne $an->data->{clustat}{sql}{clustat}{clustat_cluster_name}) || 
		    ($an->data->{clustat}{quorate}      ne $an->data->{clustat}{sql}{clustat}{clustat_quorate}))
		{
			# Update the 'clustat' entry.
			my $clustat_id = $an->data->{clustat}{sql}{clustat}{clustat_id};
			push @{$an->data->{sys}{sql}}, "
UPDATE 
    clustat 
SET 
    clustat_quorate = $say_quorate, 
    clustat_cluster_name = ".$an->data->{sys}{use_db_fh}->quote($say_cluster_name).", 
    modified_date = ".$an->data->{sys}{db_timestamp}."
WHERE 
    clustat_host_id = (".$an->data->{sys}{host_id_query}.");
";
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0022", message_vars => {
				table => "clustat"
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		}
		else
		{
			# No change.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0023", message_vars => {
				table => "clustat"
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		}
		
		# Now look for changes in 'clustat_node'
		foreach my $node (sort {$a cmp $b} keys %{$an->data->{clustat}{node}})
		{
			# First, did this exist in the database before at all?
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0027", message_vars => {
				table => "clustat_node",
				entry => "$node",
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
			if (not $an->data->{clustat}{sql}{clustat_node}{$node})
			{
				# Nope, insert it.
				$an->Log->entry({log_level => 2, message_key => "scancore_log_0024", message_vars => {
					table => "clustat_node",
					entry => "$node",
				}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
				insert_into_clustat_node($an, $node);
			}
			else
			{
				### TODO: The node name can't technically
				###       change, as a new name will be treated
				###       as a new entry. If we switch to the
				###       clustat_node_cluster_id, that might
				###       be more reliable.
				# This record existed before, look for changes.
				if (($an->data->{clustat}{node}{$node}{cluster_id} ne $an->data->{clustat}{sql}{clustat_node}{$node}{clustat_node_cluster_id}) ||
				    ($an->data->{clustat}{node}{$node}{status}     ne $an->data->{clustat}{sql}{clustat_node}{$node}{clustat_node_status}))
				{
					# Something changed.
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0025", message_vars => {
						table => "clustat_node",
						entry => "$node",
					}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
					update_clustat_node($an, $node);
				}
				else
				{
					# Nothing changed, no update needed.
					$an->Log->entry({log_level => 3, message_key => "scancore_log_0026", message_vars => {
						table => "clustat_node",
						entry => "$node",
					}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
					delete $an->data->{clustat}{sql}{clustat_node}{$node};
				}
			}
		}
		
		# Lastly, look for changes in 'clustat_service'
		foreach my $service (sort {$a cmp $b} keys %{$an->data->{clustat}{service}})
		{
			# First, did this exist in the database before at all?
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0027", message_vars => {
				table => "clustat_service",
				entry => "$service",
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
			if (not $an->data->{clustat}{sql}{clustat_service}{$service})
			{
				# Nope, insert it.
				$an->Log->entry({log_level => 2, message_key => "scancore_log_0024", message_vars => {
					table => "clustat_service",
					entry => "$service",
				}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
				insert_into_clustat_service($an, $service);
			}
			else
			{
				### NOTE: I don't check the name as a name
				###       change will look like a service
				###       disappeared and a new one appeared.
				# This record existed before, look for changes.
				if (($an->data->{clustat}{service}{$service}{host}      ne $an->data->{clustat}{sql}{clustat_service}{$service}{clustat_service_host}) ||
				    ($an->data->{clustat}{service}{$service}{status}    ne $an->data->{clustat}{sql}{clustat_service}{$service}{clustat_service_status}) ||
				    ($an->data->{clustat}{service}{$service}{is_server} ne $an->data->{clustat}{sql}{clustat_service}{$service}{clustat_service_is_vm}))
				{
					# Something changed.
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0025", message_vars => {
						table => "clustat_service",
						entry => "$service",
					}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
					update_clustat_service($an, $service);
				}
				else
				{
					# Nothing changed, no update needed.
					$an->Log->entry({log_level => 3, message_key => "scancore_log_0026", message_vars => {
						table => "clustat_service",
						entry => "$service",
					}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
					delete $an->data->{clustat}{sql}{clustat_service}{$service};
				}
			}
		}
	}
	
	# Anything left from the DB?
	foreach my $node (sort {$a cmp $b} keys %{$an->data->{clustat}{sql}{clustat_node}})
	{
		# Node disappeared. Update the last entry to have the status
		# 'DELETED' and then delete it.
		die __LINE__."; node: [$node] lost!\n";
		$an->data->{clustat}{node}{$node}{status} = "DELETED";
		update_clustat_node($an, $node);
		push @{$an->data->{sys}{sql}}, "
DELETE FROM 
    clustat_node
WHERE
    clustat_node_id = (".$an->data->{sys}{clustat_node_id_query}.")
AND
    clustat_service_name = ".$an->data->{sys}{use_db_fh}->quote($node).";
";
	}
	foreach my $service (sort {$a cmp $b} keys %{$an->data->{clustat}{sql}{clustat_service}})
	{
		# Service disappeared. Update the last entry to have the status
		# 'DELETED' and then delete it.
		die __LINE__."; service: [$service] lost!\n";
		$an->data->{clustat}{service}{$service}{status} = "DELETED";
		update_clustat_service($an, $service);
		push @{$an->data->{sys}{sql}}, "
DELETE FROM 
    clustat_service 
WHERE 
    clustat_node_id = (".$an->data->{sys}{clustat_node_id_query}.")
AND
    clustat_service_name = ".$an->data->{sys}{use_db_fh}->quote($service).";
";
	}
	
	# Now commit the changes.
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}});
		$an->data->{sys}{sql} = [];
	}
	
	return(0);
}

# Inserts a new service into the 'clustat_service' table.
sub insert_into_clustat_service
{
	my ($an, $service) = @_;
	
	my $host_name     = $an->hostname;
	my $say_host      = $an->data->{clustat}{service}{$service}{host};
	my $say_status    = $an->data->{clustat}{service}{$service}{status};
	my $say_is_server = $an->data->{clustat}{service}{$service}{is_server};
	push @{$an->data->{sys}{sql}}, "
INSERT INTO 
    clustat_service 
(
    clustat_service_clustat_id, 
    clustat_service_name, 
    clustat_service_host, 
    clustat_service_status, 
    clustat_service_is_vm, 
    modified_date
) VALUES (
    (".$an->data->{sys}{clustat_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($service).", 
    ".$an->data->{sys}{use_db_fh}->quote($say_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($say_status).", 
    $say_is_server, 
    ".$an->data->{sys}{db_timestamp}."
);
";
	
	# Now delete the entry from what I read from SQL.
	delete $an->data->{clustat}{sql}{clustat_service}{$service};
	
	return(0);
}

# Updates a record in the 'clustat_service' table for the given service.
sub update_clustat_service
{
	my ($an, $service) = @_;
	
	my $host_name     = $an->hostname;
	my $say_host      = $an->data->{clustat}{service}{$service}{host};
	my $say_status    = $an->data->{clustat}{service}{$service}{status};
	my $say_is_server = $an->data->{clustat}{service}{$service}{is_server};
	
	push @{$an->data->{sys}{sql}}, "
UPDATE 
    clustat_service 
SET 
    clustat_service_host = ".$an->data->{sys}{use_db_fh}->quote($say_host).", 
    clustat_service_status = ".$an->data->{sys}{use_db_fh}->quote($say_status).", 
    clustat_service_is_vm = $say_is_server
WHERE 
    clustat_service_id = (
        ".$an->data->{sys}{clustat_service_id_query}."
    AND
        clustat_service_name = ".$an->data->{sys}{use_db_fh}->quote($service)."
    );
";
	
	# Now delete the entry from what I read
	# from SQL.
	delete $an->data->{clustat}{sql}{clustat_service}{$service};
	
	return(0);
}

# Adds a new entry to the 'clustat_node' table.
sub insert_into_clustat_node
{
	my ($an, $node) = @_;
	
	my $host_name      = $an->hostname;
	my $say_cluster_id = $an->data->{clustat}{node}{$node}{cluster_id};
	my $say_status     = $an->data->{clustat}{node}{$node}{status};
	push @{$an->data->{sys}{sql}}, "
INSERT INTO 
    clustat_node 
(
    clustat_node_clustat_id, 
    clustat_node_name, 
    clustat_node_cluster_id, 
    clustat_node_status, 
    modified_date
) VALUES (
    (".$an->data->{sys}{clustat_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($node).", 
    ".$an->data->{sys}{use_db_fh}->quote($say_cluster_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($say_status).", 
    ".$an->data->{sys}{db_timestamp}."
);
";
	
	# Now delete the entry from what I read from SQL.
	delete $an->data->{clustat}{sql}{clustat_node}{$node};
	
	return(0);
}

# Updates a record in the 'clustat_node' table for the given node.
sub update_clustat_node
{
	my ($an, $node) = @_;
	
	my $host_name      = $an->hostname;
	my $say_status     = $an->data->{clustat}{node}{$node}{status};
	my $say_cluster_id = $an->data->{clustat}{node}{$node}{cluster_id};
	push @{$an->data->{sys}{sql}}, "
UPDATE 
    clustat_node 
SET 
    clustat_node_status = ".$an->data->{sys}{use_db_fh}->quote($say_status).",
    modified_date = ".$an->data->{sys}{db_timestamp}."
WHERE 
    clustat_node_id = (
        ".$an->data->{sys}{clustat_node_id_query}."
    AND
        clustat_node_cluster_id = ".$an->data->{sys}{use_db_fh}->quote($say_cluster_id)."
    );
";
	
	# Now delete the entry from what I read from SQL.
	delete $an->data->{clustat}{sql}{clustat_node}{$node};
	
	return(0);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "read_last_scan", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	# Couple of variables to make the code cleaner
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_vars => {
		name1 => "id",        value1 => $id, 
		name2 => "host_name", value2 => $host_name, 
	}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
	
	# This calls up the entry for this host. If no entry is found, 'new'
	# gets set to '1' and the main function won't bother looking for
	# changes and directly INSERT the scanned data.
	my $new   = 0;
	my $query = "
SELECT 
    a.clustat_quorate, 
    a.clustat_cluster_name 
FROM 
    clustat a, 
    hosts b 
WHERE 
    a.clustat_host_id = b.host_id 
AND 
    b.host_name = ".$an->data->{sys}{use_db_fh}->quote($host_name).";
";
	# TODO: This query should only ever return one row, but this fact
	#       should be explicitely checked for.
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_vars => {
		name1 => "query",        value1 => $query, 
		name2 => "results",      value2 => $results, 
		name3 => "results->[0]", value3 => $results->[0], 
	}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
	if ($results->[0])
	{
		# We've got an entry in the 'clustat' table, so now we'll look
		# for data in the node and services tables.
		my ($clustat_quorate, $clustat_cluster_name) = @{$results->[0]};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_vars => {
			name1 => "clustat_quorate",      value1 => $clustat_quorate, 
			name2 => "clustat_cluster_name", value2 => $clustat_cluster_name
		}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		
		$an->data->{clustat}{sql}{clustat}{clustat_quorate}      = $clustat_quorate ? "TRUE" : "FALSE";
		$an->data->{clustat}{sql}{clustat}{clustat_cluster_name} = $clustat_cluster_name;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_vars => {
			name1 => "clustat::sql::clustat::clustat_quorate",      value1 => $an->data->{clustat}{sql}{clustat}{clustat_quorate}, 
			name2 => "clustat::sql::clustat::clustat_cluster_name", value2 => $an->data->{clustat}{sql}{clustat}{clustat_cluster_name}
		}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		
		my $query = "
SELECT 
    a.clustat_node_name, 
    a.clustat_node_cluster_id, 
    a.clustat_node_status 
FROM 
    clustat_node a, 
    clustat b, 
    hosts c 
WHERE 
    a.clustat_node_clustat_id = b.clustat_id 
AND 
    b.clustat_host_id = c.host_id 
AND 
    c.host_name = ".$an->data->{sys}{use_db_fh}->quote($host_name).";
";
		
		my $results = $an->DB->do_db_query({query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_vars => {
			name1 => "query",       value1 => $query, 
			name2 => "results",     value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		foreach my $array_reference (@{$results})
		{
			my ($clustat_node_name, $clustat_node_cluster_id, $clustat_node_status) = @{$array_reference};
			
			# Record the values directly as we received them.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_vars => {
				name1 => "clustat_node_name",       value1 => $clustat_node_name, 
				name2 => "clustat_node_cluster_id", value2 => $clustat_node_cluster_id, 
				name3 => "clustat_node_status",      value3 => $clustat_node_status
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
			
			# Push them into the hash
			$an->data->{clustat}{sql}{clustat_node}{$clustat_node_name} = {
				clustat_node_cluster_id	=>	$clustat_node_cluster_id,
				clustat_node_status	=>	$clustat_node_status,
			};
			
			# Record the now-in-the-hash data.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_vars => {
				name1 => "clustat::sql::clustat_node::${clustat_node_name}::clustat_node_cluster_id", value1 => $an->data->{clustat}{sql}{clustat_node}{$clustat_node_name}{clustat_node_cluster_id}, 
				name2 => "clustat::sql::clustat_node::${clustat_node_name}::clustat_node_status",      value2 => $an->data->{clustat}{sql}{clustat_node}{$clustat_node_name}{clustat_node_status}
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		}
		
		# Now pull our the services
		$query = "
SELECT 
    a.clustat_service_name, 
    a.clustat_service_host, 
    a.clustat_service_status, 
    a.clustat_service_is_vm 
FROM 
    clustat_service a, 
    clustat b, 
    hosts c 
WHERE 
    a.clustat_service_clustat_id = b.clustat_id 
AND 
    b.clustat_host_id = c.host_id 
AND 
    c.host_name = ".$an->data->{sys}{use_db_fh}->quote($host_name).";
";
		$results = $an->DB->do_db_query({query => $query});
		foreach my $array_reference (@{$results})
		{
			my ($clustat_service_name, $clustat_service_host, $clustat_service_status, $clustat_service_is_vm) = @{$array_reference};
			
			# Record the values directly as we received them.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_vars => {
				name1 => "clustat_service_name",       value1 => $clustat_service_name, 
				name2 => "clustat_service_host",       value2 => $clustat_service_host, 
				name3 => "clustat_service_status",      value3 => $clustat_service_status, 
				name4 => "clustat_service_is_vm",      value4 => $clustat_service_is_vm
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
			
			# Push them into the hash
			$clustat_service_is_vm = $clustat_service_is_vm ? "TRUE" : "FALSE";
			$an->data->{clustat}{sql}{clustat_service}{$clustat_service_name} = {
				clustat_service_host		=>	$clustat_service_host, 
				clustat_service_status		=>	$clustat_service_status, 
				clustat_service_is_vm		=>	$clustat_service_is_vm
			};
			
			# Record the now-in-the-hash data.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_vars => {
				name1 => "clustat::sql::clustat_service::${clustat_service_name}::clustat_service_host",  value1 => $an->data->{clustat}{sql}{clustat_service}{$clustat_service_name}{clustat_service_host}, 
				name2 => "clustat::sql::clustat_service::${clustat_service_name}::clustat_service_status", value2 => $an->data->{clustat}{sql}{clustat_service}{$clustat_service_name}{clustat_service_status}, 
				name3 => "clustat::sql::clustat_service::${clustat_service_name}::clustat_service_is_vm", value3 => $an->data->{clustat}{sql}{clustat_service}{$clustat_service_name}{clustat_service_is_vm}, 
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file} });
		}
	}
	else
	{
		# Looks like this is the first run ever.
		$new = 1;
	}
	
	return($new);
}

# This looks rgmanager's 'clustat' and, if it is found, parse it.
sub parse_clustat
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "parse_clustat", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	my $return_code  = 0;
	if (-e $an->data->{path}{clustat})
	{
		# Found it!
		my $shell_call  = $an->data->{path}{clustat}." 2>&1 |";
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0007", message_vars => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
		open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "scancore_title_0003", message_key => "scancore_error_0006", message_vars => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__ });
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_vars => {
				name1 => "line", value1 => "$line"
			}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
			
			if ($line =~ /Could not connect to CMAN/)
			{
				# The cluster isn't running.
				$an->data->{clustat}{cluster_name} = "OFFLINE";
				$an->data->{clustat}{quorate}      = "FALSE";
			}
			elsif ($line =~ /Cluster Status for (.*?) /)
			{
				$an->data->{clustat}{cluster_name} = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_vars => {
					name1 => "clustat::cluster_name", value1 => $an->data->{clustat}{cluster_name}
				}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
			}
			elsif ($line =~ /Member Status: (.*)/)
			{
				my $quorum                       = $1;
				my $is_quorate                   = $quorum eq "Quorate" ? "TRUE" : "FALSE";
				   $an->data->{clustat}{quorate} = $is_quorate;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_vars => {
					name1 => "clustat::quorate", value1 => $an->data->{clustat}{quorate}
				}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
			}
			# Pick out service lines
			elsif ($line =~ /^(.*?):(.*?) (.*?) (.*)/)
			{
				my $type      = $1;
				my $service   = $2;
				my $host      = $3;
				my $status    = $4;
				my $is_server = $type eq "vm" ? "TRUE" : "FALSE";
				
				# Record the node info.
				$an->data->{clustat}{service}{$service}{host}      = $host;
				$an->data->{clustat}{service}{$service}{status}    = $status;
				$an->data->{clustat}{service}{$service}{is_server} = $is_server;
				$an->Log->entry({log_level => 3, message_key => "scancore_log_0019", message_vars => { 
					name1 => "clustat::service::${service}::host",      value1 => $an->data->{clustat}{service}{$service}{host},
					name2 => "clustat::service::${service}::status",    value2 => $an->data->{clustat}{service}{$service}{status},
					name3 => "clustat::service::${service}::is_server", value3 => $an->data->{clustat}{service}{$service}{is_server},
				}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
			}
			# Parse nodes. Note the '\d' to differentiate node
			# lines from service lines.
			elsif ($line =~ /^(.*?) (\d+) (.*)/)
			{
				my $node    = $1;
				my $node_id = $2;
				my $status  = $3;
				
				# I don't care about 'Local' in the status
				# string.
				$status =~ s/Local, //;
				
				# Now record the node info.
				$an->data->{clustat}{node}{$node}{cluster_id} = $node_id;
				$an->data->{clustat}{node}{$node}{status}     = $status;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_vars => { 
					name1 => "clustat::node::${node}::cluster_id", value1 => $an->data->{clustat}{node}{$node}{cluster_id},
					name2 => "clustat::node::${node}::status",     value2 => $an->data->{clustat}{node}{$node}{status},
				}, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
			}
		}
		close $file_handle;
	}
	else
	{
		# Not installed.
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0005", message_key => "scan_clustat_message_0003", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
		$return_code = 1;
	}
	
	return($return_code);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "scan_directory", }, message_key => "tools_log_0003", message_vars => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect;
	}
	
	exit($exit_code);
}

### TODO: Move this into AN::Tools
# This collects the command line switches
sub get_switches
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "get_switches", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$an->data->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$an->data->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument             = "raw";
				$an->data->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$an->data->{switches}{$last_argument} = $value;
				}
				else
				{
					$an->data->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$an->data->{switches}{$last_argument} = $argument;
				$last_argument                        = "";
			}
			else
			{
				# Got a value without an argument.
				$an->data->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($an->data->{switches}{raw})
	{
		$an->data->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	foreach my $variable (sort {$a cmp $b} keys %{$an->data->{switches}})
	{
		$an->Log->entry({
			log_level	=>	2,
			message_key	=>	"scancore_log_0010",
			message_vars	=>	{
				variable	=>	$variable,
				value		=>	$an->data->{switches}{$variable},
			},
			file		=>	$THIS_FILE,
			line		=>	__LINE__,
			log_to		=>	$an->data->{path}{log_file},
		});
	}
	
	# If the user has asked for help, print the usage info.
	if (($an->data->{switches}{h}) or ($an->data->{switches}{help}) or ($an->data->{switches}{'?'}))
	{
		print_usage($an);
		exit(0);
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, log_to => $an->data->{path}{log_file}});
	
	print $an->String->get({key => "${THIS_FILE}_message_0002"}), "\n";

	return(0);
}
