#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# ScanCore Scan Agent for LSI-based RAID controllers using the 'storcli64' command line tool.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - storcli64 not installed
# 2   - storcli64 is installed but it is not executable.
# 3   - No LSI-based controllers found.
# 4   - Got data from the wrong controller.
# 5   - Unexpecte status when querying adapter
# 6   - Failed to parse out the controller's serial number.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# TODO:
# - Check the cache policy and reset it to 'writeback' if the BBU/FBU is healthy and the cache changes to 
#   write-through.
# 
# NOTE:
# - BBU and Cachevault specs/temp ranges;
#   45646-00B_Cache_Backup_Products_SAS_SATA_RAID_Controller_UserGd.pdf ->  Specifications for the BBU Models
#   - BBU - Charge: 10 °C to 40 °C, Discharge: 10 °C to 55 °C
#   - CV  - 0 °C to 55 °C
# 

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
#use Socket;
#use utf8;
#binmode STDOUT, 'encoding(utf8)';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-storcli'		=>	{
			language		=>	"en_CA",
			log_level		=>	1,
			log_language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_db_transactions	=>	0,
			thresholds			=>	{
				raid_on_chip			=>	{
					high_warning			=>	98,
					high_critical			=>	104,
					low_warning			=>	5,
					low_critical			=>	0,
					jump				=>	8,
					buffer				=>	3,
				},
			},
		},
		section			=>	{
			controller			=>	{
				in_header			=>	1,
				in_basics			=>	0,
				in_version			=>	0,
				in_bus				=>	0,
				in_pending_images_in_flash	=>	0,
				in_status			=>	0,
				in_supported_adapter_operations	=>	0,
				in_supported_pd_operations	=>	0,
				in_supported_vd_operations	=>	0,
				in_advanced_software_option	=>	0,
				in_hardware_config		=>	0,
				in_policies			=>	0,
				in_policies_table		=>	0,
				in_boot				=>	0,
				in_high_availability		=>	0,
				in_defaults			=>	0,
				in_capabilities			=>	0,
				in_scheduled_tasks		=>	0,
				in_topology			=>	0,
				in_virtual_disk_list		=>	0,
				in_physical_disk_list		=>	0,
				in_cachevault_info		=>	0,
			},
		},
		sys			=>	{
			sql			=>	[],
			arguments		=>	{
				adapter_count		=>	"show ctrlcount",
				# BBU battery or FBU capacitor bank info.
				bbu_data		=>	"/bbu show all",
				cachevault_data		=>	"/cv show all",
				controller_info		=>	"show all", 
				physical_disk_data	=>	"/eall /sall show all",
				virtual_disk_data	=>	"/vall show all",
			},
			adapter_count		=>	0,
			adapter			=>	{},
		},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-storcli'}{language});
$an->default_log_language($an->data->{'scan-storcli'}{log_language});
$an->default_log_file    ($an->data->{'scan-storcli'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-storcli'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-storcli'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();

# Adjust the log level if requested.
adjust_log_level($an);

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "notice_message_0013", message_variables => {
	connections	=>	$connections,
}, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { uuid => $an->data->{sys}{host_uuid} }, code => 255, file => "$THIS_FILE", line => __LINE__});
}

print $an->String->get({key => "scan_storcli_message_0001"})."\n";

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
find_lsi_controllers($an);

# If we're still alive, start gathering data.
gather_data($an);

exit(0);


# Clean up and go away.
nice_exit($an);

#############################################################################################################
# Function below                                                                                            #
#############################################################################################################

# Change to a user-requested log level.
sub adjust_log_level
{
	my ($an) = @_;
	if ($an->data->{switches}{v})
	{
		$an->data->{'scan-storcli'}{log_level} = 1;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	elsif ($an->data->{switches}{vv})
	{
		$an->data->{'scan-storcli'}{log_level} = 2;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	elsif ($an->data->{switches}{vvv})
	{
		$an->data->{'scan-storcli'}{log_level} = 3;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	elsif ($an->data->{switches}{vvvv})
	{
		$an->data->{'scan-storcli'}{log_level} = 4;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	return(0);
}

# This gathers the various data from the controller(s).
sub gather_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "gather_data", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: This assumes the controllers go 0, 1, ... n. If this is wrong, we'll need to call 
	###       'storcli64 show all' and parse 'System Overview'.
	# Loops through reach found controller.
	foreach my $controller (1..$an->data->{sys}{adapter_count})
	{
		# We drop the number by 1 because the '/cX' starts at '0' where the controller count starts 
		# at '1'.
		my $adapter = ($controller - 1);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "controller", value1 => $controller, 
			name2 => "adapter",    value2 => $adapter, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Read in controller data.
		my $serial_number = get_controller_info($an, $adapter);
		
		# Read in cachevault (FBU) data (if it exists).
		get_cachevault_data($an, $adapter, $serial_number);
		
		# Read in BBU data (if it exists).
		get_bbu_data($an, $adapter, $serial_number);
		
		# Read in virtual disk information.
		get_virtual_disk_data($an, $adapter, $serial_number);
		
		# Read in the physical disk information.
		get_physical_disk_data($an, $adapter, $serial_number);
		
		die "$THIS_FILE ".__LINE__."; testing\n";
	}
	
	return(0);
}



# This looks for physical disks on the controller.
sub get_physical_disk_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_physical_disk_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $virtual_disk = "";
	my $in_overview  = 0;
	my $in_pd_list   = 0;
	my $start_break  = 0;
	my $shell_call   = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{physical_disk_data};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	return(0);
}

# This looks for virtual disks on the controller.
sub get_virtual_disk_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_virtual_disk_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $virtual_disk = "";
	my $in_overview  = 0;
	my $in_pd_list   = 0;
	my $in_vd_data   = 0;
	my $start_break  = 0;
	my $shell_call   = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{virtual_disk_data};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /\/c$adapter\/v(\d+):/)
		{
			$virtual_disk = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /PDs for VD (\d+) :/)
		{
			$virtual_disk = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /VD(\d+) Properties/)
		{
			$virtual_disk = $1;
			$in_vd_data   = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk, 
				name2 => "in_vd_data",   value2 => $in_vd_data, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		next if $virtual_disk eq "";
		
		# See if I am entering or exiting the overview chunk.
		if ($line =~ /^DG\/VD/)
		{
			$in_overview = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_overview", value1 => $in_overview, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if (($line =~ /^--------/) && ($in_overview))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$in_overview = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_overview", value1 => $in_overview, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		if ($in_overview)
		{
			process_vg_overview_data($an, $line, $serial_number);
		}
		
		# See if I am entering or exiting the physical drive chunk.
		if ($line =~ /^EID:Slt/)
		{
			$in_pd_list = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_pd_list", value1 => $in_pd_list, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if (($line =~ /^--------/) && ($in_pd_list))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$in_pd_list  = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_pd_list", value1 => $in_pd_list, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		if ($in_pd_list)
		{
			process_vg_pd_list_data($an, $line, $virtual_disk, $serial_number);
		}
		
		if ($in_vd_data)
		{
			if ($line =~ /^(.*?) = (.*)$/)
			{
				my $variable = $1;
				my $value    = $2;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Convert some formatting.
				if ($value =~ /^(\d.*B)$/)
				{
					# Convert to bytes
					$value = $an->Readable->hr_to_bytes({base2 => 1, size => $value});
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($value =~ /^(\d\d)-(\d\d)-(\d\d\d\d)$/)
				{
					# Convert dd-mm-yyyy to yyyy/mm/dd
					$value = $3."/".$2."/".$1;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($value =~ /^(\d\d):(\d\d):(\d\d) (\wM)$/)
				{
					# Convert AM/PM -> 24h
					my $hour   = $1;
					my $minute = $2;
					my $second = $3;
					my $suffix = $4;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
						name1 => "hour",   value1 => $hour, 
						name2 => "minute", value2 => $minute, 
						name3 => "second", value3 => $second, 
						name4 => "suffix", value4 => $suffix, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($suffix eq "PM")
					{
						$hour += 12;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "hour", value1 => $hour, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					$value = "$hour:$minute:$second";
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				$an->data->{virtual_disk}{$virtual_disk}{variable}{$variable} = $value;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::variable::$variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{variable}{$variable}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	close $file_handle;
	
	# Some pretty debugging code.
	foreach my $virtual_disk (sort {$a cmp $b} keys %{$an->data->{virtual_disk}})
	{
		foreach my $drive_group (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk,
				name2 => "drive_group",  value2 => $drive_group,
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $type ("variable", "temperature")
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "type", value1 => $type,
				}, file => $THIS_FILE, line => __LINE__});
				
				my $longest_variable = 0;
				foreach my $variable (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{$type}})
				{
					next if $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{$type}{$variable} eq "";
					if (length($variable) > $longest_variable)
					{
						$longest_variable = length($variable);
					}
				}
				
				# Now loop again in alphabetical order printing in the dots as needed.
				foreach my $variable (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{$type}})
				{
					#next if $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{$type}{$variable} eq "";
					my $difference   = $longest_variable - length($variable);
					my $say_variable = $variable;
					if ($difference == 0)
					{
						# Do nothing
					}
					elsif ($difference == 1) 
					{
						$say_variable .= " ";
					}
					elsif ($difference == 2) 
					{
						$say_variable .= "  ";
					}
					else
					{
						my $dots         =  $difference - 2;
						$say_variable .= " ";
						for (1 .. $dots)
						{
							$say_variable .= ".";
						}
						$say_variable .= " ";
					}
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "$say_variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{$type}{$variable},
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			foreach my $enclosure_id (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}})
			{
				foreach my $slot_number (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}})
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1 => "enclosure_id", value1 => $enclosure_id,
						name2 => "slot_number",  value2 => $slot_number,
					}, file => $THIS_FILE, line => __LINE__});
					
					my $longest_variable = 0;
					foreach my $variable (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}})
					{
						next if $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable} eq "";
						if (length($variable) > $longest_variable)
						{
							$longest_variable = length($variable);
						}
					}
				
					# Now loop again in alphabetical order printing in the dots as needed.
					foreach my $variable (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}})
					{
						#next if $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable} eq "";
						my $difference   = $longest_variable - length($variable);
						my $say_variable = $variable;
						if ($difference == 0)
						{
							# Do nothing
						}
						elsif ($difference == 1) 
						{
							$say_variable .= " ";
						}
						elsif ($difference == 2) 
						{
							$say_variable .= "  ";
						}
						else
						{
							my $dots         =  $difference - 2;
							$say_variable .= " ";
							for (1 .. $dots)
							{
								$say_variable .= ".";
							}
							$say_variable .= " ";
						}
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "$say_variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable},
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
		}
		
		# Show the base variables.
		my $longest_variable = 0;
		foreach my $variable (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{variable}})
		{
			next if $an->data->{virtual_disk}{$virtual_disk}{variable} eq "";
			if (length($variable) > $longest_variable)
			{
				$longest_variable = length($variable);
			}
		}
	
		# Now loop again in alphabetical order printing in the dots as needed.
		foreach my $variable (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{variable}})
		{
			#next if $an->data->{virtual_disk}{$virtual_disk}{variable}{$variable} eq "";
			my $difference   = $longest_variable - length($variable);
			my $say_variable = $variable;
			if ($difference == 0)
			{
				# Do nothing
			}
			elsif ($difference == 1) 
			{
				$say_variable .= " ";
			}
			elsif ($difference == 2) 
			{
				$say_variable .= "  ";
			}
			else
			{
				my $dots         =  $difference - 2;
				$say_variable .= " ";
				for (1 .. $dots)
				{
					$say_variable .= ".";
				}
				$say_variable .= " ";
			}
			$an->Log->entry({log_level => 5, message_key => "an_variables_0001", message_variables => {
				name1 => "$say_variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{variable}{$variable},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This parses a virtual disk's physical disk overview line
sub process_vg_pd_list_data
{
	my ($an, $line, $virtual_disk, $serial_number) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_vg_pd_list_data", }, message_key => "an_variables_0003", message_variables => { 
		name1 => "line",          value1 => $line, 
		name1 => "virtual_disk",  value1 => $virtual_disk, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### Sector size is either '512B' or '4 KB'
	#               EID:Slt       DID     State   DG      Size       Intf  Med     SED     PI      SeSz     Model      Sp
	#               252:0         9       Onln    0       136.218 GB SAS   HDD     N       N       512B     MK1401GRRB U
	if ($line =~ /^(\d+):(\d+)\s+(\d+)\s+(.*?)\s+(\d+)\s+(.*?B)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?B)\s+(.*?)\s+(.*)$/)
	{
		my $enclosure_id          = $1;
		my $slot_number           = $2;
		my $device_id             = $3;
		my $state                 = $4;
		my $drive_group           = $5;
		my $drive_size            = $6;
		my $interface             = $7;
		my $drive_media           = $8;
		my $self_encrypting_drive = $9;
		my $protection_info       = $10;
		my $sector_size           = $11;
		my $drive_model           = $12;
		my $spun_up               = $13;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0013", message_variables => {
			name1  => "enclosure_id",          value1  => $enclosure_id, 
			name2  => "slot_number",           value2  => $slot_number, 
			name3  => "device_id",             value3  => $device_id, 
			name4  => "state",                 value4  => $state, 
			name5  => "drive_group",           value5  => $drive_group, 
			name6  => "drive_size",            value6  => $drive_size, 
			name7  => "interface",             value7  => $interface, 
			name8  => "drive_media",           value8  => $drive_media, 
			name9  => "self_encrypting_drive", value9  => $self_encrypting_drive, 
			name10 => "protection_info",       value10 => $protection_info, 
			name11 => "sector_size",           value11 => $sector_size, 
			name12 => "drive_model",           value12 => $drive_model, 
			name13 => "spun_up",               value13 => $spun_up, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Convert the sector and drive sizes into bytes. The controller uses 'xB' but uses base2 values.
		$sector_size = $an->Readable->hr_to_bytes({base2 => 1, size => $sector_size});
		$drive_size  = $an->Readable->hr_to_bytes({base2 => 1, size => $drive_size});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "sector_size", value1 => $sector_size, 
			name2 => "drive_size",  value2 => $drive_size, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### Long hashes are long... x_x
		# Store the data (we'll convert it in a minute.
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{device_id}             = $device_id;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{'state'}               = $state;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_size}            = $drive_size;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{interface}             = $interface;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_media}           = $drive_media;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{self_encrypting_drive} = $self_encrypting_drive;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{protection_info}       = $protection_info;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sector_size}           = $sector_size;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_model}           = $drive_model;
		$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{spun_up}               = $spun_up;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
			name1  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::device_id",             value1  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{device_id}, 
			name2  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::state",                 value2  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{'state'}, 
			name3  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_size",            value3  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_size}, 
			name4  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::interface",             value4  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{interface}, 
			name5  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_media",           value5  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_media}, 
			name6  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::self_encrypting_drive", value6  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{self_encrypting_drive}, 
			name7  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::protection_info",       value7  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{protection_info}, 
			name8  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::sector_size",           value8  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sector_size}, 
			name9  => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_model",           value9  => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_model}, 
			name10 => "virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::spun_up",               value10 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{spun_up}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### WARNING: The strings we set here will be parsed later, so don't change them without also 
		###          changing where they're checked for elsewhere in this agent.
		### NOTE: We don't use a function for this because the glossary for the block of data is 
		###       specific for the table above (it would appear).
		# Translate the weird short form to useable strings
		foreach my $key (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}})
		{
			my $value = $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => ">> virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($value =~ /^DHS$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Dedicated Hot Spare";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UGood$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unconfigured Good";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^GHS$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Global Hotspare";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UBad$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unconfigured Bad";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^Onln$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Online";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^Offln$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Offline";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^U$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Spun Up";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^D$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Spun Down";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^T$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Transition";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^F$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Foreign";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UGUnsp$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unsupported";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UGShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unconfigured shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^HSPShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Hotspare shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^CFShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Configured shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^Cpybck$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Copyback";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^CBShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Copyback Shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::on_controller::${serial_number}::physical_disk::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{on_controller}{$serial_number}{physical_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	else
	{
		# Unparsed line
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "? line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This parses a virtual disk overview line
sub process_vg_overview_data
{
	my ($an, $line, $serial_number) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_vg_overview_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "line",          value1 => $line, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $drive_group                 = "";
	my $virtual_disk                = "";
	my $raid_type                   = "";
	my $array_state                 = "";
	my $access                      = "";
	my $consistent                  = "";
	my $cache                       = "";
	my $cachecade                   = "";
	my $scheduled_consistency_check = "";
	my $array_size                  = "";
	my $name                        = "";
	# Get the line when there is no name
	#	        0   / 0      RAID5   Optl    RW      Yes     NRWBD   -       OFF     953.531 GB
	if ($line =~ /^(\d+)\/(\d+)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*? \wB)$/i)
	{
		$drive_group                 = $1;
		$virtual_disk                = $2;
		$raid_type                   = $3;
		$array_state                 = $4;
		$access                      = $5;
		$consistent                  = $6;
		$cache                       = $7;
		$cachecade                   = $8;
		$scheduled_consistency_check = $9;
		$array_size                  = $10;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
			name1  => "drive_group",                 value1  => $drive_group, 
			name2  => "virtual_disk",                value2  => $virtual_disk, 
			name3  => "raid_type",                   value3  => $raid_type, 
			name4  => "array_state",                 value4  => $array_state, 
			name5  => "access",                      value5  => $access, 
			name6  => "consistent",                  value6  => $consistent, 
			name7  => "cache",                       value7  => $cache, 
			name8  => "cachecade",                   value8  => $cachecade, 
			name9  => "scheduled_consistency_check", value9  => $scheduled_consistency_check, 
			name10 => "array_size",                  value10 => $array_size, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	# Get the line when there is a name
	elsif ($line =~ /^(d+)\/(d+)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*? \wB)\s+(.*)$/)
	{
		$drive_group                 = $1;
		$virtual_disk                = $2;
		$raid_type                   = $3;
		$array_state                 = $4;
		$access                      = $5;
		$consistent                  = $6;
		$cache                       = $7;
		$cachecade                   = $8;
		$scheduled_consistency_check = $9;
		$array_size                  = $10;
		$name                        = $11;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0011", message_variables => {
			name1  => "drive_group",                 value1  => $drive_group, 
			name2  => "virtual_disk",                value2  => $virtual_disk, 
			name3  => "raid_type",                   value3  => $raid_type, 
			name4  => "array_state",                 value4  => $array_state, 
			name5  => "access",                      value5  => $access, 
			name6  => "consistent",                  value6  => $consistent, 
			name7  => "cache",                       value7  => $cache, 
			name8  => "cachecade",                   value8  => $cachecade, 
			name9  => "scheduled_consistency_check", value9  => $scheduled_consistency_check, 
			name10 => "array_size",                  value10 => $array_size, 
			name11 => "name",                        value11 => $name, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Unmatched line...
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "? line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		next;
	}
	
	# Convert the array size into bytes. The controller uses 'xB' but uses base2 values.
	$array_size = $an->Readable->hr_to_bytes({base2 => 1, size => $array_size});
	
	# Store the data.
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{on_controller}               = $serial_number;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{raid_type}                   = $raid_type;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_state}                 = $array_state;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{access}                      = $access;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{consistent}                  = $consistent;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cache}                       = $cache;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cachecade}                   = $cachecade;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{scheduled_consistency_check} = $scheduled_consistency_check;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_size}                  = $array_size;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{name}                        = $name;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
		name1  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::on_controller",               value1  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{on_controller}, 
		name2  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::raid_type",                   value2  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{raid_type}, 
		name3  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::array_state",                 value3  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_state}, 
		name4  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::access",                      value4  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{access}, 
		name5  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::consistent",                  value5  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{consistent}, 
		name6  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::cache",                       value6  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cache}, 
		name7  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::cachecade",                   value7  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cachecade}, 
		name8  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::scheduled_consistency_check", value8  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{scheduled_consistency_check}, 
		name9  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::array_size",                  value9  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_size}, 
		name10 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::name",                        value10 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### WARNING: The strings we set here will be parsed later, so don't change them without also changing
	###          where they're checked for elsewhere in this agent.
	### NOTE: We don't use a function for this because the glossary for the block of data is specific for
	###       the table above (it would appear).
	# Translate the weird short form to useable strings
	foreach my $key (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => ">> virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} eq "-")
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "No";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Cac$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "CacheCade";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Rec$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Recovery";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^OfLn$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "OffLine";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Pdgd$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Partially Degraded";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^dgrd$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Degraded";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Optl$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Optimal";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^RO$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Read Only";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^RW$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Read Write";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^HD$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Hidden";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^TRANS$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Transport Ready";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^B$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Blocked";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Consist$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Consistent";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^sCC$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Scheduled Check Consistency";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Because they hate programmers, the cache is a combination of a few of the 
		# above strings.
		if ($key eq "cache")
		{
			my $cache = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cache", value1 => $cache, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Prep some blanks
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache}  = "";
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "";
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache}  = "";
			
			# Read cache
			if ($cache =~ /NR/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache} = "No Read-Ahead";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::read_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /R/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache} = "Always Read-Ahead";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::read_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Write cache
			if ($cache =~ /AWB/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "Always Write-Back";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::write_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /WB/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "Write-Back";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::write_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /WT/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "Write-Through";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::write_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Disk cache
			if ($cache =~ /C/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache} = "Cached IO";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::disk_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /D/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache} = "Direct IO";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::disk_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	return(0);
}

# This looks for a BBU and, if it finds one, parses the output for it.
sub get_bbu_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_bbu_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $bbu_serial_number = "";
	my $bbu_data          = [];
	my $shell_call        = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{bbu_data};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		last if $line =~ /$adapter Failed /i;
		
		if ($line =~ /^Serial Number\s+(\S.*)?/i)
		{
			$bbu_serial_number = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "bbu_serial_number", value1 => $bbu_serial_number, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		push @{$bbu_data}, $line;
	}
	close $file_handle;
	
	# If I didn't find a serial number, then I probably don't have an FBU.
	return(0) if not $bbu_serial_number;
	
	# Record the controller the bbu is on.
	$an->data->{bbu}{serial_number}{$bbu_serial_number}{host_controller_serial_number} = $serial_number;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "bbu::serial_number::${bbu_serial_number}::host_controller_serial_number", value1 => $an->data->{bbu}{serial_number}{$bbu_serial_number}{host_controller_serial_number},
	}, file => $THIS_FILE, line => __LINE__});
	
	# Still alive? Good, time to parse the most annoying output ever... >_<
	my $split_point = 0;
	my $start_break = 0;
	my $end_break   = 0;
	foreach my $line (@{$bbu_data})
	{
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Property(\s+)Value/)
		{
			$split_point = length($1) + 8;
			$start_break = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "split_point", value1 => $split_point, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# See if I am entering or exiting a data chunk.
		if (($line =~ /^--------/) && ($split_point))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$split_point = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "split_point", value1 => $split_point, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		
		# If I have a split point, break the string.
		if ($split_point)
		{
			# Elegant? I think not!
			my $variable = "";
			my $value    = "";
			if ($split_point >= length($line))
			{
				# Variable with no value
				$variable =  $line;
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				($variable, $value) = ($line =~ /^(.{$split_point})(.*)$/);
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Is this a temperature or something else we want to pre-process?
			if ($value =~ /^(\d+) C$/i)
			{
				# Yup
				$value = $1;
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{temperature}{$variable} = $value;
			}
			elsif ($value =~ /^(\d+) F$/i)
			{
				# Yup, but translate
				$value = $an->Convert->convert_to_celsius({temperature => $1});
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{temperature}{$variable} = $value;
			}
			elsif ($value =~ /\d+d \((\d+) seconds\)$/i)
			{
				# This is a static time span (like the time between learn cycles.
				$value = $1;
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{variable}{$variable} = $value." seconds";
				
				my $say_time = $an->Readable->time({'time' => $value});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "say_time", value3 => $say_time,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d\d\d)\/(\d\d)\/(\d\d)\s+(\d\d:\d\d:\d\d)\s+\(\d+ seconds\)$/i)
			{
				### NOTE: The 'X seconds' seems to not change and be a useless number...
				# This is a specific time in the future, properly formatted
				my $say_date = $1." ".$2;
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{variable}{$variable} = $say_date;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "say_date", value3 => $say_date,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d)\/(\d\d)\/(\d\d\d\d)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				my $say_date = $3."/".$2."/".$1;
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{variable}{$variable} = $say_date;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "say_date", value3 => $say_date,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d+) hour\(s\)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				my $seconds = $1 * 3600;
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{variable}{$variable} = $seconds." seconds";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "seconds",  value3 => $seconds,
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Nope, normal variable.
				$an->data->{bbu}{serial_number}{$bbu_serial_number}{variable}{$variable} = $value;
			}
		}
	}
	
	# Some pretty debugging code.
	foreach my $bbu_serial_number (keys %{$an->data->{bbu}{serial_number}})
	{
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "bbu_serial_number", value1 => $bbu_serial_number,
				name2 => "type",                     value2 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $longest_variable = 0;
			foreach my $variable (sort {$a cmp $b} keys %{$an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}})
			{
				next if $an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}{$variable} eq "";
				if (length($variable) > $longest_variable)
				{
					$longest_variable = length($variable);
				}
			}
			
			# Now loop again in alphabetical order printing in the dots as needed.
			foreach my $variable (sort {$a cmp $b} keys %{$an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}})
			{
				#next if $an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}{$variable} eq "";
				my $difference   = $longest_variable - length($variable);
				my $say_variable = $variable;
				if ($difference == 0)
				{
					# Do nothing
				}
				elsif ($difference == 1) 
				{
					$say_variable .= " ";
				}
				elsif ($difference == 2) 
				{
					$say_variable .= "  ";
				}
				else
				{
					my $dots         =  $difference - 2;
					   $say_variable .= " ";
					for (1 .. $dots)
					{
						$say_variable .= ".";
					}
					$say_variable .= " ";
				}
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "$say_variable", value1 => $an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}{$variable},
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	return(0);
}

# This looks for a cachevault (flash-backup unit) and, if one is found, parses the output.
sub get_cachevault_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_cachevault_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $cachevault_serial_number = "";
	my $cachevault_data          = [];
	my $shell_call               = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{cachevault_data};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		last if $line =~ /Cachevault doesn't exist/i;
		
		if ($line =~ /^Serial Number\s+(\S.*)?/i)
		{
			$cachevault_serial_number = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "cachevault_serial_number", value1 => $cachevault_serial_number, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		push @{$cachevault_data}, $line;
	}
	close $file_handle;
	
	# If I didn't find a serial number, then I probably don't have an FBU.
	return(0) if not $cachevault_serial_number;
	
	# Record the controller the cachevault is on.
	$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{host_controller_serial_number} = $serial_number;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "cachevault::serial_number::${cachevault_serial_number}::host_controller_serial_number", value1 => $an->data->{cachevault}{serial_number}{$cachevault_serial_number}{host_controller_serial_number},
	}, file => $THIS_FILE, line => __LINE__});
	
	# Still alive? Good, time to parse the most annoying output ever... >_<
	my $split_point = 0;
	my $start_break = 0;
	my $end_break   = 0;
	foreach my $line (@{$cachevault_data})
	{
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Property(\s+)Value/)
		{
			$split_point = length($1) + 8;
			$start_break = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "split_point", value1 => $split_point, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# See if I am entering or exiting a data chunk.
		if (($line =~ /^--------/) && ($split_point))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$split_point = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "split_point", value1 => $split_point, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		
		# If I have a split point, break the string.
		if ($split_point)
		{
			my $variable = "";
			my $value    = "";
			if ($split_point >= length($line))
			{
				# Variable with no value
				$variable =  $line;
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				($variable, $value) = ($line =~ /^(.{$split_point})(.*)$/);
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Is this a temperature or something else we want to pre-process?
			if ($value =~ /^(\d+) C$/i)
			{
				# Yup
				$value = $1;
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{temperature}{$variable} = $value;
			}
			elsif ($value =~ /^(\d+) F$/i)
			{
				# Yup, but translate
				$value = $an->Convert->convert_to_celsius({temperature => $1});
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{temperature}{$variable} = $value;
			}
			elsif ($value =~ /\d+d \((\d+) seconds\)$/i)
			{
				# This is a static time span (like the time between learn cycles.
				$value = $1;
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{variable}{$variable} = $value." seconds";
				
				my $say_time = $an->Readable->time({'time' => $value});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "say_time", value3 => $say_time,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d\d\d)\/(\d\d)\/(\d\d)\s+(\d\d:\d\d:\d\d)\s+\(\d+ seconds\)$/i)
			{
				### NOTE: The 'X seconds' seems to not change and be a useless number...
				# This is a specific time in the future, properly formatted
				my $say_date = $1." ".$2;
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{variable}{$variable} = $say_date;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "say_date", value3 => $say_date,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d)\/(\d\d)\/(\d\d\d\d)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				my $say_date = $3."/".$2."/".$1;
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{variable}{$variable} = $say_date;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "say_date", value3 => $say_date,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d+) hour\(s\)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				my $seconds = $1 * 3600;
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{variable}{$variable} = $seconds." seconds";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
					name3 => "seconds",  value3 => $seconds,
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Nope, normal variable.
				$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{variable}{$variable} = $value;
			}
		}
	}
	
	# Some pretty debugging code.
	foreach my $cachevault_serial_number (keys %{$an->data->{cachevault}{serial_number}})
	{
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "cachevault_serial_number", value1 => $cachevault_serial_number,
				name2 => "type",                     value2 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $longest_variable = 0;
			foreach my $variable (sort {$a cmp $b} keys %{$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type}})
			{
				next if $an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type}{$variable} eq "";
				if (length($variable) > $longest_variable)
				{
					$longest_variable = length($variable);
				}
			}
			
			# Now loop again in alphabetical order printing in the dots as needed.
			foreach my $variable (sort {$a cmp $b} keys %{$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type}})
			{
				my $difference   = $longest_variable - length($variable);
				my $say_variable = $variable;
				if ($difference == 0)
				{
					# Do nothing
				}
				elsif ($difference == 1) 
				{
					$say_variable .= " ";
				}
				elsif ($difference == 2) 
				{
					$say_variable .= "  ";
				}
				else
				{
					my $dots         =  $difference - 2;
					   $say_variable .= " ";
					for (1 .. $dots)
					{
						$say_variable .= ".";
					}
					$say_variable .= " ";
				}
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "$say_variable", value1 => $an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type}{$variable},
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	return(0);
}

# This gets the basic information about the controller.
sub get_controller_info
{
	my ($an, $adapter) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_controller_info", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "adapter", value1 => $adapter, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $serial_number   = "";
	my $controller_data = [];
	my $shell_call      = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{controller_info};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
			$line =~ s/\r//;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		last if $line =~ /^TOPOLOGY:$/i;
		
		if ($line =~ /^Serial Number = (.*)?/i)
		{
			$serial_number = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "serial_number", value1 => $serial_number, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		push @{$controller_data}, $line;
	}
	close $file_handle;
	
	# If I found the serial number, then start parsing out the data.
	if (not $serial_number)
	{
		# Error out.
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scan_storcli_error_0006", message_variables => { adapter => $adapter }, code => 6, file => "$THIS_FILE", line => __LINE__});
		exit(6);
	}
	
	# If we're alive, we're ready to proceed.
	foreach my $line (@{$controller_data})
	{
		if ($line =~ /^(.*?) = (.*)$/)
		{
			my $variable = $1;
			my $value    = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "variable", value1 => $variable, 
				name2 => "value",    value2 => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If the variable has units, pull them out.
			if ($variable =~ /\((\w+B)\)$/i)
			{
				my $units    =  $1;
				   $variable =~ s/\($units\)//i;
				   $variable =~ s/^\s+//;
				   $variable =~ s/\s+$//;
				my $size = $an->Readable->hr_to_bytes({size => $value, type => $units, base2 => 1 });
				$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
					name3 => "units",    value3 => $units, 
					name4 => "size",     value4 => $size, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{controller}{serial_number}{$serial_number}{variable}{$variable} = $size;
			}
			elsif ($variable =~ /\(Degree Celsius\)/i)
			{
				$variable =~ s/\(Degree Celsius\)//i;
				$variable =~ s/^\s+//;
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{controller}{serial_number}{$serial_number}{temperature}{$variable} = $value;
			}
			elsif ($variable =~ /\(Degree Fahrenheit\)/i)
			{
				# Covert to °C
				$variable =~ s/\(Degree Fahrenheit\)//i;
				$variable =~ s/^\s+//;
				$variable =~ s/\s+$//;
				$value    =  $an->Convert->convert_to_celsius({temperature => $value});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{controller}{serial_number}{$serial_number}{temperature}{$variable} = $value;
			}
			else
			{
				# Catch-all
				$an->data->{controller}{serial_number}{$serial_number}{variable}{$variable} = $value;
			}
		}
	}
	
	# Some pretty debugging code.
	foreach my $serial_number (keys %{$an->data->{controller}{serial_number}})
	{
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "serial_number", value1 => $serial_number,
				name2 => "type",          value2 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $longest_variable = 0;
			foreach my $variable (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}{$serial_number}{$type}})
			{
				next if $an->data->{controller}{serial_number}{$serial_number}{$type}{$variable} eq "";
				if (length($variable) > $longest_variable)
				{
					$longest_variable = length($variable);
				}
			}
			
			# Now loop again in alphabetical order printing in the dots as needed.
			foreach my $variable (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}{$serial_number}{$type}})
			{
				next if $an->data->{controller}{serial_number}{$serial_number}{$type}{$variable} eq "";
				my $difference   = $longest_variable - length($variable);
				my $say_variable = $variable;
				if ($difference == 0)
				{
					# Do nothing
				}
				elsif ($difference == 1) 
				{
					$say_variable .= " ";
				}
				elsif ($difference == 2) 
				{
					$say_variable .= "  ";
				}
				else
				{
					my $dots         =  $difference - 2;
					   $say_variable .= " ";
					for (1 .. $dots)
					{
						$say_variable .= ".";
					}
					$say_variable .= " ";
				}
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "$say_variable", value1 => $an->data->{controller}{serial_number}{$serial_number}{$type}{$variable},
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "serial_number", value1 => $serial_number,
	}, file => $THIS_FILE, line => __LINE__});
	return($serial_number);
}

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
sub find_lsi_controllers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "find_lsi_controllers", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will keep track of how many controllers we find.
	my $adapter_count = 0;
	
	# First, do we have storcli64 installed?
	if (not -e $an->data->{path}{storcli64})
	{
		print $an->String->get({key => "scan_storcli_error_0001", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0001", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 1);
	}
	
	# Make sure it is executable
	if (not -x $an->data->{path}{storcli64})
	{
		print $an->String->get({key => "scan_storcli_error_0002", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0002", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 2);
	}
	
	# Still alive? Good! Look for controllers now.
	my $shell_call = $an->data->{path}{storcli64}." ".$an->data->{sys}{arguments}{adapter_count};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Controller Count = (\d+)/i)
		{
			$adapter_count = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "adapter_count", value1 => $adapter_count
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# Have we any adapters?
	if ($adapter_count > 0)
	{
		$an->data->{sys}{adapter_count} = $adapter_count;
		$an->Log->entry({log_level => 2, message_key => "scan_storcli_log_0001", message_variables => {
			count => $an->data->{sys}{adapter_count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		print $an->String->get({
			key		=>	"scan_storcli_error_0003",
			variables	=>	{
				path		=>	$an->data->{path}{storcli64},
			},
		})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0003", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 3);
	}
	
	return(0);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_storcli_message_0002"})."\n";

	return(0);
}
