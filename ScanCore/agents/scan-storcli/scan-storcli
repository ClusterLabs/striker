#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# ScanCore Scan Agent for LSI-based RAID controllers using the 'storcli64' command line tool.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - storcli64 not installed
# 2   - storcli64 is installed but it is not executable.
# 3   - No LSI-based controllers found.
# 4   - Got data from the wrong controller.
# 5   - Unexpecte status when querying adapter
# 6   - Failed to parse out the controller's serial number.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# TODO:
# - Check the cache policy and reset it to 'writeback' if the BBU/FBU is healthy and the cache changes to 
#   write-through.
# 
# NOTE:
# - BBU and Cachevault specs/temp ranges;
#   45646-00B_Cache_Backup_Products_SAS_SATA_RAID_Controller_UserGd.pdf ->  Specifications for the BBU Models
#   - BBU - Charge: 10 °C to 40 °C, Discharge: 10 °C to 55 °C
#   - CV  - 0 °C to 55 °C
# 

# Disable this for now.
exit(0);

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
#binmode STDOUT, 'encoding(utf8)';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-storcli'		=>	{
			# This will keep track of devices with serial numbers so that it is easy to look up
			# the UUID from the serial numbers and vice versa.
			controllers		=>	{
				by_serial		=>	{},
				by_uuid			=>	{},
			},
			cachevaults		=>	{
				by_serial		=>	{},
				by_uuid			=>	{},
			},
			bbus		=>	{
				by_serial		=>	{},
				by_uuid			=>	{},
			},
			physical_drives	=>	{
				by_serial		=>	{},
				by_uuid			=>	{},
			},
			language		=>	"en_CA",
			log_level		=>	1,
			log_language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_db_transactions	=>	0,
			thresholds			=>	{
				raid_on_chip			=>	{
					high_warning			=>	98,
					high_critical			=>	104,
					low_warning			=>	5,
					low_critical			=>	0,
					jump				=>	8,
					buffer				=>	3,
				},
			},
		},
		sys			=>	{
			sql			=>	[],
			arguments		=>	{
				adapter_count		=>	"show ctrlcount",
				alarm_state		=>	"show alarm",
				# BBU battery or FBU capacitor bank info.
				bgi_rate		=>	"show bgirate",
				bbu_data		=>	"/bbu show all",
				cc_rate			=>	"show ccrate",
				cachevault_data		=>	"/cv show all",
				controller_info		=>	"show all", 
				physical_disk_data	=>	"/eall /sall show all",
				performance_mode	=>	"show perfmode",
				pr_rate			=>	"show prrate",
				rebuild_rate		=>	"show rebuildrate",
				virtual_disk_data	=>	"/vall show all",
			},
			adapter_count		=>	0,
			adapter			=>	{},
		},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-storcli'}{language});
$an->default_log_language($an->data->{'scan-storcli'}{log_language});
$an->default_log_file    ($an->data->{'scan-storcli'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-storcli'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-storcli'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 3, message_key => "notice_message_0013", message_variables => { connections => $connections }, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { uuid => $an->data->{sys}{host_uuid} }, code => 255, file => "$THIS_FILE", line => __LINE__});
}

print $an->String->get({key => "scan_storcli_message_0001"})."\n";

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
find_lsi_controllers($an);

# If we're still alive, start gathering data.
gather_data($an);

# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);




# Clean up and go away.
nice_exit($an);

exit(0);


#############################################################################################################
# Function below                                                                                            #
#############################################################################################################

# Sort and prepare the data for insertion into the database.
sub sort_and_prepare_data
{
	my ($an) = @_;
	
	# First, sort the controllers.
	foreach my $serial_number (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}})
	{
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "serial_number", value1 => $serial_number,
				name2 => "type",          value2 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->aligned_entries({
				log_level => 2, 
				file      => $THIS_FILE,
				line      => __LINE__,
				prefix    => "$serial_number - $type",
				hash_ref  => $an->data->{controller}{serial_number}{$serial_number}{$type},
			});
		}
		
		my $storcli_controller_uuid          = "";
		my $storcli_controller_host_uuid     = $an->data->{sys}{host_uuid};
		my $storcli_controller_serial_number = $serial_number;
		my $storcli_controller_model         = $an->data->{controller}{serial_number}{$serial_number}{variable}{model};
		my $storcli_controller_alarm_state   = $an->data->{controller}{serial_number}{$serial_number}{variable}{alarm_state};
		my $storcli_controller_cache_size    = $an->data->{controller}{serial_number}{$serial_number}{variable}{on_board_memory_size};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
			name1 => "storcli_controller_host_uuid",     value1 => $storcli_controller_host_uuid,
			name2 => "storcli_controller_serial_number", value2 => $storcli_controller_serial_number,
			name3 => "storcli_controller_model",         value3 => $storcli_controller_model,
			name4 => "storcli_controller_alarm_state",   value4 => $storcli_controller_alarm_state,
			name5 => "storcli_controller_cache_size",    value5 => $storcli_controller_cache_size,
		}, file => $THIS_FILE, line => __LINE__});
	}
	#die "$THIS_FILE ".__LINE__."; testing...\n";
	
	# Now Cachevault (FBUs)
	foreach my $cachevault_serial_number (sort {$a cmp $b} keys %{$an->data->{cachevault}{serial_number}})
	{
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "cachevault_serial_number", value1 => $cachevault_serial_number,
				name2 => "type",                     value2 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->aligned_entries({
				log_level => 3, 
				file      => $THIS_FILE,
				line      => __LINE__,
				prefix    => "$cachevault_serial_number - $type",
				hash_ref  => $an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type},
			});
		}
	}
	
	# Now BBUs
	foreach my $bbu_serial_number (sort {$a cmp $b} keys %{$an->data->{bbu}{serial_number}})
	{
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "bbu_serial_number", value1 => $bbu_serial_number,
				name2 => "type",              value2 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->aligned_entries({
				log_level => 2, 
				file      => $THIS_FILE,
				line      => __LINE__,
				prefix    => "$bbu_serial_number - $type",
				hash_ref  => $an->data->{bbu}{serial_number}{$bbu_serial_number}{$type},
			});
		}
	}
	
	# Now the virtual disks. Note that '9999' is a fake VD used for physical drives not in any actual 
	# VDs.
	foreach my $virtual_disk (sort {$a cmp $b} keys %{$an->data->{virtual_disk}})
	{
		my $serial_number = $an->data->{virtual_disk}{$virtual_disk}{variable}{on_controller};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "virtual_disk",  value1 => $virtual_disk,
			name2 => "serial_number", value2 => $serial_number,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $type ("variable", "temperature")
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "type", value1 => $type,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->aligned_entries({
				log_level => 2, 
				file      => $THIS_FILE,
				line      => __LINE__,
				prefix    => "VD $virtual_disk - $type",
				hash_ref  => $an->data->{virtual_disk}{$virtual_disk}{$type},
			});
		}
		
		# Show the drive group and drives.
		foreach my $drive_group (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "drive_group", value1 => $drive_group,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $say_drive_group  = $drive_group  eq "9999" ? "x" : $drive_group;
			my $say_virtual_disk = $virtual_disk eq "9999" ? "x" : $virtual_disk;
			
			# Show the basic drive group data
			foreach my $type ("variable", "temperature")
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "type", value1 => $type,
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->aligned_entries({
					log_level => 2, 
					file      => $THIS_FILE,
					line      => __LINE__,
					prefix    => "VD $say_virtual_disk, DG $say_drive_group - $type",
					hash_ref  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{$type},
				});
			}
			
			# And show the drives in this group.
			foreach my $enclosure_id (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}})
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "enclosure_id", value1 => $enclosure_id,
				}, file => $THIS_FILE, line => __LINE__});
				foreach my $slot_number (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}})
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "slot_number", value1 => $slot_number,
					}, file => $THIS_FILE, line => __LINE__});
					foreach my $type ("variable", "temperature")
					{
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "type", value1 => $type,
						}, file => $THIS_FILE, line => __LINE__});
						$an->Log->aligned_entries({
							log_level => 2, 
							file      => $THIS_FILE,
							line      => __LINE__,
							prefix    => "VD $say_virtual_disk, DG $say_drive_group, EID $enclosure_id, Slot $slot_number - $type",
							hash_ref  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{$type},
						});
					}
				}
			}
		}
	}
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in the old data. As we compare and UPDATE if needed, then we'll delete. If any are not found,
	# then it must be new and will be INSERTed. Any old records left over will have vanished.
	read_last_scan($an);
	
	### NOTE: We will loop through each section of data we scanned, deleting records as we process them
	###       that existed in the DB, and then marking as removed anything left in the databased data not
	###       seen in this scan.
	
	# Look for new, changed or deleted controllers.
	foreach my $serial_number (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "serial_number", value1 => $serial_number,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Is this controller in the database yet?
		my $sql             = [];
		my $controller_uuid = "";
		my $is_new          = 0;
		my $changes         = 0;
		if ($an->data->{'scan-storcli'}{controllers}{by_serial}{$serial_number})
		{
			# Yes!
			$controller_uuid = $an->data->{'scan-storcli'}{controllers}{by_serial}{$serial_number};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "controller_uuid", value1 => $controller_uuid,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# No, this is a new controller. Create a new UUID for it.
			$controller_uuid = $an->Get->uuid();
			$is_new          = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "controller_uuid", value1 => $controller_uuid,
				name2 => "is_new",          value2 => $is_new,
			}, file => $THIS_FILE, line => __LINE__});
			
			# Add the keys for looking it up by UUID or serial number.
			$an->data->{'scan-storcli'}{controllers}{by_serial}{$serial_number} = $controller_uuid;
			$an->data->{'scan-storcli'}{controllers}{by_uuid}{$controller_uuid} = $serial_number;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "scan-storcli::controllers::by_serial::$serial_number", value1 => $an->data->{'scan-storcli'}{controllers}{by_serial}{$serial_number},
				name2 => "scan-storcli::controllers::by_uuid::$controller_uuid", value2 => $an->data->{'scan-storcli'}{controllers}{by_uuid}{$controller_uuid},
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# These are the values for the main table. Anything else will go in the variables table which
		# will be processed after the controller.
		my $new_model       = "";
		my $new_alarm_state = "";
		my $new_cache_size  = "";
		my $source_table    = "storcli_controllers";
		my $source_uuid     = $controller_uuid;
		my $is_temperature  = "FALSE";
		foreach my $key (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}{$serial_number}{variable}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "key", value1 => $key,
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($key eq "model")
			{
				# Store and delete the value
				$new_model = delete $an->data->{controller}{serial_number}{$serial_number}{variable}{$key};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "new_model", value1 => $new_model,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			elsif ($key eq "alarm_state")
			{
				# Store and delete the value
				$new_alarm_state = delete $an->data->{controller}{serial_number}{$serial_number}{variable}{$key};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "new_alarm_state", value1 => $new_alarm_state,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			elsif ($key eq "on_board_memory_size")
			{
				# Store and delete the value
				$new_cache_size = delete $an->data->{controller}{serial_number}{$serial_number}{variable}{$key};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "new_cache_size", value1 => $new_cache_size,
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		
		if ($is_new)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "serial_number",   value1 => $serial_number,
				name2 => "new_model",       value2 => $new_model,
				name3 => "new_alarm_state", value3 => $new_alarm_state,
				name4 => "new_cache_size",  value4 => $new_cache_size,
			}, file => $THIS_FILE, line => __LINE__});
			
			### NOTE: The rest of the alerts will be in the format '- Variable: [$value]'.
			# Send an alert telling the user that we've found a new controller.
			my $sort = 1;
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_sort		=>	$sort,	
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scan_storcli_note_0001",
				alert_message_variables	=>	{
					model			=>	$new_model,
					serial_number		=>	$serial_number,
					say_cache_size		=>	$an->Readable->bytes_to_hr({'bytes' => $new_cache_size}),
					alarm_state		=>	$new_alarm_state,
				},
			});
			
			# INSERT
			my $query = "
INSERT INTO 
    storcli_controllers
(
    storcli_controller_host_uuid, 
    storcli_controller_uuid, 
    storcli_controller_serial_number, 
    storcli_controller_model, 
    storcli_controller_alarm_state, 
    storcli_controller_cache_size, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_alarm_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_cache_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			# Now record the query in the array
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
			push @{$sql}, $query;
			
			### Process the rest of the variables now. 
			# Variables
			foreach my $key (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}{$serial_number}{variable}})
			{
				   $sort++; 
				my $value = delete $an->data->{controller}{serial_number}{$serial_number}{variable}{$key};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "key",   value1 => $key,
					name2 => "value", value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
				
				# Send an alert telling the user that we've found a new controller.
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_agent_name	=>	"$THIS_FILE",
					alert_sort		=>	$sort,
					alert_header		=>	'FALSE',
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_storcli_note_0002",
					alert_message_variables	=>	{
						name			=>	$key,
						value			=>	$value,
					},
				});
				
				# INSERT
				my $query = "
INSERT INTO 
    storcli_variables
(
    storcli_variable_uuid, 
    storcli_variable_host_uuid, 
    storcli_variable_source_table, 
    storcli_variable_source_uuid, 
    storcli_variable_is_temperature, 
    storcli_variable_name, 
    storcli_variable_value, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->Get->uuid()).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    'storcli_controllers', 
    ".$an->data->{sys}{use_db_fh}->quote($controller_uuid).", 
    FALSE, 
    ".$an->data->{sys}{use_db_fh}->quote($key).", 
    ".$an->data->{sys}{use_db_fh}->quote($value).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				# Now record the query in the array
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
				push @{$sql}, $query;
			}
			
			# Temperatures
			foreach my $key (sort {$a cmp $b} keys %{$an->data->{controller}{serial_number}{$serial_number}{temperature}})
			{
				my $value = delete $an->data->{controller}{serial_number}{$serial_number}{variable}{$key};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "key",   value1 => $key,
					name2 => "value", value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
				
				### TODO: Process the temperature.
				# INSERT
				my $query = "
INSERT INTO 
    storcli_variables
(
    storcli_variable_uuid, 
    storcli_variable_host_uuid, 
    storcli_variable_source_table, 
    storcli_variable_source_uuid, 
    storcli_variable_is_temperature, 
    storcli_variable_name, 
    storcli_variable_value, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->Get->uuid()).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    'storcli_controllers', 
    ".$an->data->{sys}{use_db_fh}->quote($controller_uuid).", 
    TRUE, 
    ".$an->data->{sys}{use_db_fh}->quote($key).", 
    ".$an->data->{sys}{use_db_fh}->quote($value).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				# Now record the query in the array
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
				push @{$sql}, $query;
			}
		}
		else
		{
			### NOTE: The serial number should never change (a changed SN/controller should be 
			###       picked up as a new controller), but we check/update just to be safe.
			# Look for changes.
			my $old_serial_number = $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$controller_uuid}{storcli_controller_serial_number};
			my $old_model         = $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$controller_uuid}{storcli_controller_model};
			my $old_alarm_state   = $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$controller_uuid}{storcli_controller_alarm_state};
			my $old_cache_size    = $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$controller_uuid}{storcli_controller_cache_size};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "serial_number",     value1 => $serial_number,
				name2 => "old_serial_number", value2 => $old_serial_number,
				name3 => "new_model",         value3 => $new_model,
				name4 => "old_model",         value4 => $old_model,
				name5 => "new_alarm_state",   value5 => $new_alarm_state,
				name6 => "old_alarm_state",   value6 => $old_alarm_state,
				name7 => "new_cache_size",    value7 => $new_cache_size,
				name8 => "old_cache_size",    value8 => $old_cache_size,
			}, file => $THIS_FILE, line => __LINE__});
			
			if (($serial_number   ne $old_serial_number) or 
			    ($new_model       ne $old_model)         or 
			    ($new_alarm_state ne $old_alarm_state)   or 
			    ($new_cache_size  ne $old_cache_size))
			{
				my $query = "
UPDATE 
    storcli_controllers
SET 
    storcli_controller_serial_number = ".$an->data->{sys}{use_db_fh}->quote($serial_number).", 
    storcli_controller_model         = ".$an->data->{sys}{use_db_fh}->quote($new_model).", 
    storcli_controller_alarm_state   = ".$an->data->{sys}{use_db_fh}->quote($new_alarm_state).", 
    storcli_controller_cache_size    = ".$an->data->{sys}{use_db_fh}->quote($new_cache_size).", 
    modified_date                    = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    storcli_controller_host_uuid     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    storcli_controller_uuid          = ".$an->data->{sys}{use_db_fh}->quote($controller_uuid)." 
;";
				
				# Now record the query in the array
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
				push @{$sql}, $query;
			}
			else
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "no changes", value1 => "----",
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now see if any other variables have changed, been added or disappeared.
		}
	}
	
	die "$THIS_FILE ".__LINE__."; testing...\n";
	
	
	# Now commit the changes.
	commit_sql($an);
	
	return(0);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in the controller(s)
	my $query = "
SELECT 
    storcli_controller_uuid, 
    storcli_controller_host_uuid, 
    storcli_controller_serial_number, 
    storcli_controller_model, 
    storcli_controller_alarm_state, 
    storcli_controller_cache_size 
FROM 
    storcli_controllers 
WHERE 
    storcli_controller_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_controller_uuid          = $row->[0]; 
		my $storcli_controller_serial_number = $row->[1]; 
		my $storcli_controller_model         = $row->[2]; 
		my $storcli_controller_alarm_state   = $row->[3]; 
		my $storcli_controller_cache_size    = $row->[4]; 
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "storcli_controller_uuid",          value1 => $storcli_controller_uuid, 
			name2 => "storcli_controller_serial_number", value2 => $storcli_controller_serial_number, 
			name3 => "storcli_controller_model",         value3 => $storcli_controller_model, 
			name4 => "storcli_controller_alarm_state",   value4 => $storcli_controller_alarm_state, 
			name5 => "storcli_controller_cache_size",    value5 => $storcli_controller_cache_size, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the information about this controllers
		$an->data->{'scan-storcli'}{controllers}{by_serial}{$storcli_controller_serial_number} = $storcli_controller_uuid;
		$an->data->{'scan-storcli'}{controllers}{by_uuid}{$storcli_controller_uuid}            = $storcli_controller_serial_number;
		$an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid} = {
			storcli_controller_serial_number	=>	$storcli_controller_serial_number, 
			storcli_controller_model		=>	$storcli_controller_model, 
			storcli_controller_alarm_state		=>	$storcli_controller_alarm_state, 
			storcli_controller_cache_size		=>	$storcli_controller_cache_size, 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "sql::storcli_controllers::storcli_controller_uuid::${storcli_controller_uuid}::storcli_controller_serial_number", value1 => $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_serial_number}, 
			name2 => "sql::storcli_controllers::storcli_controller_uuid::${storcli_controller_uuid}::storcli_controller_model",         value2 => $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_model}, 
			name3 => "sql::storcli_controllers::storcli_controller_uuid::${storcli_controller_uuid}::storcli_controller_alarm_state",   value3 => $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_alarm_state}, 
			name4 => "sql::storcli_controllers::storcli_controller_uuid::${storcli_controller_uuid}::storcli_controller_cache_size",    value4 => $an->data->{sql}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_cache_size}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# Now load the cachevault data
	$query = "
SELECT 
    storcli_cachevault_uuid, 
    storcli_cachevault_controller_uuid, 
    storcli_cachevault_serial_number, 
    storcli_cachevault_state, 
    storcli_cachevault_design_capacity, 
    storcli_cachevault_replacement_needed, 
    storcli_cachevault_type, 
    storcli_cachevault_manufacture_date 
FROM 
    storcli_cachevaults
WHERE
    storcli_cachevault_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_cachevault_uuid               = $row->[0]; 
		my $storcli_cachevault_controller_uuid    = $row->[1];
		my $storcli_cachevault_serial_number      = $row->[2];
		my $storcli_cachevault_state              = defined $row->[3] ? $row->[3] : "";
		my $storcli_cachevault_design_capacity    = defined $row->[4] ? $row->[4] : "";
		my $storcli_cachevault_replacement_needed = defined $row->[5] ? $row->[5] : "";
		my $storcli_cachevault_type               = defined $row->[6] ? $row->[6] : "";
		my $storcli_cachevault_manufacture_date   = defined $row->[7] ? $row->[7] : "";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "storcli_cachevault_uuid",               value1 => $storcli_cachevault_uuid, 
			name2 => "storcli_cachevault_controller_uuid",    value2 => $storcli_cachevault_controller_uuid, 
			name3 => "storcli_cachevault_serial_number",      value3 => $storcli_cachevault_serial_number, 
			name3 => "storcli_cachevault_state",              value3 => $storcli_cachevault_state, 
			name4 => "storcli_cachevault_design_capacity",    value4 => $storcli_cachevault_design_capacity, 
			name5 => "storcli_cachevault_replacement_needed", value5 => $storcli_cachevault_replacement_needed, 
			name6 => "storcli_cachevault_type",               value6 => $storcli_cachevault_type, 
			name7 => "storcli_cachevault_manufacture_date",   value7 => $storcli_cachevault_manufacture_date, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the information about this cachevault
		$an->data->{'scan-storcli'}{cachevaults}{by_serial}{$storcli_cachevault_serial_number} = $storcli_cachevault_uuid;
		$an->data->{'scan-storcli'}{cachevaults}{by_uuid}{$storcli_cachevault_uuid}            = $storcli_cachevault_serial_number;
		$an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid} = {
			storcli_cachevault_controller_uuid	=>	$storcli_cachevault_controller_uuid, 
			storcli_cachevault_serial_number	=>	$storcli_cachevault_serial_number, 
			storcli_cachevault_state		=>	$storcli_cachevault_state, 
			storcli_cachevault_design_capacity	=>	$storcli_cachevault_design_capacity, 
			storcli_cachevault_replacement_needed	=>	$storcli_cachevault_replacement_needed, 
			storcli_cachevault_type			=>	$storcli_cachevault_type, 
			storcli_cachevault_manufacture_date	=>	$storcli_cachevault_manufacture_date, 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
			name1 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_controller_uuid",    value1 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_controller_uuid}, 
			name2 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_serial_number",      value2 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_serial_number}, 
			name3 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_state",              value3 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_state}, 
			name4 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_design_capacity",    value4 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_design_capacity}, 
			name5 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_replacement_needed", value5 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_replacement_needed}, 
			name6 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_type",               value6 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_type}, 
			name7 => "sql::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::storcli_cachevault_manufacture_date",   value7 => $an->data->{sql}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_manufacture_date}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# The BBU data...
	$query = "
SELECT 
    storcli_bbu_uuid, 
    storcli_bbu_controller_uuid, 
    storcli_bbu_serial_number, 
    storcli_bbu_type, 
    storcli_bbu_model, 
    storcli_bbu_state, 
    storcli_bbu_manufacture_date, 
    storcli_bbu_design_capacity, 
    storcli_bbu_replacement_needed 
FROM 
    storcli_bbus
WHERE
    storcli_bbu_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_bbu_uuid               = $row->[0]; 
		my $storcli_bbu_controller_uuid    = $row->[1];
		my $storcli_bbu_serial_number      = $row->[2];
		my $storcli_bbu_type               = defined $row->[3] ? $row->[3] : "";
		my $storcli_bbu_model              = defined $row->[4] ? $row->[4] : "";
		my $storcli_bbu_state              = defined $row->[5] ? $row->[5] : "";
		my $storcli_bbu_manufacture_date   = defined $row->[6] ? $row->[6] : "";
		my $storcli_bbu_design_capacity    = defined $row->[7] ? $row->[7] : "";
		my $storcli_bbu_replacement_needed = defined $row->[8] ? $row->[8] : "";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
			name1 => "storcli_bbu_uuid",               value1 => $storcli_bbu_uuid, 
			name2 => "storcli_bbu_controller_uuid",    value2 => $storcli_bbu_controller_uuid, 
			name3 => "storcli_bbu_serial_number",      value3 => $storcli_bbu_serial_number, 
			name4 => "storcli_bbu_type",               value4 => $storcli_bbu_type, 
			name5 => "storcli_bbu_model",              value5 => $storcli_bbu_model, 
			name6 => "storcli_bbu_state",              value6 => $storcli_bbu_state, 
			name7 => "storcli_bbu_manufacture_date",   value7 => $storcli_bbu_manufacture_date, 
			name8 => "storcli_bbu_design_capacity",    value8 => $storcli_bbu_design_capacity, 
			name9 => "storcli_bbu_replacement_needed", value9 => $storcli_bbu_replacement_needed, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the information about this BBU
		$an->data->{'scan-storcli'}{bbus}{by_serial}{$storcli_bbu_serial_number} = $storcli_bbu_controller_uuid;
		$an->data->{'scan-storcli'}{bbus}{by_uuid}{$storcli_bbu_controller_uuid} = $storcli_bbu_serial_number;
		$an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid} = {
			storcli_bbu_controller_uuid	=>	$storcli_bbu_controller_uuid, 
			storcli_bbu_serial_number	=>	$storcli_bbu_serial_number,
			storcli_bbu_type		=>	$storcli_bbu_type, 
			storcli_bbu_model		=>	$storcli_bbu_model, 
			storcli_bbu_state		=>	$storcli_bbu_state, 
			storcli_bbu_manufacture_date	=>	$storcli_bbu_manufacture_date, 
			storcli_bbu_design_capacity	=>	$storcli_bbu_design_capacity, 
			storcli_bbu_replacement_needed	=>	$storcli_bbu_replacement_needed, 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_controller_uuid",    value1 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_controller_uuid}, 
			name3 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_serial_number",      value2 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_serial_number}, 
			name4 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_type",               value3 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_type}, 
			name5 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_model",              value4 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_model}, 
			name6 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_state",              value5 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_state}, 
			name7 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_manufacture_date",   value6 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_manufacture_date}, 
			name8 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_design_capacity",    value7 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_design_capacity}, 
			name9 => "sql::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::storcli_bbu_replacement_needed", value8 => $an->data->{sql}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_replacement_needed}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# The virtual drives data...
	$query = "
SELECT 
    storcli_virtual_drive_uuid, 
    storcli_virtual_drive_controller_uuid, 
    storcli_virtual_drive_creation_date, 
    storcli_virtual_drive_data_protection, 
    storcli_virtual_drive_disk_cache_policy, 
    storcli_virtual_drive_emulation_type, 
    storcli_virtual_drive_encryption, 
    storcli_virtual_drive_blocks, 
    storcli_virtual_drive_strip_size, 
    storcli_virtual_drive_drives_per_span, 
    storcli_virtual_drive_span_depth, 
    storcli_virtual_drive_scsi_naa_id 
FROM 
    storcli_virtual_drives
WHERE
    storcli_virtual_drive_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_virtual_drive_uuid              = $row->[0]; 
		my $storcli_virtual_drive_controller_uuid   = $row->[1];
		my $storcli_virtual_drive_creation_date     = defined $row->[2]  ? $row->[2]  : "";
		my $storcli_virtual_drive_data_protection   = defined $row->[3]  ? $row->[3]  : "";
		my $storcli_virtual_drive_disk_cache_policy = defined $row->[4]  ? $row->[4]  : "";
		my $storcli_virtual_drive_emulation_type    = defined $row->[5]  ? $row->[5]  : "";
		my $storcli_virtual_drive_encryption        = defined $row->[6]  ? $row->[6]  : "";
		my $storcli_virtual_drive_blocks            = defined $row->[7]  ? $row->[7]  : "";
		my $storcli_virtual_drive_strip_size        = defined $row->[8]  ? $row->[8]  : "";
		my $storcli_virtual_drive_drives_per_span   = defined $row->[9]  ? $row->[9]  : "";
		my $storcli_virtual_drive_span_depth        = defined $row->[10] ? $row->[10] : "";
		my $storcli_virtual_drive_scsi_naa_id       = defined $row->[11] ? $row->[11] : "";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0012", message_variables => {
			name1  => "storcli_virtual_drive_uuid",              value1  => $storcli_virtual_drive_uuid, 
			name2  => "storcli_virtual_drive_controller_uuid",   value2  => $storcli_virtual_drive_controller_uuid, 
			name3  => "storcli_virtual_drive_creation_date",     value3  => $storcli_virtual_drive_creation_date, 
			name4  => "storcli_virtual_drive_data_protection",   value4  => $storcli_virtual_drive_data_protection, 
			name5  => "storcli_virtual_drive_disk_cache_policy", value5  => $storcli_virtual_drive_disk_cache_policy, 
			name6  => "storcli_virtual_drive_emulation_type",    value6  => $storcli_virtual_drive_emulation_type, 
			name7  => "storcli_virtual_drive_encryption",        value7  => $storcli_virtual_drive_encryption, 
			name8  => "storcli_virtual_drive_blocks",            value8  => $storcli_virtual_drive_blocks, 
			name9  => "storcli_virtual_drive_strip_size",        value9  => $storcli_virtual_drive_strip_size, 
			name10 => "storcli_virtual_drive_drives_per_span",   value10 => $storcli_virtual_drive_drives_per_span, 
			name11 => "storcli_virtual_drive_span_depth",        value11 => $storcli_virtual_drive_span_depth, 
			name12 => "storcli_virtual_drive_scsi_naa_id",       value12 => $storcli_virtual_drive_scsi_naa_id, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the drive group data. (Drive groups have no SN)
		$an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid} = {
			storcli_virtual_drive_controller_uuid	=>	$storcli_virtual_drive_controller_uuid, 
			storcli_virtual_drive_creation_date	=>	$storcli_virtual_drive_creation_date, 
			storcli_virtual_drive_data_protection	=>	$storcli_virtual_drive_data_protection, 
			storcli_virtual_drive_disk_cache_policy	=>	$storcli_virtual_drive_disk_cache_policy, 
			storcli_virtual_drive_emulation_type	=>	$storcli_virtual_drive_emulation_type, 
			storcli_virtual_drive_encryption	=>	$storcli_virtual_drive_encryption, 
			storcli_virtual_drive_blocks		=>	$storcli_virtual_drive_blocks, 
			storcli_virtual_drive_strip_size	=>	$storcli_virtual_drive_strip_size, 
			storcli_virtual_drive_drives_per_span	=>	$storcli_virtual_drive_drives_per_span, 
			storcli_virtual_drive_span_depth	=>	$storcli_virtual_drive_span_depth, 
			storcli_virtual_drive_scsi_naa_id	=>	$storcli_virtual_drive_scsi_naa_id, 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0011", message_variables => {
			name1  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_controller_uuid",   value1  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_controller_uuid}, 
			name2  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_creation_date",     value2  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_creation_date}, 
			name3  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_data_protection",   value3  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_data_protection}, 
			name4  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_disk_cache_policy", value4  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_disk_cache_policy}, 
			name5  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_emulation_type",    value5  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_emulation_type}, 
			name6  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_encryption",        value6  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_encryption}, 
			name7  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_blocks",            value7  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_blocks}, 
			name8  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_strip_size",        value8  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_strip_size}, 
			name9  => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_drives_per_span",   value9  => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_drives_per_span}, 
			name10 => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_span_depth",        value10 => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_span_depth}, 
			name11 => "sql::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::storcli_virtual_drive_scsi_naa_id",       value11 => $an->data->{sql}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_scsi_naa_id}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# The drive group data...
	$query = "
SELECT 
    storcli_drive_group_uuid, 
    storcli_drive_group_virtual_drive_uuid, 
    storcli_drive_group_access, 
    storcli_drive_group_array_size, 
    storcli_drive_group_array_state, 
    storcli_drive_group_cache, 
    storcli_drive_group_cachecade, 
    storcli_drive_group_consistent, 
    storcli_drive_group_disk_cache, 
    storcli_drive_group_raid_type, 
    storcli_drive_group_read_cache, 
    storcli_drive_group_scheduled_cc, 
    storcli_drive_group_write_cache 
FROM 
    storcli_drive_groups
WHERE
    storcli_drive_group_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_drive_group_uuid               = $row->[0]; 
		my $storcli_drive_group_virtual_drive_uuid = $row->[1];
		my $storcli_drive_group_access             = defined $row->[2]  ? $row->[2]  : "";
		my $storcli_drive_group_array_size         = defined $row->[3]  ? $row->[3]  : "";
		my $storcli_drive_group_array_state        = defined $row->[4]  ? $row->[4]  : "";
		my $storcli_drive_group_cache              = defined $row->[5]  ? $row->[5]  : "";
		my $storcli_drive_group_cachecade          = defined $row->[6]  ? $row->[6]  : "";
		my $storcli_drive_group_consistent         = defined $row->[7]  ? $row->[7]  : "";
		my $storcli_drive_group_disk_cache         = defined $row->[8]  ? $row->[8]  : "";
		my $storcli_drive_group_raid_type          = defined $row->[9]  ? $row->[9]  : "";
		my $storcli_drive_group_read_cache         = defined $row->[10] ? $row->[10] : "";
		my $storcli_drive_group_scheduled_cc       = defined $row->[11] ? $row->[11] : "";
		my $storcli_drive_group_write_cache        = defined $row->[12] ? $row->[12] : "";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0013", message_variables => {
			name1  => "storcli_drive_group_uuid",               value1  => $storcli_drive_group_uuid, 
			name2  => "storcli_drive_group_virtual_drive_uuid", value2  => $storcli_drive_group_virtual_drive_uuid, 
			name3  => "storcli_drive_group_access",             value3  => $storcli_drive_group_access, 
			name4  => "storcli_drive_group_array_size",         value4  => $storcli_drive_group_array_size, 
			name5  => "storcli_drive_group_array_state",        value5  => $storcli_drive_group_array_state, 
			name6  => "storcli_drive_group_cache",              value6  => $storcli_drive_group_cache, 
			name7  => "storcli_drive_group_cachecade",          value7  => $storcli_drive_group_cachecade, 
			name8  => "storcli_drive_group_consistent",         value8  => $storcli_drive_group_consistent, 
			name9  => "storcli_drive_group_disk_cache",         value9  => $storcli_drive_group_disk_cache, 
			name10 => "storcli_drive_group_raid_type",          value10 => $storcli_drive_group_raid_type, 
			name11 => "storcli_drive_group_read_cache",         value11 => $storcli_drive_group_read_cache, 
			name12 => "storcli_drive_group_scheduled_cc",       value12 => $storcli_drive_group_scheduled_cc, 
			name13 => "storcli_drive_group_write_cache",        value13 => $storcli_drive_group_write_cache, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the drive group data. (Drive groups have no SN)
		$an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid} = {
			storcli_drive_group_virtual_drive_uuid	=>	$storcli_drive_group_virtual_drive_uuid, 
			storcli_drive_group_access		=>	$storcli_drive_group_access, 
			storcli_drive_group_array_size		=>	$storcli_drive_group_array_size, 
			storcli_drive_group_array_state		=>	$storcli_drive_group_array_state, 
			storcli_drive_group_cache		=>	$storcli_drive_group_cache, 
			storcli_drive_group_cachecade		=>	$storcli_drive_group_cachecade, 
			storcli_drive_group_consistent		=>	$storcli_drive_group_consistent, 
			storcli_drive_group_disk_cache		=>	$storcli_drive_group_disk_cache, 
			storcli_drive_group_raid_type		=>	$storcli_drive_group_raid_type, 
			storcli_drive_group_read_cache		=>	$storcli_drive_group_read_cache, 
			storcli_drive_group_scheduled_cc	=>	$storcli_drive_group_scheduled_cc, 
			storcli_drive_group_write_cache		=>	$storcli_drive_group_write_cache, 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0012", message_variables => {
			name1  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_virtual_drive_uuid", value1  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_virtual_drive_uuid}, 
			name2  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_access",             value2  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_access}, 
			name3  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_array_size",         value3  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_array_size}, 
			name4  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_array_state",        value4  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_array_state}, 
			name5  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_cache",              value5  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_cache}, 
			name6  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_cachecade",          value6  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_cachecade}, 
			name7  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_consistent",         value7  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_consistent}, 
			name8  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_disk_cache",         value8  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_disk_cache}, 
			name9  => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_raid_type",          value9  => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_raid_type}, 
			name10 => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_read_cache",         value10 => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_read_cache}, 
			name11 => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_scheduled_cc",       value11 => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_scheduled_cc}, 
			name12 => "sql::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::storcli_drive_group_write_cache",        value12 => $an->data->{sql}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_write_cache}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# And now, the physical drives.
	$query = "
SELECT 
    storcli_physical_drive_uuid, 
    storcli_physical_drive_controller_uuid, 
    storcli_physical_drive_size, 
    storcli_physical_drive_sector_size, 
    storcli_physical_drive_vendor, 
    storcli_physical_drive_model, 
    storcli_physical_drive_serial_number, 
    storcli_physical_drive_self_encrypting_drive 
FROM 
    storcli_physical_drives
WHERE
    storcli_physical_drive_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_physical_drive_uuid                  = $row->[0]; 
		my $storcli_physical_drive_controller_uuid       = $row->[1];
		my $storcli_physical_drive_size                  = defined $row->[2] ? $row->[2] : "";
		my $storcli_physical_drive_sector_size           = defined $row->[3] ? $row->[3] : "";
		my $storcli_physical_drive_vendor                = defined $row->[4] ? $row->[4] : "";
		my $storcli_physical_drive_model                 = defined $row->[5] ? $row->[5] : "";
		my $storcli_physical_drive_serial_number         = defined $row->[6] ? $row->[6] : "";
		my $storcli_physical_drive_self_encrypting_drive = defined $row->[7] ? $row->[7] : "";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "storcli_physical_drive_uuid",                  value1 => $storcli_physical_drive_uuid, 
			name2 => "storcli_physical_drive_controller_uuid",       value2 => $storcli_physical_drive_controller_uuid, 
			name3 => "storcli_physical_drive_size",                  value3 => $storcli_physical_drive_size, 
			name4 => "storcli_physical_drive_sector_size",           value4 => $storcli_physical_drive_sector_size, 
			name5 => "storcli_physical_drive_vendor",                value5 => $storcli_physical_drive_vendor, 
			name6 => "storcli_physical_drive_model",                 value6 => $storcli_physical_drive_model, 
			name7 => "storcli_physical_drive_serial_number",         value7 => $storcli_physical_drive_serial_number, 
			name8 => "storcli_physical_drive_self_encrypting_drive", value8 => $storcli_physical_drive_self_encrypting_drive, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the information about this physical drive
		$an->data->{'scan-storcli'}{physical_drives}{by_serial}{$storcli_physical_drive_serial_number} = $storcli_physical_drive_uuid;
		$an->data->{'scan-storcli'}{physical_drives}{by_uuid}{$storcli_physical_drive_uuid}            = $storcli_physical_drive_serial_number;
		$an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid} = {
			storcli_physical_drive_controller_uuid		=>	$storcli_physical_drive_controller_uuid, 
			storcli_physical_drive_size			=>	$storcli_physical_drive_size, 
			storcli_physical_drive_sector_size		=>	$storcli_physical_drive_sector_size, 
			storcli_physical_drive_vendor			=>	$storcli_physical_drive_vendor, 
			storcli_physical_drive_model			=>	$storcli_physical_drive_model, 
			storcli_physical_drive_serial_number		=>	$storcli_physical_drive_serial_number, 
			storcli_physical_drive_self_encrypting_drive	=>	$storcli_physical_drive_self_encrypting_drive, 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
			name1 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_controller_uuid",       value1 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_controller_uuid}, 
			name2 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_size",                  value2 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_size}, 
			name3 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_sector_size",           value3 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_sector_size}, 
			name4 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_vendor",                value4 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_vendor}, 
			name5 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_model",                 value5 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_model}, 
			name6 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_serial_number",         value6 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_serial_number}, 
			name7 => "sql::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::storcli_physical_drive_self_encrypting_drive", value7 => $an->data->{sql}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_self_encrypting_drive}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# Lastly, the variables.
	$query = "
SELECT 
    storcli_variable_uuid, 
    storcli_variable_source_table, 
    storcli_variable_source_uuid, 
    storcli_variable_is_temperature, 
    storcli_variable_name, 
    storcli_variable_value 
FROM 
    storcli_variables
WHERE
    storcli_variable_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $storcli_variable_uuid            = $row->[0]; 
		my $storcli_variable_source_table    = $row->[1]; 
		my $storcli_variable_source_uuid     = $row->[2]; 
		my $storcli_variable_is_temperature  = $row->[3]; 
		my $storcli_variable_name            = $row->[4]; 
		my $storcli_variable_value           = defined $row->[5] ? $row->[5] : ""; 
		$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
			name1 => "storcli_variable_uuid",           value1 => $storcli_variable_uuid, 
			name2 => "storcli_variable_source_table",   value2 => $storcli_variable_source_table, 
			name3 => "storcli_variable_source_uuid",    value3 => $storcli_variable_source_uuid, 
			name4 => "storcli_variable_is_temperature", value4 => $storcli_variable_is_temperature, 
			name5 => "storcli_variable_name",           value5 => $storcli_variable_name, 
			name6 => "storcli_variable_value",          value6 => $storcli_variable_value, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# We store these differently for easier reference.
		$an->data->{sql}{storcli_variables}{storcli_variable_uuid}{source_table}{$storcli_variable_source_table}{source_uuid}{$storcli_variable_source_uuid}{variable}{$storcli_variable_name} = {
			storcli_variable_uuid		=>	$storcli_variable_uuid, 
			storcli_variable_is_temperature	=>	$storcli_variable_is_temperature, 
			storcli_variable_value		=>	$storcli_variable_value, 
		};
		
		# Entries are so long that we log the one per variable.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sql::storcli_variables::storcli_variable_uuid::source_table::${storcli_variable_source_table}::source_uuid::${storcli_variable_source_uuid}::variable::${storcli_variable_name}::storcli_variable_uuid",           value1 => $an->data->{sql}{storcli_variables}{storcli_variable_uuid}{source_table}{$storcli_variable_source_table}{source_uuid}{$storcli_variable_source_uuid}{variable}{$storcli_variable_name}{storcli_variable_uuid}, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sql::storcli_variables::storcli_variable_uuid::source_table::${storcli_variable_source_table}::source_uuid::${storcli_variable_source_uuid}::variable::${storcli_variable_name}::storcli_variable_is_temperature", value1 => $an->data->{sql}{storcli_variables}{storcli_variable_uuid}{source_table}{$storcli_variable_source_table}{source_uuid}{$storcli_variable_source_uuid}{variable}{$storcli_variable_name}{storcli_variable_is_temperature}, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "sql::storcli_variables::storcli_variable_uuid::source_table::${storcli_variable_source_table}::source_uuid::${storcli_variable_source_uuid}::variable::${storcli_variable_name}::storcli_variable_value",          value1 => $an->data->{sql}{storcli_variables}{storcli_variable_uuid}{source_table}{$storcli_variable_source_table}{source_uuid}{$storcli_variable_source_uuid}{variable}{$storcli_variable_name}{storcli_variable_value}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# Return the number 
	return(0);
}

# This looks at each DB's 'updated' table to see if any are behind. If any are, it will update the tables 
# based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Update Controllers and the various dangly bits hanging off them.
		update_db_controllers($an);
		update_db_cachevaults($an);
		update_db_bbus($an);
		update_db_virtual_drives($an);
		update_db_drive_groups($an);
		update_db_physical_drives($an);
		update_db_variables($an);
	}
	
	return(0);
}

# Update the 'storcli_physical_drives' table.
sub update_db_physical_drives
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_physical_drives" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_physical_drives' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_physical_drive_uuid, 
    storcli_physical_drive_controller_uuid, 
    storcli_physical_drive_size, 
    storcli_physical_drive_sector_size, 
    storcli_physical_drive_vendor, 
    storcli_physical_drive_model, 
    storcli_physical_drive_serial_number, 
    storcli_physical_drive_self_encrypting_drive, 
    modified_date 
FROM 
    history.storcli_physical_drives
WHERE
    storcli_physical_drive_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_physical_drive_uuid                  = $row->[0]; 
			my $storcli_physical_drive_controller_uuid       = $row->[1];
			my $storcli_physical_drive_size                  = defined $row->[2] ? $row->[2] : "";
			my $storcli_physical_drive_sector_size           = defined $row->[3] ? $row->[3] : "";
			my $storcli_physical_drive_vendor                = defined $row->[4] ? $row->[4] : "";
			my $storcli_physical_drive_model                 = defined $row->[5] ? $row->[5] : "";
			my $storcli_physical_drive_serial_number         = defined $row->[6] ? $row->[6] : "";
			my $storcli_physical_drive_self_encrypting_drive = defined $row->[7] ? $row->[7] : "";
			my $modified_date                                = $row->[8];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "storcli_physical_drive_uuid",                  value1 => $storcli_physical_drive_uuid, 
				name2 => "storcli_physical_drive_controller_uuid",       value2 => $storcli_physical_drive_controller_uuid, 
				name3 => "storcli_physical_drive_size",                  value3 => $storcli_physical_drive_size, 
				name4 => "storcli_physical_drive_sector_size",           value4 => $storcli_physical_drive_sector_size, 
				name5 => "storcli_physical_drive_vendor",                value5 => $storcli_physical_drive_vendor, 
				name6 => "storcli_physical_drive_model",                 value6 => $storcli_physical_drive_model, 
				name7 => "storcli_physical_drive_serial_number",         value7 => $storcli_physical_drive_serial_number, 
				name8 => "storcli_physical_drive_self_encrypting_drive", value8 => $storcli_physical_drive_self_encrypting_drive, 
				name9 => "modified_date",                                value9 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid} = {
				storcli_physical_drive_controller_uuid		=>	$storcli_physical_drive_controller_uuid, 
				storcli_physical_drive_uuid			=>	$storcli_physical_drive_uuid, 
				storcli_physical_drive_controller_uuid		=>	$storcli_physical_drive_controller_uuid, 
				storcli_physical_drive_size			=>	$storcli_physical_drive_size, 
				storcli_physical_drive_sector_size		=>	$storcli_physical_drive_sector_size, 
				storcli_physical_drive_vendor			=>	$storcli_physical_drive_vendor, 
				storcli_physical_drive_model			=>	$storcli_physical_drive_model, 
				storcli_physical_drive_serial_number		=>	$storcli_physical_drive_serial_number, 
				storcli_physical_drive_self_encrypting_drive	=>	$storcli_physical_drive_self_encrypting_drive, 
			};
			$an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid} = {
				storcli_physical_drive_controller_uuid		=>	$storcli_physical_drive_controller_uuid, 
				storcli_physical_drive_uuid			=>	$storcli_physical_drive_uuid, 
				storcli_physical_drive_controller_uuid		=>	$storcli_physical_drive_controller_uuid, 
				storcli_physical_drive_size			=>	$storcli_physical_drive_size, 
				storcli_physical_drive_sector_size		=>	$storcli_physical_drive_sector_size, 
				storcli_physical_drive_vendor			=>	$storcli_physical_drive_vendor, 
				storcli_physical_drive_model			=>	$storcli_physical_drive_model, 
				storcli_physical_drive_serial_number		=>	$storcli_physical_drive_serial_number, 
				storcli_physical_drive_self_encrypting_drive	=>	$storcli_physical_drive_self_encrypting_drive, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_physical_drive_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}})
		{
			my $storcli_physical_drive_controller_uuid   = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_controller_uuid};
			my $storcli_physical_drive_size = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_size};
			my $storcli_physical_drive_sector_size = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_sector_size};
			my $storcli_physical_drive_vendor = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_vendor};
			my $storcli_physical_drive_model = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_model};
			my $storcli_physical_drive_serial_number = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_serial_number};
			my $storcli_physical_drive_self_encrypting_drive = $an->data->{db_data}{unified}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{storcli_physical_drive_self_encrypting_drive};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "storcli_physical_drive_uuid",                  value1 => $storcli_physical_drive_uuid, 
				name2 => "storcli_physical_drive_controller_uuid",       value2 => $storcli_physical_drive_controller_uuid, 
				name3 => "storcli_physical_drive_size",            	value3 => $storcli_physical_drive_size, 
				name4 => "storcli_physical_drive_sector_size",           value4 => $storcli_physical_drive_sector_size, 
				name5 => "storcli_physical_drive_vendor",          	value5 => $storcli_physical_drive_vendor, 
				name6 => "storcli_physical_drive_model",           	value6 => $storcli_physical_drive_model, 
				name7 => "storcli_physical_drive_serial_number",         value7 => $storcli_physical_drive_serial_number, 
				name8 => "storcli_physical_drive_self_encrypting_drive", value8 => $storcli_physical_drive_self_encrypting_drive, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_physical_drive_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_physical_drives::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_physical_drives}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_physical_drives::modified_date::${modified_date}::storcli_physical_drive_uuid::${storcli_physical_drive_uuid}", value1 => $an->data->{db_data}{$id}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid})
						{
							# No, so UPDATE it. Note that I don't need to worry
							# about the host_uuid because we've only got 
							# storcli_physical_drive_uuid from this host.
							my $query = "
UPDATE 
    public.storcli_physical_drives
SET
    storcli_physical_drive_controller_uuid       = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_controller_uuid).", 
    storcli_physical_drive_size                  = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_size).", 
    storcli_physical_drive_sector_size           = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_sector_size).", 
    storcli_physical_drive_vendor                = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_vendor).", 
    storcli_physical_drive_model                 = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_model).", 
    storcli_physical_drive_serial_number         = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_serial_number).", 
    storcli_physical_drive_self_encrypting_drive = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_self_encrypting_drive).", 
    modified_date                                = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_physical_drive_uuid              = ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_physical_drives
(
    storcli_physical_drive_uuid, 
    storcli_physical_drive_host_uuid, 
    storcli_physical_drive_controller_uuid, 
    storcli_physical_drive_size, 
    storcli_physical_drive_sector_size, 
    storcli_physical_drive_vendor, 
    storcli_physical_drive_model, 
    storcli_physical_drive_serial_number, 
    storcli_physical_drive_self_encrypting_drive, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_sector_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_vendor).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_self_encrypting_drive).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_physical_drive_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_physical_drives}{modified_date}{$modified_date}{storcli_physical_drive_uuid}{$storcli_physical_drive_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_physical_drives
(
    storcli_physical_drive_uuid, 
    storcli_physical_drive_host_uuid, 
    storcli_physical_drive_controller_uuid, 
    storcli_physical_drive_size, 
    storcli_physical_drive_sector_size, 
    storcli_physical_drive_vendor, 
    storcli_physical_drive_model, 
    storcli_physical_drive_serial_number, 
    storcli_physical_drive_self_encrypting_drive, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_sector_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_vendor).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_physical_drive_self_encrypting_drive).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_physical_drive_uuid?
			} # foreach my $id 
		} # foreach my $storcli_physical_drive_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'storcli_drive_groups' table.
sub update_db_drive_groups
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_drive_groups" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_drive_groups' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_drive_group_uuid, 
    storcli_drive_group_virtual_drive_uuid, 
    storcli_drive_group_access, 
    storcli_drive_group_array_size, 
    storcli_drive_group_array_state, 
    storcli_drive_group_cache, 
    storcli_drive_group_cachecade, 
    storcli_drive_group_consistent, 
    storcli_drive_group_disk_cache, 
    storcli_drive_group_raid_type, 
    storcli_drive_group_read_cache, 
    storcli_drive_group_scheduled_cc, 
    storcli_drive_group_write_cache, 
    modified_date 
FROM 
    history.storcli_drive_groups
WHERE
    storcli_drive_group_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_drive_group_uuid               = $row->[0]; 
			my $storcli_drive_group_virtual_drive_uuid = $row->[1];
			my $storcli_drive_group_access             = defined $row->[2]  ? $row->[2]  : "";
			my $storcli_drive_group_array_size         = defined $row->[3]  ? $row->[3]  : "";
			my $storcli_drive_group_array_state        = defined $row->[4]  ? $row->[4]  : "";
			my $storcli_drive_group_cache              = defined $row->[5]  ? $row->[5]  : "";
			my $storcli_drive_group_cachecade          = defined $row->[6]  ? $row->[6]  : "";
			my $storcli_drive_group_consistent         = defined $row->[7]  ? $row->[7]  : "";
			my $storcli_drive_group_disk_cache         = defined $row->[8]  ? $row->[8]  : "";
			my $storcli_drive_group_raid_type          = defined $row->[9]  ? $row->[9]  : "";
			my $storcli_drive_group_read_cache         = defined $row->[10] ? $row->[10] : "";
			my $storcli_drive_group_scheduled_cc       = defined $row->[11] ? $row->[11] : "";
			my $storcli_drive_group_write_cache        = defined $row->[12] ? $row->[12] : "";
			my $modified_date                          = $row->[13];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0014", message_variables => {
				name1  => "storcli_drive_group_uuid",               value1  => $storcli_drive_group_uuid, 
				name2  => "storcli_drive_group_virtual_drive_uuid", value2  => $storcli_drive_group_virtual_drive_uuid, 
				name3  => "storcli_drive_group_access",             value3  => $storcli_drive_group_access, 
				name4  => "storcli_drive_group_array_size",         value4  => $storcli_drive_group_array_size, 
				name5  => "storcli_drive_group_array_state",        value5  => $storcli_drive_group_array_state, 
				name6  => "storcli_drive_group_cache",              value6  => $storcli_drive_group_cache, 
				name7  => "storcli_drive_group_cachecade",          value7  => $storcli_drive_group_cachecade, 
				name8  => "storcli_drive_group_consistent",         value8  => $storcli_drive_group_consistent, 
				name9  => "storcli_drive_group_disk_cache",         value9  => $storcli_drive_group_disk_cache, 
				name10 => "storcli_drive_group_raid_type",          value10 => $storcli_drive_group_raid_type, 
				name11 => "storcli_drive_group_read_cache",         value11 => $storcli_drive_group_read_cache, 
				name12 => "storcli_drive_group_scheduled_cc",       value12 => $storcli_drive_group_scheduled_cc, 
				name13 => "storcli_drive_group_write_cache",        value13 => $storcli_drive_group_write_cache, 
				name14 => "modified_date",                          value14 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid} = {
				storcli_drive_group_virtual_drive_uuid	=>	$storcli_drive_group_virtual_drive_uuid, 
				storcli_drive_group_access		=>	$storcli_drive_group_access, 
				storcli_drive_group_array_size		=>	$storcli_drive_group_array_size, 
				storcli_drive_group_array_state		=>	$storcli_drive_group_array_state, 
				storcli_drive_group_cache		=>	$storcli_drive_group_cache, 
				storcli_drive_group_cachecade		=>	$storcli_drive_group_cachecade, 
				storcli_drive_group_consistent		=>	$storcli_drive_group_consistent, 
				storcli_drive_group_disk_cache		=>	$storcli_drive_group_disk_cache, 
				storcli_drive_group_raid_type		=>	$storcli_drive_group_raid_type, 
				storcli_drive_group_read_cache		=>	$storcli_drive_group_read_cache, 
				storcli_drive_group_scheduled_cc	=>	$storcli_drive_group_scheduled_cc, 
				storcli_drive_group_write_cache		=>	$storcli_drive_group_write_cache, 
			};
			$an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid} = {
				storcli_drive_group_virtual_drive_uuid	=>	$storcli_drive_group_virtual_drive_uuid, 
				storcli_drive_group_access		=>	$storcli_drive_group_access, 
				storcli_drive_group_array_size		=>	$storcli_drive_group_array_size, 
				storcli_drive_group_array_state		=>	$storcli_drive_group_array_state, 
				storcli_drive_group_cache		=>	$storcli_drive_group_cache, 
				storcli_drive_group_cachecade		=>	$storcli_drive_group_cachecade, 
				storcli_drive_group_consistent		=>	$storcli_drive_group_consistent, 
				storcli_drive_group_disk_cache		=>	$storcli_drive_group_disk_cache, 
				storcli_drive_group_raid_type		=>	$storcli_drive_group_raid_type, 
				storcli_drive_group_read_cache		=>	$storcli_drive_group_read_cache, 
				storcli_drive_group_scheduled_cc	=>	$storcli_drive_group_scheduled_cc, 
				storcli_drive_group_write_cache		=>	$storcli_drive_group_write_cache, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_drive_group_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}})
		{
			my $storcli_drive_group_virtual_drive_uuid = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_virtual_drive_uuid};
			my $storcli_drive_group_access             = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_access};
			my $storcli_drive_group_array_size         = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_array_size};
			my $storcli_drive_group_array_state        = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_array_state};
			my $storcli_drive_group_cache              = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_cache};
			my $storcli_drive_group_cachecade          = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_cachecade};
			my $storcli_drive_group_consistent         = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_consistent};
			my $storcli_drive_group_disk_cache         = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_disk_cache};
			my $storcli_drive_group_raid_type          = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_raid_type};
			my $storcli_drive_group_read_cache         = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_read_cache};
			my $storcli_drive_group_scheduled_cc       = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_scheduled_cc};
			my $storcli_drive_group_write_cache        = $an->data->{db_data}{unified}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{storcli_drive_group_write_cache};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0013", message_variables => {
				name1  => "storcli_drive_group_uuid",               value1  => $storcli_drive_group_uuid, 
				name2  => "storcli_drive_group_virtual_drive_uuid", value2  => $storcli_drive_group_virtual_drive_uuid, 
				name3  => "storcli_drive_group_access",             value3  => $storcli_drive_group_access, 
				name4  => "storcli_drive_group_array_size",         value4  => $storcli_drive_group_array_size, 
				name5  => "storcli_drive_group_array_state",        value5  => $storcli_drive_group_array_state, 
				name6  => "storcli_drive_group_cache",              value6  => $storcli_drive_group_cache, 
				name7  => "storcli_drive_group_cachecade",          value7  => $storcli_drive_group_cachecade, 
				name8  => "storcli_drive_group_consistent",         value8  => $storcli_drive_group_consistent, 
				name9  => "storcli_drive_group_disk_cache",         value9  => $storcli_drive_group_disk_cache, 
				name10 => "storcli_drive_group_raid_type",          value10 => $storcli_drive_group_raid_type, 
				name11 => "storcli_drive_group_read_cache",         value11 => $storcli_drive_group_read_cache, 
				name12 => "storcli_drive_group_scheduled_cc",       value12 => $storcli_drive_group_scheduled_cc, 
				name13 => "storcli_drive_group_write_cache",        value13 => $storcli_drive_group_write_cache, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_drive_group_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_drive_groups::storcli_drive_group_uuid::${storcli_drive_group_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_drive_groups}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_drive_groups::modified_date::${modified_date}::storcli_drive_group_uuid::${storcli_drive_group_uuid}", value1 => $an->data->{db_data}{$id}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid})
						{
							# No, so UPDATE it. Note that I don't need to worry
							# about the host_uuid because we've only got 
							# storcli_drive_group_uuid from this host.
							my $query = "
UPDATE 
    public.storcli_drive_groups
SET
    storcli_drive_group_virtual_drive_uuid = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_virtual_drive_uuid).", 
    storcli_drive_group_access             = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_access).", 
    storcli_drive_group_array_size         = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_array_size).", 
    storcli_drive_group_array_state        = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_array_state).", 
    storcli_drive_group_cache              = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_cache).", 
    storcli_drive_group_cachecade          = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_cachecade).", 
    storcli_drive_group_consistent         = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_consistent).", 
    storcli_drive_group_disk_cache         = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_disk_cache).", 
    storcli_drive_group_raid_type          = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_raid_type).", 
    storcli_drive_group_read_cache         = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_read_cache).", 
    storcli_drive_group_scheduled_cc       = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_scheduled_cc).", 
    storcli_drive_group_write_cache        = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_write_cache).", 
    modified_date                          = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_drive_group_uuid               = ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_drive_groups
(
    storcli_drive_group_uuid, 
    storcli_drive_group_host_uuid, 
    storcli_drive_group_virtual_drive_uuid, 
    storcli_drive_group_access, 
    storcli_drive_group_array_size, 
    storcli_drive_group_array_state, 
    storcli_drive_group_cache, 
    storcli_drive_group_cachecade, 
    storcli_drive_group_consistent, 
    storcli_drive_group_disk_cache, 
    storcli_drive_group_raid_type, 
    storcli_drive_group_read_cache, 
    storcli_drive_group_scheduled_cc, 
    storcli_drive_group_write_cache, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_virtual_drive_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_array_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_array_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_cachecade).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_consistent).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_disk_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_raid_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_read_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_scheduled_cc).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_write_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_drive_group_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_drive_groups}{modified_date}{$modified_date}{storcli_drive_group_uuid}{$storcli_drive_group_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_drive_groups
(
   storcli_drive_group_uuid, 
    storcli_drive_group_host_uuid, 
    storcli_drive_group_virtual_drive_uuid, 
    storcli_drive_group_access, 
    storcli_drive_group_array_size, 
    storcli_drive_group_array_state, 
    storcli_drive_group_cache, 
    storcli_drive_group_cachecade, 
    storcli_drive_group_consistent, 
    storcli_drive_group_disk_cache, 
    storcli_drive_group_raid_type, 
    storcli_drive_group_read_cache, 
    storcli_drive_group_scheduled_cc, 
    storcli_drive_group_write_cache, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_virtual_drive_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_array_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_array_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_cachecade).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_consistent).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_disk_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_raid_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_read_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_scheduled_cc).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_drive_group_write_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_drive_group_uuid?
			} # foreach my $id 
		} # foreach my $storcli_drive_group_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'storcli_virtual_drives' table.
sub update_db_virtual_drives
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_virtual_drives" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_virtual_drives' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_virtual_drive_uuid, 
    storcli_virtual_drive_controller_uuid, 
    storcli_virtual_drive_creation_date, 
    storcli_virtual_drive_data_protection, 
    storcli_virtual_drive_disk_cache_policy, 
    storcli_virtual_drive_emulation_type, 
    storcli_virtual_drive_encryption, 
    storcli_virtual_drive_blocks, 
    storcli_virtual_drive_strip_size, 
    storcli_virtual_drive_drives_per_span, 
    storcli_virtual_drive_span_depth, 
    storcli_virtual_drive_scsi_naa_id, 
    modified_date 
FROM 
    history.storcli_virtual_drives
WHERE
    storcli_virtual_drive_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_virtual_drive_uuid              = $row->[0]; 
			my $storcli_virtual_drive_controller_uuid   = $row->[1];
			my $storcli_virtual_drive_creation_date     = defined $row->[2]  ? $row->[2]  : "";
			my $storcli_virtual_drive_data_protection   = defined $row->[3]  ? $row->[3]  : "";
			my $storcli_virtual_drive_disk_cache_policy = defined $row->[4]  ? $row->[4]  : "";
			my $storcli_virtual_drive_emulation_type    = defined $row->[5]  ? $row->[5]  : "";
			my $storcli_virtual_drive_encryption        = defined $row->[6]  ? $row->[6]  : "";
			my $storcli_virtual_drive_blocks            = defined $row->[7]  ? $row->[7]  : "";
			my $storcli_virtual_drive_strip_size        = defined $row->[8]  ? $row->[8]  : "";
			my $storcli_virtual_drive_drives_per_span   = defined $row->[9]  ? $row->[9]  : "";
			my $storcli_virtual_drive_span_depth        = defined $row->[10] ? $row->[10] : "";
			my $storcli_virtual_drive_scsi_naa_id       = defined $row->[11] ? $row->[11] : "";
			my $modified_date                           = $row->[12];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0013", message_variables => {
				name1  => "storcli_virtual_drive_uuid",              value1  => $storcli_virtual_drive_uuid, 
				name2  => "storcli_virtual_drive_controller_uuid",   value2  => $storcli_virtual_drive_controller_uuid, 
				name3  => "storcli_virtual_drive_creation_date",     value3  => $storcli_virtual_drive_creation_date, 
				name4  => "storcli_virtual_drive_data_protection",   value4  => $storcli_virtual_drive_data_protection, 
				name5  => "storcli_virtual_drive_disk_cache_policy", value5  => $storcli_virtual_drive_disk_cache_policy, 
				name6  => "storcli_virtual_drive_emulation_type",    value6  => $storcli_virtual_drive_emulation_type, 
				name7  => "storcli_virtual_drive_encryption",        value7  => $storcli_virtual_drive_encryption, 
				name8  => "storcli_virtual_drive_blocks",            value8  => $storcli_virtual_drive_blocks, 
				name9  => "storcli_virtual_drive_strip_size",        value9  => $storcli_virtual_drive_strip_size, 
				name10 => "storcli_virtual_drive_drives_per_span",   value10 => $storcli_virtual_drive_drives_per_span, 
				name11 => "storcli_virtual_drive_span_depth",        value11 => $storcli_virtual_drive_span_depth, 
				name12 => "storcli_virtual_drive_scsi_naa_id",       value12 => $storcli_virtual_drive_scsi_naa_id, 
				name13 => "modified_date",                           value13 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid} = {
				storcli_virtual_drive_controller_uuid	=>	$storcli_virtual_drive_controller_uuid, 
				storcli_virtual_drive_creation_date	=>	$storcli_virtual_drive_creation_date, 
				storcli_virtual_drive_data_protection	=>	$storcli_virtual_drive_data_protection, 
				storcli_virtual_drive_disk_cache_policy	=>	$storcli_virtual_drive_disk_cache_policy, 
				storcli_virtual_drive_emulation_type	=>	$storcli_virtual_drive_emulation_type, 
				storcli_virtual_drive_encryption	=>	$storcli_virtual_drive_encryption, 
				storcli_virtual_drive_blocks		=>	$storcli_virtual_drive_blocks, 
				storcli_virtual_drive_strip_size	=>	$storcli_virtual_drive_strip_size, 
				storcli_virtual_drive_drives_per_span	=>	$storcli_virtual_drive_drives_per_span, 
				storcli_virtual_drive_span_depth	=>	$storcli_virtual_drive_span_depth, 
				storcli_virtual_drive_scsi_naa_id	=>	$storcli_virtual_drive_scsi_naa_id, 
			};
			$an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid} = {
				storcli_virtual_drive_controller_uuid	=>	$storcli_virtual_drive_controller_uuid, 
				storcli_virtual_drive_creation_date	=>	$storcli_virtual_drive_creation_date, 
				storcli_virtual_drive_data_protection	=>	$storcli_virtual_drive_data_protection, 
				storcli_virtual_drive_disk_cache_policy	=>	$storcli_virtual_drive_disk_cache_policy, 
				storcli_virtual_drive_emulation_type	=>	$storcli_virtual_drive_emulation_type, 
				storcli_virtual_drive_encryption	=>	$storcli_virtual_drive_encryption, 
				storcli_virtual_drive_blocks		=>	$storcli_virtual_drive_blocks, 
				storcli_virtual_drive_strip_size	=>	$storcli_virtual_drive_strip_size, 
				storcli_virtual_drive_drives_per_span	=>	$storcli_virtual_drive_drives_per_span, 
				storcli_virtual_drive_span_depth	=>	$storcli_virtual_drive_span_depth, 
				storcli_virtual_drive_scsi_naa_id	=>	$storcli_virtual_drive_scsi_naa_id, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_virtual_drive_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}})
		{
			my $storcli_virtual_drive_controller_uuid   = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_controller_uuid};
			my $storcli_virtual_drive_creation_date     = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_creation_date};
			my $storcli_virtual_drive_data_protection   = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_data_protection};
			my $storcli_virtual_drive_disk_cache_policy = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_disk_cache_policy};
			my $storcli_virtual_drive_emulation_type    = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_emulation_type};
			my $storcli_virtual_drive_encryption        = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_encryption};
			my $storcli_virtual_drive_blocks            = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_blocks};
			my $storcli_virtual_drive_strip_size        = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_strip_size};
			my $storcli_virtual_drive_drives_per_span   = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_drives_per_span};
			my $storcli_virtual_drive_span_depth        = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_span_depth};
			my $storcli_virtual_drive_scsi_naa_id       = $an->data->{db_data}{unified}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{storcli_virtual_drive_scsi_naa_id};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0012", message_variables => {
				name1  => "storcli_virtual_drive_uuid",              value1  => $storcli_virtual_drive_uuid, 
				name2  => "storcli_virtual_drive_controller_uuid",   value2  => $storcli_virtual_drive_controller_uuid, 
				name3  => "storcli_virtual_drive_creation_date",     value3  => $storcli_virtual_drive_creation_date, 
				name4  => "storcli_virtual_drive_data_protection",   value4  => $storcli_virtual_drive_data_protection, 
				name5  => "storcli_virtual_drive_disk_cache_policy", value5  => $storcli_virtual_drive_disk_cache_policy, 
				name6  => "storcli_virtual_drive_emulation_type",    value6  => $storcli_virtual_drive_emulation_type, 
				name7  => "storcli_virtual_drive_encryption",        value7  => $storcli_virtual_drive_encryption, 
				name8  => "storcli_virtual_drive_blocks",            value8  => $storcli_virtual_drive_blocks, 
				name9  => "storcli_virtual_drive_strip_size",        value9  => $storcli_virtual_drive_strip_size, 
				name10 => "storcli_virtual_drive_drives_per_span",   value10 => $storcli_virtual_drive_drives_per_span, 
				name11 => "storcli_virtual_drive_span_depth",        value11 => $storcli_virtual_drive_span_depth, 
				name12 => "storcli_virtual_drive_scsi_naa_id",       value12 => $storcli_virtual_drive_scsi_naa_id, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_virtual_drive_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_virtual_drives::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_virtual_drives}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_virtual_drives::modified_date::${modified_date}::storcli_virtual_drive_uuid::${storcli_virtual_drive_uuid}", value1 => $an->data->{db_data}{$id}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid})
						{
							# No, so UPDATE it. Note that I don't need to worry
							# about the host_uuid because we've only got 
							# storcli_virtual_drive_uuid from this host.
							my $query = "
UPDATE 
    public.storcli_virtual_drives
SET
    storcli_virtual_drive_controller_uuid   = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_controller_uuid).", 
    storcli_virtual_drive_creation_date     = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_creation_date).", 
    storcli_virtual_drive_data_protection   = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_data_protection).", 
    storcli_virtual_drive_disk_cache_policy = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_disk_cache_policy).", 
    storcli_virtual_drive_emulation_type    = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_emulation_type).", 
    storcli_virtual_drive_encryption        = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_encryption).", 
    storcli_virtual_drive_blocks            = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_blocks).", 
    storcli_virtual_drive_strip_size        = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_strip_size).", 
    storcli_virtual_drive_drives_per_span   = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_drives_per_span).", 
    storcli_virtual_drive_span_depth        = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_span_depth).", 
    storcli_virtual_drive_scsi_naa_id       = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_scsi_naa_id).", 
    modified_date                           = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_virtual_drive_uuid              = ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_virtual_drives
(
    storcli_virtual_drive_uuid, 
    storcli_virtual_drive_host_uuid, 
    storcli_virtual_drive_controller_uuid, 
    storcli_virtual_drive_creation_date, 
    storcli_virtual_drive_data_protection, 
    storcli_virtual_drive_disk_cache_policy, 
    storcli_virtual_drive_emulation_type, 
    storcli_virtual_drive_encryption, 
    storcli_virtual_drive_blocks, 
    storcli_virtual_drive_strip_size, 
    storcli_virtual_drive_drives_per_span, 
    storcli_virtual_drive_span_depth, 
    storcli_virtual_drive_scsi_naa_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_creation_date).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_data_protection).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_disk_cache_policy).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_emulation_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_encryption).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_blocks).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_strip_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_drives_per_span).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_span_depth).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_scsi_naa_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_virtual_drive_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_virtual_drives}{modified_date}{$modified_date}{storcli_virtual_drive_uuid}{$storcli_virtual_drive_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_virtual_drives
(
    storcli_virtual_drive_uuid, 
    storcli_virtual_drive_host_uuid, 
    storcli_virtual_drive_controller_uuid, 
    storcli_virtual_drive_creation_date, 
    storcli_virtual_drive_data_protection, 
    storcli_virtual_drive_disk_cache_policy, 
    storcli_virtual_drive_emulation_type, 
    storcli_virtual_drive_encryption, 
    storcli_virtual_drive_blocks, 
    storcli_virtual_drive_strip_size, 
    storcli_virtual_drive_drives_per_span, 
    storcli_virtual_drive_span_depth, 
    storcli_virtual_drive_scsi_naa_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_creation_date).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_data_protection).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_disk_cache_policy).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_emulation_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_encryption).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_blocks).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_strip_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_drives_per_span).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_span_depth).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_virtual_drive_scsi_naa_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_virtual_drive_uuid?
			} # foreach my $id 
		} # foreach my $storcli_virtual_drive_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'storcli_bbus' table.
sub update_db_bbus
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_bbus" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_bbus' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_bbu_uuid, 
    storcli_bbu_controller_uuid, 
    storcli_bbu_serial_number, 
    storcli_bbu_type, 
    storcli_bbu_model, 
    storcli_bbu_state, 
    storcli_bbu_manufacture_date, 
    storcli_bbu_design_capacity, 
    storcli_bbu_replacement_needed, 
    modified_date 
FROM 
    history.storcli_bbus
WHERE
    storcli_bbu_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_bbu_uuid               = $row->[0]; 
			my $storcli_bbu_controller_uuid    = $row->[1];
			my $storcli_bbu_serial_number      = $row->[2];
			my $storcli_bbu_type               = defined $row->[3] ? $row->[3] : "";
			my $storcli_bbu_model              = defined $row->[4] ? $row->[4] : "";
			my $storcli_bbu_state              = defined $row->[5] ? $row->[5] : "";
			my $storcli_bbu_manufacture_date   = defined $row->[6] ? $row->[6] : "";
			my $storcli_bbu_design_capacity    = defined $row->[7] ? $row->[7] : "";
			my $storcli_bbu_replacement_needed = defined $row->[8] ? $row->[8] : "";
			my $modified_date                  = $row->[9];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "storcli_bbu_uuid",               value1  => $storcli_bbu_uuid, 
				name2  => "storcli_bbu_controller_uuid",    value2  => $storcli_bbu_controller_uuid, 
				name3  => "storcli_bbu_serial_number",      value3  => $storcli_bbu_serial_number, 
				name4  => "storcli_bbu_type",               value4  => $storcli_bbu_type, 
				name5  => "storcli_bbu_model",              value5  => $storcli_bbu_model, 
				name6  => "storcli_bbu_state",              value6  => $storcli_bbu_state, 
				name7  => "storcli_bbu_manufacture_date",   value7  => $storcli_bbu_manufacture_date, 
				name8  => "storcli_bbu_design_capacity",    value8  => $storcli_bbu_design_capacity, 
				name9  => "storcli_bbu_replacement_needed", value9  => $storcli_bbu_replacement_needed, 
				name10 => "modified_date",                  value10 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid} = {
				storcli_bbu_controller_uuid	=>	$storcli_bbu_controller_uuid, 
				storcli_bbu_serial_number	=>	$storcli_bbu_serial_number,
				storcli_bbu_type		=>	$storcli_bbu_type, 
				storcli_bbu_model		=>	$storcli_bbu_model, 
				storcli_bbu_state		=>	$storcli_bbu_state, 
				storcli_bbu_manufacture_date	=>	$storcli_bbu_manufacture_date, 
				storcli_bbu_design_capacity	=>	$storcli_bbu_design_capacity, 
				storcli_bbu_replacement_needed	=>	$storcli_bbu_replacement_needed, 
			};
			$an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid} = {
				storcli_bbu_controller_uuid	=>	$storcli_bbu_controller_uuid, 
				storcli_bbu_serial_number	=>	$storcli_bbu_serial_number,
				storcli_bbu_type		=>	$storcli_bbu_type, 
				storcli_bbu_model		=>	$storcli_bbu_model, 
				storcli_bbu_state		=>	$storcli_bbu_state, 
				storcli_bbu_manufacture_date	=>	$storcli_bbu_manufacture_date, 
				storcli_bbu_design_capacity	=>	$storcli_bbu_design_capacity, 
				storcli_bbu_replacement_needed	=>	$storcli_bbu_replacement_needed, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_bbus}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_bbu_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}})
		{
			my $storcli_bbu_controller_uuid    = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_controller_uuid};
			my $storcli_bbu_serial_number      = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_serial_number};
			my $storcli_bbu_type               = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_type};
			my $storcli_bbu_model              = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_model};
			my $storcli_bbu_state              = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_state};
			my $storcli_bbu_manufacture_date   = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_manufacture_date};
			my $storcli_bbu_design_capacity    = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_design_capacity};
			my $storcli_bbu_replacement_needed = $an->data->{db_data}{unified}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}{storcli_bbu_replacement_needed};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "storcli_bbu_uuid",               value1 => $storcli_bbu_uuid, 
				name2 => "storcli_bbu_controller_uuid",    value2 => $storcli_bbu_controller_uuid, 
				name3 => "storcli_bbu_serial_number",      value3 => $storcli_bbu_serial_number, 
				name4 => "storcli_bbu_type",               value4 => $storcli_bbu_type, 
				name5 => "storcli_bbu_model",              value5 => $storcli_bbu_model, 
				name6 => "storcli_bbu_state",              value6 => $storcli_bbu_state, 
				name7 => "storcli_bbu_manufacture_date",   value7 => $storcli_bbu_manufacture_date, 
				name8 => "storcli_bbu_design_capacity",    value8 => $storcli_bbu_design_capacity, 
				name9 => "storcli_bbu_replacement_needed", value9 => $storcli_bbu_replacement_needed, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_bbu_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_bbus::storcli_bbu_uuid::${storcli_bbu_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_bbus}{storcli_bbu_uuid}{$storcli_bbu_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_bbus::modified_date::${modified_date}::storcli_bbu_uuid::${storcli_bbu_uuid}", value1 => $an->data->{db_data}{$id}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid})
						{
							# No, so UPDATE it. Note that I don't need to worry
							# about the host_uuid because we've only got 
							# storcli_bbu_uuid from this host.
							my $query = "
UPDATE 
    public.storcli_bbus
SET
    storcli_bbu_controller_uuid    = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_controller_uuid).", 
    storcli_bbu_serial_number      = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_serial_number).", 
    storcli_bbu_type               = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_type).", 
    storcli_bbu_model              = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_model).", 
    storcli_bbu_state              = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_state).", 
    storcli_bbu_manufacture_date   = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_manufacture_date).", 
    storcli_bbu_design_capacity    = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_design_capacity).", 
    storcli_bbu_replacement_needed = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_replacement_needed).", 
    modified_date                  = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_bbu_uuid               = ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_bbus
(
    storcli_bbu_uuid, 
    storcli_bbu_host_uuid, 
    storcli_bbu_controller_uuid, 
    storcli_bbu_serial_number, 
    storcli_bbu_type, 
    storcli_bbu_model, 
    storcli_bbu_state, 
    storcli_bbu_design_capacity, 
    storcli_bbu_manufacture_date, 
    storcli_bbu_replacement_needed, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_design_capacity).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_manufacture_date).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_replacement_needed).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_bbu_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_bbus}{modified_date}{$modified_date}{storcli_bbu_uuid}{$storcli_bbu_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_bbus
(
    storcli_bbu_uuid, 
    storcli_bbu_host_uuid, 
    storcli_bbu_controller_uuid, 
    storcli_bbu_serial_number, 
    storcli_bbu_type, 
    storcli_bbu_model, 
    storcli_bbu_state, 
    storcli_bbu_design_capacity, 
    storcli_bbu_manufacture_date, 
    storcli_bbu_replacement_needed, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_design_capacity).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_manufacture_date).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_bbu_replacement_needed).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_bbu_uuid?
			} # foreach my $id 
		} # foreach my $storcli_bbu_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'storcli_cachevaults' table.
sub update_db_cachevaults
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_cachevaults" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_cachevaults' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_cachevault_uuid, 
    storcli_cachevault_controller_uuid, 
    storcli_cachevault_serial_number, 
    storcli_cachevault_state, 
    storcli_cachevault_design_capacity, 
    storcli_cachevault_replacement_needed, 
    storcli_cachevault_type, 
    storcli_cachevault_manufacture_date, 
    modified_date 
FROM 
    history.storcli_cachevaults
WHERE
    storcli_cachevault_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_cachevault_uuid               = $row->[0]; 
			my $storcli_cachevault_controller_uuid    = $row->[1];
			my $storcli_cachevault_serial_number      = $row->[2]; 
			my $storcli_cachevault_state              = defined $row->[3] ? $row->[3] : "";
			my $storcli_cachevault_design_capacity    = defined $row->[4] ? $row->[4] : "";
			my $storcli_cachevault_replacement_needed = defined $row->[5] ? $row->[5] : "";
			my $storcli_cachevault_type               = defined $row->[6] ? $row->[6] : "";
			my $storcli_cachevault_manufacture_date   = defined $row->[7] ? $row->[7] : "";
			my $modified_date                         = $row->[8];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "storcli_cachevault_uuid",               value1 => $storcli_cachevault_uuid, 
				name2 => "storcli_cachevault_controller_uuid",    value2 => $storcli_cachevault_controller_uuid, 
				name3 => "storcli_cachevault_serial_number",      value3 => $storcli_cachevault_serial_number, 
				name4 => "storcli_cachevault_state",              value4 => $storcli_cachevault_state, 
				name5 => "storcli_cachevault_design_capacity",    value5 => $storcli_cachevault_design_capacity, 
				name6 => "storcli_cachevault_replacement_needed", value6 => $storcli_cachevault_replacement_needed, 
				name7 => "storcli_cachevault_type",               value7 => $storcli_cachevault_type, 
				name8 => "storcli_cachevault_manufacture_date",   value8 => $storcli_cachevault_manufacture_date, 
				name9 => "modified_date",                         value9 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid} = {
				storcli_cachevault_controller_uuid	=>	$storcli_cachevault_controller_uuid, 
				storcli_cachevault_serial_number	=>	$storcli_cachevault_serial_number, 
				storcli_cachevault_state		=>	$storcli_cachevault_state, 
				storcli_cachevault_design_capacity	=>	$storcli_cachevault_design_capacity, 
				storcli_cachevault_replacement_needed	=>	$storcli_cachevault_replacement_needed, 
				storcli_cachevault_type			=>	$storcli_cachevault_type, 
				storcli_cachevault_manufacture_date	=>	$storcli_cachevault_manufacture_date, 
			};
			$an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid} = {
				storcli_cachevault_controller_uuid	=>	$storcli_cachevault_controller_uuid, 
				storcli_cachevault_serial_number	=>	$storcli_cachevault_serial_number, 
				storcli_cachevault_state		=>	$storcli_cachevault_state, 
				storcli_cachevault_design_capacity	=>	$storcli_cachevault_design_capacity, 
				storcli_cachevault_replacement_needed	=>	$storcli_cachevault_replacement_needed, 
				storcli_cachevault_type			=>	$storcli_cachevault_type, 
				storcli_cachevault_manufacture_date	=>	$storcli_cachevault_manufacture_date, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_cachevault_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}})
		{
			my $storcli_cachevault_controller_uuid    = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_controller_uuid};
			my $storcli_cachevault_serial_number      = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_serial_number};
			my $storcli_cachevault_state              = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_state};
			my $storcli_cachevault_design_capacity    = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_design_capacity};
			my $storcli_cachevault_replacement_needed = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_replacement_needed};
			my $storcli_cachevault_type               = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_type};
			my $storcli_cachevault_manufacture_date   = $an->data->{db_data}{unified}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{storcli_cachevault_manufacture_date};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "storcli_cachevault_uuid",               value1 => $storcli_cachevault_uuid, 
				name2 => "storcli_cachevault_controller_uuid",    value2 => $storcli_cachevault_controller_uuid, 
				name3 => "storcli_cachevault_serial_number",      value3 => $storcli_cachevault_serial_number, 
				name4 => "storcli_cachevault_state",              value4 => $storcli_cachevault_state, 
				name5 => "storcli_cachevault_design_capacity",    value5 => $storcli_cachevault_design_capacity, 
				name6 => "storcli_cachevault_replacement_needed", value6 => $storcli_cachevault_replacement_needed, 
				name7 => "storcli_cachevault_type",               value7 => $storcli_cachevault_type, 
				name8 => "storcli_cachevault_manufacture_date",   value8 => $storcli_cachevault_manufacture_date, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_cachevault_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_cachevaults::storcli_cachevault_uuid::${storcli_cachevault_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_cachevaults}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_cachevaults::modified_date::${modified_date}::storcli_cachevault_uuid::${storcli_cachevault_uuid}", value1 => $an->data->{db_data}{$id}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid})
						{
							# No, so UPDATE it. Note that I don't need to worry
							# about the host_uuid because we've only got 
							# storcli_cachevault_uuid from this host.
							my $query = "
UPDATE 
    public.storcli_cachevaults
SET
    storcli_cachevault_controller_uuid    = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_controller_uuid).", 
    storcli_cachevault_serial_number      = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_serial_number).", 
    storcli_cachevault_state              = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_state).", 
    storcli_cachevault_design_capacity    = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_design_capacity).", 
    storcli_cachevault_replacement_needed = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_replacement_needed).", 
    storcli_cachevault_type               = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_type).", 
    storcli_cachevault_manufacture_date   = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_manufacture_date).", 
    modified_date                         = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_cachevault_uuid               = ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_cachevaults
(
    storcli_cachevault_uuid, 
    storcli_cachevault_host_uuid, 
    storcli_cachevault_controller_uuid, 
    storcli_cachevault_serial_number, 
    storcli_cachevault_state, 
    storcli_cachevault_design_capacity, 
    storcli_cachevault_replacement_needed, 
    storcli_cachevault_type, 
    storcli_cachevault_manufacture_date, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_design_capacity).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_replacement_needed).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_manufacture_date).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_cachevault_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_cachevaults}{modified_date}{$modified_date}{storcli_cachevault_uuid}{$storcli_cachevault_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_cachevaults
(
    storcli_cachevault_uuid, 
    storcli_cachevault_host_uuid, 
    storcli_cachevault_controller_uuid, 
    storcli_cachevault_serial_number, 
    storcli_cachevault_state, 
    storcli_cachevault_design_capacity, 
    storcli_cachevault_replacement_needed, 
    storcli_cachevault_type, 
    storcli_cachevault_manufacture_date, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_design_capacity).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_replacement_needed).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_cachevault_manufacture_date).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_cachevault_uuid?
			} # foreach my $id 
		} # foreach my $storcli_cachevault_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'storcli_variables' table.
sub update_db_variables
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_variables" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_variables' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_variable_uuid, 
    storcli_variable_source_table, 
    storcli_variable_source_uuid, 
    storcli_variable_is_temperature, 
    storcli_variable_name, 
    storcli_variable_value, 
    modified_date 
FROM 
    history.storcli_variables
WHERE
    storcli_variable_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_variable_uuid            = $row->[0]; 
			my $storcli_variable_source_table    = $row->[1]; 
			my $storcli_variable_source_uuid     = $row->[2]; 
			my $storcli_variable_is_temperature  = $row->[3]; 
			my $storcli_variable_name            = $row->[4]; 
			my $storcli_variable_value           = defined $row->[5] ? $row->[5] : ""; 
			my $modified_date                    = $row->[6];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
				name1 => "storcli_variable_uuid",           value1 => $storcli_variable_uuid, 
				name2 => "storcli_variable_source_table",   value2 => $storcli_variable_source_table, 
				name3 => "storcli_variable_source_uuid",    value3 => $storcli_variable_source_uuid, 
				name4 => "storcli_variable_is_temperature", value4 => $storcli_variable_is_temperature, 
				name5 => "storcli_variable_name",           value5 => $storcli_variable_name, 
				name6 => "storcli_variable_value",          value6 => $storcli_variable_value, 
				name7 => "modified_date",                   value7 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid} = {
				storcli_variable_source_table	=>	$storcli_variable_source_table, 
				storcli_variable_source_uuid	=>	$storcli_variable_source_uuid, 
				storcli_variable_is_temperature	=>	$storcli_variable_is_temperature, 
				storcli_variable_name		=>	$storcli_variable_name, 
				storcli_variable_value		=>	$storcli_variable_value, 
			};
			$an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid} = {
				storcli_variable_source_table	=>	$storcli_variable_source_table, 
				storcli_variable_source_uuid	=>	$storcli_variable_source_uuid, 
				storcli_variable_is_temperature	=>	$storcli_variable_is_temperature, 
				storcli_variable_name		=>	$storcli_variable_name, 
				storcli_variable_value		=>	$storcli_variable_value, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_variables}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_variable_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}})
		{
			my $storcli_variable_source_table   = $an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid}{storcli_variable_source_table};
			my $storcli_variable_source_uuid    = $an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid}{storcli_variable_source_uuid};
			my $storcli_variable_is_temperature = $an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid}{storcli_variable_is_temperature};
			my $storcli_variable_name           = $an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid}{storcli_variable_name};
			my $storcli_variable_value          = $an->data->{db_data}{unified}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid}{storcli_variable_value};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
				name1 => "storcli_variable_uuid",           value1 => $storcli_variable_uuid, 
				name2 => "storcli_variable_source_table",   value2 => $storcli_variable_source_table, 
				name3 => "storcli_variable_source_uuid",    value3 => $storcli_variable_source_uuid, 
				name4 => "storcli_variable_is_temperature", value4 => $storcli_variable_is_temperature, 
				name5 => "storcli_variable_name",           value5 => $storcli_variable_name, 
				name6 => "storcli_variable_value",          value6 => $storcli_variable_value, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_variable_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_variables::storcli_variable_uuid::${storcli_variable_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_variables::storcli_variable_uuid::${storcli_variable_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_variables}{storcli_variable_uuid}{$storcli_variable_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_variables::modified_date::${modified_date}::storcli_variable_uuid::${storcli_variable_uuid}", value1 => $an->data->{db_data}{$id}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid})
						{
							# No, so UPDATE it. Note that I don't need to worry
							# about the host_uuid because we've only got 
							# storcli_variable_uuid from this host.
							my $query = "
UPDATE 
    public.storcli_variables
SET
    storcli_variable_source_table   = ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_source_table).", 
    storcli_variable_source_uuid    = ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_source_uuid).", 
    storcli_variable_is_temperature = ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_is_temperature).", 
    storcli_variable_name           = ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_name).", 
    storcli_variable_value          = ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_value).", 
    modified_date                   = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_variable_uuid           = ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_variables
(
    storcli_variable_uuid, 
    storcli_variable_host_uuid, 
    storcli_variable_source_table, 
    storcli_variable_source_uuid, 
    storcli_variable_is_temperature, 
    storcli_variable_name, 
    storcli_variable_value, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_source_table).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_source_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_is_temperature).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_variable_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_variables}{modified_date}{$modified_date}{storcli_variable_uuid}{$storcli_variable_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_variables
(
    storcli_variable_uuid, 
    storcli_variable_host_uuid, 
    storcli_variable_source_table, 
    storcli_variable_source_uuid, 
    storcli_variable_is_temperature, 
    storcli_variable_name, 
    storcli_variable_value, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_source_table).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_source_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_is_temperature).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_variable_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_variable_uuid?
			} # foreach my $id 
		} # foreach my $storcli_variable_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'storcli_controllers' table.
sub update_db_controllers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_controllers" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'storcli_controllers' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    storcli_controller_uuid, 
    storcli_controller_serial_number, 
    storcli_controller_model, 
    storcli_controller_alarm_state, 
    storcli_controller_cache_size, 
    modified_date 
FROM 
    history.storcli_controllers
WHERE
    storcli_controller_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $storcli_controller_uuid          = $row->[0]; 
			my $storcli_controller_serial_number = $row->[1]; 
			my $storcli_controller_model         = $row->[2]; 
			my $storcli_controller_alarm_state   = $row->[3]; 
			my $storcli_controller_cache_size    = $row->[4]; 
			my $modified_date                    = $row->[5];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "storcli_controller_uuid",          value1 => $storcli_controller_uuid, 
				name2 => "storcli_controller_serial_number", value2 => $storcli_controller_serial_number, 
				name3 => "storcli_controller_model",         value3 => $storcli_controller_model, 
				name4 => "storcli_controller_alarm_state",   value4 => $storcli_controller_alarm_state, 
				name5 => "storcli_controller_cache_size",    value5 => $storcli_controller_cache_size, 
				name6 => "modified_date",                    value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid} = {
				storcli_controller_serial_number	=>	$storcli_controller_serial_number, 
				storcli_controller_model		=>	$storcli_controller_model, 
				storcli_controller_alarm_state		=>	$storcli_controller_alarm_state, 
				storcli_controller_cache_size		=>	$storcli_controller_cache_size, 
			};
			$an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid} = {
				storcli_controller_serial_number	=>	$storcli_controller_serial_number, 
				storcli_controller_model		=>	$storcli_controller_model, 
				storcli_controller_alarm_state		=>	$storcli_controller_alarm_state, 
				storcli_controller_cache_size		=>	$storcli_controller_cache_size, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{storcli_controllers}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $storcli_controller_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}})
		{
			my $storcli_controller_serial_number = $an->data->{db_data}{unified}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_serial_number};
			my $storcli_controller_model = $an->data->{db_data}{unified}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_model};
			my $storcli_controller_alarm_state = $an->data->{db_data}{unified}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_alarm_state};
			my $storcli_controller_cache_size = $an->data->{db_data}{unified}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid}{storcli_controller_cache_size};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
				name1 => "storcli_controller_uuid",          value1  => $storcli_controller_uuid, 
				name2 => "storcli_controller_serial_number", value2 => $storcli_controller_serial_number, 
				name3 => "storcli_controller_model",         value3 => $storcli_controller_model, 
				name4 => "storcli_controller_alarm_state",   value4 => $storcli_controller_alarm_state, 
				name5 => "storcli_controller_cache_size",    value5 => $storcli_controller_cache_size, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'storcli_controller_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::storcli_controllers::storcli_controller_uuid::${storcli_controller_uuid}::seen", value1 => $an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::storcli_controllers::storcli_controller_uuid::${storcli_controller_uuid}::exists", value1 => $an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{storcli_controllers}{storcli_controller_uuid}{$storcli_controller_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::storcli_controllers::modified_date::${modified_date}::storcli_controller_uuid::${storcli_controller_uuid}", value1 => $an->data->{db_data}{$id}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.storcli_controllers
SET
    storcli_controller_serial_number = ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_serial_number).", 
    storcli_controller_model         = ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_model).", 
    storcli_controller_alarm_state   = ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_alarm_state).", 
    storcli_controller_cache_size    = ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_cache_size).", 
    modified_date                    = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    storcli_controller_host_uuid     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    storcli_controller_uuid          = ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.storcli_controllers
(
    storcli_controller_host_uuid, 
    storcli_controller_uuid, 
    storcli_controller_serial_number, 
    storcli_controller_model, 
    storcli_controller_alarm_state, 
    storcli_controller_cache_size, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_alarm_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_cache_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'storcli_controller_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{storcli_controllers}{modified_date}{$modified_date}{storcli_controller_uuid}{$storcli_controller_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.storcli_controllers
(
    storcli_controller_host_uuid, 
    storcli_controller_uuid, 
    storcli_controller_serial_number, 
    storcli_controller_model, 
    storcli_controller_alarm_state, 
    storcli_controller_cache_size, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_serial_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_model).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_alarm_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($storcli_controller_cache_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen storcli_controller_uuid?
			} # foreach my $id 
		} # foreach my $storcli_controller_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load the schema. If the schema gets
# loaded, we'll check other databases for older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through the databases...
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => "$THIS_FILE" }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='storcli_controllers' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		
		# Did we find the table?
		if ($count < 1)
		{
			# Nope. Need to load the database schema.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This gathers the various data from the controller(s).
sub gather_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "gather_data", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: This assumes the controllers go 0, 1, ... n. If this is wrong, we'll need to call 
	###       'storcli64 show all' and parse 'System Overview'.
	# Loops through reach found controller.
	foreach my $controller (1..$an->data->{sys}{adapter_count})
	{
		# We drop the number by 1 because the '/cX' starts at '0' where the controller count starts 
		# at '1'.
		my $adapter = ($controller - 1);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "controller", value1 => $controller, 
			name2 => "adapter",    value2 => $adapter, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Read in controller data.
		my $serial_number = get_controller_info($an, $adapter);
		
		# Read in cachevault (FBU) data (if it exists).
		get_cachevault_data($an, $adapter, $serial_number);
		
		# Read in BBU data (if it exists).
		get_bbu_data($an, $adapter, $serial_number);
		
		# Read in virtual disk information.
		get_virtual_disk_data($an, $adapter, $serial_number);
		
		# Read in the physical disk information.
		get_physical_disk_data($an, $adapter, $serial_number);
	}
	
	# Sort and prepare the data for insertion into the database.
	sort_and_prepare_data($an);
	
	return(0);
}

# This looks for physical disks on the controller.
sub get_physical_disk_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_physical_disk_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $virtual_disk     = 9999;
	my $drive_group      = 9999;
	my $enclosure_id     = "";
	my $slot_number      = "";
	my $in_drive_header  = 0;
	my $in_port_status   = 0;
	my $start_break      = 0;
	my $sector_size      = 0;
	my $sector_variables = [];
	my $shell_call       = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{physical_disk_data};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# See if I am entering or exiting a section.
		if ($line =~ /Drive \/c$adapter\/e(\d+)\/s(\d+):/i)
		{
			$enclosure_id    = $1;
			$slot_number     = $2;
			#$slot_number     = sprintf("%02d", $slot_number);
			$in_drive_header = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "enclosure_id",    value1 => $enclosure_id, 
				name2 => "slot_number",     value2 => $slot_number, 
				name3 => "in_drive_header", value3 => $in_drive_header, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if ($line =~ /Drive \/c$adapter\/e(\d+)\/s(\d+) State/i)
		{
			$enclosure_id    = $1;
			$slot_number     = $2;
			#$slot_number     = sprintf("%02d", $slot_number);
			$in_drive_header = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "enclosure_id",    value1 => $enclosure_id, 
				name2 => "slot_number",     value2 => $slot_number, 
				name3 => "in_drive_header", value3 => $in_drive_header, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if ($line =~ /^Port Status /)
		{
			$in_port_status = 1;
			$start_break    = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "in_port_status", value1 => $in_port_status, 
				name2 => "start_break",    value2 => $start_break, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if (($line =~ /^--------/) && ($in_port_status))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# In 'port status' and start break set, must be end break.
				$in_port_status = 0;
				$start_break    = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_port_status", value1 => $in_port_status, 
					name2 => "start_break",    value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				
				### NOTE: So far as I can tell, there is only ever two SAS ports on hard 
				###       drives. The way the system parses them handles N-number of ports,
				###       though. For now, we'll squeeze these into the top layer variables
				###       to save having to have another table to process.
				my $sas_port_0_port_status = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{0}{port_status};
				my $sas_port_0_link_speed  = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{0}{link_speed};
				my $sas_port_0_sas_address = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{0}{sas_address};
				my $sas_port_1_port_status = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{1}{port_status};
				my $sas_port_1_link_speed  = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{1}{link_speed};
				my $sas_port_1_sas_address = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{1}{sas_address};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
					name1 => "sas_port_0_port_status", value1 => $sas_port_0_port_status, 
					name2 => "sas_port_0_link_speed",  value2 => $sas_port_0_link_speed, 
					name3 => "sas_port_0_sas_address", value3 => $sas_port_0_sas_address, 
					name4 => "sas_port_1_port_status", value4 => $sas_port_1_port_status, 
					name5 => "sas_port_1_link_speed",  value5 => $sas_port_1_link_speed, 
					name6 => "sas_port_1_sas_address", value6 => $sas_port_1_sas_address, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sas_port_0_port_status} = $sas_port_0_port_status;
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sas_port_0_link_speed}  = $sas_port_0_link_speed;
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sas_port_0_sas_address} = $sas_port_0_sas_address;
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sas_port_1_port_status} = $sas_port_1_port_status;
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sas_port_1_link_speed}  = $sas_port_1_link_speed;
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sas_port_1_sas_address} = $sas_port_1_sas_address;
				next;
			}
		}
		# We stop processing a give drive when we see 'Inquiry Data'.
		if ($line =~ /^Inquiry Data =/)
		{
			# Process and variables that need their size calculated from sectors to bytes.
			# These are always variables.
			foreach my $variable (sort {$a cmp $b} @{$sector_variables})
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable}, 
				}, file => $THIS_FILE, line => __LINE__});
				next if not $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable};

				my $value = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($value =~ /^(\d+) bytes, (\d+) sectors/)
				{
					my $size    = $1;
					my $sectors = $2;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
						name1 => "size",        value1 => $size, 
						name2 => "sectors",     value2 => $sectors, 
						name3 => "sector_size", value3 => $sector_size, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($sector_size)
					{
						$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable} = ($sectors * $sector_size);
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable}, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					else
					{
						$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable} = $size;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$variable}, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
			
			# Record the drive as being on this controller.
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{on_controller} = $serial_number;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::on_controller", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{on_controller}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$virtual_disk     = 9999;
			$drive_group      = 9999;
			$enclosure_id     = "";
			$slot_number      = "";
			$in_drive_header  = 0;
			$in_port_status   = 0;
			$start_break      = 0;
			$sector_size      = 0;
			$sector_variables = [];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "virtual_disk",    value1 => $virtual_disk, 
				name2 => "drive_group",     value2 => $drive_group, 
				name3 => "enclosure_id",    value3 => $enclosure_id, 
				name4 => "slot_number",     value4 => $slot_number, 
				name5 => "in_drive_header", value5 => $in_drive_header, 
				name6 => "in_port_status",  value6 => $in_port_status, 
				name7 => "start_break",     value7 => $start_break, 
				name8 => "sector_size",     value8 => $sector_size, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		next if not $enclosure_id;
		
		# If I am in the drive header, look for this drive's "Drive Group".
		if (($in_drive_header) && ($line =~ /^$enclosure_id:$slot_number\s+\d+\s+.*?\s+(.*?)\s+/))
		{
			$drive_group = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "drive_group", value1 => $drive_group, 
				name2 => "line",        value2 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($drive_group eq "-")
			{
				$drive_group = 9999 ;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "drive_group", value1 => $drive_group, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Find the virtual disk this drive is connected to, if any.
			foreach my $this_virtual_disk (sort {$a cmp $b} keys %{$an->data->{virtual_disk}})
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${this_virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_size", value1 => $an->data->{virtual_disk}{$this_virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_size}, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($an->data->{virtual_disk}{$this_virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_size})
				{
					# Found it.
					$virtual_disk = $this_virtual_disk;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "virtual_disk", value1 => $virtual_disk, 
					}, file => $THIS_FILE, line => __LINE__});
					last;
				}
			}
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# If I am in the port status, parse the port info.
		if (($in_port_status) && ($line =~ /^(\d+)\s+(.*?)\s+(\d.*?)Gb\/s\s+(0x.*)$/))
		{
			my $sas_port    = $1;
			my $port_status = $2;
			my $link_speed  = $3." Gbps";
			my $sas_address = $4;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "sas_port",    value1 => $sas_port, 
				name2 => "port_status", value2 => $port_status, 
				name3 => "link_speed",  value3 => $link_speed, 
				name4 => "sas_address", value4 => $sas_address, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{$sas_port}{port_status} = $port_status;
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{$sas_port}{link_speed}  = $link_speed;
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{$sas_port}{sas_address} = $sas_address;
			# These are so flipping long that we print them as three separate log entries so that
			# they're easier to read in the logs.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::sas_port::${sas_port}::port_status", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{$sas_port}{port_status}, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::sas_port::${sas_port}::link_speed",  value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{$sas_port}{link_speed}, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::sas_port::${sas_port}::sas_address", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{sas_port}{$sas_port}{sas_address}, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		### If I have a 'variable = value' pair split and parse.
		# The 'Drive position' isn't set for drives not in an array/drive group.
		if ($line =~ /^Drive position = DriveGroup:(\d+), Span:(\d+), Row:(\d+)/i)
		{
			my $this_drive_group = $1;
			my $span             = $2;
			my $row              = $3;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "this_drive_group", value1 => $this_drive_group, 
				name2 => "span",             value2 => $span, 
				name3 => "row",              value3 => $row, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# I don't pick up this until well into the scan, but the drive group should match 
			# what we found earlier. Just to be safe though, if not, throw a warning.
			if ($this_drive_group ne $drive_group)
			{
				# Report this error 
				$an->Log->entry({log_level => 0, title_key => "tools_title_0002", message_key => "scan_storcli_warning_0001", message_variables => { 
					adapter         => $adapter,
					serial_number   => $serial_number, 
					virtual_disk    => $virtual_disk, 
					enclosure_id    => $enclosure_id, 
					slot_number     => $slot_number, 
					span            => $span, 
					row             => $row, 
					old_drive_group => $drive_group,
					new_drive_group => $this_drive_group,
					shell_call      => $shell_call,
				}, file => $THIS_FILE, line => __LINE__});
				$drive_group = $this_drive_group;
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "drive_group", value1 => $drive_group, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{span} = $span;
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{row}  = $row;
			
			# These are so flipping long that we print them as three separate log entries so that
			# they're easier to read in the logs.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::span", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{span}, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::row", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{row}, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# Split and process all 'variable = value' lines we've not already handled.
		if ($line =~ /^(.*?)\s+=\s+(.*)$/)
		{
			my $variable = $1;
			my $value    = $2;
			my $type     = "variable";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "variable", value1 => $variable, 
				name2 => "value",    value2 => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Process some variable names.
			if ($variable =~ /^SN$/i)
			{
				$variable = "Serial Number";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ /^WWN$/i)
			{
				$variable = "World Wide Name";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ /^PI /i)
			{
				$variable =~ s/^PI /Protection Information /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ / Id$/i)
			{
				$variable =~ s/ Id$/ Identification/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ /^Sector Size$/i)
			{
				# Convert to bytes and record.
				$value       = $an->Readable->hr_to_bytes({base2 => 1, size => $value})." Bytes";
				$sector_size = $value;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "value",       value1 => $value, 
					name2 => "sector_size", value2 => $sector_size, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ / EKM/i)
			{
				# De-TLA it
				$variable =~ s/ EKM/ External Key Management/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ /S\.M\.A\.R\.T\./i)
			{
				$variable =~ s/S\.M\.A\.R\.T\./SMART/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($variable =~ /S\.M\.A\.R\.T/i)
			{
				$variable =~ s/S\.M\.A\.R\.T/SMART/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Process some values.
			if ($value =~ /^(\d.*?B) \[(0x.*?) Sectors\]/)
			{
				my $size        = $1;
				my $hex_sectors = $2;
				my $sectors     = hex $hex_sectors;
				my $bytes       = $an->Readable->hr_to_bytes({base2 => 1, size => $size});
				   $value       = "$bytes bytes, $sectors sectors";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
					name1 => "size",        value1 => $size, 
					name2 => "bytes",       value2 => $bytes, 
					name3 => "hex_sectors", value3 => $hex_sectors, 
					name4 => "value",       value4 => $value, 
					name5 => "variable",    value5 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Mark this for sector size calculation later.
				push @{$sector_variables}, $variable;
			}
			if (($value =~ /^(\d+\s*[A-Za-z]+B)$/i) or ($value =~ /^(\d+\.\d+\s*[A-Za-z]+B)$/i))
			{
				my $size  = $1;
				    $value = $an->Readable->hr_to_bytes({base2 => 1, size => $size})." Bytes";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "size",  value1 => $size, 
					name2 => "value", value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^(\d.*?)C \(\d.*? F\)/i)
			{
				$value = $1;
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "value", value1 => $value, 
					name2 => "type",  value2 => $type, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if (($value =~ /^(\d+)C$/i) or ($value =~ /^(\d+\.\d+)C$/i))
			{
				$value = $1;
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "value", value1 => $value, 
					name2 => "type",  value2 => $type, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if (($value =~ /^(\d+)F$/i) or ($value =~ /^(\d+\.\d+)F$/i))
			{
				$value = $an->Convert->convert_to_celsius({temperature => $1});
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "value", value1 => $value, 
					name2 => "type",  value2 => $type, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^(\d.*?)Gb\/s$/)
			{
				$value = $1." Gbps";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value eq "NA")
			{
				$value = "N/A";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Process/standardize the variable.
			$variable =  lc($variable);
			$variable =~ s/ /_/g;
			$variable =~ s/&/and/g;
			$variable =~ s/\//_or_/g;
			$variable =~ s/_%/_percent/g;
			$variable =~ s/{_}+/_/g;
			
			# Record
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{$type}{$variable} = $value;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::${type}::$variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{$type}{$variable}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	return(0);
}

# This looks for virtual disks on the controller.
sub get_virtual_disk_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_virtual_disk_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $virtual_disk = "";
	my $in_overview  = 0;
	my $in_pd_list   = 0;
	my $in_vd_data   = 0;
	my $start_break  = 0;
	my $shell_call   = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{virtual_disk_data};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /\/c$adapter\/v(\d+):/)
		{
			$virtual_disk                                                     = $1;
			$an->data->{virtual_disk}{$virtual_disk}{variable}{on_controller} = $serial_number;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk::${virtual_disk}::variable::on_controller", value1 => $an->data->{virtual_disk}{$virtual_disk}{variable}{on_controller}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# We set the VD '9999' to the same SN so that we can find unallocated disks later.
			if (not $an->data->{virtual_disk}{9999}{variable}{on_controller})
			{
				$an->data->{virtual_disk}{9999}{variable}{on_controller} = $serial_number;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::9999::variable::on_controller", value1 => $an->data->{virtual_disk}{9999}{variable}{on_controller}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		if ($line =~ /PDs for VD (\d+) :/)
		{
			$virtual_disk = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($line =~ /VD(\d+) Properties/)
		{
			$virtual_disk = $1;
			$in_vd_data   = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "virtual_disk", value1 => $virtual_disk, 
				name2 => "in_vd_data",   value2 => $in_vd_data, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		next if $virtual_disk eq "";
		
		# See if I am entering or exiting the overview chunk.
		if ($line =~ /^DG\/VD/)
		{
			$in_overview = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_overview", value1 => $in_overview, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if (($line =~ /^--------/) && ($in_overview))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$in_overview = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_overview", value1 => $in_overview, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		if ($in_overview)
		{
			process_vg_overview_data($an, $line, $serial_number);
		}
		
		# See if I am entering or exiting the physical drive chunk.
		if ($line =~ /^EID:Slt/)
		{
			$in_pd_list = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_pd_list", value1 => $in_pd_list, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		if (($line =~ /^--------/) && ($in_pd_list))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$in_pd_list  = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_pd_list", value1 => $in_pd_list, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		if ($in_pd_list)
		{
			process_vg_pd_list_data($an, $line, $virtual_disk, $serial_number);
		}
		
		if ($in_vd_data)
		{
			if ($line =~ /^(.*?) = (.*)$/)
			{
				my $variable = $1;
				my $value    = $2;
				my $type     = "variable";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Convert some formatting.
				if (($value =~ /^(\d+\s*[A-Za-z]+B)$/i) or ($value =~ /^(\d+\.\d+\s*[A-Za-z]+B)$/i))
				{
					# Convert to bytes
					$value = $an->Readable->hr_to_bytes({base2 => 1, size => $value})." Bytes";
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($value =~ /^(\d\d)-(\d\d)-(\d\d\d\d)$/)
				{
					# Convert dd-mm-yyyy to yyyy/mm/dd
					$value = $3."/".$2."/".$1;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($value =~ /^(\d\d):(\d\d):(\d\d) (\wM)$/)
				{
					# Convert AM/PM -> 24h
					my $hour   = $1;
					my $minute = $2;
					my $second = $3;
					my $suffix = $4;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
						name1 => "hour",   value1 => $hour, 
						name2 => "minute", value2 => $minute, 
						name3 => "second", value3 => $second, 
						name4 => "suffix", value4 => $suffix, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($suffix eq "PM")
					{
						$hour += 12;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "hour", value1 => $hour, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					$value = "$hour:$minute:$second";
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				# Record
				$variable =  lc($variable);
				$variable =~ s/ /_/g;
				$variable =~ s/&/and/g;
				$variable =~ s/\// or /g;
				$variable =~ s/_%/_percent/g;
				$variable =~ s/{_}+/_/g;
				$an->data->{virtual_disk}{$virtual_disk}{$type}{$variable} = $value;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::${type}::$variable", value1 => $an->data->{virtual_disk}{$virtual_disk}{$type}{$variable}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	close $file_handle;
	
	return(0);
}

# This parses a virtual disk's physical disk overview line
sub process_vg_pd_list_data
{
	my ($an, $line, $virtual_disk, $serial_number) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_vg_pd_list_data", }, message_key => "an_variables_0003", message_variables => { 
		name1 => "line",          value1 => $line, 
		name1 => "virtual_disk",  value1 => $virtual_disk, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### Sector size is either '512B' or '4 KB'
	#               EID:Slt       DID     State   DG      Size       Intf  Med     SED     PI      SeSz     Model      Sp
	#               252:0         9       Onln    0       136.218 GB SAS   HDD     N       N       512B     MK1401GRRB U
	if ($line =~ /^(\d+):(\d+)\s+(\d+)\s+(.*?)\s+(.*?)\s+(.*?B)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?B)\s+(.*?)\s+(.*)$/)
	{
		my $enclosure_id          = $1;
		my $slot_number           = $2;
		my $device_id             = $3;
		my $state                 = $4;
		my $drive_group           = $5;
		my $drive_size            = $6;
		my $interface             = $7;
		my $drive_media           = $8;
		my $self_encrypting_drive = $9;
		my $protection_info       = $10;
		my $sector_size           = $11;
		my $drive_model           = $12;
		my $spun_up               = $13;
		#   $slot_number           = sprintf("%02d", $slot_number);
		   $drive_group           = 9999 if $drive_group eq "-";
		   $protection_info       = $protection_info       =~ /n/i ? "No" : "Yes";
		   $self_encrypting_drive = $self_encrypting_drive =~ /n/i ? "No" : "Yes";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0013", message_variables => {
			name1  => "enclosure_id",          value1  => $enclosure_id, 
			name2  => "slot_number",           value2  => $slot_number, 
			name3  => "device_id",             value3  => $device_id, 
			name4  => "state",                 value4  => $state, 
			name5  => "drive_group",           value5  => $drive_group, 
			name6  => "drive_size",            value6  => $drive_size, 
			name7  => "interface",             value7  => $interface, 
			name8  => "drive_media",           value8  => $drive_media, 
			name9  => "self_encrypting_drive", value9  => $self_encrypting_drive, 
			name10 => "protection_info",       value10 => $protection_info, 
			name11 => "sector_size",           value11 => $sector_size, 
			name12 => "drive_model",           value12 => $drive_model, 
			name13 => "spun_up",               value13 => $spun_up, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Convert the sector and drive sizes into bytes. The controller uses 'xB' but uses base2 values.
		$sector_size = $an->Readable->hr_to_bytes({base2 => 1, size => $sector_size})." Bytes";
		$drive_size  = $an->Readable->hr_to_bytes({base2 => 1, size => $drive_size})." Bytes";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "sector_size", value1 => $sector_size, 
			name2 => "drive_size",  value2 => $drive_size, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### Long hashes are long... x_x
		# Store the data (we'll convert it in a minute.
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{device_id}             = $device_id;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{'state'}               = $state;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_size}            = $drive_size;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{interface}             = $interface;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_media}           = $drive_media;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{self_encrypting_drive} = $self_encrypting_drive;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{protection_info}       = $protection_info;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sector_size}           = $sector_size;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_model}           = $drive_model;
		$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{spun_up}               = $spun_up;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
			name1  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::device_id",             value1  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{device_id}, 
			name2  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::state",                 value2  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{'state'}, 
			name3  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_size",            value3  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_size}, 
			name4  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::interface",             value4  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{interface}, 
			name5  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_media",           value5  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_media}, 
			name6  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::self_encrypting_drive", value6  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{self_encrypting_drive}, 
			name7  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::protection_info",       value7  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{protection_info}, 
			name8  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::sector_size",           value8  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{sector_size}, 
			name9  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::drive_model",           value9  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{drive_model}, 
			name10 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::spun_up",               value10 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{spun_up}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### WARNING: The strings we set here will be parsed later, so don't change them without also 
		###          changing where they're checked for elsewhere in this agent.
		### NOTE: We don't use a function for this because the glossary for the block of data is 
		###       specific for the table above (it would appear).
		# Translate the weird short form to useable strings
		foreach my $key (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}})
		{
			my $value = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => ">> virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($value =~ /^DHS$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Dedicated Hot Spare";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UGood$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unconfigured Good";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^GHS$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Global Hotspare";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UBad$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unconfigured Bad";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^Onln$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Online";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^Offln$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Offline";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^U$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Spun Up";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^D$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Spun Down";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^T$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Transition";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^F$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Foreign";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UGUnsp$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unsupported";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^UGShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Unconfigured shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^HSPShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Hotspare shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^CFShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Configured shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^Cpybck$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Copyback";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^CBShld$/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key} = "Copyback Shielded";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::enclosure_id::${enclosure_id}::slot_number::${slot_number}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{enclosure_id}{$enclosure_id}{slot_number}{$slot_number}{variable}{$key}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	else
	{
		# Unparsed line
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "? line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This parses a virtual disk overview line
sub process_vg_overview_data
{
	my ($an, $line, $serial_number) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_vg_overview_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "line",          value1 => $line, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $drive_group                 = "";
	my $virtual_disk                = "";
	my $raid_type                   = "";
	my $array_state                 = "";
	my $access                      = "";
	my $consistent                  = "";
	my $cache                       = "";
	my $cachecade                   = "";
	my $scheduled_consistency_check = "";
	my $array_size                  = "";
	my $name                        = "";
	# Get the line when there is no name
	#	        0   / 0      RAID5   Optl    RW      Yes     NRWBD   -       OFF     953.531 GB
	if ($line =~ /^(\d+)\/(\d+)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*? \wB)$/i)
	{
		$drive_group                 = $1;
		$virtual_disk                = $2;
		$raid_type                   = $3;
		$array_state                 = $4;
		$access                      = $5;
		$consistent                  = $6;
		$cache                       = $7;
		$cachecade                   = $8;
		$scheduled_consistency_check = $9;
		$array_size                  = $10;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
			name1  => "drive_group",                 value1  => $drive_group, 
			name2  => "virtual_disk",                value2  => $virtual_disk, 
			name3  => "raid_type",                   value3  => $raid_type, 
			name4  => "array_state",                 value4  => $array_state, 
			name5  => "access",                      value5  => $access, 
			name6  => "consistent",                  value6  => $consistent, 
			name7  => "cache",                       value7  => $cache, 
			name8  => "cachecade",                   value8  => $cachecade, 
			name9  => "scheduled_consistency_check", value9  => $scheduled_consistency_check, 
			name10 => "array_size",                  value10 => $array_size, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	# Get the line when there is a name
	elsif ($line =~ /^(d+)\/(d+)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*?)\s+(.*? \wB)\s+(.*)$/)
	{
		$drive_group                 = $1;
		$virtual_disk                = $2;
		$raid_type                   = $3;
		$array_state                 = $4;
		$access                      = $5;
		$consistent                  = $6;
		$cache                       = $7;
		$cachecade                   = $8;
		$scheduled_consistency_check = $9;
		$array_size                  = $10;
		$name                        = $11;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0011", message_variables => {
			name1  => "drive_group",                 value1  => $drive_group, 
			name2  => "virtual_disk",                value2  => $virtual_disk, 
			name3  => "raid_type",                   value3  => $raid_type, 
			name4  => "array_state",                 value4  => $array_state, 
			name5  => "access",                      value5  => $access, 
			name6  => "consistent",                  value6  => $consistent, 
			name7  => "cache",                       value7  => $cache, 
			name8  => "cachecade",                   value8  => $cachecade, 
			name9  => "scheduled_consistency_check", value9  => $scheduled_consistency_check, 
			name10 => "array_size",                  value10 => $array_size, 
			name11 => "name",                        value11 => $name, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Unmatched line...
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "? line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		next;
	}
	
	# Convert the array size into bytes. The controller uses 'xB' but uses base2 values.
	$array_size = $an->Readable->hr_to_bytes({base2 => 1, size => $array_size})." Bytes";
	
	# Store the data.
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{on_controller}               = $serial_number;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{raid_type}                   = $raid_type;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_state}                 = $array_state;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{access}                      = $access;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{consistent}                  = $consistent;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cache}                       = $cache;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cachecade}                   = $cachecade;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{scheduled_consistency_check} = $scheduled_consistency_check;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_size}                  = $array_size;
	$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{name}                        = $name;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
		name1  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::on_controller",               value1  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{on_controller}, 
		name2  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::raid_type",                   value2  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{raid_type}, 
		name3  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::array_state",                 value3  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_state}, 
		name4  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::access",                      value4  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{access}, 
		name5  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::consistent",                  value5  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{consistent}, 
		name6  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::cache",                       value6  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cache}, 
		name7  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::cachecade",                   value7  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{cachecade}, 
		name8  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::scheduled_consistency_check", value8  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{scheduled_consistency_check}, 
		name9  => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::array_size",                  value9  => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{array_size}, 
		name10 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::name",                        value10 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{name}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### WARNING: The strings we set here will be parsed later, so don't change them without also changing
	###          where they're checked for elsewhere in this agent.
	### NOTE: We don't use a function for this because the glossary for the block of data is specific for
	###       the table above (it would appear).
	# Translate the weird short form to useable strings
	foreach my $key (sort {$a cmp $b} keys %{$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => ">> virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} eq "-")
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "No";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Cac$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "CacheCade";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Rec$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Recovery";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^OfLn$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "OffLine";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Pdgd$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Partially Degraded";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^dgrd$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Degraded";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Optl$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Optimal";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^RO$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Read Only";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^RW$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Read Write";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^HD$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Hidden";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^TRANS$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Transport Ready";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^B$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Blocked";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^Consist$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Consistent";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} =~ /^sCC$/i)
		{
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key} = "Scheduled Check Consistency";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::$key", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Because they hate programmers, the cache is a combination of a few of the 
		# above strings.
		if ($key eq "cache")
		{
			my $cache = $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{$key};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cache", value1 => $cache, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Prep some blanks
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache}  = "";
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "";
			$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache}  = "";
			
			# Read cache
			if ($cache =~ /NR/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache} = "No Read-Ahead";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::read_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /R/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache} = "Always Read-Ahead";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::read_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{read_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Write cache
			if ($cache =~ /AWB/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "Always Write-Back";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::write_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /WB/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "Write-Back";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::write_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /WT/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache} = "Write-Through";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::write_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{write_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Disk cache
			if ($cache =~ /C/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache} = "Cached IO";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::disk_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($cache =~ /D/i)
			{
				$an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache} = "Direct IO";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "virtual_disk::${virtual_disk}::drive_group::${drive_group}::variable::disk_cache", value1 => $an->data->{virtual_disk}{$virtual_disk}{drive_group}{$drive_group}{variable}{disk_cache}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	return(0);
}

# This looks for a BBU and, if it finds one, parses the output for it.
sub get_bbu_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_bbu_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $bbu_serial_number = "";
	my $bbu_data          = [];
	my $shell_call        = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{bbu_data};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		last if $line =~ /$adapter Failed /i;
		
		if ($line =~ /^Serial Number\s+(\S.*)?/i)
		{
			$bbu_serial_number = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "bbu_serial_number", value1 => $bbu_serial_number, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		push @{$bbu_data}, $line;
	}
	close $file_handle;
	
	# If I didn't find a serial number, then I probably don't have an FBU.
	return(0) if not $bbu_serial_number;
	
	# Record the controller the bbu is on.
	$an->data->{bbu}{serial_number}{$bbu_serial_number}{host_controller_serial_number} = $serial_number;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "bbu::serial_number::${bbu_serial_number}::host_controller_serial_number", value1 => $an->data->{bbu}{serial_number}{$bbu_serial_number}{host_controller_serial_number},
	}, file => $THIS_FILE, line => __LINE__});
	
	# Still alive? Good, time to parse the most annoying output ever... >_<
	my $split_point = 0;
	my $start_break = 0;
	my $end_break   = 0;
	foreach my $line (@{$bbu_data})
	{
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Property(\s+)Value/)
		{
			$split_point = length($1) + 8;
			$start_break = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "split_point", value1 => $split_point, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# See if I am entering or exiting a data chunk.
		if (($line =~ /^--------/) && ($split_point))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$split_point = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "split_point", value1 => $split_point, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		
		# If I have a split point, break the string.
		if ($split_point)
		{
			# Elegant? I think not!
			my $variable = "";
			my $value    = "";
			my $type     = "variable";
			if ($split_point >= length($line))
			{
				# Variable with no value
				$variable =  $line;
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				($variable, $value) = ($line =~ /^(.{$split_point})(.*)$/);
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Because LSI is either evil or amazingly incompetent, we have the variable
				# "Absolute State of charge" listed twice, but once with 'State' and the 
				# other with 'state' (capital versus small 'S'). We fix it because it's the
				# same data and we don't want two records, so the second copy will now just
				# overwrite the first one.
				if ($variable eq "Absolute State of charge")
				{
					$variable = "Absolute state of charge";
				}
				
				# They use 'Temperature' twice; once for the temperature and once to show if
				# it is OK or not. We'll avoid one clobbering the other by renaming the 
				# status one.
				if (($variable eq "Temperature") && ($value !~ /\d/))
				{
					$variable = "Temperature Status";
				}
			}
			
			# Is this a temperature or something else we want to pre-process?
			if ($value =~ /^(\d+) C$/i)
			{
				# Yup
				$value = $1;
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d+) F$/i)
			{
				# Yup, but translate
				$value = $an->Convert->convert_to_celsius({temperature => $1});
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /\d+d \((\d+) seconds\)$/i)
			{
				# This is a static time span (like the time between learn cycles.
				$value =  $1;
				$value .= " seconds";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d\d\d)\/(\d\d)\/(\d\d)\s+(\d\d:\d\d:\d\d)\s+\(\d+ seconds\)$/i)
			{
				### NOTE: The 'X seconds' seems to not change and be a useless number...
				# This is a specific time in the future, properly formatted
				$value = "$1/$2/$3, $4";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d)\/(\d\d)\/(\d\d\d\d)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				$value = $3."/".$2."/".$1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d+) hour\(s\)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				$value =  $1 * 3600;
				$value .= " seconds";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Record
			$variable =  lc($variable);
			$variable =~ s/ /_/g;
			$variable =~ s/&/and/g;
			$variable =~ s/\// or /g;
			$variable =~ s/_%/_percent/g;
			$variable =~ s/{_}+/_/g;
			
			# 'Auto-Learn' and 'Auto_Learn' are both used because screw consistency, right?
			$variable =~ s/auto-learn/auto_learn/;
			
			$an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}{$variable} = $value;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bbu:serial_number::${bbu_serial_number}::${type}::$variable", value1 => $an->data->{bbu}{serial_number}{$bbu_serial_number}{$type}{$variable},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This looks for a cachevault (flash-backup unit) and, if one is found, parses the output.
sub get_cachevault_data
{
	my ($an, $adapter, $serial_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_cachevault_data", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "adapter",       value1 => $adapter, 
		name2 => "serial_number", value2 => $serial_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $cachevault_serial_number = "";
	my $cachevault_data          = [];
	my $shell_call               = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{cachevault_data};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		last if $line =~ /Cachevault doesn't exist/i;
		
		if ($line =~ /^Serial Number\s+(\S.*)?/i)
		{
			$cachevault_serial_number = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "cachevault_serial_number", value1 => $cachevault_serial_number, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		push @{$cachevault_data}, $line;
	}
	close $file_handle;
	
	# If I didn't find a serial number, then I probably don't have an FBU.
	return(0) if not $cachevault_serial_number;
	
	# Record the controller the cachevault is on.
	$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{host_controller_serial_number} = $serial_number;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "cachevault::serial_number::${cachevault_serial_number}::host_controller_serial_number", value1 => $an->data->{cachevault}{serial_number}{$cachevault_serial_number}{host_controller_serial_number},
	}, file => $THIS_FILE, line => __LINE__});
	
	# Still alive? Good, time to parse the most annoying output ever... >_<
	my $split_point = 0;
	my $start_break = 0;
	my $end_break   = 0;
	foreach my $line (@{$cachevault_data})
	{
		next if not $line;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /Property(\s+)Value/)
		{
			$split_point = length($1) + 8;
			$start_break = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "split_point", value1 => $split_point, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# See if I am entering or exiting a data chunk.
		if (($line =~ /^--------/) && ($split_point))
		{
			if (not $start_break)
			{
				# Split point set, must be the start break
				$start_break = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "start_break", value1 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
			else
			{
				# Split point and start break set, must be end break.
				$split_point = 0;
				$start_break = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "split_point", value1 => $split_point, 
					name2 => "start_break", value2 => $start_break, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		
		# If I have a split point, break the string.
		if ($split_point)
		{
			my $variable = "";
			my $value    = "";
			my $type     = "variable";
			if ($split_point >= length($line))
			{
				# Variable with no value
				$variable =  $line;
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				($variable, $value) = ($line =~ /^(.{$split_point})(.*)$/);
				$variable =~ s/\s+$//;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Is this a temperature or something else we want to pre-process?
			if ($value =~ /^(\d+) C$/i)
			{
				# Yup
				$value = $1;
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d+) F$/i)
			{
				# Yup, but translate
				$value = $an->Convert->convert_to_celsius({temperature => $1});
				$type  = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /\d+d \((\d+) seconds\)$/i)
			{
				# This is a static time span (like the time between learn cycles.
				$value =  $1;
				$value .= " seconds";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d\d\d)\/(\d\d)\/(\d\d)\s+(\d\d:\d\d:\d\d)\s+\(\d+ seconds\)$/i)
			{
				### NOTE: The 'X seconds' seems to not change and be a useless number...
				# This is a specific time in the future, properly formatted
				# yyyy/mm/dd -> 
				$value = "$1/$2/$3, $4";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d\d)\/(\d\d)\/(\d\d\d\d)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				$value = $3."/".$2."/".$1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($value =~ /^(\d+) hour\(s\)$/i)
			{
				# 'Murica! mm/dd/yyyy -> yyyy/mm/dd
				$value =  $1 * 3600;
				$value .= " seconds";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable,
					name2 => "value",    value2 => $value,
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Record
			$variable =  lc($variable);
			$variable =~ s/ /_/g;
			$variable =~ s/&/and/g;
			$variable =~ s/\// or /g;
			$variable =~ s/_%/_percent/g;
			$variable =~ s/{_}+/_/g;
			
			# 'Auto-Learn' and 'Auto_Learn' are both used because screw consistency, right?
			$variable =~ s/auto-learn/auto_learn/;
			
			$an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type}{$variable} = $value;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cachevault:serial_number::${cachevault_serial_number}::${type}::$variable", value1 => $an->data->{cachevault}{serial_number}{$cachevault_serial_number}{$type}{$variable}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This gets the basic information about the controller.
sub get_controller_info
{
	my ($an, $adapter) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_controller_info", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "adapter", value1 => $adapter, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $in_raid_level_supported = 0;
	my $multiline_value         = "";
	my $in_header           = 1;
	my $in_basics           = 0;
	my $in_supported_ops    = 0;
	my $in_supported_pd_ops = 0;
	my $in_supported_vd_ops = 0;
	my $in_hardware_config  = 0;
	my $in_capabilities     = 0;
	my $in_policies         = 0;
	my $in_defaults         = 0;
	my $serial_number       = "";
	my $controller_data     = [];
	my $shell_call          = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{controller_info};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		next if not $line;
		last if $line =~ /^TOPOLOGY:$/i;
		
		# RAID Level Supported can be multi-line because $reasons.
		if ($line eq /RAID Level Supported = (.*)$/)
		{
			$multiline_value         = $1;
			$in_raid_level_supported = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "multiline_value",         value1 => $multiline_value, 
				name2 => "in_raid_level_supported", value2 => $in_raid_level_supported, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($in_raid_level_supported)
		{
			if ($line =~ / = /)
			{
				# Found the next line, close up RAID Level Supported.
				push @{$controller_data}, "RAID Level Supported = $multiline_value";
				$multiline_value         = "";
				$in_raid_level_supported = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "multiline_value",         value1 => $multiline_value, 
					name2 => "in_raid_level_supported", value2 => $in_raid_level_supported, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				$multiline_value .= " $line";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "multiline_value", value1 => $multiline_value, 
				}, file => $THIS_FILE, line => __LINE__});
				next;
			}
		}
		
		if ($line =~ /^Serial Number = (.*)?/i)
		{
			$serial_number = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "serial_number", value1 => $serial_number, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		### LSI reuses the save variable names in different sections. This tries to catch and rename 
		### them
		# Ignore stuff in the header
		if ($line =~ /^Basics/)
		{
			$in_header = 0;
			$in_basics = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "in_header", value1 => $in_header, 
				name2 => "in_basics", value2 => $in_basics, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($in_basics)
		{
			if ($line =~ /^Version/)
			{
				$in_basics = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "in_basics", value1 => $in_basics, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($line =~ /^Controller\s+=/)
		{
			# This is the header data, which we don't care about.
			next;
		}
		if ($in_header)
		{
			next;
		}
		
		# Mangle supported adapter operation variables.
		if ($line =~ /^Supported Adapter Operations/)
		{
			$in_supported_ops = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_supported_ops", value1 => $in_supported_ops, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($in_supported_ops)
		{
			if ($line =~ /^Supported PD Operations/)
			{
				$in_supported_ops    = 0;
				$in_supported_pd_ops = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_supported_ops",    value1 => $in_supported_ops, 
					name2 => "in_supported_pd_ops", value2 => $in_supported_pd_ops, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			if ($line =~ /^BBU /)
			{
				$line =~ s/^BBU /BBU Supported /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Rebuild Rate /)
			{
				$line =~ s/^Rebuild Rate /Configurable Rebuild Rate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^CC Rate /)
			{
				$line =~ s/^CC Rate /Configurable Consistency Check Rate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^BGI Rate /)
			{
				$line =~ s/^BGI Rate /Configurable background Initialization Rate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Reconstruct Rate /)
			{
				$line =~ s/^Reconstruct Rate /Configurable Reconstruct Rate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Patrol Read Rate /)
			{
				$line =~ s/^Patrol Read Rate /Configurable Patrol Read Rate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Alarm Control /)
			{
				$line =~ s/^Alarm Control /Configurable Alarm Control /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Spanning /)
			{
				$line =~ s/^Spanning /Spanning Supported /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /Hot Spare /)
			{
				$line =~ s/Hot Spare /Hot Spare Supported /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Foreign Config Import /)
			{
				$line =~ s/^Foreign Config Import /Foreign Config Import Supported /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Self Diagnostic /)
			{
				$line =~ s/^Self Diagnostic /Self Diagnostic Supported /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Abort CC on Error /)
			{
				$line =~ s/^Abort CC on Error /Configurable Abort CC on Error /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Block SSD Write Disk Cache Change /)
			{
				$line =~ s/^Block SSD Write Disk Cache Change /Configurable Block SSD Write Disk Cache Change /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Mangle supported adapter physical disk operation variables.
		if ($in_supported_pd_ops)
		{
			if ($line =~ /^Supported VD Operations/)
			{
				$in_supported_pd_ops = 0;
				$in_supported_vd_ops = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_supported_pd_ops", value1 => $in_supported_pd_ops, 
					name2 => "in_supported_vd_ops", value2 => $in_supported_vd_ops, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Deny Locate /)
			{
				$line =~ s/^Deny Locate /Deny Physical Disk Locate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Read Policy /)
			{
				$line =~ s/^Read Policy /Physical Disk Read Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Write Policy /)
			{
				$line =~ s/^Write Policy /Physical Disk Write Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Mangle supported adapter virtual disk operation variables.
		if ($in_supported_vd_ops)
		{
			if ($line =~ /^Advanced Software Option/)
			{
				$in_supported_vd_ops = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "in_supported_vd_ops", value1 => $in_supported_vd_ops, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Deny Locate /)
			{
				$line =~ s/^Deny Locate /Deny Virtual Disk Locate /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Read Policy /)
			{
				$line =~ s/^Read Policy /Virtual Disk Read Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Write Policy /)
			{
				$line =~ s/^Write Policy /Virtual Disk Write Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Mangle hardware config variables.
		if ($line =~ /^HwCfg/)
		{
			$in_hardware_config = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_hardware_config", value1 => $in_hardware_config, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($in_hardware_config)
		{
			if ($line =~ /^Policies/)
			{
				$in_hardware_config  = 0;
				$in_policies         = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_hardware_config", value1 => $in_hardware_config, 
					name2 => "in_policies",        value2 => $in_policies, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^BBU /)
			{
				$line =~ s/^BBU /BBU Connected /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Mangle policy variables.
		if ($in_policies)
		{
			if ($line =~ /^Boot/)
			{
				$in_policies = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "in_policies", value1 => $in_policies, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Disable Online Controller Reset /)
			{
				$line =~ s/^Disable Online Controller Reset /Disable Online Controller Reset Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Expose Enclosure Devices /)
			{
				$line =~ s/^Expose Enclosure Devices /Expose Enclosure Devices Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Maintain PD Fail History /)
			{
				$line =~ s/^Maintain PD Fail History /Maintain PD Fail History Policy /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Mangle defaults variables
		if ($line =~ /^Defaults/)
		{
			$in_defaults = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "in_defaults", value1 => $in_defaults, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($in_defaults)
		{
			if ($line =~ /^Capabilities/)
			{
				$in_defaults     = 0;
				$in_capabilities = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "in_defaults",     value1 => $in_defaults, 
					name2 => "in_capabilities", value2 => $in_capabilities, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Disable Online Controller Reset /)
			{
				$line =~ s/^Disable Online Controller Reset /Disable Online Controller Reset Default /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Expose Enclosure Devices /)
			{
				$line =~ s/^Expose Enclosure Devices /Expose Enclosure Devices Default /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Maintain PD Fail History /)
			{
				$line =~ s/^Maintain PD Fail History /Maintain PD Fail History Default /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Mangle capability variables.
		if ($in_capabilities)
		{
			if ($line =~ /^Scheduled Tasks/)
			{
				$in_capabilities = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "in_capabilities", value1 => $in_capabilities, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($line =~ /^Boot Volume Supported /)
			{
				$line =~ s/^Boot Volume Supported /Boot Volume Capable /;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "<< line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# T10-PI (T10 working group, Protection Information) has three levels (Taken from the Seagate
		# PDF listed below):
		# Type 0 - Describes a drive that is not formatted with PI information bytes. This allows 
		#          for legacy support in non-PI systems.
		# Type 1 - Provides support of PI protection using 10- and 16-byte commands. The RDPROTECT
		#          and WRTPROTECT bits allow for checking control through the CDB. Eight bytes of
		#          Protection Information are transmitted at sector boundaries across the interface 
		#          if RDPROTECT and WRTPROTECT bits are non-zero values. Type I does not allow the 
		#          use of 32-byte commands.
		# Type 2 - Provides checking control and additional expected fields within the 32-byte CDBs. 
		#          Eight bytes of Protection Information are transmitted at sector boundaries across 
		#          the interface if RDPROTECT and WRTPROTECT bits are non-zero values. Type II does 
		#          allow the use of 10- and 16-byte commands with zero values in the RDPROTECT and 
		#          WRTPROTECT fields. The drive will generate a dummy (for example, 0xFFFF) eight 
		#          bytes of Protection Information in the media, but these eight bytes will not be 
		#          transferred to the host during read.
		# Type 3 - ? (GUARD tag, reference tag and app tag are combined)
		#          - http://www.snia.org/sites/default/education/tutorials/2008/fall/storage/RichardVanderbilt_Why_Data_Integrity_rev2.pdf
		#          Protection is enabled and the 32-byte commands are not valid. The Reference Tag is
		#          not defined and may be used as an extension of the Application Tag. The drive will
		#          not check the Reference Tag. 
		#          - https://www.hgst.com/sites/default/files/resources/End-to-end_Data_Protection.pdf
		#          Type 3 does not define the ref tag.
		#          - http://lxr.free-electrons.com/source/block/t10-pi.c
		#          
		
		# LSI loves to randomly sticking things together...
		$line =~ s/BatteryFRU/Battery FRU/;
		$line =~ s/ChipRevision/Chip Revision/;
		$line =~ s/DisableHII/Disable HII/;
		$line =~ s/EnableCrashDump/Enable Crash-Dump/;
		$line =~ s/EnableLDBBM/Enable LDBBM/;
		
		### NOTE: ROC is RAID on Chip, which is what they call their controller's ASIC
		# and they love their weird short forms
		$line =~ s/Ctrl/Controller/i;
		$line =~ s/Mfg/Manufacture/i;
		$line =~ s/Cfg/Config/i;
		$line =~ s/Perf /Performance /i;
		$line =~ s/Ext /External /i;
		$line =~ s/ VD/ Virtual Disk/i;
		$line =~ s/ VDs/ Virtual Disks/i;
		$line =~ s/VD /Virtual Disk /i;
		$line =~ s/ PD/ Physical Disk/i;
		$line =~ s/ PI/ Protection Information/i;
		$line =~ s/ LDPI/ Logical Disk Protection Information/i;	# https://www.seagate.com/files/staticfiles/docs/pdf/whitepaper/safeguarding-data-from-corruption-technology-paper-tp621us.pdf
		$line =~ s/ CC/ Consistency Check/i;
		$line =~ s/ BGI/ Background Initialization/i;
		$line =~ s/ BGI/ Background/i;
		$line =~ s/ LD/ Logical Device/i;
		$line =~ s/ FW/ Firmware/i;
		$line =~ s/ HII/ Human Interface Infrastructure/i;
		$line =~ s/ PFK/ Premium Feature Key/i;
		$line =~ s/ WB/ Write-Back/i;
		$line =~ s/SSC /Security Subsystem Class /i;		# https://en.wikipedia.org/wiki/Opal_Storage_Specification
		$line =~ s/ SMP/ Serial Management Protocol/i;		# https://en.wikipedia.org/wiki/Serial_Attached_SCSI#Characteristics
		$line =~ s/ STP/ Serial ATA Tunneling Protocol/i;	# https://en.wikipedia.org/wiki/Serial_Attached_SCSI#Characteristics
		$line =~ s/Phys /Physical Layers /i;			# 12Gps MegaRAID SAS Software User Guide, March 14, 2016, 4.14.8, https://en.wikipedia.org/wiki/PHY_(chip)
		$line =~ s/Phy /Physical Layer /i;			# 12Gps MegaRAID SAS Software User Guide, March 14, 2016, 4.14.8, https://en.wikipedia.org/wiki/PHY_(chip)
		$line =~ s/ OCE/ Online Capacity Expansion/i;		# 12Gps MegaRAID SAS Software User Guide, March 14, 2016, 5.5.14 -> 5
		$line =~ s/ RLM/ RAID Level Migration/i;		# 12Gps MegaRAID SAS Software User Guide, March 14, 2016, 5.5.14 -> 5
		$line =~ s/ EKM/ External Key Management/i;
		$line =~ s/ BBM/ Bad Block Management/i;
		$line =~ s/ QD/ Queue Depth/i;
		$line =~ s/NCQ/Native Command Queuing/i;		# https://en.wikipedia.org/wiki/Native_Command_Queuing
		$line =~ s/ LDBBM/ Logical Disk Bad Block Management/i;
		$line =~ s/TPM/Trusted Platform Module/i;		# https://en.wikipedia.org/wiki/Trusted_Platform_Module
		$line =~ s/\(hrs\)/\(Hours\)/i;
		$line =~ s/ hrs/ Hours/i;
		$line =~ s/ZCR /Zero-Channel RAID/i;
		$line =~ s/R1E /RAID 1E/i;
		$line =~ s/R10/RAID 10/i;
		$line =~ s/RAID(\d+)/RAID $1/gi;
		$line =~ s/TTY /Terminal /i;
		$line =~ s/CME /Continuous Media Error/i;
		$line =~ s/SGE /Scatter-Gather Element/i;		# https://en.wikipedia.org/wiki/Vectored_I/O
		
		# Standardize some random strings with the same meaning
		$line =~ s/Id /ID /;
		$line =~ s/ NA/ N\/A/;
		$line =~ s/Bios/BIOS/;
		$line =~ s/S\.M\.A\.R\.T\./SMART/i;
		$line =~ s/S\.M\.A\.R\.T/SMART/i;
		
		# And randomly using sentances...
		$line =~ s/A rollback operation is in progress/Roll-back operation in progress/i;
		$line =~ s/must be rebooted to complete security operation/Reboot Required for Security Operation/i;
		$line =~ s/Maximum number of direct attached drives to spin up in 1 min/direct attached drives spun-up per minute/i;
		
		# And things that break variables when they change
		$line =~ s/\(Default\)//;
		$line =~ s/Sesmonitoring/SCSI Enclusure Service Monitoring/i;		# https://en.wikipedia.org/wiki/SES-2_Enclosure_Management
		$line =~ s/SecurityonJBOD/Security on JBOD/i;
		$line =~ s/ForceFlash/Force Flash/i;
		$line =~ s/DisableImmediateIO/Disable Immediate IO/i;
		$line =~ s/LargeIOSupport/Large IO Support/i;
		$line =~ s/DrvActivityLEDSetting/Drive Activity LED Setting/i;
		$line =~ s/FlushWriteVerify/Flush Write Verify/i;
		$line =~ s/CPLDUpdate/Complex Programmable Logic Device Update/i;	# https://en.wikipedia.org/wiki/Complex_programmable_logic_device
		$line =~ s/ForceTo512e/Force to 512e/i;					# 512-byte sector size emulation
		$line =~ s/discardCacheDuringLDDelete/Discard Cache During Logical Disk Delete/;
		$line =~ s/Breakmirror/Break Mirror/i;					# 12Gps MegaRAID SAS Software User Guide, March 14, 2016, 4.14.16
		$line =~ s/Cachebypass/Cache Bypass/i;
		$line =~ s/PolaritySplit/Polarity Split/i;
		$line =~ s/EnableCrashDump/Enable Crash Dump/i;
		$line =~ s/PowerSave/Power Save/i;
		
		push @{$controller_data}, $line;
	}
	close $file_handle;
	
	# If I didn't find a serial number, something went wrong.
	if (not $serial_number)
	{
		# Error out.
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scan_storcli_error_0006", message_variables => { adapter => $adapter }, code => 6, file => "$THIS_FILE", line => __LINE__});
		exit(6);
	}
	
	# Get the current alarm state.
	$shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{alarm_state};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^Alarm\s+(.*)$/i)
		{
			my $state = $1;
			   $line  = "Alarm State = $state";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$controller_data}, $line;
		}
	}
	close $file_handle;
	
	# Get the rebuild rate
	$shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{rebuild_rate};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^Rebuildrate\s+(\d+)%$/i)
		{
			my $rate = $1;
			   $line = "Rebuild Rate % = $rate";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$controller_data}, $line;
		}
	}
	close $file_handle;
	
	# Get the background initialization rate
	$shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{bgi_rate};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^BGI Rate\s+(\d+)%$/i)
		{
			my $rate = $1;
			   $line = "Background Initialization Rate % = $rate";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$controller_data}, $line;
		}
	}
	close $file_handle;
	
	# Get the consistency check rate
	$shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{cc_rate};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^CC Rate\s+(\d+)%$/i)
		{
			my $rate = $1;
			   $line = "Consistency Check Rate % = $rate";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$controller_data}, $line;
		}
	}
	close $file_handle;
	
	# Get the patrol read rate
	$shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{pr_rate};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^Patrol Read Rate\s+(\d+)%$/i)
		{
			my $rate = $1;
			   $line = "Patrol Read Rate % = $rate";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$controller_data}, $line;
		}
	}
	close $file_handle;
	
	# Get the performance mode
	$shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{performance_mode};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^Perf Mode\s+(.*)$/i)
		{
			my $mode = $1;
			   $line = "Performance Mode = $mode";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "<< line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$controller_data}, $line;
		}
	}
	close $file_handle;
	
	# If we're alive, we're ready to proceed.
	foreach my $line (@{$controller_data})
	{
		my $type = "variable";
		if ($line =~ /^(.*?)\s+=\s+(.*)$/)
		{
			my $variable = $1;
			my $value    = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "variable", value1 => $variable, 
				name2 => "value",    value2 => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If the variable has units, pull them out.
			if ($variable =~ /\((\w+B)\)$/i)
			{
				my $units    =  $1;
				   $variable =~ s/\($units\)//i;
				   $variable =~ s/^\s+//;
				   $variable =~ s/\s+$//;
				my $size = $an->Readable->hr_to_bytes({size => $value, type => $units, base2 => 1 })." Bytes";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
					name3 => "units",    value3 => $units, 
					name4 => "size",     value4 => $size, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($variable =~ /\(Degree Celsius\)/i)
			{
				$variable =~ s/\(Degree Celsius\)//i;
				$variable =~ s/^\s+//;
				$variable =~ s/\s+$//;
				$type     = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
					name3 => "type",     value3 => $type, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($variable =~ /\(Degree Fahrenheit\)/i)
			{
				# Covert to °C
				$variable =~ s/\(Degree Fahrenheit\)//i;
				$variable =~ s/^\s+//;
				$variable =~ s/\s+$//;
				$value    =  $an->Convert->convert_to_celsius({temperature => $value});
				$type     = "temperature";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
					name3 => "type",     value3 => $type, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Convert some values.
			if ($value =~ /(\d\d)\/(\d\d)\/(\d\d\d\d), (\d\d:\d\d:\d\d)/)
			{
				# mm/dd/yyyy -> yyyy/mm/dd
				$value = "$3/$1/$2, $4";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /(\d+) hrs/)
			{
				$value = "$1 Hours";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /\(hrs\)/)
			{
				$value =~ s/\(hrs\)/\(Hours\)/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if (($value =~ /^(\d+\s*[A-Za-z]+B)$/i) or ($value =~ /^(\d+\.\d+\s*[A-Za-z]+B)$/i))
			{
				my $size  = $1;
				   $value = $an->Readable->hr_to_bytes({base2 => 1, size => $size});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "size",  value1 => $size, 
					name2 => "value", value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^00\/00\/00$/i)
			{
				$value = "N/A";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			if ($value =~ /^AWB$/i)
			{
				$value = "Always Write-Back";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^WB$/i)
			{
				$value = "Write-Back";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($value =~ /^WT$/i)
			{
				$value = "Write-Through";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Store it
			if (exists $an->data->{controller}{serial_number}{$serial_number}{$type}{$variable})
			{
				# Conflict! This is a dirty way to keep them separate
				$variable .= " 2";
			}
			$variable =  lc($variable);
			$variable =~ s/ /_/g;
			$variable =~ s/&/and/g;
			$variable =~ s/\// or /g;
			$variable =~ s/_%/_percent/g;
			$variable =~ s/{_}+/_/g;
			$an->data->{controller}{serial_number}{$serial_number}{$type}{$variable} = $value;
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "serial_number", value1 => $serial_number,
	}, file => $THIS_FILE, line => __LINE__});
	return($serial_number);
}

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
sub find_lsi_controllers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "find_lsi_controllers", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will keep track of how many controllers we find.
	my $adapter_count = 0;
	
	# First, do we have storcli64 installed?
	if (not -e $an->data->{path}{storcli64})
	{
		print $an->String->get({key => "scan_storcli_error_0001", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0001", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 1);
	}
	
	# Make sure it is executable
	if (not -x $an->data->{path}{storcli64})
	{
		print $an->String->get({key => "scan_storcli_error_0002", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0002", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 2);
	}
	
	# Still alive? Good! Look for controllers now.
	my $shell_call = $an->data->{path}{storcli64}." ".$an->data->{sys}{arguments}{adapter_count};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Controller Count = (\d+)/i)
		{
			$adapter_count = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "adapter_count", value1 => $adapter_count
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# Have we any adapters?
	if ($adapter_count > 0)
	{
		$an->data->{sys}{adapter_count} = $adapter_count;
		$an->Log->entry({log_level => 2, message_key => "scan_storcli_log_0001", message_variables => {
			count => $an->data->{sys}{adapter_count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		print $an->String->get({key => "scan_storcli_error_0003", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0003", message_variables => { path => $an->data->{path}{storcli64} }, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 3);
	}
	
	return(0);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_storcli_message_0002"})."\n";

	return(0);
}
