#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# ScanCore Scan Agent for LSI-based RAID controllers using the 'storcli64' command line tool.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - storcli64 not installed
# 2   - storcli64 is installed but it is not executable.
# 3   - No LSI-based controllers found.
# 4   - Got data from the wrong controller.
# 5   - Unexpecte status when querying adapter
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# ToDo:
# - Check the cache policy and reset it to 'writeback' if the BBU/FBU is healthy and the cache changes to 
#   write-through.
# 

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
#use Socket;
#use utf8;
#binmode STDOUT, 'encoding(utf8)';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-storcli'		=>	{
			language		=>	"en_CA",
			log_level		=>	1,
			log_language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_db_transactions	=>	0,
		},
		section			=>	{
			controller			=>	{
				in_header			=>	1,
				in_basics			=>	0,
				in_version			=>	0,
				in_bus				=>	0,
				in_pending_images_in_flash	=>	0,
				in_status			=>	0,
				in_supported_adapter_operations	=>	0,
				in_supported_pd_operations	=>	0,
				in_supported_vd_operations	=>	0,
				in_advanced_software_option	=>	0,
				in_hardware_config		=>	0,
				in_policies			=>	0,
				in_policies_table		=>	0,
				in_boot				=>	0,
				in_high_availability		=>	0,
				in_defaults			=>	0,
				in_capabilities			=>	0,
				in_scheduled_tasks		=>	0,
				in_topology			=>	0,
				in_virtual_disk_list		=>	0,
				in_physical_disk_list		=>	0,
				in_cachevault_info		=>	0,
			},
		},
		sys			=>	{
			sql			=>	[],
			arguments		=>	{
				adapter_count		=>	"show ctrlcount",
				# BBU battery or FBU capacitor bank info.
				bbu_data		=>	"/bbu show all",
				cachevault_data		=>	"/cv show all",
				controller_info		=>	"show all", 
				physical_disk_data	=>	"/eall /sall show all",
				virtual_disk_data	=>	"/vall show all",
			},
			adapter_count		=>	0,
			adapter			=>	{},
		},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-storcli'}{language});
$an->default_log_language($an->data->{'scan-storcli'}{log_language});
$an->default_log_file    ($an->data->{'scan-storcli'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-storcli'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-storcli'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();

# Adjust the log level if requested.
adjust_log_level($an);

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "notice_message_0013", message_variables => {
	connections	=>	$connections,
}, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { 
		uuid => $an->data->{sys}{host_uuid},
	}, code => 255, file => "$THIS_FILE", line => __LINE__});
}

print $an->String->get({key => "scan_storcli_message_0001"})."\n";

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
find_lsi_controllers($an);

# If we're still alive, start gathering data.
gather_data($an);

exit(0);


# Clean up and go away.
nice_exit($an);

#############################################################################################################
# Function below                                                                                            #
#############################################################################################################

# Change to a user-requested log level.
sub adjust_log_level
{
	my ($an) = @_;
	if ($an->data->{switches}{v})
	{
		$an->data->{'scan-storcli'}{log_level} = 1;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	elsif ($an->data->{switches}{vv})
	{
		$an->data->{'scan-storcli'}{log_level} = 2;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	elsif ($an->data->{switches}{vvv})
	{
		$an->data->{'scan-storcli'}{log_level} = 3;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	elsif ($an->data->{switches}{vvvv})
	{
		$an->data->{'scan-storcli'}{log_level} = 4;
		$an->Log->level($an->data->{'scan-storcli'}{log_level});
	}
	return(0);
}

# This gathers the various data from the controller(s).
sub gather_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "gather_data", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: This assumes the controllers go 0, 1, ... n. If this is wrong, we'll need to call 
	###       'storcli64 show all' and parse 'System Overview'.
	# Loops through reach found controller.
	foreach my $controller (1..$an->data->{sys}{adapter_count})
	{
		# We drop the number by 1 because the '/cX' starts at '0' where the controller count starts 
		# at '1'.
		my $adapter = ($controller - 1);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "controller", value1 => $controller, 
			name2 => "adapter",    value2 => $adapter, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Read in basic and version data.
		get_controller_info($an, $adapter);
		
		die "$THIS_FILE ".__LINE__."; testing\n";
	}
	
	return(0);
}

# This gets the basic information about the controller.
sub get_controller_info
{
	my ($an, $adapter) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "parse_supported_adapter_operations", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "adapter", value1 => $adapter, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $an->data->{path}{storcli64}." /c".$adapter." ".$an->data->{sys}{arguments}{controller_info};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
			$line =~ s/\r//;
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+:/:/;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		last if $line =~ /^TOPOLOGY:$/i;
		
		if ($line =~ /^(.*?) = (.*)$/)
		{
			my $variable = $1;
			my $value    = $2;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "variable", value1 => $variable, 
				name2 => "value",    value2 => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($variable =~ /^Model$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{model} = $value;
			}
			elsif ($variable =~ /^Serial Number$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{serial_number} = $value;
			}
			elsif ($variable =~ /^Revision N/i)
			{
				$an->data->{adapter}{$adapter}{controller}{revision_number} = $value;
			}
			elsif ($variable =~ /^Firmware Package Build$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{firmware_package_number} = $value;
			}
			elsif ($variable =~ /^Firmware Version$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{firmware_version} = $value;
			}
			elsif ($variable =~ /^Controller Status$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{status} = $value;
			}
			elsif ($variable =~ /^Memory Correctable Errors$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{memory_correctable_errors} = $value;
			}
			elsif ($variable =~ /^Memory Uncorrectable Errors$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{memory_uncorrectable_errors} = $value;
			}
			elsif ($variable =~ /booted into safe mode/i)
			{
				$an->data->{adapter}{$adapter}{controller}{booted_into_safe_mode} = $value;
			}
			elsif ($variable =~ /^On Board Memory Size$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{cache_size} = $value;
			}
			elsif ($variable =~ /^Size of CacheCade \((\w+B)\)$/i)
			{
				my $units = $1;
				$an->data->{adapter}{$adapter}{controller}{cachecade_size} = $value." ".$units;
			}
			elsif ($variable =~ /^$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{} = $value;
			}
			elsif ($variable =~ /^$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{} = $value;
			}
			elsif ($variable =~ /^$/i)
			{
				$an->data->{adapter}{$adapter}{controller}{} = $value;
			}
			else
			{
				# Catch-all
			}
		}
=pod
Current Size of CacheCade (GB) = 0
Current Size of FW Cache (MB) = 821
ROC temperature(Degree Celsius) = 63		<-- 

Policies :
========

Flush Time(Default) = 4s
Auto Rebuild = On
Battery Warning = On
Restore HotSpare on Insertion = Off
Expose Enclosure Devices = On
Maintain PD Fail History = On
Reorder Host Requests = On
Load Balance Mode = Auto
Security Key Assigned = On
Use drive activity for locate = Off

Boot :
====
Stop BIOS on Error = Off
Enable Ctrl-R = Yes
Enable Web BIOS = No
Enable PreBoot CLI = No
Enable BIOS = Yes
Allow Boot with Preserved Cache = Off

Scheduled Tasks :
===============
Consistency Check Reoccurrence = 168 hrs
Next Consistency check launch = 11/21/2015, 03:00:00
Patrol Read Reoccurrence = 168 hrs
Next Patrol Read launch = 11/21/2015, 03:00:00
Battery learn Reoccurrence = 672 hrs
Next Battery Learn = 11/18/2015, 18:00:00
=cut
	}
	close $file_handle;
	
	return(0);
}

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
sub find_lsi_controllers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "find_lsi_controllers", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will keep track of how many controllers we find.
	my $adapter_count = 0;
	
	# First, do we have storcli64 installed?
	if (not -e $an->data->{path}{storcli64})
	{
		print $an->String->get({key => "scan_storcli_error_0001", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0001", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 1);
	}
	
	# Make sure it is executable
	if (not -x $an->data->{path}{storcli64})
	{
		print $an->String->get({key => "scan_storcli_error_0002", variables => { path => $an->data->{path}{storcli64} }})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0002", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 2);
	}
	
	# Still alive? Good! Look for controllers now.
	my $shell_call = $an->data->{path}{storcli64}." ".$an->data->{sys}{arguments}{adapter_count};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Controller Count = (\d+)/i)
		{
			$adapter_count = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "adapter_count", value1 => $adapter_count
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# Have we any adapters?
	if ($adapter_count > 0)
	{
		$an->data->{sys}{adapter_count} = $adapter_count;
		$an->Log->entry({log_level => 2, message_key => "scan_storcli_log_0001", message_variables => {
			count => $an->data->{sys}{adapter_count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		print $an->String->get({
			key		=>	"scan_storcli_error_0003",
			variables	=>	{
				path		=>	$an->data->{path}{storcli64},
			},
		})."\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0003", message_variables => {
			path	=>	$an->data->{path}{storcli64},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 3);
	}
	
	return(0);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_storcli_message_0002"})."\n";

	return(0);
}
