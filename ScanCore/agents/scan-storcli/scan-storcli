#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# ScanCore Scan Agent for LSI-based RAID controllers using the 'storcli64' command line tool.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - storcli64 not installed
# 2  - storcli64 is installed but it is not executable.
# 3  - No LSI-based controllers found.
# 

exit(0);

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
use Socket;
#use utf8;
#binmode STDOUT, 'encoding(utf8)';

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			host_uuid		=>	"/etc/striker/host.uuid",
			ipmitool		=>	"/usr/bin/ipmitool",
			log_file		=>	"/var/log/striker.log",
			storcli			=>	"/sbin/storcli64",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		# This is used so that the user can set the language in on
		# striker.conf variable.
		scancore		=>	{
			language		=>	"en_CA",
			log_level			=>	2,
			log_language			=>	"en_CA",
		},
		section			=>	{
			controller			=>	{
				in_header			=>	1,
				in_basics			=>	0,
				in_version			=>	0,
				in_bus				=>	0,
				in_pending_images_in_flash	=>	0,
				in_status			=>	0,
				in_supported_adapter_operations	=>	0,
				in_supported_pd_operations	=>	0,
				in_supported_vd_operations	=>	0,
				in_advanced_software_option	=>	0,
				in_hardware_config		=>	0,
				in_policies			=>	0,
				in_policies_table		=>	0,
				in_boot				=>	0,
				in_high_availability		=>	0,
				in_defaults			=>	0,
				in_capabilities			=>	0,
				in_scheduled_tasks		=>	0,
				in_topology			=>	0,
				in_virtual_disk_list		=>	0,
				in_physical_disk_list		=>	0,
				in_cachevault_info		=>	0,
			},
		},
		sys			=>	{
			sql			=>	[],
			arguments		=>	{
				adapter_count		=>	"show ctrlcount",
				# BBU battery or FBU capacitor bank info.
				cache_backup		=>	"",
				controller_info		=>	"show all", # /cX before it.
				physical_disks		=>	"",
				virtual_disks		=>	"",
			},
		},
	},
});

# Set some defaults
$an->default_language    ($an->data->{scancore}{language});
$an->default_log_language($an->data->{scancore}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});

# Read my stuff
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set the log level.
$an->Log->level($an->data->{scancore}{log_level});

# Read in the language strings.
$an->String->read_words({file => $an->data->{path}{strings}});
$an->String->read_words({file => $an->data->{path}{core_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for
# help.
get_switches($an);
print $an->String->get({key => "scan_storcli_message_0001"}), "\n";

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
find_lsi_controllers($an);

# If we're still alive, start gathering data.
gather_data($an);


# Clean up and go away.
nice_exit($an);

#############################################################################################################
# Function below                                                                                            #
#############################################################################################################

# This sets the active section to '1' when a storcli header is passed in.
sub set_active_section
{
	my ($an, $type, $line) = @_;
	
	# These variables are used to track which section is being parsed.
	if ($type eq "adapter")
	{
		$an->data->{$type}{in_header}                       = 0;
		$an->data->{$type}{in_basics}                       = 0;
		$an->data->{$type}{in_version}                      = 0;
		$an->data->{$type}{in_bus}                          = 0;
		$an->data->{$type}{in_pending_images_in_flash}      = 0;
		$an->data->{$type}{in_status}                       = 0;
		$an->data->{$type}{in_supported_adapter_operations} = 0;
		$an->data->{$type}{in_supported_pd_operations}      = 0;
		$an->data->{$type}{in_supported_vd_operations}      = 0;
		$an->data->{$type}{in_advanced_software_option}     = 0;
		$an->data->{$type}{in_hardware_config}              = 0;
		$an->data->{$type}{in_policies}                     = 0;
		$an->data->{$type}{in_policies_table}               = 0;
		$an->data->{$type}{in_boot}                         = 0;
		$an->data->{$type}{in_high_availability}            = 0;
		$an->data->{$type}{in_defaults}                     = 0;
		$an->data->{$type}{in_capabilities}                 = 0;
		$an->data->{$type}{in_scheduled_tasks}              = 0;
		$an->data->{$type}{in_topology}                     = 0;
		$an->data->{$type}{in_virtual_disk_list}            = 0;
		$an->data->{$type}{in_physical_disk_list}           = 0;
		$an->data->{$type}{in_cachevault_info}              = 0;
		
		if ($line =~ /^Basics:$/i)
		{
			$an->data->{$type}{in_basics} = 1;
		}
		elsif ($line =~ /^Version:$/i)
		{
			$an->data->{$type}{in_version} = 1;
		}
		elsif ($line =~ /^Bus:$/i)
		{
			$an->data->{$type}{in_bus} = 1;
		}
		elsif ($line =~ /^Pending Images in Flash:$/i)
		{
			$an->data->{$type}{in_pending_images_in_flash} = 1;
		}
		elsif ($line =~ /^Status:$/i)
		{
			$an->data->{$type}{in_status} = 1;
		}
		elsif ($line =~ /^Supported Adapter Operations:$/i)
		{
			$an->data->{$type}{in_supported_adapter_operations} = 1;
		}
		elsif ($line =~ /^Supported PD Operations:$/i)
		{
			$an->data->{$type}{in_supported_pd_operations} = 1;
		}
		elsif ($line =~ /^Supported VD Operations:$/i)
		{
			$an->data->{$type}{in_supported_vd_operations} = 1;
		}
		elsif ($line =~ /^Advanced Software Option:$/i)
		{
			$an->data->{$type}{in_advanced_software_option} = 1;
		}
		elsif ($line =~ /^HwCfg:$/i)
		{
			$an->data->{$type}{in_hardware_config} = 1;
		}
		elsif ($line =~ /^Policies:$/i)
		{
			$an->data->{$type}{in_policies} = 1;
		}
		elsif ($line =~ /^Policies Table:$/i)
		{
			$an->data->{$type}{in_policies_table} = 1;
		}
		elsif ($line =~ /^Boot:$/i)
		{
			$an->data->{$type}{in_boot} = 1;
		}
		elsif ($line =~ /^High Availability:$/i)
		{
			$an->data->{$type}{in_high_availability} = 1;
		}
		elsif ($line =~ /^Defaults:$/i)
		{
			$an->data->{$type}{in_defaults} = 1;
		}
		elsif ($line =~ /^Capabilities:$/i)
		{
			$an->data->{$type}{in_capabilities} = 1;
		}
		elsif ($line =~ /^Scheduled Tasks:$/i)
		{
			$an->data->{$type}{in_scheduled_tasks} = 1;
		}
		elsif ($line =~ /^TOPOLOGY:$/i)
		{
			$an->data->{$type}{in_topology} = 1;
		}
		elsif ($line =~ /^VD LIST:$/i)
		{
			$an->data->{$type}{in_virtual_disk_list} = 1;
		}
		elsif ($line =~ /^PD LIST:$/i)
		{
			$an->data->{$type}{in_physical_disk_list} = 1;
		}
		elsif ($line =~ /^Cachevault_Info:$/i)
		{
			$an->data->{$type}{in_cachevault_info} = 1;
		}
	}
	
	return(0);
}

# This gathers the various data from the controller(s).
sub gather_data
{
	my ($an) = @_;
	
	# Read in information about the adapter(s);
	my $type       = "adapter";
	my $adapter    = "";
	my $port_type  = "";
	my $shell_call = $an->data->{path}{storcli}." /cAll ".$an->data->{sys}{arguments}{controller_info}." 2>&1 |";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		   $line =~ s/\s+:/:/;
		if (not $line)
		{
			$port_type = "";
			next;
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line ~= /:$/)
		{
			set_active_section($an, $type, $line);
		}
		
		if ($an->data->{$type}{in_header})
		{
		}
		elsif ($an->data->{$type}{in_basics})
		{
		}
		elsif ($an->data->{$type}{in_version}                      = 0;
		elsif ($an->data->{$type}{in_bus}                          = 0;
		elsif ($an->data->{$type}{in_pending_images_in_flash}      = 0;
		elsif ($an->data->{$type}{in_status}                       = 0;
		elsif ($an->data->{$type}{in_supported_adapter_operations} = 0;
		elsif ($an->data->{$type}{in_supported_pd_operations}      = 0;
		elsif ($an->data->{$type}{in_supported_vd_operations}      = 0;
		elsif ($an->data->{$type}{in_advanced_software_option}     = 0;
		elsif ($an->data->{$type}{in_hardware_config}              = 0;
		elsif ($an->data->{$type}{in_policies}                     = 0;
		elsif ($an->data->{$type}{in_policies_table}               = 0;
		elsif ($an->data->{$type}{in_boot}                         = 0;
		elsif ($an->data->{$type}{in_high_availability}            = 0;
		elsif ($an->data->{$type}{in_defaults}                     = 0;
		elsif ($an->data->{$type}{in_capabilities}                 = 0;
		elsif ($an->data->{$type}{in_scheduled_tasks}              = 0;
		elsif ($an->data->{$type}{in_topology}                     = 0;
		elsif ($an->data->{$type}{in_virtual_disk_list}            = 0;
		elsif ($an->data->{$type}{in_physical_disk_list}           = 0;
		elsif ($an->data->{$type}{in_cachevault_info}              = 0;
=pod
Basics :
Version :
Bus :
Pending Images in Flash :
Status :
======
Controller Status = Optimal
Memory Correctable Errors = 0
Memory Uncorrectable Errors = 0
ECC Bucket Count = 0
Any Offline VD Cache Preserved = No
BBU Status = 0
Support PD Firmware Download = No
Lock Key Assigned = Yes
Failed to get lock key on bootup = No
Lock key has not been backed up = No
Bios was not detected during boot = No
Controller must be rebooted to complete security operation = No
A rollback operation is in progress = No
At least one PFK exists in NVRAM = No
SSC Policy is WB = No
Controller has booted into safe mode = No


Supported Adapter Operations :
============================
Rebuild Rate = Yes
CC Rate = Yes
BGI Rate  = Yes
Reconstruct Rate = Yes
Patrol Read Rate = Yes
Alarm Control = Yes
Cluster Support = No
BBU  = Yes
Spanning = Yes
Dedicated Hot Spare = Yes
Revertible Hot Spares = Yes
Foreign Config Import = Yes
Self Diagnostic = Yes
Allow Mixed Redundancy on Array = No
Global Hot Spares = Yes
Deny SCSI Passthrough = No
Deny SMP Passthrough = No
Deny STP Passthrough = No
Support more than 8 Phys = Yes
FW and Event Time in GMT = No
Support Enhanced Foreign Import = Yes
Support Enclosure Enumeration = Yes
Support Allowed Operations = Yes
Abort CC on Error = Yes
Support Multipath = Yes
Support Odd & Even Drive count in RAID1E = No
Support Security = Yes
Support Config Page Model = Yes
Support the OCE without adding drives = Yes
Support EKM = Yes
Snapshot Enabled = No
Support PFK = Yes
Support PI = Yes
Support LDPI Type1 = No
Support LDPI Type2 = No
Support LDPI Type3 = No
Support Ld BBM Info = No
Support Shield State = Yes
Block SSD Write Disk Cache Change = Yes
Support Suspend Resume BG ops = Yes
Support Emergency Spares = Yes
Support Set Link Speed = Yes
Support Boot Time PFK Change = No
Support JBOD = Yes
Disable Online PFK Change = No
Support Perf Tuning = Yes
Support SSD PatrolRead = Yes
Real Time Scheduler = Yes
Support Reset Now = Yes
Support Emulated Drives = Yes
Headless Mode = Yes
Dedicated HotSpares Limited = No
Point In Time Progress = Yes
Extended LD = No


Supported PD Operations :
=======================
Force Online = Yes
Force Offline = Yes
Force Rebuild = Yes
Deny Force Failed = No
Deny Force Good/Bad = No
Deny Missing Replace = No
Deny Clear = No
Deny Locate = No
Support Power State = Yes
Set Power State For Cfg = No
Support T10 Power State = No
Support Temperature = Yes
NCQ = No


Supported VD Operations :
=======================
Read Policy = Yes
Write Policy = Yes
IO Policy = Yes
Access Policy = Yes
Disk Cache Policy = Yes
Reconstruction = Yes
Deny Locate = No
Deny CC = No
Allow Ctrl Encryption = No
Enable LDBBM = Yes
Support FastPath = Yes
Performance Metrics = Yes
Power Savings = No
Support Powersave Max With Cache = No
Support Breakmirror = Yes
Support SSC WriteBack = No
Support SSC Association = Yes
Support VD Hide = No
Support VD HOQRebuid = No


Advanced Software Option :
========================

------------------------------------------------------
Adv S/W Opt         Time Remaining  Mode              
------------------------------------------------------
MegaRAID FastPath   Unlimited      Factory Installed  
MegaRAID SafeStore  Unlimited       Secured           
MegaRAID RAID6      Unlimited       Factory Installed 
MegaRAID RAID5      Unlimited       Factory Installed 
------------------------------------------------------

Safe ID =  9X9EEK139UJVVRLFC5QB838VMNJAPKJRMC3QB8AZ

HwCfg :
=====
ChipRevision =  C0
BatteryFRU = N/A
Front End Port Count = 0
Backend Port Count = 8
BBU = Present
Alarm = On
Serial Debugger = Present
NVRAM Size = 32KB
Flash Size = 16MB
On Board Memory Size = 1024MB
On Board Expander = Absent
Temperature Sensor for ROC = Present
Temperature Sensor for Controller = Absent
Current Size of CacheCade (GB) = 0
Current Size of FW Cache (MB) = 834
ROC temperature(Degree Celsius) = 64


Policies :
========

Policies Table :
==============

------------------------------------------------
Policy                          Current Default 
------------------------------------------------
Predictive Fail Poll Interval   300 sec         
Interrupt Throttle Active Count 16              
Interrupt Throttle Completion   50 us           
Rebuild Rate                    30 %    30%     
PR Rate                         30 %    30%     
BGI Rate                        30 %    30%     
Check Consistency Rate          30 %    30%     
Reconstruction Rate             30 %    30%     
Cache Flush Interval            4s              
------------------------------------------------

Flush Time(Default) = 4s
Drive Coercion Mode = none
Auto Rebuild = On
Battery Warning = On
ECC Bucket Size = 15
ECC Bucket Leak Rate (hrs) = 24
Restore HotSpare on Insertion = Off
Expose Enclosure Devices = On
Maintain PD Fail History = On
Reorder Host Requests = On
Auto detect BackPlane = SGPIO/i2c SEP
Load Balance Mode = Auto
Security Key Assigned = On
Disable Online Controller Reset = Off
Use drive activity for locate = Off


Boot :
====
BIOS Enumerate VDs = 1
Stop BIOS on Error = Off
Delay during POST = 0
Spin Down Mode = None
Enable Ctrl-R = Yes
Enable Web BIOS = No
Enable PreBoot CLI = No
Enable BIOS = Yes
Max Drives to Spinup at One Time = 2
Maximum number of direct attached drives to spin up in 1 min = 10
Delay Among Spinup Groups (sec) = 12
Allow Boot with Preserved Cache = Off


High Availability :
=================
Topology Type = None
Cluster Permitted = No
Cluster Active = No


Defaults :
========
Phy Polarity = 0
Phy PolaritySplit = 0
Strip Size = 256kB
Write Policy = WB
Read Policy = RA
Cache When BBU Bad = Off
Cached IO = Off
VD PowerSave Policy = Controller Defined
Default spin down time (mins) = 30
Coercion Mode = None
ZCR Config = Unknown
Max Chained Enclosures = 16
Direct PD Mapping = No
Restore Hot Spare on Insertion = No
Expose Enclosure Devices = Yes
Maintain PD Fail History = Yes
Zero Based Enclosure Enumeration = No
Disable Puncturing = No
EnableLDBBM = Yes
Un-Certified Hard Disk Drives = Allow
SMART Mode = Mode 6
Enable LED Header = No
LED Show Drive Activity = Yes
Dirty LED Shows Drive Activity = No
EnableCrashDump = No
Disable Online Controller Reset = No
Treat Single span R1E as R10 = No
Power Saving option = Enabled
TTY Log In Flash = No
Auto Enhanced Import = Yes
BreakMirror RAID Support = Yes
Disable Join Mirror = Yes
Enable Shield State = Yes
Time taken to detect CME = 60 sec


Capabilities :
============
Supported Drives = SAS, SATA
Boot Volume Supported = NO
RAID Level Supported = RAID0, RAID1, RAID5, RAID6, RAID00, RAID10, RAID50, 
RAID60, PRL 11, PRL 11 with spanning, SRL 3 supported, 
PRL11-RLQ0 DDF layout with no span, PRL11-RLQ0 DDF layout with span
Enable JBOD = No
Mix in Enclosure = Allowed
Mix of SAS/SATA of HDD type in VD = Allowed
Mix of SAS/SATA of SSD type in VD = Allowed
Mix of SSD/HDD in VD = Allowed
SAS Disable = No
Max Arms Per VD = 32
Max Spans Per VD = 8
Max Arrays = 128
Max VD per array = 16
Max Number of VDs = 64
Max Parallel Commands = 928
Max SGE Count = 60
Max Data Transfer Size = 8192 sectors
Max Strips PerIO = 42
Max Configurable CacheCade Size = 0
Min Strip Size = 64 KB
Max Strip Size = 1.0 MB


Scheduled Tasks :
===============
Consistency Check Reoccurrence = 168 hrs
Next Consistency check launch = 10/03/2015, 03:00:00
Patrol Read Reoccurrence = 168 hrs
Next Patrol Read launch = 10/03/2015, 03:00:00
Battery learn Reoccurrence = 672 hrs
Next Battery Learn = 10/21/2015, 17:00:00
OEMID = LSI

Drive Groups = 1

TOPOLOGY :
========

-------------------------------------------------------------------------
DG Arr Row EID:Slot DID Type  State BT      Size PDC  PI SED DS3  FSpace 
-------------------------------------------------------------------------
 0 -   -   -        -   RAID6 Optl  N  32.737 TB dflt N  Y   dflt N      
 0 0   -   -        -   RAID6 Optl  N  32.737 TB dflt N  Y   dflt N      
 0 0   0   15:0     13  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   1   15:1     10  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   2   15:2     18  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   3   15:3     14  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   4   15:4     29  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   5   15:5     19  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   6   15:6     25  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   7   15:7     30  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   8   15:8     12  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   9   15:9     21  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   10  15:10    20  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   11  15:11    11  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   12  15:12    23  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   13  15:13    32  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   14  15:14    31  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   15  15:15    9   DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   16  15:16    8   DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   17  15:17    27  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   18  15:18    24  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   19  15:19    28  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   20  15:20    22  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
 0 0   21  15:21    16  DRIVE Onln  N   1.636 TB dflt N  Y   dflt -      
-------------------------------------------------------------------------

DG=Disk Group Index|Arr=Array Index|Row=Row Index|EID=Enclosure Device ID
DID=Device ID|Type=Drive Type|Onln=Online|Rbld=Rebuild|Dgrd=Degraded
Pdgd=Partially degraded|Offln=Offline|BT=Background Task Active
PDC=PD Cache|PI=Protection Info|SED=Self Encrypting Drive|Frgn=Foreign
DS3=Dimmer Switch 3|dflt=Default|Msng=Missing|FSpace=Free Space Present

Virtual Drives = 1

VD LIST :
=======

----------------------------------------------------------
DG/VD TYPE  State Access Consist Cache sCC      Size Name 
----------------------------------------------------------
0/0   RAID6 Optl  RW     Yes     RWBD  -   32.737 TB      
----------------------------------------------------------

Cac=CacheCade|Rec=Recovery|OfLn=OffLine|Pdgd=Partially Degraded|dgrd=Degraded
Optl=Optimal|RO=Read Only|RW=Read Write|HD=Hidden|B=Blocked|Consist=Consistent|
R=Read Ahead Always|NR=No Read Ahead|WB=WriteBack|
AWB=Always WriteBack|WT=WriteThrough|C=Cached IO|D=Direct IO|sCC=Scheduled
Check Consistency

Physical Drives = 24

PD LIST :
=======

-----------------------------------------------------------------------
EID:Slt DID State DG     Size Intf Med SED PI SeSz Model            Sp 
-----------------------------------------------------------------------
15:0     13 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:1     10 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:2     18 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:3     14 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:4     29 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:5     19 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:6     25 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:7     30 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:8     12 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:9     21 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:10    20 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:11    11 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:12    23 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:13    32 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:14    31 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:15     9 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:16     8 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:17    27 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:18    24 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:19    28 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:20    22 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:21    16 Onln   0 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  U  
15:22    17 GHS    - 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  D  
15:23    26 GHS    - 1.636 TB SAS  HDD Y   N  512B HUC101818CS4201  D  
-----------------------------------------------------------------------

EID-Enclosure Device ID|Slt-Slot No.|DID-Device ID|DG-DriveGroup
DHS-Dedicated Hot Spare|UGood-Unconfigured Good|GHS-Global Hotspare
UBad-Unconfigured Bad|Onln-Online|Offln-Offline|Intf-Interface
Med-Media Type|SED-Self Encryptive Drive|PI-Protection Info
SeSz-Sector Size|Sp-Spun|U-Up|D-Down|T-Transition|F-Foreign
UGUnsp-Unsupported|UGShld-UnConfigured shielded|HSPShld-Hotspare shielded
CFShld-Configured shielded


Cachevault_Info :
===============

------------------------------------
Model  State   Temp Mode MfgDate    
------------------------------------
CVPM03 Optimal 33C  -    2014/11/05 
------------------------------------
=cut
		
		if ($line =~ /Controller = (\d+)/i)
		{
			# storcli_adapter -> storcli_adapter_adapter_number
			$adapter = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "adapter", value1 => $adapter
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# If I don't have an adapter, skip the line.
		next if $adapter !~ /^\d+/;
		
		### Now start digging data out!
		# Controller info
		if ($line =~ /^Model = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_product_name
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{product_name} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::product_name", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{product_name}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Serial Number = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_serial_number
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{serial_number} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::serial_number", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{serial_number}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^SAS Address = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_sas_address
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{sas_address} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::sas_address", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{sas_address}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^PCI Address = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_pci_address
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{pci_address} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::pci_address", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{pci_address}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Mfg Date = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_manufacture_date
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{manufacture_date} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::manufacture_date", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{manufacture_date}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Rework Date = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_rework_date
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{rework_date} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::rework_date", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{rework_date}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Revision No = (.*)?/i)
		{
			# storcli_adapter -> storcli_adapter_revision_number
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{revision_number} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_adapter::revision_number", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_adapter}{revision_number}
			}, file => $THIS_FILE, line => __LINE__});
		}
		# Firmware info.
		elsif ($line =~ /^Firmware Package Build = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_package_build
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{package_build} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::package_build", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{package_build}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Firmware Version = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Bios Version = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_bios_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{bios_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::bios_version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{bios_version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^WebBIOS Version = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_webbios_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{webbios_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::webbios_version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{webbios_version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Preboot CLI Version = (.*)?/i)
		{
			# storcli_firmware -> name_storcli_firmware_preboot_cli_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{preboot_cli_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::preboot_cli_version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{preboot_cli_version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Boot Block Version = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_boot_block_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{boot_block_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::boot_block_version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{boot_block_version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Bootloader Version = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_boot_block_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{boot_block_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::boot_block_version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{boot_block_version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Driver Name = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_driver_name
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{driver_name} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::driver_name", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{driver_name}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Driver Version = (.*)?/i)
		{
			# storcli_firmware -> storcli_firmware_driver_version
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{driver_version} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::driver_version", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{driver_version}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Image name = (.*)?/i)
		{
			# storcli_firmware -> link_storcli_firmware_pending_images_in_flash
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{pending_images_in_flash} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_firmware::pending_images_in_flash", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_firmware}{pending_images_in_flash}
			}, file => $THIS_FILE, line => __LINE__});
		}
		# Bus info
		elsif ($line =~ /^Vendor Id = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_vendor_id
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{vendor_id} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::vendor_id", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{vendor_id}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Device Id = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_device_id
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{device_id} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::device_id", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{device_id}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^SubVendor Id = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_subvendor_id
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{subvendor_id} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::subvendor_id", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{subvendor_id}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^SubDevice Id = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_subdevice_id
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{subdevice_id} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::subdevice_id", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{subdevice_id}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Host Interface = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_host_interface
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{host_interface} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::host_interface", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{host_interface}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Device Interface = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_device_interface
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{device_interface} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::device_interface", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{device_interface}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Bus Number = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_bus_number
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{bus_number} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::bus_number", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{bus_number}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Device Number = (.*)?/i)
		{
			# storcli_bus -> storclstorcli_bus_device_number
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{device_number} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::device_number", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{device_number}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Function Number = (.*)?/i)
		{
			# storcli_bus -> storcli_bus_function_number
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{function_number} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_bus::function_number", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_bus}{function_number}
			}, file => $THIS_FILE, line => __LINE__});
		}
		# Status
		elsif ($line =~ /^Controller Status = (.*)?/i)
		{
			# storcli_status -> storcli_bus_function_number
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{function_number} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::function_number", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{function_number}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Memory Correctable Errors = (.*)?/i)
		{
			# storcli_status -> storcli_status_memory_correctable_errors
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{memory_correctable_errors} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::memory_correctable_errors", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{memory_correctable_errors}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Memory Uncorrectable Errors = (.*)?/i)
		{
			# storcli_status -> storcli_status_memory_uncorrectable_errors
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{memory_uncorrectable_errors} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::memory_uncorrectable_errors", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{memory_uncorrectable_errors}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^ECC Bucket Count = (.*)?/i)
		{
			# storcli_status -> storcli_status_ecc_bucket_count
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{ecc_bucket_count} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::ecc_bucket_count", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{ecc_bucket_count}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Any Offline VD Cache Preserved = (.*)?/i)
		{
			# storcli_status -> storcli_status_any_offline_vd_cache_preserved
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{any_offline_vd_cache_preserved} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::any_offline_vd_cache_preserved", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{any_offline_vd_cache_preserved}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^BBU Status = (.*)?/i)
		{
			# storcli_status -> storcli_status_bbu_status
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{bbu_status} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::bbu_status", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{bbu_status}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support PD Firmware Download = (.*)?/i)
		{
			# storcli_status -> storcli_status_support_pd_firmware_download
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{support_pd_firmware_download} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::support_pd_firmware_download", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{support_pd_firmware_download}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Lock Key Assigned = (.*)?/i)
		{
			# storcli_status -> storcli_status_lock_key_assigned
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{lock_key_assigned} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::lock_key_assigned", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{lock_key_assigned}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Failed to get lock key on bootup = (.*)?/i)
		{
			# storcli_status -> storcli_status_failed_to_get_lock_key_on_bootup
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{failed_to_get_lock_key_on_bootup} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::failed_to_get_lock_key_on_bootup", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{failed_to_get_lock_key_on_bootup}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Bios was not detected during boot = (.*)?/i)
		{
			# storcli_status -> storcli_status_bios_not_detected_during_boot
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{bios_not_detected_during_boot} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::bios_not_detected_during_boot", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{bios_not_detected_during_boot}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Controller must be rebooted to complete security operation = (.*)?/i)
		{
			# storcli_status -> storcli_status_rebooted_for_security_operation
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{rebooted_for_security_operation} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::rebooted_for_security_operation", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{rebooted_for_security_operation}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^A rollback operation is in progress = (.*)?/i)
		{
			# storcli_status -> storcli_status_rollback_operation_in_progress
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{rollback_operation_in_progress} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::rollback_operation_in_progress", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{rollback_operation_in_progress}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^At least one PFK exists in NVRAM = (.*)?/i)	# Premium Feature Key
		{
			# storcli_status -> storcli_status_at_least_one_pfk_exists_in_nvram
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{at_least_one_pfk_exists_in_nvram} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::at_least_one_pfk_exists_in_nvram", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{at_least_one_pfk_exists_in_nvram}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^SSC Policy is WB = (.*)?/i)	# Solid State Cache policy
		{
			# storcli_status -> storcli_status_ssc_policy_is_wb
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{ssc_policy_is_wb} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::ssc_policy_is_wb", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{ssc_policy_is_wb}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Controller has booted into safe mode = (.*)?/i)
		{
			# storcli_status -> storcli_status_controller_booted_into_safe_mode
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{controller_booted_into_safe_mode} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_status::controller_booted_into_safe_mode", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_status}{controller_booted_into_safe_mode}
			}, file => $THIS_FILE, line => __LINE__});
		}
		# Supported Operations
		elsif ($line =~ /^Rebuild Rate = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_rebuild_rate
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{rebuild_rate} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::rebuild_rate", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{rebuild_rate}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^CC Rate = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_cc_rate
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{cc_rate} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::cc_rate", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{cc_rate}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^BGI Rate = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_bgi_rate
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{bgi_rate} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::bgi_rate", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{bgi_rate}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Reconstruct Rate = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_reconstruct_rate
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{reconstruct_rate} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::reconstruct_rate", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{reconstruct_rate}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Patrol Read Rate = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_patrol_read_rate
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{patrol_read_rate} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::patrol_read_rate", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{patrol_read_rate}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Alarm Control = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_alarm_control
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{alarm_control} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::alarm_control", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{alarm_control}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Cluster Support = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_cluster_support
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{cluster_support} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::cluster_support", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{cluster_support}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^BBU = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_bbu
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{bbu} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::bbu", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{bbu}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Spanning = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_spanning
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{spanning} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::spanning", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{spanning}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Dedicated Hot Spare = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_dedicated_hot_spare
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{dedicated_hot_spare} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::dedicated_hot_spare", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{dedicated_hot_spare}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Revertible Hot Spares = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_revertible_hot_spares
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{revertible_hot_spares} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::revertible_hot_spares", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{revertible_hot_spares}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Foreign Config Import = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_foreign_config_import
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{foreign_config_import} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::foreign_config_import", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{foreign_config_import}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Self Diagnostic = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_self_diagnostic
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{self_diagnostic} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::self_diagnostic", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{self_diagnostic}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Allow Mixed Redundancy on Array = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_allow_mixed_redundancy
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{allow_mixed_redundancy} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::allow_mixed_redundancy", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{allow_mixed_redundancy}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Global Hot Spares = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_global_hot_spares
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{allow_mixed_redundancy} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::allow_mixed_redundancy", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{allow_mixed_redundancy}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny SCSI Passthrough = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_deny_scsi_passthrough
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{deny_scsi_passthrough} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::deny_scsi_passthrough", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{deny_scsi_passthrough}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny SMP Passthrough = (.*)?/i)	# Serial Management Protocol
		{
			# storcli_supported_ops -> storcli_supported_ops_deny_smp_passthrough
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{deny_smp_passthrough} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::deny_smp_passthrough", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{deny_smp_passthrough}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny STP Passthrough = (.*)?/i)	# Serial Tunneling Protocol
		{
			# storcli_supported_ops -> storcli_supported_ops_deny_stp_passthrough
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{deny_stp_passthrough} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::deny_stp_passthrough", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{deny_stp_passthrough}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support more than 8 Phys = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_support_more_than_8_pd
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{support_more_than_8_pd} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::support_more_than_8_pd", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{support_more_than_8_pd}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^FW and Event Time in GMT = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_fw_and_event_time_in_gmt
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{fw_and_event_time_in_gmt} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::fw_and_event_time_in_gmt", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{fw_and_event_time_in_gmt}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Enhanced Foreign Import = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_enhanced_foreign_import
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{enhanced_foreign_import} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::enhanced_foreign_import", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{enhanced_foreign_import}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Enclosure Enumeration = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_enclosure_enumeration
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{enclosure_enumeration} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::enclosure_enumeration", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{enclosure_enumeration}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Allowed Operations = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_allowed_operations
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{allowed_operations} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::allowed_operations", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{allowed_operations}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Abort CC on Error = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_abort_cc_on_error
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{abort_cc_on_error} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::abort_cc_on_error", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{abort_cc_on_error}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Multipath = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_multipath
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{multipath} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::multipath", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{multipath}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Odd & Even Drive count in RAID1E = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_odd_even_pd_count_raid1e
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{odd_even_pd_count_raid1e} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::odd_even_pd_count_raid1e", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{odd_even_pd_count_raid1e}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Security = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_security
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{security} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::security", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{security}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Config Page Model = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_config_page_model
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{config_page_model} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::config_page_model", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{config_page_model}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support the OCE without adding drives = (.*)?/i)	# Online Capacity Expansion
		{
			# storcli_supported_ops -> storcli_supported_ops_oce_without_adding_drives
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{oce_without_adding_drives} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::oce_without_adding_drives", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{oce_without_adding_drives}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support EKM = (.*)?/i)	# External Key Management
		{
			# storcli_supported_ops -> storcli_supported_ops_external_key_management
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{external_key_management} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::external_key_management", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{external_key_management}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Snapshot Enabled = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_snapshot_enabled
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{snapshot_enabled} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::snapshot_enabled", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{snapshot_enabled}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support PFK = (.*)?/i)	# Premium Feature Key
		{
			# storcli_supported_ops -> storcli_supported_ops_premium_feature_key
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{premium_feature_key} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::premium_feature_key", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{premium_feature_key}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support PI = (.*)?/i)	# Protection Information
		{
			# storcli_supported_ops -> storcli_supported_ops_protection_information
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{protection_information} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::protection_information", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{protection_information}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support LDPI Type1 = (.*)?/i)	# 
		{
			# storcli_supported_ops -> storcli_supported_ops_ldpi_type1
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ldpi_type1} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::ldpi_type1", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ldpi_type1}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support LDPI Type2 = (.*)?/i)	# 
		{
			# storcli_supported_ops -> storcli_supported_ops_ldpi_type2
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ldpi_type2} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::ldpi_type2", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ldpi_type2}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support LDPI Type3 = (.*)?/i)	# 
		{
			# storcli_supported_ops -> storcli_supported_ops_ldpi_type3
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ldpi_type3} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::ldpi_type3", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ldpi_type3}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Ld BBM Info = (.*)?/i)	# Logical Disk Bad Block Management
		{
			# storcli_supported_ops -> storcli_supported_ops_ld_bbm_info
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ld_bbm_info} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::ld_bbm_info", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ld_bbm_info}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Shield State = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_shield_state
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{shield_state} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::shield_state", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{shield_state}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Block SSD Write Disk Cache Change = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_block_ssd_wdc_change
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{block_ssd_wdc_change} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::block_ssd_wdc_change", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{block_ssd_wdc_change}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Suspend Resume BG ops = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_suspend_resume_bg_ops
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{suspend_resume_bg_ops} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::suspend_resume_bg_ops", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{suspend_resume_bg_ops}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Emergency Spares = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_emergency_spares
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{emergency_spares} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::emergency_spares", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{emergency_spares}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Set Link Speed = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_set_link_speed
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{set_link_speed} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::set_link_speed", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{set_link_speed}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Boot Time PFK Change = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_boot_time_pfk_change
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{boot_time_pfk_change} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::boot_time_pfk_change", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{boot_time_pfk_change}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support JBOD = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_jbod
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{jbod} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::jbod", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{jbod}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Disable Online PFK Change = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_disable_online_pfk_change
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{disable_online_pfk_change} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::disable_online_pfk_change", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{disable_online_pfk_change}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Perf Tuning = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_performance_tuning
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{performance_tuning} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::performance_tuning", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{performance_tuning}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support SSD PatrolRead = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_ssd_patrol_read
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ssd_patrol_read} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::ssd_patrol_read", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{ssd_patrol_read}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Real Time Scheduler = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_real_time_scheduler
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{real_time_scheduler} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::real_time_scheduler", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{real_time_scheduler}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Reset Now = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_reset_now
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{reset_now} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::reset_now", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{reset_now}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Emulated Drives = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_emulated_drives
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{emulated_drives} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::emulated_drives", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{emulated_drives}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Headless Mode = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_headless_mode
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{headless_mode} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::headless_mode", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{headless_mode}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Dedicated HotSpares Limited = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_dedicated_hs_limited
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{dedicated_hs_limited} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::dedicated_hs_limited", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{dedicated_hs_limited}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Point In Time Progress = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_point_in_time_progress
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{point_in_time_progress} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::point_in_time_progress", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{point_in_time_progress}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Extended LD = (.*)?/i)
		{
			# storcli_supported_ops -> storcli_supported_ops_extended_ld
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{extended_ld} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_ops::extended_ld", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_ops}{extended_ld}
			}, file => $THIS_FILE, line => __LINE__});
		}
		# Supported Physical Disk Operations
		elsif ($line =~ /^Force Online = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_force_online
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{force_online} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::force_online", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{force_online}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Force Rebuild = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_force_rebuild
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{force_rebuild} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::force_rebuild", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{force_rebuild}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny Force Failed = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_deny_force_failed
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_force_failed} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::deny_force_failed", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_force_failed}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny Force Good\/Bad = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_deny_force_good_Bad
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_force_good_Bad} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::deny_force_good_Bad", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_force_good_Bad}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny Missing Replace = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_deny_missing_replace
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_missing_replace} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::deny_missing_replace", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_missing_replace}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny Clear = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_deny_clear
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_clear} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::deny_clear", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_clear}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Deny Locate = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_deny_locate
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_locate} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::deny_locate", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{deny_locate}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Power State = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_support_power_state
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{support_power_state} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::support_power_state", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{support_power_state}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Set Power State For Cfg = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_set_power_state_for_config
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{set_power_state_for_config} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::set_power_state_for_config", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{set_power_state_for_config}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support T10 Power State = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_support_t10_power_state
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{support_t10_power_state} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::support_t10_power_state", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{support_t10_power_state}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^Support Temperature = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_support_temperature
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{support_temperature} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::support_temperature", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{support_temperature}
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($line =~ /^NCQ = (.*)?/i)
		{
			# storcli_supported_pd_ops -> storcli_supported_pd_ops_ncq
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{ncq} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::ncq", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{ncq}
			}, file => $THIS_FILE, line => __LINE__});
		}
		# Supported Virtual Disk Operations
		elsif ($line =~ /^NCQ = (.*)?/i)
		{
			# storcli_supported_vd_ops -> 
			$an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_vd_ops}{ncq} = $1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "storcli::${adapter}::adapter::${adapter}::storcli_supported_pd_ops::ncq", value1 => $an->data->{storcli}{$adapter}{adapter}{$adapter}{storcli_supported_pd_ops}{ncq}
			}, file => $THIS_FILE, line => __LINE__});
		}

=pod
Supported VD Operations :
=======================
Read Policy = Yes
Write Policy = Yes
IO Policy = Yes
Access Policy = Yes
Disk Cache Policy = Yes
Reconstruction = Yes
Deny Locate = No
Deny CC = No
Allow Ctrl Encryption = No
Enable LDBBM = Yes
Support FastPath = No
Performance Metrics = Yes
Power Savings = No
Support Powersave Max With Cache = No
Support Breakmirror = No
Support SSC WriteBack = No
Support SSC Association = No
Support VD Hide = No
Support VD HOQRebuid = No


Advanced Software Option :
========================

-------------------------------------
Adv S/W Opt     Time Remaining  Mode 
-------------------------------------
MegaRAID RAID6  Unlimited       -    
MegaRAID RAID5  Unlimited       -    
-------------------------------------

Safe ID =  V4ASBCV2HMN47EW7SLGXEF1C3HM36SEGWXMVEVIZ

HwCfg :
=====
ChipRevision =  D1
BatteryFRU = N/A
Front End Port Count = 0
Backend Port Count = 8
BBU = Present
Alarm = Disable
Serial Debugger = Present
NVRAM Size = 32KB
Flash Size = 16MB
On Board Memory Size = 1024MB
On Board Expander = Absent
Temperature Sensor for ROC = Present
Temperature Sensor for Controller = Absent
Current Size of CacheCade (GB) = 0
Current Size of FW Cache (MB) = 873
ROC temperature(Degree Celsius) = 78


Policies :
========

Policies Table :
==============

------------------------------------------------
Policy                          Current Default 
------------------------------------------------
Predictive Fail Poll Interval   300 sec         
Interrupt Throttle Active Count 16              
Interrupt Throttle Completion   50 us           
Rebuild Rate                    30 %    30%     
PR Rate                         20 %    30%     
BGI Rate                        30 %    30%     
Check Consistency Rate          30 %    30%     
Reconstruction Rate             30 %    30%     
Cache Flush Interval            4s              
------------------------------------------------

Flush Time(Default) = 4s
Drive Coercion Mode = none
Auto Rebuild = On
Battery Warning = On
ECC Bucket Size = 15
ECC Bucket Leak Rate (hrs) = 24
Restore HotSpare on Insertion = On
Expose Enclosure Devices = Off
Maintain PD Fail History = On
Reorder Host Requests = On
Auto detect BackPlane = SGPIO/i2c SEP
Load Balance Mode = Auto
Security Key Assigned = Off
Disable Online Controller Reset = Off
Use drive activity for locate = Off


Boot :
====
BIOS Enumerate VDs = 1
Stop BIOS on Error = Off
Delay during POST = 0
Spin Down Mode = None
Enable Ctrl-R = No
Enable Web BIOS = Yes
Enable PreBoot CLI = Yes
Enable BIOS = Yes
Max Drives to Spinup at One Time = 2
Maximum number of direct attached drives to spin up in 1 min = 20
Delay Among Spinup Groups (sec) = 6
Allow Boot with Preserved Cache = Off


High Availability :
=================
Topology Type = None
Cluster Permitted = No
Cluster Active = No


Defaults :
========
Phy Polarity = 0
Phy PolaritySplit = 0
Strip Size = 64kB
Write Policy = WT
Read Policy = None
Cache When BBU Bad = Off
Cached IO = Off
VD PowerSave Policy = Automatic
Default spin down time (mins) = 30
Coercion Mode = None
ZCR Config = Unknown
Max Chained Enclosures = 16
Direct PD Mapping = No
Restore Hot Spare on Insertion = Yes
Expose Enclosure Devices = No
Maintain PD Fail History = Yes
Zero Based Enclosure Enumeration = No
Disable Puncturing = No
EnableLDBBM = Yes
Un-Certified Hard Disk Drives = Allow
SMART Mode = Mode 6
Enable LED Header = No
LED Show Drive Activity = Yes
Dirty LED Shows Drive Activity = No
EnableCrashDump = No
Disable Online Controller Reset = No
Treat Single span R1E as R10 = No
Power Saving option = Enabled
TTY Log In Flash = Yes
Auto Enhanced Import = No
BreakMirror RAID Support = No
Disable Join Mirror = No
Enable Shield State = Yes
Time taken to detect CME = 60 sec


Capabilities :
============
Supported Drives = SAS, SATA
Boot Volume Supported = NO
RAID Level Supported = RAID0, RAID1, RAID5, RAID6, RAID00, RAID10, RAID50, 
RAID60, PRL 11, PRL 11 with spanning, SRL 3 supported, 
PRL11-RLQ0 DDF layout with no span, PRL11-RLQ0 DDF layout with span
Enable JBOD = No
Mix in Enclosure = Allowed
Mix of SAS/SATA of HDD type in VD = Not Allowed
Mix of SAS/SATA of SSD type in VD = Not Allowed
Mix of SSD/HDD in VD = Not Allowed
SAS Disable = No
Max Arms Per VD = 32
Max Spans Per VD = 8
Max Arrays = 128
Max VD per array = 16
Max Number of VDs = 64
Max Parallel Commands = 1008
Max SGE Count = 60
Max Data Transfer Size = 8192 sectors
Max Strips PerIO = 42
Max Configurable CacheCade Size = 0
Min Strip Size = 8 KB
Max Strip Size = 1.0 MB


Scheduled Tasks :
===============
Consistency Check Reoccurrence = 168 hrs
Next Consistency check launch = 08/08/2015, 03:00:00
Patrol Read Reoccurrence = 168 hrs
Next Patrol Read launch = 08/08/2015, 03:00:00
Battery learn Reoccurrence = 672 hrs
Next Battery Learn = 08/28/2015, 00:00:00
OEMID = Unknown

Drive Groups = 1

TOPOLOGY :
========

--------------------------------------------------------------------------
DG Arr Row EID:Slot DID Type  State BT       Size PDC  PI SED DS3  FSpace 
--------------------------------------------------------------------------
 0 -   -   -        -   RAID6 Optl  N  544.875 GB dsbl N  N   none N      
 0 0   -   -        -   RAID6 Optl  N  544.875 GB dsbl N  N   none N      
 0 0   0   252:0    9   DRIVE Onln  N  136.218 GB dsbl N  N   none -      
 0 0   1   252:6    12  DRIVE Onln  N  136.218 GB dsbl N  N   none -      
 0 0   2   252:7    13  DRIVE Onln  N  136.218 GB dsbl N  N   none -      
 0 0   3   252:3    7   DRIVE Onln  N  136.218 GB dsbl N  N   none -      
 0 0   4   252:4    11  DRIVE Onln  N  136.218 GB dsbl N  N   none -      
 0 0   5   252:5    14  DRIVE Onln  N  136.218 GB dsbl N  N   none -      
--------------------------------------------------------------------------

DG=Disk Group Index|Arr=Array Index|Row=Row Index|EID=Enclosure Device ID
DID=Device ID|Type=Drive Type|Onln=Online|Rbld=Rebuild|Dgrd=Degraded
Pdgd=Partially degraded|Offln=Offline|BT=Background Task Active
PDC=PD Cache|PI=Protection Info|SED=Self Encrypting Drive|Frgn=Foreign
DS3=Dimmer Switch 3|dflt=Default|Msng=Missing|FSpace=Free Space Present

Virtual Drives = 1

VD LIST :
=======

-----------------------------------------------------------
DG/VD TYPE  State Access Consist Cache sCC       Size Name 
-----------------------------------------------------------
0/0   RAID6 Optl  RW     Yes     NRWBD -   544.875 GB      
-----------------------------------------------------------

Cac=CacheCade|Rec=Recovery|OfLn=OffLine|Pdgd=Partially Degraded|dgrd=Degraded
Optl=Optimal|RO=Read Only|RW=Read Write|HD=Hidden|B=Blocked|Consist=Consistent|
R=Read Ahead Always|NR=No Read Ahead|WB=WriteBack|
AWB=Always WriteBack|WT=WriteThrough|C=Cached IO|D=Direct IO|sCC=Scheduled
Check Consistency

Physical Drives = 8

PD LIST :
=======

-------------------------------------------------------------------------
EID:Slt DID State DG       Size Intf Med SED PI SeSz Model            Sp 
-------------------------------------------------------------------------
252:0     9 Onln   0 136.218 GB SAS  HDD N   N  512B MK1401GRRB       U  
252:1    10 GHS    - 136.218 GB SAS  HDD N   N  512B MK1401GRRB       D  
252:2     8 GHS    - 136.218 GB SAS  HDD N   N  512B MK1401GRRB       D  
252:3     7 Onln   0 136.218 GB SAS  HDD N   N  512B MK1401GRRB       U  
252:4    11 Onln   0 136.218 GB SAS  HDD N   N  512B MK1401GRRB       U  
252:5    14 Onln   0 136.218 GB SAS  HDD N   N  512B MK1401GRRB       U  
252:6    12 Onln   0 136.218 GB SAS  HDD N   N  512B MK1401GRRB       U  
252:7    13 Onln   0 136.218 GB SAS  HDD N   N  512B MK1401GRRB       U  
-------------------------------------------------------------------------

EID-Enclosure Device ID|Slt-Slot No.|DID-Device ID|DG-DriveGroup
DHS-Dedicated Hot Spare|UGood-Unconfigured Good|GHS-Global Hotspare
UBad-Unconfigured Bad|Onln-Online|Offln-Offline|Intf-Interface
Med-Media Type|SED-Self Encryptive Drive|PI-Protection Info
SeSz-Sector Size|Sp-Spun|U-Up|D-Down|T-Transition|F-Foreign
UGUnsp-Unsupported|UGShld-UnConfigured shielded|HSPShld-Hotspare shielded
CFShld-Configured shielded


Cachevault_Info :
===============

--------------------------------------
Model    State   Temp Mode MfgDate    
--------------------------------------
SuperCaP Optimal 32C  -    2013/10/25 
--------------------------------------

=cut
	}
	close $file_handle;
	
	return(0);
}

# This does two things; It checks to see if storcli64 is installed (exits '1' if not, exits '2' if not 
# executable) and then checks to see if any controllers are found in the system (exits '3' if not). 
sub find_lsi_controllers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "find_lsi_controllers", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will keep track of how many controllers we find.
	my $adapter_count = 0;
	
	# First, do we have storcli64 installed?
	if (not -e $an->data->{path}{storcli})
	{
		print $an->String->get({
			key		=>	"scan_storcli_error_0001",
			variables	=>	{
				path		=>	$an->data->{path}{storcli},
			},
		}), "\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0001", message_variables => {
			path	=>	$an->data->{path}{storcli},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 1);
	}
	
	# Make sure it is executable
	if (not -x $an->data->{path}{storcli})
	{
		print $an->String->get({
			key		=>	"scan_storcli_error_0002",
			variables	=>	{
				path		=>	$an->data->{path}{storcli},
			},
		}), "\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0002", message_variables => {
			path	=>	$an->data->{path}{storcli},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 2);
	}
	
	# Still alive? Good! Look for controllers now.
	my $shell_call = $an->data->{path}{storcli}." ".$an->data->{sys}{arguments}{adapter_count}." 2>&1 |";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\r//;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Controller Count = (\d+)/i)
		{
			$adapter_count = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "adapter_count", value1 => $adapter_count
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# Have we any adapters?
	if ($adapter_count > 0)
	{
		$an->Log->entry({log_level => 2, message_key => "scan_storcli_log_0001", message_variables => {
			count	=>	$adapter_count, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		print $an->String->get({
			key		=>	"scan_storcli_error_0003",
			variables	=>	{
				path		=>	$an->data->{path}{storcli},
			},
		}), "\n";
		$an->Log->entry({log_level => 1, message_key => "scan_storcli_error_0003", message_variables => {
			path	=>	$an->data->{path}{storcli},
		}, file => $THIS_FILE, line => __LINE__});
		nice_exit($an, 3);
	}
	
	return(0);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit(0);
}

### TODO: Move this into AN::Tools
# This collects the command line switches
sub get_switches
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_switches", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$an->data->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$an->data->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument         = "raw";
				$an->data->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$an->data->{switches}{$last_argument} = $value;
				}
				else
				{
					$an->data->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$an->data->{switches}{$last_argument} = $argument;
				$last_argument                    = "";
			}
			else
			{
				# Got a value without an argument.
				$an->data->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($an->data->{switches}{raw})
	{
		$an->data->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	foreach my $variable (sort {$a cmp $b} keys %{$an->data->{switches}})
	{
		$an->Log->entry({
			log_level	=>	2,
			title_key	=>	"scancore_title_0001",
			message_key	=>	"scancore_log_0010",
			message_vars	=>	{
				variable	=>	$variable,
				value		=>	$an->data->{switches}{$variable},
			},
			file		=>	$THIS_FILE,
			line		=>	__LINE__,
			language	=>	$an->data->{scancore}{log_language},
			log_to		=>	$an->data->{path}{log_file},
		});
	}
	
	# If the user has asked for help, print the usage info.
	if (($an->data->{switches}{h}) or ($an->data->{switches}{help}) or ($an->data->{switches}{'?'}))
	{
		print_usage($an);
		exit(0);
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_storcli_message_0002"}), "\n";

	return(0);
}
