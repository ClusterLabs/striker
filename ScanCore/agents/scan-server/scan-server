#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released under the terms of the GNU GPL 
# version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - Passed in host name was not found in the database.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# NOTE:
#  - This agent monitors servers, which are NOT tagged to hosts. So it doesn't load or update schemas on its
#    own.
# 
# TODO: 
#  - Check each pass if the server is running and, if so, update /shared/definition. Do this before looking
#    for changes!
#  - Add a check to see if libvirtd is set to start on boot and disable it, if so.
#  - Add a 'maintenance mode' where the VM is no longer monitored by the cluster. When in maintenance mode,
#    we will not touch it. Otherwise, if it is found to be running on a node but not in clustat, use 
#    clusvcadm to add it to the cluster control.
#  - If a VM becomes 'defined', undefine it. (virsh dominfo <server> | grep Persistent) -> yes|no
# 

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Text::Diff;

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			cluster_conf		=>	"/etc/cluster/cluster.conf",
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			host_uuid		=>	"/etc/striker/host.uuid",
			libvirtd_socket		=>	"/var/run/libvirt/libvirt-sock", 
			strings			=>	"$running_directory/$THIS_FILE.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			virsh			=>	"/usr/bin/virsh",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-server'		=>	{
			language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_level		=>	2,
			log_language		=>	"en_CA",
			log_db_transactions	=>	0,
		},
		server		=>	{},
		sys		=>	{
			# This will get set by AN::Tools::DB->connect_to_databases()
			sql			=>	[],
			# This is the source name of anything added to 'shared' by this agent.
			shared_source_name	=>	'scan-server', 
			# This is the shared record used in 'shared' to store the XML definition data, 
			# current host and current state.
			shared_definition_name	=>	'definition',
			shared_host_name	=>	'host',
			shared_state_name	=>	'state',
		},
	}
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-server'}{language});
$an->default_log_language($an->data->{'scan-server'}{log_language});
$an->default_log_file    ($an->data->{'scan-server'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-server'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-server'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();

# Adjust the log level if requested.
adjust_log_level($an);

print $an->String->get({key => "scan_server_message_0001"})."\n";

# Don't bother proceeding if there is no cluster.conf.
if (not -e $an->data->{path}{cluster_conf})
{
	nice_exit($an, 1);
}

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "notice_message_0013", message_variables => {
	connections	=>	$connections,
}, file => $THIS_FILE, line => __LINE__});

# If 'libvirtd' isn't running (locally or on the peer, if we can connect to it), exit.
if (not scan_servers($an))
{
	# libvirtd not found, exit.
	nice_exit($an, 1);
}

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { 
		uuid => $an->data->{sys}{host_uuid},
	}, code => 255, file => "$THIS_FILE", line => __LINE__});
}

# Look for changes.
find_changes($an);

# This checks to ensure that libvirtd is not set to start on boot, which can be set after an OS update.
check_libvirtd($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
nice_exit($an, 0);

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This checks to ensure that libvirtd is not set to start on boot, which can be set after an OS update.
sub check_libvirtd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_libvirtd", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $state = $an->System->daemon_boot_config({daemon => "libvirtd"});
	my $rc3   = $state->{3};
	my $rc5   = $state->{5};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "rc3", value1 => $rc3, 
		name2 => "rc5", value2 => $rc5, 
	}, file => $THIS_FILE, line => __LINE__});
	if (($rc3 eq "on") or ($rc5 eq "on"))
	{
		# Turn it off.
		$an->Log->entry({log_level => 1, message_key => "scan_server_log_0001", message_variables => {
			'3' => $rc3, 
			'5' => $rc5, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $state = $an->System->daemon_boot_config({
				daemon => "libvirtd",
				set    => "off",
			});
		my $rc3   = $state->{3};
		my $rc5   = $state->{5};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "rc3", value1 => $rc3, 
			name2 => "rc5", value1 => $rc5, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# Change to a user-requested log level.
sub adjust_log_level
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "adjust_log_level", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if ($an->data->{switches}{v})
	{
		$an->data->{'scan-server'}{log_level} = 1;
		$an->Log->level($an->data->{'scan-server'}{log_level});
	}
	elsif ($an->data->{switches}{vv})
	{
		$an->data->{'scan-server'}{log_level} = 2;
		$an->Log->level($an->data->{'scan-server'}{log_level});
	}
	elsif ($an->data->{switches}{vvv})
	{
		$an->data->{'scan-server'}{log_level} = 3;
		$an->Log->level($an->data->{'scan-server'}{log_level});
	}
	elsif ($an->data->{switches}{vvvv})
	{
		$an->data->{'scan-server'}{log_level} = 4;
		$an->Log->level($an->data->{'scan-server'}{log_level});
	}
	return(0);
}

# This looks for servers locally and on the peer and reads in their data.
sub scan_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_servers", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will get set to '1' if we find any server info locally or on the peer (if we can find our 
	# peer).
	my $proceed = 0;
	
	# Find out who I am and who my peer is
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cluster_conf},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Only proceed if I am in an Anvil!
	my $local_access = 1;
	if ($an->data->{sys}{anvil_name})
	{
		# First, check for local servers.
		my $shell_call = $an->data->{path}{virsh}." list --all";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^error:/)
			{
				# Not running
				$local_access = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "local_access", value1 => $local_access, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			if ($line =~ /^\d+ (.*?) (.*)$/)
			{
				my $server_name  = $1;
				my $server_state = $2;
				$an->data->{server_name}{$server_name} = {
					host	=>	$an->data->{sys}{local_node},
					'state'	=>	$server_state,
					definition	=>	"",
					uuid		=>	"",
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		
		# Now check the peer.
		my $peer_access = 1;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
			name2 => "target",     value2 => $an->data->{sys}{peer_node},
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{peer_node},
			port		=>	"", 
			password	=>	$an->data->{sys}{anvil_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^error:/)
			{
				# Not running
				$peer_access = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_access", value1 => $peer_access, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			if ($line =~ /^\d+ (.*?) (.*)$/)
			{
				my $server_name  = $1;
				my $server_state = $2;
				$an->data->{server_name}{$server_name} = {
					host		=>	$an->data->{sys}{peer_node},
					'state'		=>	$server_state,
					definition	=>	"",
					uuid		=>	"",
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "local_access", value1 => $local_access, 
			name2 => "peer_access",  value2 => $peer_access, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($local_access) or ($peer_access))
		{
			$proceed = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "proceed", value1 => $proceed, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		
	}
	
	if ($proceed)
	{
		# If I have local access, see if I can read the XML definition files of any servers NOT found
		# running locally or on the peer.
		if (($local_access) && ($an->data->{path}{shared_definitions}) && (-d $an->data->{path}{shared_definitions}))
		{
			# The directory is there, so look for files.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "path::shared_definitions", value1 => $an->data->{path}{shared_definitions},
			}, file => $THIS_FILE, line => __LINE__});
			local(*DIRECTORY);
			opendir(DIRECTORY, $an->data->{path}{shared_definitions});
			while(my $file = readdir(DIRECTORY))
			{
				if ($file =~ /(.*)\.xml$/)
				{
					my $this_server = $1;
					my $full_path   = $an->data->{path}{shared_definitions}."/".$file;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
						name1 => "file",        value1 => $file,
						name2 => "this_server", value2 => $this_server,
						name3 => "full_path",   value3 => $full_path,
					}, file => $THIS_FILE, line => __LINE__});
					my $already_found = 0;
					foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{server_name}})
					{
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "server_name", value1 => $server_name,
						}, file => $THIS_FILE, line => __LINE__});
						if ($server_name eq $this_server)
						{
							$already_found = 1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "already_found", value1 => $already_found,
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
					
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "already_found", value1 => $already_found,
					}, file => $THIS_FILE, line => __LINE__});
					if (not $already_found)
					{
						# Read in the definition file and record it's data.
						my $definition  = "";
						my $server_uuid = "";
						my $shell_call  = $full_path;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "shell_call", value1 => $shell_call,
						}, file => $THIS_FILE, line => __LINE__});
						open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => "$THIS_FILE", line => __LINE__});
						while(<$file_handle>)
						{
							chomp;
							my $line = $_;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "line", value1 => $line,
							}, file => $THIS_FILE, line => __LINE__});
							$definition .= $line."\n";
							
							if ($line =~ /<uuid>([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})<\/uuid>/)
							{
								$server_uuid = $1;
								$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
									name1 => "server_uuid", value1 => $server_uuid, 
								}, file => $THIS_FILE, line => __LINE__});
							}
						}
						# Record it if we found the UUID.
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "server_uuid", value1 => $server_uuid, 
						}, file => $THIS_FILE, line => __LINE__});
						if ($server_uuid)
						{
							# We're not setting the host or state because we 
							# don't know if it's running on another Anvil!.
							$an->data->{server_uuid}{$server_uuid} = {
								name		=>	$this_server,
								host		=>	"",
								'state'		=>	"",
								definition	=>	$definition,
							};
						}
					}
				}
			}
			close DIRECTORY;
		}
		
		# Now gather the details on the servers.
		foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{server_name}})
		{
			my $server_host  = $an->data->{server_name}{$server_name}{host};
			my $server_state = $an->data->{server_name}{$server_name}{'state'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "server_name",     value1 => $server_name, 
				name2 => "server_host",     value2 => $server_host, 
				name3 => "server_state",    value3 => $server_state, 
				name4 => "sys::local_node", value4 => $an->data->{sys}{local_node}, 
				name5 => "sys::peer_node",  value5 => $an->data->{sys}{peer_node}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $server_xml = "";
			my $shell_call = "virsh dumpxml $server_name";
			if ($server_host eq $an->data->{sys}{local_node})
			{
				# Locally hosted, call virsh directly
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					$server_xml .= "$line\n";
				}
				close $file_handle;
			}
			elsif ($server_host eq $an->data->{sys}{peer_node})
			{
				# Remote, call over SSH.
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "shell_call", value1 => $shell_call,
					name2 => "target",     value2 => $an->data->{sys}{peer_node},
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target		=>	$server_host,
					port		=>	"", 
					password	=>	$an->data->{sys}{anvil_password},
					ssh_fh		=>	"",
					'close'		=>	0,
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					$server_xml .= "$line\n";
				}
			}
			$an->data->{server_name}{$server_name}{definition} = $server_xml;
			
			# Dig out details now.
			foreach my $line (split/\n/, $server_xml)
			{
				if ($line =~ /<uuid>([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})<\/uuid>/)
				{
					$an->data->{server_name}{$server_name}{uuid} = $1;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "server_name::${server_name}::uuid", value1 => $an->data->{server_name}{$server_name}{uuid}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			# Now that I have the UUID, record the details using the UUID as the key
			my $server_uuid = $an->data->{server_name}{$server_name}{uuid};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "server_uuid", value1 => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($server_uuid)
			{
				$an->data->{server_uuid}{$server_uuid} = {
					name		=>	$server_name,
					host		=>	$an->data->{server_name}{$server_name}{host},
					'state'		=>	$an->data->{server_name}{$server_name}{'state'},
					definition	=>	$an->data->{server_name}{$server_name}{definition},
				};
			}
			else
			{
				die "$THIS_FILE ".__LINE__."; There should be a server UUID here...\n";
			}
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "proceed", value1 => $proceed, 
	}, file => $THIS_FILE, line => __LINE__});
	return($proceed);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through each server
	foreach my $server_uuid (sort {$a cmp $b} keys %{$an->data->{server_uuid}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "server_uuid", value1 => $server_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (read_last_scan($an, $server_uuid))
		{
			### Existing server, UPDATE or INSERT as needed.
			# NOTE: For now, we only catch name changes here.
			# New values
			my $new_server_name       = $an->data->{server_uuid}{$server_uuid}{name};
			my $new_server_host       = $an->data->{server_uuid}{$server_uuid}{host};
			my $new_server_state      = $an->data->{server_uuid}{$server_uuid}{'state'};
			my $new_server_definition = $an->data->{server_uuid}{$server_uuid}{definition};
			
			# Old values
			my $old_server_name       = $an->data->{sql}{$server_uuid}{server_name};
			my $old_server_host       = $an->data->{sql}{$server_uuid}{server_host};
			my $old_server_state      = $an->data->{sql}{$server_uuid}{server_state};
			my $old_server_definition = $an->data->{sql}{$server_uuid}{server_definition};
			
			# Diff?
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "old_server_name",       value1 => $old_server_name, 
				name2 => "new_server_name",       value2 => $new_server_name, 
				name3 => "old_server_host",       value3 => $old_server_host, 
				name4 => "new_server_host",       value4 => $new_server_host, 
				name5 => "old_server_state",      value5 => $old_server_state, 
				name6 => "new_server_state",      value6 => $new_server_state, 
				name7 => "old_server_definition", value7 => $old_server_definition, 
				name8 => "new_server_definition", value8 => $new_server_definition, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($new_server_name       ne $old_server_name) || 
			    ($new_server_host       ne $old_server_host) || 
			    ($new_server_state      ne $old_server_state) || 
			    ($new_server_definition ne $old_server_definition))
			{
				# Something has changed.
				if ($new_server_name ne $old_server_name)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1 => "old_server_name", value1 => $old_server_name, 
						name2 => "new_server_name", value2 => $new_server_name, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				if ($new_server_host ne $old_server_host)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1 => "old_server_host", value1 => $old_server_host, 
						name2 => "new_server_host", value2 => $new_server_host, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				if ($new_server_state ne $old_server_state)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1 => "old_server_state", value1 => $old_server_state, 
						name2 => "new_server_state", value2 => $new_server_state, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				if ($new_server_definition ne $old_server_definition)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
						name1 => "old_server_definition", value1 => $old_server_definition, 
						name2 => "new_server_definition", value2 => $new_server_definition, 
						name3 => "diff",                  value3 => diff \$old_server_definition, \$new_server_definition, { STYLE => 'Unified' },
					}, file => $THIS_FILE, line => __LINE__});
				}
				my $query = "
UPDATE 
    servers 
SET 
    server_name       = ".$an->data->{sys}{use_db_fh}->quote($new_server_name).", 
    server_host       = ".$an->data->{sys}{use_db_fh}->quote($new_server_host).", 
    server_state      = ".$an->data->{sys}{use_db_fh}->quote($new_server_state).", 
    server_definition = ".$an->data->{sys}{use_db_fh}->quote($new_server_definition).", 
    modified_date     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
;";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				### Now what actually changed?
				# The server name?
				if ($new_server_name ne $old_server_name)
				{
					# This should be a rare event, so it in a notice-level alert.
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_server_message_0006",
						alert_message_variables	=>	{
							old			=>	$old_server_name, 
							new			=>	$new_server_name,
						},
					});
				}
				# The current host?
				if ($new_server_host ne $old_server_host)
				{
					# New host, this is a worthy alert so it is note level
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_server_message_0008",
						alert_message_variables	=>	{
							server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
							new			=>	$new_server_host,
							old			=>	$old_server_host,
						},
					});
				}
				# The current state?
				if ($new_server_state ne $old_server_state)
				{
					# State changes are a little more important.
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_server_message_0010",
						alert_message_variables	=>	{
							server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
							new			=>	$new_server_state,
							old			=>	$old_server_state,
						},
					});
					# If this server's new state is 'started', make sure we clear the
					# 'server' -> 'server_stop_reason'
					if ($new_server_state eq /started/i)
					{
						my $query = "
UPDATE 
    servers 
SET 
    server_stop_reason = '', 
    modified_date      = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
;";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
					}
				}
				# The definition file?
				if ($new_server_definition ne $old_server_definition)
				{
					# This will happen whenever the virsh ID changes, disks are 
					# inserted/ejected, etc. So it's a notice-level event.
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_server_message_0007",
						alert_message_variables	=>	{
							server			=>	$new_server_name, 
							new			=>	$new_server_definition,
							diff			=>	diff \$old_server_definition, \$new_server_definition, { STYLE => 'Unified' },
						},
					});
				}
			}
		}
		else
		{
			# If the user hasn't set the default migration type, make it 'live'.
			$an->data->{sys}{'default'}{migration_type} = "live" if not $an->data->{sys}{'default'}{migration_type};
			
			# New server, INSERT everything.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "server_uuid", value1 => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			my $server_name           = $an->data->{server_uuid}{$server_uuid}{name};
			my $server_stop_reason    = "";
			my $server_start_after    = "NULL";
			my $server_start_delay    = 0;
			my $server_host           = $an->data->{server_uuid}{$server_uuid}{host};
			my $server_state          = $an->data->{server_uuid}{$server_uuid}{'state'};
			my $server_definition     = $an->data->{server_uuid}{$server_uuid}{definition};
			my $server_migration_type = $an->data->{sys}{'default'}{migration_type} =~ /cold/i ? "cold" : "live";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "server_uuid",           value1 => $server_uuid, 
				name2 => "server_name",           value2 => $server_name, 
				name3 => "server_stop_reason",    value3 => $server_stop_reason, 
				name4 => "server_start_after",    value4 => $server_start_after, 
				name5 => "server_start_delay",    value5 => $server_start_delay, 
				name6 => "server_host",           value6 => $server_host, 
				name7 => "server_migration_type", value7 => $server_migration_type, 
				name8 => "server_definition",     value8 => $server_definition, 
				name9 => "server_state",          value9 => $server_state, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $query = "
INSERT INTO 
    servers 
(
    server_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_host, 
    server_state, 
    server_definition, 
    server_migration_type, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_after).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_definition).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_migration_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Translate the server's UUID to a name is 'server_start_after' is set. If the UUID
			# is all '0', then the server won't boot via 'anvil-safe-start' at all.
			my $say_start_after    = "";
			   $server_start_after = "" if $server_start_after eq "NULL";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "server_start_after", value1 => $server_start_after, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($server_start_after eq "00000000-0000-0000-0000-000000000000")
			{
				$say_start_after = "#!string!scan_server_message_0005!#";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "say_start_after", value1 => $say_start_after, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($server_start_after)
			{
				my $return = $an->Get->server_data({
					uuid  => $server_start_after, 
				});
				$say_start_after = $return->{name};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "say_start_after", value1 => $say_start_after, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"scan_server_message_0003",
				alert_title_variables	=>	{
					name			=>	$server_name,
				},
				alert_message_key	=>	"scan_server_message_0004",
				alert_message_variables	=>	{
					uuid			=>	$server_uuid, 
					start_after		=>	$say_start_after, 
					start_delay		=>	$server_start_delay, 
					host			=>	$server_host, 
					'state'			=>	$server_state, 
					definition		=>	$server_definition,
					migration_type		=>	$an->data->{sys}{'default'}{migration_type} =~ /cold/i ? "#!string!scan_server_state_0002!#" : "#!string!scan_server_state_0001!#",
				},
			});
		}
	}
	
	# Now commit the changes.
	commit_sql($an);
	
	return(0);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an, $server_uuid) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "server_uuid", value1 => "$server_uuid" 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Couple of variables to make the code cleaner
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "id",        value1 => $id, 
		name2 => "host_name", value2 => $host_name, 
	}, file => $THIS_FILE, line => __LINE__});

	# This calls up the entry for this host. If no entry is found, 'new' gets set to '1' and the main 
	# function won't bother looking for changes and directly INSERT the scanned data.
	my $query = "
SELECT 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_note, 
    server_definition, 
    server_host, 
    server_state 
FROM 
    servers 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)."
;";
	$query =~ s/'NULL'/NULL/g;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $server_name        = $row->[0];
		my $server_stop_reason = $row->[1];
		my $server_start_after = $row->[2];
		my $server_start_delay = $row->[3];
		my $server_note        = $row->[4];
		my $server_definition  = $row->[5];
		my $server_host        = $row->[6];
		my $server_state       = $row->[7];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
			name1 => "server_uuid",        value1 => $server_uuid, 
			name2 => "server_name",        value2 => $server_name, 
			name3 => "server_stop_reason", value3 => $server_stop_reason, 
			name4 => "server_start_after", value4 => $server_start_after, 
			name5 => "server_start_delay", value5 => $server_start_delay, 
			name6 => "server_note",        value6 => $server_note, 
			name7 => "server_definition",  value7 => $server_definition, 
			name8 => "server_host",        value8 => $server_host, 
			name9 => "server_state",       value9 => $server_state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Push the data into the hash for later comparison
		$an->data->{sql}{$server_uuid}{server_name}        = $server_name;
		$an->data->{sql}{$server_uuid}{server_stop_reason} = $server_stop_reason;
		$an->data->{sql}{$server_uuid}{server_start_after} = $server_start_after;
		$an->data->{sql}{$server_uuid}{server_start_delay} = $server_start_delay;
		$an->data->{sql}{$server_uuid}{server_note}        = $server_note, 
		$an->data->{sql}{$server_uuid}{server_definition}  = $server_definition, 
		$an->data->{sql}{$server_uuid}{server_host}        = $server_host, 
		$an->data->{sql}{$server_uuid}{server_state}       = $server_state, 
		$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
			name1 => "sql::${server_uuid}::server_name",        value1 => $an->data->{sql}{$server_uuid}{server_name}, 
			name2 => "sql::${server_uuid}::server_stop_reason", value2 => $an->data->{sql}{$server_uuid}{server_stop_reason}, 
			name3 => "sql::${server_uuid}::server_start_after", value3 => $an->data->{sql}{$server_uuid}{server_start_after}, 
			name4 => "sql::${server_uuid}::server_start_delay", value4 => $an->data->{sql}{$server_uuid}{server_start_delay}, 
			name6 => "sql::${server_uuid}::server_note",        value6 => $an->data->{sql}{$server_uuid}{server_note}, 
			name7 => "sql::${server_uuid}::server_definition",  value7 => $an->data->{sql}{$server_uuid}{server_definition}, 
			name8 => "sql::${server_uuid}::server_host",        value8 => $an->data->{sql}{$server_uuid}{server_host}, 
			name9 => "sql::${server_uuid}::server_state",       value9 => $an->data->{sql}{$server_uuid}{server_state}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory", }, message_key => "tools_log_0003", message_variables => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit($exit_code);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "${THIS_FILE}_message_0002"})."\n";

	return(0);
}
