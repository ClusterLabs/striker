#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released under the terms of the GNU GPL 
# version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - Passed in host name was not found in the database.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# NOTE:
#  - 
# 
# TODO: 
#  - Figure out how to handle a definition change seen by one node but not the other (ie: because it was 
#    offline).
#  - Add a check to see if libvirtd is set to start on boot and disable it, if so.
# 

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Text::Diff;

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			cluster_conf		=>	"/etc/cluster/cluster.conf",
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			definitions		=>	"/shared/definitions",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			host_uuid		=>	"/etc/striker/host.uuid",
			libvirtd_socket		=>	"/var/run/libvirt/libvirt-sock", 
			strings			=>	"$running_directory/$THIS_FILE.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			virsh			=>	"/usr/bin/virsh",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-server'		=>	{
			language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_level		=>	2,
			log_language		=>	"en_CA",
		},
		server		=>	{},
		sys		=>	{
			# This will get set by AN::Tools::DB->connect_to_databases()
			sql			=>	[],
			# This is the source name of anything added to 'shared' by this agent.
			shared_source_name	=>	'scan-server', 
			# This is the shared record used in 'shared' to store the XML definition data, 
			# current host and current state.
			shared_definition_name	=>	'definition',
			shared_host_name	=>	'host',
			shared_state_name	=>	'state',
		},
	}
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-server'}{language});
$an->default_log_language($an->data->{'scan-server'}{log_language});
$an->default_log_file    ($an->data->{'scan-server'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-server'}{log_level});

# Read in the language strings.
$an->String->read_words({file => $an->data->{path}{strings}});
$an->String->read_words({file => $an->data->{path}{core_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();

# Don't bother proceeding if there is no cluster.conf.
if (not -e $an->data->{path}{cluster_conf})
{
	nice_exit($an, 1);
}

# If 'libvirtd' isn't running (locally or on the peer, if we can connect to it), exit.
if (not scan_servers($an))
{
	# libvirtd not found, exit.
	nice_exit($an, 1);
}

# Still alive?
print $an->String->get({key => "scan_server_message_0001"})."\n";

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "scancore_log_0005", message_variables => {
	connections	=>	$connections,
}, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { 
		uuid => $an->data->{sys}{host_uuid},
	}, code => 255, file => "$THIS_FILE", line => __LINE__});
}

# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
nice_exit($an, 0);

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This looks for servers locally and on the peer and reads in their data.
sub scan_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will get set to '1' if we find any server info locally or on the peer (if we can find our 
	# peer).
	my $proceed = 0;
	
	# Find out who I am and who my peer is
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cluster_conf},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Only proceed if I am in an Anvil!
	my $local_access = 1;
	if ($an->data->{sys}{anvil_name})
	{
		# First, check for local servers.
		my $shell_call = $an->data->{path}{virsh}." list --all";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^error:/)
			{
				# Not running
				$local_access = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "local_access", value1 => $local_access, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			if ($line =~ /^\d+ (.*?) (.*)$/)
			{
				my $server_name  = $1;
				my $server_state = $2;
				$an->data->{server_name}{$server_name} = {
					host	=>	$an->data->{sys}{local_node},
					'state'	=>	$server_state,
					definition	=>	"",
					uuid		=>	"",
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		
		# Now check the peer.
		my $peer_access = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
			name2 => "target",     value2 => $an->data->{sys}{peer_node},
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{peer_node},
			port		=>	"", 
			password	=>	$an->data->{sys}{anvil_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		foreach my $line (@{$return})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^error:/)
			{
				# Not running
				$peer_access = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_access", value1 => $peer_access, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			if ($line =~ /^\d+ (.*?) (.*)$/)
			{
				my $server_name  = $1;
				my $server_state = $2;
				$an->data->{server_name}{$server_name} = {
					host		=>	$an->data->{sys}{peer_node},
					'state'		=>	$server_state,
					definition	=>	"",
					uuid		=>	"",
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "local_access", value1 => $local_access, 
			name2 => "peer_access",  value2 => $peer_access, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($local_access) or ($peer_access))
		{
			$proceed = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "proceed", value1 => $proceed, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	if ($proceed)
	{
		# If I have local access, see if I can read the XML definition files of any servers NOT found
		# running locally or on the peer.
		if (($local_access) && ($an->data->{path}{definitions}) && (-d $an->data->{path}{definitions}))
		{
			# The directory is there, so look for files.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "path::definitions", value1 => $an->data->{path}{definitions},
			}, file => $THIS_FILE, line => __LINE__});
			local(*DIRECTORY);
			opendir(DIRECTORY, $an->data->{path}{definitions});
			while(my $file = readdir(DIRECTORY))
			{
				if ($file =~ /(.*)\.xml$/)
				{
					my $this_server = $1;
					my $full_path   = $an->data->{path}{definitions}."/".$file;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
						name1 => "file",        value1 => $file,
						name2 => "this_server", value2 => $this_server,
						name3 => "full_path",   value3 => $full_path,
					}, file => $THIS_FILE, line => __LINE__});
					my $already_found = 0;
					foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{server_name}})
					{
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "server_name", value1 => $server_name,
						}, file => $THIS_FILE, line => __LINE__});
						if ($server_name eq $this_server)
						{
							$already_found = 1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "already_found", value1 => $already_found,
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
					
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "already_found", value1 => $already_found,
					}, file => $THIS_FILE, line => __LINE__});
					if (not $already_found)
					{
						# Read in the definition file and record it's data.
						my $definition  = "";
						my $server_uuid = "";
						my $shell_call  = $full_path;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "shell_call", value1 => $shell_call,
						}, file => $THIS_FILE, line => __LINE__});
						open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => "$THIS_FILE", line => __LINE__});
						while(<$file_handle>)
						{
							chomp;
							my $line = $_;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "line", value1 => $line,
							}, file => $THIS_FILE, line => __LINE__});
							$definition .= $line."\n";
							
							if ($line =~ /<uuid>([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})<\/uuid>/)
							{
								$server_uuid = $1;
								$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
									name1 => "server_uuid", value1 => $server_uuid, 
								}, file => $THIS_FILE, line => __LINE__});
							}
						}
						# Record it if we found the UUID.
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "server_uuid", value1 => $server_uuid, 
						}, file => $THIS_FILE, line => __LINE__});
						if ($server_uuid)
						{
							# We're not setting the host or state because we 
							# don't know if it's running on another Anvil!.
							$an->data->{server_uuid}{$server_uuid} = {
								name		=>	$this_server,
								host		=>	"",
								'state'		=>	"",
								definition	=>	$definition,
							};
						}
					}
				}
			}
			close DIRECTORY;
		}
		
		# Now gather the details on the servers.
		foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{server_name}})
		{
			my $server_host  = $an->data->{server_name}{$server_name}{host};
			my $server_state = $an->data->{server_name}{$server_name}{'state'};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
				name1 => "server_name",     value1 => $server_name, 
				name2 => "server_host",     value2 => $server_host, 
				name3 => "server_state",    value3 => $server_state, 
				name4 => "sys::local_node", value4 => $an->data->{sys}{local_node}, 
				name5 => "sys::peer_node",  value5 => $an->data->{sys}{peer_node}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $server_xml = "";
			my $shell_call = "virsh dumpxml $server_name";
			if ($server_host eq $an->data->{sys}{local_node})
			{
				# Locally hosted, call virsh directly
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					$server_xml .= "$line\n";
				}
				close $file_handle;
			}
			elsif ($server_host eq $an->data->{sys}{peer_node})
			{
				# Remote, call over SSH.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "shell_call", value1 => $shell_call,
					name2 => "target",     value2 => $an->data->{sys}{peer_node},
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target		=>	$server_host,
					port		=>	"", 
					password	=>	$an->data->{sys}{anvil_password},
					ssh_fh		=>	"",
					'close'		=>	0,
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					$server_xml .= "$line\n";
				}
			}
			$an->data->{server_name}{$server_name}{definition} = $server_xml;
			
			# Dig out details now.
			foreach my $line (split/\n/, $server_xml)
			{
				if ($line =~ /<uuid>([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})<\/uuid>/)
				{
					$an->data->{server_name}{$server_name}{uuid} = $1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "server_name::${server_name}::uuid", value1 => $an->data->{server_name}{$server_name}{uuid}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			# Now that I have the UUID, record the details using the UUID as the key
			my $server_uuid = $an->data->{server_name}{$server_name}{uuid};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "server_uuid", value1 => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($server_uuid)
			{
				$an->data->{server_uuid}{$server_uuid} = {
					name		=>	$server_name,
					host		=>	$an->data->{server_name}{$server_name}{host},
					'state'		=>	$an->data->{server_name}{$server_name}{'state'},
					definition	=>	$an->data->{server_name}{$server_name}{definition},
				};
			}
			else
			{
				die "$THIS_FILE ".__LINE__."; There should be a server UUID here...\n";
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "proceed", value1 => $proceed, 
	}, file => $THIS_FILE, line => __LINE__});
	return($proceed);
}

# This looks at each DB's 'updated' table to see if any are behind. If any are, it will update the tables 
# based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		update_db_server($an);
	}
	
	return(0);
}

# Update the 'server' table.
sub update_db_server
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_server", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'server' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    server_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_group, 
    server_start_delay, 
    modified_date 
FROM 
    history.server
WHERE
    server_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $server_uuid        = $row->[0];
			my $server_name        = $row->[1];
			my $server_stop_reason = $row->[2];
			my $server_start_group = $row->[3];
			my $server_start_delay = $row->[4];
			my $modified_date      = $row->[5];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "server_uuid",        value1 => $server_uuid, 
				name2 => "server_name",        value2 => $server_name, 
				name3 => "server_stop_reason", value3 => $server_stop_reason, 
				name4 => "server_start_group", value4 => $server_start_group, 
				name5 => "server_start_delay", value5 => $server_start_delay, 
				name6 => "modified_date",      value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{server}{modified_date}{$modified_date}{server_uuid}{$server_uuid} = {
				server_name		=>	$server_name, 
				server_stop_reason	=>	$server_stop_reason, 
				server_start_group	=>	$server_start_group, 
				server_start_delay	=>	$server_start_delay, 
			};
			$an->data->{db_data}{$id}{server}{server_uuid}{$server_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{server}{server_uuid}{$server_uuid}{seen}     = 0;
			# Record the values from this DB
			$an->data->{db_data}{$id}{server}{modified_date}{$modified_date}{server_uuid}{$server_uuid} = {
				server_name		=>	$server_name, 
				server_stop_reason	=>	$server_stop_reason, 
				server_start_group	=>	$server_start_group, 
				server_start_delay	=>	$server_start_delay, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	my $first_record = 1;
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{server}{modified_date}})
	{
		my $server_uuid        = $an->data->{db_data}{unified}{server}{modified_date}{$modified_date}{server_uuid};
		my $server_name        = $an->data->{db_data}{unified}{server}{modified_date}{$modified_date}{server_name};
		my $server_stop_reason = $an->data->{db_data}{unified}{server}{modified_date}{$modified_date}{server_stop_reason};
		my $server_start_group = $an->data->{db_data}{unified}{server}{modified_date}{$modified_date}{server_start_group};
		my $server_start_delay = $an->data->{db_data}{unified}{server}{modified_date}{$modified_date}{server_start_delay};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
			name1 => "modified_date",      value1 => $modified_date, 
			name2 => "server_uuid",        value2 => $server_uuid, 
			name3 => "server_name",        value3 => $server_name, 
			name4 => "server_stop_reason", value4 => $server_stop_reason, 
			name5 => "server_start_group", value5 => $server_start_group, 
			name6 => "server_start_delay", value6 => $server_start_delay, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
		{
			# If this is the first record, then a little consideration is needed... One of three
			# things can happen;
			# 1. The record doesn't exist at all, INSERT
			# 2. The record exists, but is old. UPDATE
			# 3. The record exists and is up to date, ignore it.
			# Case 1 & 2 go to the public schema.
			# 
			# All other records are written directly to the history schema as needed.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "id", value1 => $id,
			}, file => $THIS_FILE, line => __LINE__});
			my $query = "";
			if ($first_record)
			{
				# Do we have a server record?
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::server::exists", value1 => $an->data->{db_data}{$id}{server}{'exists'},
				}, file => $THIS_FILE, line => __LINE__});
				if ($an->data->{db_data}{$id}{server}{'exists'})
				{
					# Yup. Is the most recent instance in this database though?
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::server::modified_date::${modified_date}", value1 => $an->data->{db_data}{$id}{server}{modified_date}{$modified_date},
					}, file => $THIS_FILE, line => __LINE__});
					if (not $an->data->{db_data}{$id}{server}{modified_date}{$modified_date})
					{
						# No it doesn't, so we need to UPDATE the public schema to 
						# get it up to date (the trigger will copy it into the 
						# history schema).
						$query = "
UPDATE 
    public.server
SET
    server_name          = ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    server_stop_reason   = ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    server_start_group   = ".$an->data->{sys}{use_db_fh}->quote($server_start_group).", 
    server_start_delay   = ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    modified_date        = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    server_host_uuid    = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND
    server_uuid         = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
;";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# There is no 'server' in the databases at all, so add it.
					$query = "
INSERT INTO 
    public.server
(
    server_uuid, 
    server_host_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_group, 
    server_start_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_group).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
					# Now record the query in the array
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "id",    value1 => $id, 
						name2 => "query", value2 => $query
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
				}
			}
			
			# Proceed if the query isn't set yet.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query,
			}, file => $THIS_FILE, line => __LINE__});
			if (not $query)
			{
				# No query yet. Do we need to add this record to this databases?
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::server::modified_date::${modified_date}", value1 => $an->data->{db_data}{$id}{server}{modified_date}{$modified_date},
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{server}{modified_date}{$modified_date})
				{
					# Insert it.
					$query = "
INSERT INTO 
    history.server
(
    server_uuid, 
    server_host_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_group, 
    server_start_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_group).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
					# Now record the query in the array
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "id",    value1 => $id, 
						name2 => "query", value2 => $query
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
				}
			}
		} # foreach my $id 
		$first_record = 0;
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load the schema. If the schema gets
# loaded, we'll check other databases for older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => "$THIS_FILE" }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='server' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through each server
	foreach my $server_uuid (sort {$a cmp $b} keys %{$an->data->{server_uuid}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "server_uuid", value1 => $server_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		die "$THIS_FILE ".__LINE__."; Missing server UUID\n" if not $server_uuid;
		
		if (read_last_scan($an, $server_uuid))
		{
			### Existing server, UPDATE or INSERT as needed.
			# NOTE: For now, we only catch name changes here.
			# New values
			my $new_server_name = $an->data->{server_uuid}{$server_uuid}{name};
			
			# Old values
			my $old_server_name = $an->data->{sql}{$server_uuid}{server_name};
			
			# Diff?
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "old_server_name", value1 => $old_server_name, 
				name2 => "new_server_name", value2 => $new_server_name, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($new_server_name) && ($new_server_name ne $old_server_name))
			{
				# New server name. Neat!
				my $query = "
UPDATE 
    server 
SET 
    server_name = ".$an->data->{sys}{use_db_fh}->quote($new_server_name)." 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
AND 
    server_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# This should be a rare event, so it in a notice-level alert.
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_agent_name	=>	"$THIS_FILE",
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_server_message_0006",
					alert_message_variables	=>	{
						old			=>	$old_server_name, 
						new			=>	$new_server_name,
					},
				});
			}
		}
		else
		{
			# New server, INSERT everything.
			my $server_name        = $an->data->{server_uuid}{$server_uuid}{name};
			my $server_stop_reason = "";
			my $server_start_group = 1;
			my $server_start_delay = 0;
			# These go into 'shared'
			my $server_host        = $an->data->{server_uuid}{$server_uuid}{host};
			my $server_state       = $an->data->{server_uuid}{$server_uuid}{'state'};
			my $server_definition  = $an->data->{server_uuid}{$server_uuid}{definition};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "server_uuid",        value1 => $server_uuid, 
				name2 => "server_name",        value2 => $server_name, 
				name3 => "server_stop_reason", value3 => $server_stop_reason, 
				name4 => "server_start_group", value4 => $server_start_group, 
				name5 => "server_start_delay", value5 => $server_start_delay, 
				name6 => "server_host",        value6 => $server_host, 
				name7 => "server_definition",  value7 => $server_definition, 
				name8 => "server_state",       value8 => $server_state, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $query = "
INSERT INTO 
    server 
(
    server_uuid, 
    server_host_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_group, 
    server_start_delay, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
    ".$an->data->{sys}{use_db_fh}->quote($server_name).",  
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).",  
    ".$an->data->{sys}{use_db_fh}->quote($server_start_group).",  
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# A 'start_group' of '9999' means that the server will not be booted. As such, a 
			# string is returned instead of the value if appropriate.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"scan_server_message_0003",
				alert_title_variables	=>	{
					name			=>	$server_name,
				},
				alert_message_key	=>	"scan_server_message_0004",
				alert_message_variables	=>	{
					uuid			=>	$server_uuid, 
					start_group		=>	$server_start_group eq "9999" ? "#!string!scan_server_message_0005!#" : $server_start_group, 
					start_delay		=>	$server_start_delay, 
					host			=>	$server_host, 
					'state'			=>	$server_state, 
				},
			});
		}
		
		### NOTE: Despite the server possibly being new, there could be records in 'shared' for this 
		###       server from another source. So we need to check and see if the shared data exists
		###       in all cases.
		my $shared_definition_name = $an->data->{sys}{shared_definition_name};
		my $shared_host_name       = $an->data->{sys}{shared_host_name};
		my $shared_state_name      = $an->data->{sys}{shared_state_name};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "shared_definition_name", value1 => $shared_definition_name, 
			name2 => "shared_host_name",       value2 => $shared_host_name, 
			name3 => "shared_state_name",      value3 => $shared_state_name, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### Definition File
		# Only proceed if we have a definition file and it appears to contain the complete definition
		# file.
		if ((exists $an->data->{sql}{$server_uuid}{shared_name}{$shared_definition_name}) && ($an->data->{sql}{$server_uuid}{shared_name}{$shared_definition_name}{shared_data} =~ /<\/domain>/g))
		{
			# We know about this definition, so see if we need to UPDATE it.
			my $shared_uuid           = $an->data->{sql}{$server_uuid}{shared_name}{$shared_definition_name}{shared_uuid};
			my $old_server_definition = $an->data->{sql}{$server_uuid}{shared_name}{$shared_definition_name}{shared_data};
			my $server_definition     = $an->data->{server_uuid}{$server_uuid}{definition};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "shared_uuid",           value1 => $shared_uuid, 
				name2 => "old_server_definition", value2 => $old_server_definition, 
				name3 => "server_definition",     value3 => $server_definition, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($old_server_definition ne $server_definition)
			{
				# The definition has changed (no surprise, being a new host) so UPDATE. Note
				# that we've got the UUID so we don't need to specify the shared name or 
				# whatnot.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "old_server_definition", value1 => $old_server_definition, 
					name2 => "server_definition",     value2 => $server_definition, 
				}, file => $THIS_FILE, line => __LINE__});
				my $query = "
UPDATE 
    shared 
SET 
    shared_data = ".$an->data->{sys}{use_db_fh}->quote($server_definition)." 
WHERE 
    shared_uuid = ".$an->data->{sys}{use_db_fh}->quote($shared_uuid)."
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# This is an info level alert as it changes frequently
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_agent_name	=>	"$THIS_FILE",
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_server_message_0007",
					alert_message_variables	=>	{
						server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
						new			=>	$server_definition,
						diff			=>	diff \$old_server_definition, \$server_definition, { STYLE => 'Unified' },
					},
				});
			}
		}
		elsif ($an->data->{server_uuid}{$server_uuid}{definition})
		{
			# Nope, this is new, too, so INSERT it.
			my $shared_uuid        = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
			my $server_definition  = $an->data->{server_uuid}{$server_uuid}{definition};
			my $shared_source_name = $an->data->{sys}{shared_source_name};
			my $query              = "
INSERT INTO 
    shared 
(
    shared_uuid, 
    shared_source_name, 
    shared_record_locator, 
    shared_name, 
    shared_data, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($shared_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($shared_source_name).",
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($shared_definition_name).",
    ".$an->data->{sys}{use_db_fh}->quote($server_definition).",
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Send an alert (it will almost certainly be with a new server alert as well).
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scan_server_message_0006",
				alert_message_variables	=>	{
					server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
					new			=>	$server_definition,
				},
			});
		}
		
		### Current Host 
		# Now the host, but only proceed if we have a defined host.
		if ((exists $an->data->{sql}{$server_uuid}{shared_name}{$shared_host_name}) && ($an->data->{sql}{$server_uuid}{shared_name}{$shared_host_name}{shared_data}))
		{
			# We know about this host, so see if we need to UPDATE it.
			my $shared_uuid     = $an->data->{sql}{$server_uuid}{shared_name}{$shared_host_name}{shared_uuid};
			my $old_server_host = $an->data->{sql}{$server_uuid}{shared_name}{$shared_host_name}{shared_data};
			my $server_host     = $an->data->{server_uuid}{$server_uuid}{host};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "shared_uuid",     value1 => $shared_uuid, 
				name2 => "old_server_host", value2 => $old_server_host, 
				name3 => "server_host",     value3 => $server_host, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($old_server_host ne $server_host)
			{
				# The host has changed, so UPDATE.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "old_server_host", value1 => $old_server_host, 
					name2 => "server_host",     value2 => $server_host, 
				}, file => $THIS_FILE, line => __LINE__});
				my $query = "
UPDATE 
    shared 
SET 
    shared_data = ".$an->data->{sys}{use_db_fh}->quote($server_host)." 
WHERE 
    shared_uuid = ".$an->data->{sys}{use_db_fh}->quote($shared_uuid)."
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
			
			# This is an info level alert as it changes frequently
			$an->Alert->register_alert({
				alert_level		=>	"info", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0002",
				alert_message_key	=>	"scan_server_message_0008",
				alert_message_variables	=>	{
					server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
					new			=>	$server_host,
					old			=>	$old_server_host,
				},
			});
		}
		elsif ($an->data->{server_uuid}{$server_uuid}{host})
		{
			# Nope, this is new, too, so INSERT it.
			my $shared_uuid        = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
			my $server_host  = $an->data->{server_uuid}{$server_uuid}{host};
			my $shared_source_name = $an->data->{sys}{shared_source_name};
			my $query              = "
INSERT INTO 
    shared 
(
    shared_uuid, 
    shared_source_name, 
    shared_record_locator, 
    shared_name, 
    shared_data, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($shared_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($shared_source_name).",
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($shared_host_name).",
    ".$an->data->{sys}{use_db_fh}->quote($server_host).",
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Send an alert (it will almost certainly be with a new server alert as well).
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scan_server_message_0009",
				alert_message_variables	=>	{
					server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
					new			=>	$server_host,
				},
			});
		}
		
		### Current State
		# Now the host, but only proceed if we have a defined host.
		if ((exists $an->data->{sql}{$server_uuid}{shared_name}{$shared_state_name}) && ($an->data->{sql}{$server_uuid}{shared_name}{$shared_state_name}{shared_data}))
		{
			# We know about this state, so see if we need to UPDATE it.
			my $shared_uuid      = $an->data->{sql}{$server_uuid}{shared_name}{$shared_state_name}{shared_uuid};
			my $old_server_state = $an->data->{sql}{$server_uuid}{shared_name}{$shared_state_name}{shared_data};
			my $server_state     = $an->data->{server_uuid}{$server_uuid}{host};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "shared_uuid",     value1 => $shared_uuid, 
				name2 => "old_server_state", value2 => $old_server_state, 
				name3 => "server_state",     value3 => $server_state, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($old_server_state ne $server_state)
			{
				# The host has changed, so UPDATE.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "old_server_state", value1 => $old_server_state, 
					name2 => "server_state",     value2 => $server_state, 
				}, file => $THIS_FILE, line => __LINE__});
				my $query = "
UPDATE 
    shared 
SET 
    shared_data = ".$an->data->{sys}{use_db_fh}->quote($server_state)." 
WHERE 
    shared_uuid = ".$an->data->{sys}{use_db_fh}->quote($shared_uuid)."
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
			
			# This is an info level alert as it changes frequently
			$an->Alert->register_alert({
				alert_level		=>	"info", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0002",
				alert_message_key	=>	"scan_server_message_0010",
				alert_message_variables	=>	{
					server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
					new			=>	$server_state,
					old			=>	$old_server_state,
				},
			});
		}
		elsif ($an->data->{server_uuid}{$server_uuid}{host})
		{
			# Nope, this is new, too, so INSERT it.
			my $shared_uuid        = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
			my $server_state       = $an->data->{server_uuid}{$server_uuid}{'state'};
			my $shared_source_name = $an->data->{sys}{shared_source_name};
			my $query              = "
INSERT INTO 
    shared 
(
    shared_uuid, 
    shared_source_name, 
    shared_record_locator, 
    shared_name, 
    shared_data, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($shared_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($shared_source_name).",
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).",
    ".$an->data->{sys}{use_db_fh}->quote($shared_state_name).",
    ".$an->data->{sys}{use_db_fh}->quote($server_state).",
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Send an alert (it will almost certainly be with a new server alert as well).
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scan_server_message_0011",
				alert_message_variables	=>	{
					server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
					new			=>	$server_state,
				},
			});
		}
	}
	
	# Now commit the changes.
	commit_sql($an);
	
	return(0);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an, $server_uuid) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "server_uuid", value1 => "$server_uuid" 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Couple of variables to make the code cleaner
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "id",        value1 => $id, 
		name2 => "host_name", value2 => $host_name, 
	}, file => $THIS_FILE, line => __LINE__});

	# This calls up the entry for this host. If no entry is found, 'new' gets set to '1' and the main 
	# function won't bother looking for changes and directly INSERT the scanned data.
	my $query = "
SELECT 
    server_name, 
    server_stop_reason, 
    server_start_group, 
    server_start_delay 
FROM 
    server 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)."
AND 
    server_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query});
	my $count   = @{$results};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $server_name        = $row->[0];
		my $server_stop_reason = $row->[1];
		my $server_start_group = $row->[2];
		my $server_start_delay = $row->[3];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "server_uuid",        value1 => $server_uuid, 
			name2 => "server_name",        value2 => $server_name, 
			name3 => "server_stop_reason", value3 => $server_stop_reason, 
			name4 => "server_start_group", value4 => $server_start_group, 
			name5 => "server_start_delay", value5 => $server_start_delay, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Push the data into the hash for later comparison
		$an->data->{sql}{$server_uuid}{server_name}        = $server_name;
		$an->data->{sql}{$server_uuid}{server_stop_reason} = $server_stop_reason;
		$an->data->{sql}{$server_uuid}{server_start_group} = $server_start_group;
		$an->data->{sql}{$server_uuid}{server_start_delay} = $server_start_delay;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "sql::${server_uuid}::server_name",        value1 => $an->data->{sql}{$server_uuid}{server_name}, 
			name2 => "sql::${server_uuid}::server_stop_reason", value2 => $an->data->{sql}{$server_uuid}{server_stop_reason}, 
			name3 => "sql::${server_uuid}::server_start_group", value3 => $an->data->{sql}{$server_uuid}{server_start_group}, 
			name4 => "sql::${server_uuid}::server_start_delay", value4 => $an->data->{sql}{$server_uuid}{server_start_delay}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### NOTE: If 'count' is 0, we'll need to INSERT but that doesn't mean there isn't data in 'shared' 
	###       for this server. So we check explicitely for data in shared regardless.
	$results = "";
	$query   = "
SELECT 
    shared_uuid, 
    shared_name, 
    shared_data 
FROM 
    shared 
WHERE 
    shared_source_name = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{shared_source_name})."
AND 
    shared_record_locator = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	$results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $shared_uuid           = $row->[0];
		my $shared_name           = $row->[1];
		my $shared_data           = $row->[2];
		### NOTE: The log entries here are set to '3' because the XML definition is big and grows the
		###       log too quickly.
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "shared_uuid", value1 => $shared_uuid, 
			name2 => "shared_name", value2 => $shared_name, 
			name3 => "shared_data", value3 => $shared_data, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Push the data into the hash for later comparison
		$an->data->{sql}{$server_uuid}{shared_name}{$shared_name}{shared_uuid} = $shared_uuid;
		$an->data->{sql}{$server_uuid}{shared_name}{$shared_name}{shared_data} = $shared_data;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "sql::${server_uuid}::shared_name::${shared_name}::shared_uuid", value1 => $an->data->{sql}{$server_uuid}{shared_name}{$shared_name}{shared_uuid}, 
			name2 => "sql::${server_uuid}::shared_name::${shared_name}::shared_data", value2 => $an->data->{sql}{$server_uuid}{shared_name}{$shared_name}{shared_data}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	return($count);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory", }, message_key => "tools_log_0003", message_variables => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit($exit_code);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "${THIS_FILE}_message_0002"})."\n";

	return(0);
}
