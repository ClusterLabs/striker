#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released under the terms of the GNU GPL 
# version 2.
#
# https://alteeve.com
# 
# Exit Codes:
# 0   - Success
# 1   - Passed in host name was not found in the database.
# 2   - Lost contact with the peer.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# NOTE:
#  - This agent monitors servers, which are NOT tagged to hosts. So it doesn't load or update schemas on its
#    own.
# 
# TODO: 
#  - Check each pass if the server is running and, if so, update /shared/definition. Do this before looking
#    for changes!
#  - Add a 'maintenance mode' where the VM is no longer monitored by the cluster. When in maintenance mode,
#    we will not touch it. Otherwise, if it is found to be running on a node but not in clustat, use 
#    clusvcadm to add it to the cluster control.
#  - Hit a case where rgmanager THOUGHT a server was running fine on a node, when it wasn't running anywhere.
#    Check for this state and stop the service is it happens.
# 

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Text::Diff;
no warnings 'recursion';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			strings			=>	"$running_directory/$THIS_FILE.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-server'		=>	{
			disable			=>	0,
			language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_level		=>	2,
			log_language		=>	"en_CA",
			log_db_transactions	=>	0,
		},
		scancore		=>	{
			archive			=>	{
				directory		=>	"/var/ScanCore/archives/",
				division		=>	25000,
				trigger			=>	20000,
				count			=>	10000,
				dump_file_header	=>	"
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = history, pg_catalog;
",
			},
		},
		server		=>	{},
		shut_off	=>	{},
		sys		=>	{
			'default'	=>	{
				migration_type	=>	"live",
			},
			# When a lock is requested, this is set to the time the lock was set. 
			# DB->do_db_write() and DB->do_db_read() will check this and if its age is >50% of
			# scancore::locking::reap_age, it will renew the lock.
			local_lock_active	=>	0,
			# This will get set by AN::Tools::DB->connect_to_databases()
			sql			=>	[],
			# This is the source name of anything added to 'shared' by this agent.
			shared_source_name	=>	'scan-server', 
			# This is the shared record used in 'shared' to store the XML definition data, 
			# current host and current state.
			shared_definition_name	=>	'definition',
			shared_host_name	=>	'host',
			shared_state_name	=>	'state',
		},
	}
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-server'}{language});
$an->default_log_language($an->data->{'scan-server'}{log_language});
$an->default_log_file    ($an->data->{'scan-server'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-server'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-server'}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

# Help?
if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or
    ($an->data->{switches}{help}))
{
	# Help!
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Exit if we're disabled.
if ($an->data->{'scan-server'}{disable})
{
	$an->nice_exit({exit_code => 1});
}

print $an->String->get({key => "scan_server_message_0001"})."\n";

# Don't bother proceeding if there is no cluster.conf.
if (not -e $an->data->{path}{cman_config})
{
	$an->nice_exit({exit_code => 1});
}

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "notice_message_0013", message_variables => { connections => $connections }, file => $THIS_FILE, line => __LINE__});

# If 'libvirtd' isn't running (locally or on the peer, if we can connect to it), exit.
if (not scan_servers($an))
{
	# libvirtd not found, exit.
	$an->nice_exit({exit_code => 1});
}

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { 
		uuid => $an->data->{sys}{host_uuid},
	}, code => 255, file => $THIS_FILE, line => __LINE__});
}

### NOTE: The servers table is sync'ed in ScanCore proper.

# Look for changes.
find_changes($an);

# This checks to ensure that libvirtd is not set to start on boot, which can be set after an OS update.
check_libvirtd($an);

# This makes sure that the pre/post migration scripts and inserted ISO disk images exist in /shared/files/ 
# still and removed/ejects them, if not.
check_for_removed_files($an);

# This looks for defined servers that are powered off.
check_for_defined_servers($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This looks for any servers in the 'shut off' state and, if they're defined in /shared/definitions, they are
# undefined.
sub check_for_defined_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_for_defined_servers" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{shut_off}})
	{
		my $server_definition = $an->data->{path}{shared_definitions}."/".$server_name.".xml";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "server_definition", value1 => $server_definition, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (-e $server_definition)
		{
			# Dump the definition to a backup file.
			my $backup_file =  $an->data->{path}{shared_archive}."/".$server_name.".pre-undefine.".$an->Get->date_and_time({split_date_time => 0, no_spaces => 1}).".xml";
			   $backup_file =~ s/:/-/g;
			my $shell_call  =  $an->data->{path}{virsh}." dumpxml $server_name > $backup_file";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			# Make sure the backup is good.
			my $proceed = 0;
			if (-e $backup_file)
			{
				my $shell_call = "
if \$(".$an->data->{path}{'grep'}." -q '</domain>' $backup_file)
then
    echo ok
else
    echo 'bad dump'
fi";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					
					if ($line eq "ok")
					{
						$proceed = 1;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "proceed", value1 => $proceed, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
				close $file_handle;
			}
			
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "proceed", value1 => $proceed, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($proceed)
			{
				my $shell_call  = $an->data->{path}{virsh}." undefine $server_name";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
				
				# Send the alert. It should be top of the email, except behind a stuck-paused
				# server.
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_sort		=>	2,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0004",
					alert_message_key	=>	"scan_server_message_0023",
					alert_message_variables	=>	{
						server			=>	$server_name, 
						backup			=>	$backup_file,
					},
				});
			}
		}
	}
	
	return(0);
}

### TODO: Verify this isn't corrupting the XML definition file
# This makes sure that the pre/post migration scripts and inserted ISO disk images exist in /shared/files/ 
# still and removed/ejects them, if not.
sub check_for_removed_files
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_for_removed_files" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This should only ever run on a node in an Anvil!.
	$an->data->{scancore}{i_am_a} = $an->Get->what_am_i();
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ((not -e $an->data->{path}{shared_files}) or ($an->data->{scancore}{i_am_a} ne "node"))
	{
		return(1);
	}
	
	### Still alive?
	# Get the Anvil! data.
	my $anvil_name = $an->data->{sys}{anvil_name};
	my $anvil_uuid = $an->data->{sys}{anvil_uuid};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "anvil_name", value1 => $anvil_name, 
		name2 => "anvil_uuid", value2 => $anvil_uuid, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get a list of files
	my ($files, $partition) = $an->Get->shared_files();
	foreach my $file (sort {$a cmp $b} keys %{$files})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0012", message_variables => {
			name1  => "${file}::type",       value1  => $files->{$file}{type},
			name2  => "${file}::mode",       value2  => $files->{$file}{mode},
			name3  => "${file}::owner",      value3  => $files->{$file}{user},
			name4  => "${file}::group",      value4  => $files->{$file}{group},
			name5  => "${file}::size",       value5  => $files->{$file}{size},
			name6  => "${file}::modified",   value6  => $files->{$file}{month},
			name7  => "${file}::day",        value7  => $files->{$file}{day},
			name8  => "${file}::time",       value8  => $files->{$file}{'time'},
			name9  => "${file}::year",       value9  => $files->{$file}{year},
			name10 => "${file}::target",     value10 => $files->{$file}{target},
			name11 => "${file}::optical",    value11 => $files->{$file}{optical},
			name12 => "${file}::executable", value12 => $files->{$file}{executable},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### NOTE: For now, we don't delete pre/post migration scripts as them missing isn't critical.
	### NOTE: We will use on-disk XML as that is most relevant for booting, which is where missing files
	###       are a problem.
	# Now loop through each server on this Anvil! and parse their XML files to see if they have a mounted
	# ISO that no longer exists. If so, eject it.
	my $server_data = $an->ScanCore->get_servers();
	foreach my $hash_ref (@{$server_data})
	{
		my $server_uuid                     = $hash_ref->{server_uuid};
		my $server_name                     = $hash_ref->{server_name};
		my $server_pre_migration_script     = $hash_ref->{server_pre_migration_script};
		my $server_pre_migration_arguments  = $hash_ref->{server_pre_migration_arguments};
		my $server_post_migration_script    = $hash_ref->{server_post_migration_script};
		my $server_post_migration_arguments = $hash_ref->{server_post_migration_arguments};
		my $server_anvil_uuid               = $hash_ref->{server_anvil_uuid};
		my $server_host                     = $hash_ref->{server_host};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "server_uuid",                     value1 => $server_uuid,
			name2 => "server_name",                     value2 => $server_name,
			name3 => "server_pre_migration_script",     value3 => $server_pre_migration_script,
			name4 => "server_pre_migration_arguments",  value4 => $server_pre_migration_arguments,
			name5 => "server_post_migration_script",    value5 => $server_post_migration_script,
			name6 => "server_post_migration_arguments", value6 => $server_post_migration_arguments,
			name7 => "server_anvil_uuid",               value7 => $server_anvil_uuid,
			name8 => "server_host",                     value8 => $server_host,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Skip this server if it isn't on this Anvil!.
		next if $anvil_uuid ne $server_anvil_uuid;
		
		# Skip this server if it wasn't found locally.
		if (($server_uuid) && (not exists $an->data->{server_uuid}{$server_uuid}{name}))
		{
			$an->Log->entry({log_level => 2, message_key => "scan_server_message_0015", message_variables => { 
				server_name => $server_name, 
				server_uuid => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# Get the on-disk XML.
		my $definition_file = $an->data->{path}{shared_definitions}."/".$server_name.".xml";
		if (not -e $definition_file)
		{
			# No sense proceeding.
			$an->Log->entry({log_level => 2, message_key => "scan_server_message_0016", message_variables => { 
				server_name     => $server_name, 
				definition_file => $definition_file, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		my $server_definition = "";
		my $on_disk_xml       = "";
		my $shell_call        = $definition_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line,
			}, file => $THIS_FILE, line => __LINE__});
			
			$on_disk_xml .= $line."\n";
			if ($line =~ /<\/domain>/)
			{
				# Looks like we got the XML properly
				$server_definition = $on_disk_xml;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "server_definition", value1 => $server_definition, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# Did I read the file successfully?
		if (not $server_definition)
		{
			# Nope.
			$an->Log->entry({log_level => 2, message_key => "scan_server_message_0017", message_variables => { 
				server_name     => $server_name, 
				definition_file => $definition_file, 
			}, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# OK, now look for mounted ISOs. 
		my $in_cdrom    = 0;
		my $this_device = "";
		my $do_eject    = 0;
		my $file        = "";
		foreach my $line (split/\n/, $server_definition)
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (($line =~ /type='file'/) && ($line =~ /device='cdrom'/))
			{
				# Found an optical disk (DVD/CD).
				$in_cdrom = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "in_cdrom", value1 => $in_cdrom, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($in_cdrom)
			{
				if ($line =~ /<\/disk>/)
				{
					# Done. Eject if needed.
					$in_cdrom = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "in_cdrom", value1 => $in_cdrom, 
						name2 => "do_eject", value2 => $do_eject, 
					}, file => $THIS_FILE, line => __LINE__});
					
					if ($do_eject)
					{
						# I don't have a scanned Anvil!, so I need to directly see if
						# the server is running or not.
						my $server_is_running = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "server_host", value1 => $server_host,
						}, file => $THIS_FILE, line => __LINE__});
						if ($server_host)
						{
							# Read the current server config from virsh.
							$server_is_running = 1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "server_is_running", value1 => $server_is_running,
							}, file => $THIS_FILE, line => __LINE__});
						}
						
						# This method was originally designed for use via web apps, 
						# so we need to set a few CGI variables.
						$an->data->{cgi}{anvil_uuid} = $server_anvil_uuid;
						$an->data->{cgi}{server}     = $server_name;
						$an->data->{cgi}{device}     = $this_device;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
							name1 => "cgi::anvil_uuid", value1 => $an->data->{cgi}{anvil_uuid}, 
							name2 => "cgi::server",     value2 => $an->data->{cgi}{server}, 
							name3 => "cgi::device",     value3 => $an->data->{cgi}{device}, 
						}, file => $THIS_FILE, line => __LINE__});
						
						$an->Striker->_server_eject_media({
							server_is_running => $server_is_running,
							quiet             => 1,
						});
						
						# Register an alert
						$an->Alert->register_alert({
							alert_level		=>	"warning", 
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	"an_alert_title_0004",
							alert_message_key	=>	"scan_server_message_0014",
							alert_message_variables	=>	{
								server			=>	$server_name, 
								file			=>	$file,
							},
						});
					}
					$do_eject    = 0;
					$this_device = "";
					$file        = "";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
						name1 => "do_eject",    value1 => $do_eject, 
						name2 => "this_device", value2 => $this_device, 
						name3 => "file",        value3 => $file, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				if ($line =~ /dev='(.*?)'/)
				{
					# Found the device.
					$this_device = $1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "this_device", value1 => $this_device, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($line =~ /file='(.*?)'\/>/)
				{
					# Found media
					$file = $1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "file", value1 => $file, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Take the path off.
					my $shared_files = $an->data->{path}{shared_files};
					$file =~ s/^$shared_files\///;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "shared_files", value1 => $shared_files, 
						name2 => "file",         value2 => $file, 
					}, file => $THIS_FILE, line => __LINE__});
					
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "files->{$file}{type}", value1 => $files->{$file}{type}, 
					}, file => $THIS_FILE, line => __LINE__});
					if (not $files->{$file}{type})
					{
						# Eject this disk
						$do_eject = 1;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "do_eject", value1 => $do_eject, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
		}
	}
	
	return(0);
}

# This checks to ensure that libvirtd is not set to start on boot, which can be set after an OS update.
sub check_libvirtd
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_libvirtd" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $state = $an->System->daemon_boot_config({daemon => "libvirtd"});
	my $rc3   = $state->{3};
	my $rc5   = $state->{5};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "rc3", value1 => $rc3, 
		name2 => "rc5", value2 => $rc5, 
	}, file => $THIS_FILE, line => __LINE__});
	if (($rc3 eq "on") or ($rc5 eq "on"))
	{
		# Turn it off.
		$an->Log->entry({log_level => 1, message_key => "scan_server_log_0001", message_variables => {
			'3' => $rc3, 
			'5' => $rc5, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $state = $an->System->daemon_boot_config({
				daemon => "libvirtd",
				set    => "off",
			});
		my $rc3   = $state->{3};
		my $rc5   = $state->{5};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "rc3", value1 => $rc3, 
			name2 => "rc5", value2 => $rc5, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

### NOTE: This has caused more concern than it has helped. It's fired during live migrations (thankfully to
###       no effect). Disabling it.
# This tries to resume a 'paused' server, which can happen sometimes when rgmanager tries to start a server.
sub resume_server
{
	my ($an, $server_name) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "resume_server" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "server_name", value1 => "$server_name" 
	}, file => $THIS_FILE, line => __LINE__});
	
	return(0);
	
	my $server_state = "";
	my $force_reset  = 0;
	my $shell_call   = $an->data->{path}{virsh}." resume $server_name";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /Resetting the Virtual Machine is required/)
		{
			$force_reset = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "force_reset", value1 => $force_reset, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "force_reset", value1 => $force_reset, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($force_reset)
	{
		my $shell_call   = $an->data->{path}{virsh}." destroy $server_name";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Send an alert, and make sure it's top of the email.
		$an->Alert->register_alert({
			alert_level		=>	"critical", 
			alert_sort		=>	1,
			alert_agent_name	=>	$THIS_FILE,
			alert_title_key		=>	"an_alert_title_0005",
			alert_message_key	=>	"scan_server_message_0024",
			alert_message_variables	=>	{
				server_name		=>	$server_name, 
			},
		});
	}
	
	# If I didn't reset it, look at it's current state.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "force_reset", value1 => $force_reset, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not $force_reset)
	{
		# Sleep for a moment to make sure virsh has caught up.
		sleep 2;
		
		my $shell_call = $an->data->{path}{virsh}." list --all";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line = $an->String->clean_spaces({string => $_});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^\d+ $server_name (.*)$/)
			{
				$server_state = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "server_name",  value1 => $server_name, 
					name2 => "server_state", value2 => $server_state, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($server_state ne "paused")
				{
					# Send an alert
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_server_message_0018",
						alert_message_variables	=>	{
							server_name		=>	$server_name, 
							server_state		=>	$server_state,
						},
					});
				}
				
				last;
			}
		}
		close $file_handle;
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "server_state", value1 => $server_state, 
	}, file => $THIS_FILE, line => __LINE__});
	return($server_state);
}

# This looks for servers locally and on the peer and reads in their data.
sub scan_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_servers" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# This will get set to '1' if we find any server info locally or on the peer (if we can find our 
	# peer).
	my $proceed = 0;
	
	# Find out who I am and who my peer is
	my $return = $an->Get->local_anvil_details({
		hostname_full	=>	$an->hostname,
		hostname_short	=>	$an->short_hostname,
		config_file	=>	$an->data->{path}{cman_config},
	});
	$an->data->{sys}{local_node}     = $return->{local_node};
	$an->data->{sys}{peer_node}      = $return->{peer_node};
	$an->data->{sys}{anvil_name}     = $return->{anvil_name};
	$an->data->{sys}{anvil_uuid}     = $return->{anvil_uuid};
	$an->data->{sys}{anvil_password} = $return->{anvil_password};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "sys::local_node", value1 => $an->data->{sys}{local_node}, 
		name2 => "sys::peer_node",  value2 => $an->data->{sys}{peer_node}, 
		name3 => "sys::anvil_name", value3 => $an->data->{sys}{anvil_name}, 
		name4 => "sys::anvil_uuid", value4 => $an->data->{sys}{anvil_uuid}, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil_password", value1 => $an->data->{sys}{anvil_password}, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Only proceed if I am in an Anvil!
	my $local_access = 1;
	if ($an->data->{sys}{anvil_uuid})
	{
		# First, check for local servers.
		my $shell_call = $an->data->{path}{virsh}." list --all";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			   $line =~ s/^\s+//;
			   $line =~ s/\s+$//;
			   $line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^error:/)
			{
				# Not running
				$local_access = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "local_access", value1 => $local_access, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			if ($line =~ /^\d+ (.*?) (.*)$/)
			{
				my $server_name  = $1;
				my $server_state = $2;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "server_name",  value1 => $server_name, 
					name2 => "server_state", value2 => $server_state, 
				}, file => $THIS_FILE, line => __LINE__});
				
				### NOTE: This has caused more concern than it has helped. It's fired during 
				###       live migrations (thankfully to no effect). Disabling it.
				# If the 'state' is 'paused', try and resume it.
# 				if ($server_state eq "paused")
# 				{
# 					$server_state = resume_server($an, $server_name);
# 					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
# 						name1 => "server_name",  value1 => $server_name, 
# 						name2 => "server_state", value2 => $server_state, 
# 					}, file => $THIS_FILE, line => __LINE__});
# 				}
				
				$an->data->{server_name}{$server_name} = {
					host	=>	$an->data->{sys}{local_node},
					'state'	=>	$server_state,
					definition	=>	"",
					uuid		=>	"",
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			if ($line =~ /- (.*?) shut off/)
			{
				# The server is shut off.
				my $server_name  = $1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "server_name", value1 => $server_name, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->data->{shut_off}{$server_name} = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shut_off::$server_name", value1 => $an->data->{shut_off}{$server_name}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		
		# Now check the peer.
		my $peer_access = 1;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call", value1 => $shell_call,
			name2 => "target",     value2 => $an->data->{sys}{peer_node},
		}, file => $THIS_FILE, line => __LINE__});
		my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
			target		=>	$an->data->{sys}{peer_node},
			port		=>	22, 
			password	=>	$an->data->{sys}{anvil_password},
			ssh_fh		=>	"",
			'close'		=>	0,
			shell_call	=>	$shell_call,
		});
		my $lines_returned = @{$return};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "error",          value1 => $error,
			name2 => "lines_returned", value2 => $lines_returned,
			name3 => "return",         value3 => $return,
		}, file => $THIS_FILE, line => __LINE__});
		
		# For some unknown reason, periodically we'll get 'Unknown error while connecting to...' 
		# errors. When this happens
		if ((not $lines_returned) or ($error))
		{
			# Try again next scan.
			$an->Log->entry({log_level => 1, message_key => "scan_server_log_0002", file => $THIS_FILE, line => __LINE__});
			$an->nice_exit({exit_code => 2});
		}
		
		foreach my $line (@{$return})
		{
			$line =~ s/^\s+//;
			$line =~ s/\s+$//;
			$line =~ s/\s+/ /g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^error:/)
			{
				# Not running
				$peer_access = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_access", value1 => $peer_access, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			if ($line =~ /^\d+ (.*?) (.*)$/)
			{
				my $server_name  = $1;
				my $server_state = $2;
				$an->data->{server_name}{$server_name} = {
					host		=>	$an->data->{sys}{peer_node},
					'state'		=>	$server_state,
					definition	=>	"",
					uuid		=>	"",
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "local_access", value1 => $local_access, 
			name2 => "peer_access",  value2 => $peer_access, 
		}, file => $THIS_FILE, line => __LINE__});
		if (($local_access) or ($peer_access))
		{
			$proceed = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "proceed", value1 => $proceed, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		
	}
	
	if ($proceed)
	{
		# If I have local access, see if I can read the XML definition files of any servers NOT found
		# running locally or on the peer.
		if (($local_access) && ($an->data->{path}{shared_definitions}) && (-d $an->data->{path}{shared_definitions}))
		{
			# The directory is there, so look for files.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "path::shared_definitions", value1 => $an->data->{path}{shared_definitions},
			}, file => $THIS_FILE, line => __LINE__});
			local(*DIRECTORY);
			opendir(DIRECTORY, $an->data->{path}{shared_definitions});
			while(my $file = readdir(DIRECTORY))
			{
				if ($file =~ /(.*)\.xml$/)
				{
					my $this_server = $1;
					my $full_path   = $an->data->{path}{shared_definitions}."/".$file;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
						name1 => "file",        value1 => $file,
						name2 => "this_server", value2 => $this_server,
						name3 => "full_path",   value3 => $full_path,
					}, file => $THIS_FILE, line => __LINE__});
					my $already_found = 0;
					foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{server_name}})
					{
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "server_name", value1 => $server_name,
						}, file => $THIS_FILE, line => __LINE__});
						if ($server_name eq $this_server)
						{
							$already_found = 1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "already_found", value1 => $already_found,
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
					
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "already_found", value1 => $already_found,
					}, file => $THIS_FILE, line => __LINE__});
					if (not $already_found)
					{
						# Read in the definition file and record its data.
						my $valid_xml   = 0;
						my $definition  = "";
						my $server_uuid = "";
						my $shell_call  = $full_path;
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1 => "shell_call", value1 => $shell_call,
						}, file => $THIS_FILE, line => __LINE__});
						open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 254, file => $THIS_FILE, line => __LINE__});
						while(<$file_handle>)
						{
							chomp;
							my $line = $_;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "line", value1 => $line,
							}, file => $THIS_FILE, line => __LINE__});
							$definition .= $line."\n";
							
							if ($line =~ /<uuid>([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})<\/uuid>/)
							{
								$server_uuid = $1;
								$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
									name1 => "server_uuid", value1 => $server_uuid, 
								}, file => $THIS_FILE, line => __LINE__});
							}
							if ($line =~ /<\/domain>/)
							{
								$valid_xml = 1;
								$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
									name1 => "valid_xml", value1 => $valid_xml, 
								}, file => $THIS_FILE, line => __LINE__});
							}
						}
						# Record it if we found the UUID.
						$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
							name1 => "server_uuid", value1 => $server_uuid, 
							name2 => "valid_xml",   value2 => $valid_xml, 
						}, file => $THIS_FILE, line => __LINE__});
						if (($server_uuid) && ($valid_xml))
						{
							# We're not setting the host or state because we 
							# don't know if it is running on another Anvil!.
							$an->data->{server_uuid}{$server_uuid} = {
								name		=>	$this_server,
								host		=>	"",
								'state'		=>	"",
								definition	=>	$definition,
							};
						}
					}
				}
			}
			close DIRECTORY;
		}
		
		# Now gather the details on the servers.
		foreach my $server_name (sort {$a cmp $b} keys %{$an->data->{server_name}})
		{
			my $server_host  = $an->data->{server_name}{$server_name}{host};
			my $server_state = $an->data->{server_name}{$server_name}{'state'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "server_name",     value1 => $server_name, 
				name2 => "server_host",     value2 => $server_host, 
				name3 => "server_state",    value3 => $server_state, 
				name4 => "sys::local_node", value4 => $an->data->{sys}{local_node}, 
				name5 => "sys::peer_node",  value5 => $an->data->{sys}{peer_node}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $server_xml = "";
			my $shell_call = $an->data->{path}{virsh}." dumpxml $server_name";
			if ($server_host eq $an->data->{sys}{local_node})
			{
				# Locally hosted, call virsh directly
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or die "Failed to call: [$shell_call], error was: $!\n";
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					$server_xml .= "$line\n";
				}
				close $file_handle;
				$server_xml =~ s/\n$//m;
			}
			elsif ($server_host eq $an->data->{sys}{peer_node})
			{
				# Remote, call over SSH.
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "shell_call", value1 => $shell_call,
					name2 => "target",     value2 => $an->data->{sys}{peer_node},
				}, file => $THIS_FILE, line => __LINE__});
				my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
					target		=>	$server_host,
					port		=>	"", 
					password	=>	$an->data->{sys}{anvil_password},
					ssh_fh		=>	"",
					'close'		=>	0,
					shell_call	=>	$shell_call,
				});
				foreach my $line (@{$return})
				{
					next if not $line;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
					$server_xml .= "$line\n";
				}
			}
			$an->data->{server_name}{$server_name}{definition} = $server_xml;
			
			# Dig out details now.
			foreach my $line (split/\n/, $server_xml)
			{
				if ($line =~ /<uuid>([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})<\/uuid>/)
				{
					$an->data->{server_name}{$server_name}{uuid} = $1;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "server_name::${server_name}::uuid", value1 => $an->data->{server_name}{$server_name}{uuid}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			# Now that I have the UUID, record the details using the UUID as the key
			my $server_uuid = $an->data->{server_name}{$server_name}{uuid};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "server_uuid", value1 => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($server_uuid)
			{
				$an->data->{server_uuid}{$server_uuid} = {
					name		=>	$server_name,
					host		=>	$an->data->{server_name}{$server_name}{host},
					'state'		=>	$an->data->{server_name}{$server_name}{'state'},
					definition	=>	$an->data->{server_name}{$server_name}{definition},
				};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "server_name",                        value1 => $server_name, 
					name2 => "server_name::${server_name}::host",  value2 => $an->data->{server_name}{$server_name}{host}, 
					name3 => "server_name::${server_name}::state", value3 => $an->data->{server_name}{$server_name}{'state'}, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				die "$THIS_FILE ".__LINE__."; There should be a server UUID here...\n";
			}
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "proceed", value1 => $proceed, 
	}, file => $THIS_FILE, line => __LINE__});
	return($proceed);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through each server
	foreach my $server_uuid (sort {$a cmp $b} keys %{$an->data->{server_uuid}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "server_uuid", value1 => $server_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (read_last_scan($an, $server_uuid))
		{
			### Existing server, UPDATE or INSERT as needed.
			# NOTE: For now, we only catch name changes here.
			# New values
			my $new_server_name       = $an->data->{server_uuid}{$server_uuid}{name};
			my $new_server_host       = $an->data->{server_uuid}{$server_uuid}{host};
			my $new_server_state      = $an->data->{server_uuid}{$server_uuid}{'state'};
			my $new_server_definition = $an->data->{server_uuid}{$server_uuid}{definition};
			
			# Old values
			my $old_server_anvil_uuid = $an->data->{sql}{$server_uuid}{server_anvil_uuid};
			my $old_server_name       = $an->data->{sql}{$server_uuid}{server_name};
			my $old_server_host       = $an->data->{sql}{$server_uuid}{server_host};
			my $old_server_state      = $an->data->{sql}{$server_uuid}{server_state};
			my $old_server_definition = $an->data->{sql}{$server_uuid}{server_definition};
			
			# Diff?
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "old_server_anvil_uuid", value1  => $old_server_anvil_uuid, 
				name2  => "sys::anvil_uuid",       value2  => $an->data->{sys}{anvil_uuid}, 
				name3  => "old_server_name",       value3  => $old_server_name, 
				name4  => "new_server_name",       value4  => $new_server_name, 
				name5  => "old_server_host",       value5  => $old_server_host, 
				name6  => "new_server_host",       value6  => $new_server_host, 
				name7  => "old_server_state",      value7  => $old_server_state, 
				name8  => "new_server_state",      value8  => $new_server_state, 
				name9  => "old_server_definition", value9  => $old_server_definition, 
				name10 => "new_server_definition", value10 => $new_server_definition, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($an->data->{sys}{anvil_uuid} ne $old_server_anvil_uuid) or 
			    ($new_server_name             ne $old_server_name)       or 
			    ($new_server_host             ne $old_server_host)       or 
			    ($new_server_state            ne $old_server_state)      or 
			    ($new_server_definition       ne $old_server_definition))
			{
				# Something has changed.
				my $query = "
UPDATE 
    servers 
SET 
    server_anvil_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{anvil_uuid}).", 
    server_name       = ".$an->data->{sys}{use_db_fh}->quote($new_server_name).", 
    server_host       = ".$an->data->{sys}{use_db_fh}->quote($new_server_host).", 
    server_state      = ".$an->data->{sys}{use_db_fh}->quote($new_server_state).", 
    server_definition = ".$an->data->{sys}{use_db_fh}->quote($new_server_definition).", 
    modified_date     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
;";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;

				### Now what actually changed?
				# The host Anvil! system?
				if ($an->data->{sys}{anvil_uuid} ne $old_server_anvil_uuid)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1  => "old_server_anvil_uuid", value1  => $old_server_anvil_uuid, 
						name2  => "sys::anvil_uuid",       value2  => $an->data->{sys}{anvil_uuid}, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# This should be a rare event, and almost certainly triggered by an 
					# admin.
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_server_message_0013",
						alert_message_variables	=>	{
							server			=>	$new_server_name, 
							anvil_name		=>	$an->data->{sys}{anvil_name},
						},
					});
				}
				# The server name?
				if ($new_server_name ne $old_server_name)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1 => "old_server_name", value1 => $old_server_name, 
						name2 => "new_server_name", value2 => $new_server_name, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# This should be a rare event, so it in a notice-level alert.
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_server_message_0006",
						alert_message_variables	=>	{
							old			=>	$old_server_name, 
							new			=>	$new_server_name,
						},
					});
				}
				# The current host?
				if ($new_server_host ne $old_server_host)
				{
					$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
						name1 => "old_server_host", value1 => $old_server_host, 
						name2 => "new_server_host", value2 => $new_server_host, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# New host, this is a worthy alert so it is note level
					my $message_key = "scan_server_message_0008";
					if (not $new_server_host)
					{
						# It shut down
						$message_key = "scan_server_message_0019";
					}
					elsif (not $old_server_host)
					{
						# It has booted.
						$message_key = "scan_server_message_0020";
					}
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	$message_key,
						alert_message_variables	=>	{
							server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
							new			=>	$new_server_host,
							old			=>	$old_server_host,
						},
					});
				}
				# The current state?
				if ($new_server_state ne $old_server_state)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "old_server_state", value1 => $old_server_state, 
						name2 => "new_server_state", value2 => $new_server_state, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# State changes are a little more important.
					my $message_key = "scan_server_message_0010";
					if (not $new_server_state)
					{
						# It has shut down.
						$message_key = "scan_server_message_0021";
					}
					elsif (not $old_server_state)
					{
						# It has started.
						$message_key = "scan_server_message_0022";
					}
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	$message_key,
						alert_message_variables	=>	{
							server			=>	$an->data->{server_uuid}{$server_uuid}{name}, 
							new			=>	$new_server_state,
							old			=>	$old_server_state,
						},
					});
					if ($new_server_state eq "started")
					{
						my $query = "
UPDATE 
    servers 
SET 
    server_stop_reason = '', 
    modified_date      = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_uuid        = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
;";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
					}
				}
				# The definition file?
				if ($new_server_definition ne $old_server_definition)
				{
					$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
						name1 => "old_server_definition", value1 => $old_server_definition, 
						name2 => "new_server_definition", value2 => $new_server_definition, 
						name3 => "diff",                  value3 => diff \$old_server_definition, \$new_server_definition, { STYLE => 'Unified' },
					}, file => $THIS_FILE, line => __LINE__});
					
					# This will happen whenever the virsh ID changes, disks are 
					# inserted/ejected, etc. So it is a info-level event.
					$an->Alert->register_alert({
						alert_level		=>	"info", 
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0002",
						alert_message_key	=>	"scan_server_message_0007",
						alert_message_variables	=>	{
							server			=>	$new_server_name, 
							new			=>	$new_server_definition,
							diff			=>	diff \$old_server_definition, \$new_server_definition, { STYLE => 'Unified' },
						},
					});
				}
			}
		}
		else
		{
			# If the user hasn't set the default migration type, make it 'live'.
			$an->data->{sys}{'default'}{migration_type} = "live" if not $an->data->{sys}{'default'}{migration_type};
			
			# New server, INSERT everything.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "server_uuid", value1 => $server_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			my $server_name           = $an->data->{server_uuid}{$server_uuid}{name};
			my $server_stop_reason    = "";
			my $server_start_after    = "NULL";
			my $server_start_delay    = 0;
			my $server_host           = $an->data->{server_uuid}{$server_uuid}{host};
			my $server_state          = $an->data->{server_uuid}{$server_uuid}{'state'};
			my $server_definition     = $an->data->{server_uuid}{$server_uuid}{definition};
			my $server_migration_type = $an->data->{sys}{'default'}{migration_type} =~ /cold/i ? "cold" : "live";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "server_uuid",           value1 => $server_uuid, 
				name2 => "server_name",           value2 => $server_name, 
				name3 => "server_stop_reason",    value3 => $server_stop_reason, 
				name4 => "server_start_after",    value4 => $server_start_after, 
				name5 => "server_start_delay",    value5 => $server_start_delay, 
				name6 => "server_host",           value6 => $server_host, 
				name7 => "server_migration_type", value7 => $server_migration_type, 
				name8 => "server_definition",     value8 => $server_definition, 
				name9 => "server_state",          value9 => $server_state, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $query = "
INSERT INTO 
    servers 
(
    server_uuid, 
    server_anvil_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_host, 
    server_state, 
    server_definition, 
    server_migration_type, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{anvil_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_after).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_definition).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_migration_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Translate the server's UUID to a name is 'server_start_after' is set. If the UUID
			# is all '0', then the server won't boot via 'anvil-safe-start' at all.
			my $say_start_after    = "";
			   $server_start_after = "" if $server_start_after eq "NULL";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "server_start_after", value1 => $server_start_after, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($server_start_after eq "00000000-0000-0000-0000-000000000000")
			{
				$say_start_after = "#!string!scan_server_message_0005!#";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "say_start_after", value1 => $say_start_after, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($server_start_after)
			{
				my $return = $an->Get->server_data({
					uuid  => $server_start_after, 
				});
				$say_start_after = $return->{name};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "say_start_after", value1 => $say_start_after, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"scan_server_message_0003",
				alert_title_variables	=>	{
					name			=>	$server_name,
				},
				alert_message_key	=>	"scan_server_message_0004",
				alert_message_variables	=>	{
					uuid			=>	$server_uuid, 
					start_after		=>	$say_start_after, 
					start_delay		=>	$server_start_delay, 
					host			=>	$server_host, 
					'state'			=>	$server_state, 
					definition		=>	$server_definition,
					migration_type		=>	$an->data->{sys}{'default'}{migration_type} =~ /cold/i ? "#!string!scan_server_state_0002!#" : "#!string!scan_server_state_0001!#",
				},
			});
		}
	}
	
	# Now commit the changes.
	$an->DB->commit_sql({source => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an, $server_uuid) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "server_uuid", value1 => "$server_uuid" 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Couple of variables to make the code cleaner
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "id",        value1 => $id, 
		name2 => "host_name", value2 => $host_name, 
	}, file => $THIS_FILE, line => __LINE__});

	# This calls up the entry for this host. If no entry is found, 'new' gets set to '1' and the main 
	# function won't bother looking for changes and directly INSERT the scanned data.
	my $query = "
SELECT 
    server_anvil_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_note, 
    server_definition, 
    server_host, 
    server_state 
FROM 
    servers 
WHERE 
    server_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)."
;";
	$query =~ s/'NULL'/NULL/g;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $server_anvil_uuid  =         $row->[0];
		my $server_name        =         $row->[1];
		my $server_stop_reason = defined $row->[2] ? $row->[2] : "";
		my $server_start_after = defined $row->[3] ? $row->[3] : "";
		my $server_start_delay =         $row->[4];
		my $server_note        = defined $row->[5] ? $row->[5] : "";
		my $server_definition  =         $row->[6];
		my $server_host        = defined $row->[7] ? $row->[7] : "";
		my $server_state       = defined $row->[8] ? $row->[8] : "";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
			name1  => "server_anvil_uuid",  value1  => $server_anvil_uuid, 
			name2  => "server_uuid",        value2  => $server_uuid, 
			name3  => "server_name",        value3  => $server_name, 
			name4  => "server_stop_reason", value4  => $server_stop_reason, 
			name5  => "server_start_after", value5  => $server_start_after, 
			name6  => "server_start_delay", value6  => $server_start_delay, 
			name7  => "server_note",        value7  => $server_note, 
			name8  => "server_definition",  value8  => $server_definition, 
			name9  => "server_host",        value9  => $server_host, 
			name10 => "server_state",       value10 => $server_state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Push the data into the hash for later comparison
		$an->data->{sql}{$server_uuid}{server_anvil_uuid}  = $server_anvil_uuid;
		$an->data->{sql}{$server_uuid}{server_name}        = $server_name;
		$an->data->{sql}{$server_uuid}{server_stop_reason} = $server_stop_reason;
		$an->data->{sql}{$server_uuid}{server_start_after} = $server_start_after;
		$an->data->{sql}{$server_uuid}{server_start_delay} = $server_start_delay;
		$an->data->{sql}{$server_uuid}{server_note}        = $server_note, 
		$an->data->{sql}{$server_uuid}{server_definition}  = $server_definition, 
		$an->data->{sql}{$server_uuid}{server_host}        = $server_host, 
		$an->data->{sql}{$server_uuid}{server_state}       = $server_state, 
		$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
			name1 => "sql::${server_uuid}::server_anvil_uuid",  value1 => $an->data->{sql}{$server_uuid}{server_anvil_uuid}, 
			name2 => "sql::${server_uuid}::server_name",        value2 => $an->data->{sql}{$server_uuid}{server_name}, 
			name3 => "sql::${server_uuid}::server_stop_reason", value3 => $an->data->{sql}{$server_uuid}{server_stop_reason}, 
			name4 => "sql::${server_uuid}::server_start_after", value4 => $an->data->{sql}{$server_uuid}{server_start_after}, 
			name5 => "sql::${server_uuid}::server_start_delay", value5 => $an->data->{sql}{$server_uuid}{server_start_delay}, 
			name6 => "sql::${server_uuid}::server_note",        value6 => $an->data->{sql}{$server_uuid}{server_note}, 
			name7 => "sql::${server_uuid}::server_definition",  value7 => $an->data->{sql}{$server_uuid}{server_definition}, 
			name8 => "sql::${server_uuid}::server_host",        value8 => $an->data->{sql}{$server_uuid}{server_host}, 
			name9 => "sql::${server_uuid}::server_state",       value9 => $an->data->{sql}{$server_uuid}{server_state}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	return($count);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_server_message_0002"})."\n";

	return(0);
}
