#!/usr/bin/perl
# 
# This is a ScanCore agent for monitoring bonded network interfaces. It is
# designed for active/passive (mode=1) bonds. Other modes have not been tested
# and may or may not work.
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - Passed in host name was not found in the database.
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.
# 
# NOTE:
#  - Call: [fence_tool ls | grep master | awk '{print $3}'] to see which node
#    is the fence master and use this node only to try and recover failed
#    services.
# 
# TODO:
# - If the 'ifn_bond1' interface goes to MII state 'down', try to ping the peer
#   on the BCN and, if successful, start migrating the VMs off.

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		# This will store the data read in when parsing bonds.
		bond		=>	{},
		path		=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			host_uuid		=>	"/etc/striker/host.uuid",
			proc_bond		=>	"/proc/net/bonding",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		# This is used so that the user can set the language in on striker.conf variable.
		'scan-bond'		=>	{
			language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_level		=>	1,
			log_language		=>	"en_CA",
			log_db_transactions	=>	0,
		},
		sql		=>	{
		},
		sys		=>	{
			# This will get set by AN::Tools::DB->connect_to_databases()
			bond_uuid_query		=>	"",
			sql			=>	[],
		},
	}
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{'scan-bond'}{language});
$an->default_log_language($an->data->{'scan-bond'}{log_language});
$an->default_log_file    ($an->data->{'scan-bond'}{log_file});

# Set the log level.
$an->Log->level($an->data->{'scan-bond'}{log_level});
$an->Log->db_transactions(1) if $an->data->{'scan-bond'}{log_db_transactions};

# Read in the language strings.
$an->String->read_words({file => $an->data->{path}{strings}});
$an->String->read_words({file => $an->data->{path}{core_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for
# help.
print $an->String->get({key => "scan_bond_message_0001"})."\n";
$an->Get->switches();

# Read in bond. If it returns '1', then bond wasn't found and we will exit.
if (parse_bonds($an))
{
	# No bonds found, exit.
	nice_exit($an, 1);
}

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "notice_message_0013", message_variables => {
	connections	=>	$connections,
}, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { 
		uuid => $an->data->{sys}{host_uuid},
	}, code => 255, file => "$THIS_FILE", line => __LINE__});
}

# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
nice_exit($an, 0);

#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This looks at each DB's 'updated' table to see if any are behind. If any are, it will update the tables 
# based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Update bond and interfaces
		update_db_bond($an);
		update_db_bond_interface($an);
	}
	
	return(0);
}

# Update the bond_interface table
sub update_db_bond_interface
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_bond_interface", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'bond_interface' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    a.bond_interface_name, 
    a.bond_interface_bond_uuid, 
    a.bond_interface_mii_status, 
    a.bond_interface_speed, 
    a.bond_interface_duplex, 
    a.bond_interface_failure_count, 
    a.bond_interface_mac, 
    a.bond_interface_slave_queue_id, 
    a.modified_date 
FROM 
    history.bond_interface a, 
    public.bond b
WHERE
    a.bond_interface_bond_uuid = b.bond_uuid
AND
    b.bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $bond_interface_name           = $row->[0];
			my $bond_interface_bond_uuid      = $row->[1];
			my $bond_interface_mii_status     = $row->[2];
			my $bond_interface_speed          = $row->[3];
			my $bond_interface_duplex         = $row->[4];
			my $bond_interface_failure_count  = $row->[5];
			my $bond_interface_mac            = $row->[6];
			my $bond_interface_slave_queue_id = $row->[7];
			my $modified_date                 = $row->[8];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "bond_interface_name",           value1 => $bond_interface_name, 
				name2 => "bond_interface_bond_uuid",      value2 => $bond_interface_bond_uuid, 
				name3 => "bond_interface_mii_status",     value3 => $bond_interface_mii_status, 
				name4 => "bond_interface_speed",          value4 => $bond_interface_speed, 
				name5 => "bond_interface_duplex",         value5 => $bond_interface_duplex, 
				name6 => "bond_interface_failure_count",  value6 => $bond_interface_failure_count, 
				name7 => "bond_interface_mac",            value7 => $bond_interface_mac, 
				name8 => "bond_interface_slave_queue_id", value8 => $bond_interface_slave_queue_id, 
				name9 => "modified_date",                 value9 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name} = {
				bond_interface_bond_uuid	=>	$bond_interface_bond_uuid, 
				bond_interface_mii_status	=>	$bond_interface_mii_status, 
				bond_interface_speed		=>	$bond_interface_speed, 
				bond_interface_duplex		=>	$bond_interface_duplex, 
				bond_interface_failure_count	=>	$bond_interface_failure_count, 
				bond_interface_mac		=>	$bond_interface_mac, 
				bond_interface_slave_queue_id	=>	$bond_interface_slave_queue_id, 
			};
			$an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen}     = 0;
			$an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name} = {
				bond_interface_bond_uuid	=>	$bond_interface_bond_uuid, 
				bond_interface_mii_status	=>	$bond_interface_mii_status, 
				bond_interface_speed		=>	$bond_interface_speed, 
				bond_interface_duplex		=>	$bond_interface_duplex, 
				bond_interface_failure_count	=>	$bond_interface_failure_count, 
				bond_interface_mac		=>	$bond_interface_mac, 
				bond_interface_slave_queue_id	=>	$bond_interface_slave_queue_id, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{bond_interface}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $bond_interface_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}})
		{
			my $bond_interface_bond_uuid      = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_bond_uuid};
			my $bond_interface_mii_status     = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_mii_status};
			my $bond_interface_speed          = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_speed};
			my $bond_interface_duplex         = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_duplex};
			my $bond_interface_failure_count  = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_failure_count};
			my $bond_interface_mac            = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_mac};
			my $bond_interface_slave_queue_id = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_slave_queue_id};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "bond_interface_name",           value1 => $bond_interface_name, 
				name2 => "bond_interface_bond_uuid",      value2 => $bond_interface_bond_uuid, 
				name3 => "bond_interface_mii_status",     value3 => $bond_interface_mii_status, 
				name4 => "bond_interface_speed",          value4 => $bond_interface_speed, 
				name5 => "bond_interface_duplex",         value5 => $bond_interface_duplex, 
				name6 => "bond_interface_failure_count",  value6 => $bond_interface_failure_count, 
				name7 => "bond_interface_mac",            value7 => $bond_interface_mac, 
				name8 => "bond_interface_slave_queue_id", value8 => $bond_interface_slave_queue_id, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'bond_interface_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::bond_interface::bond_interface_name::${bond_interface_name}::seen", value1 => $an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::bond_interface::bond_interface_name::${bond_interface_name}::exists", value1 => $an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::bond_interface::modified_date::${modified_date}::bond_interface_name::${bond_interface_name}", value1 => $an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.bond_interface
SET
    bond_interface_mii_status     = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    bond_interface_speed          = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    bond_interface_duplex         = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    bond_interface_failure_count  = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    bond_interface_mac            = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    bond_interface_slave_queue_id = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    bond_interface_name      = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)." 
AND 
    bond_interface_bond_uuid = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.bond_interface
(
    bond_interface_name, 
    bond_interface_bond_uuid, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'bond_interface_name' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.bond_interface
(
    bond_interface_id, 
    bond_interface_name, 
    bond_interface_bond_uuid, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    (
        SELECT 
            bond_interface_id 
        FROM 
            public.bond_interface 
        WHERE 
            bond_interface_bond_uuid = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid)." 
        AND 
            bond_interface_name = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)."
    ), 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen bond_interface_name?
			} # foreach my $id 
		} # foreach my $bond_interface_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'bond' table.
sub update_db_bond
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_bond", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'bond' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
FROM 
    history.bond
WHERE
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $bond_uuid                 = $row->[0];
			my $bond_name                 = $row->[1];
			my $bond_mode                 = $row->[2];
			my $bond_primary_slave        = $row->[3];
			my $bond_primary_reselect     = $row->[4];
			my $bond_active_slave         = $row->[5];
			my $bond_mii_status           = $row->[6];
			my $bond_mii_polling_interval = $row->[7];
			my $bond_up_delay             = $row->[8];
			my $bond_down_delay           = $row->[9];
			my $modified_date             = $row->[10];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0011", message_variables => {
				name1  => "bond_uuid",                 value1  => $bond_uuid, 
				name2  => "bond_name",                 value2  => $bond_name, 
				name3  => "bond_mode",                 value3  => $bond_mode, 
				name4  => "bond_primary_slave",        value4  => $bond_primary_slave, 
				name5  => "bond_primary_reselect",     value5  => $bond_primary_reselect, 
				name6  => "bond_active_slave",         value6  => $bond_active_slave, 
				name7  => "bond_mii_status",           value7  => $bond_mii_status, 
				name8  => "bond_mii_polling_interval", value8  => $bond_mii_polling_interval, 
				name9  => "bond_up_delay",             value9  => $bond_up_delay, 
				name10 => "bond_down_delay",           value10 => $bond_down_delay, 
				name11 => "modified_date",             value11 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid} = {
				bond_name			=>	$bond_name, 
				bond_mode			=>	$bond_mode, 
				bond_primary_slave		=>	$bond_primary_slave, 
				bond_primary_reselect		=>	$bond_primary_reselect, 
				bond_active_slave		=>	$bond_active_slave, 
				bond_mii_status			=>	$bond_mii_status, 
				bond_mii_polling_interval	=>	$bond_mii_polling_interval, 
				bond_up_delay			=>	$bond_up_delay, 
				bond_down_delay			=>	$bond_down_delay, 
			};
			$an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid} = {
				bond_name			=>	$bond_name, 
				bond_mode			=>	$bond_mode, 
				bond_primary_slave		=>	$bond_primary_slave, 
				bond_primary_reselect		=>	$bond_primary_reselect, 
				bond_active_slave		=>	$bond_active_slave, 
				bond_mii_status			=>	$bond_mii_status, 
				bond_mii_polling_interval	=>	$bond_mii_polling_interval, 
				bond_up_delay			=>	$bond_up_delay, 
				bond_down_delay			=>	$bond_down_delay, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{bond}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $bond_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}})
		{
			my $bond_name                 = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_name};
			my $bond_mode                 = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_mode};
			my $bond_primary_slave        = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_primary_slave};
			my $bond_primary_reselect     = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_primary_reselect};
			my $bond_active_slave         = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_active_slave};
			my $bond_mii_status           = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_mii_status};
			my $bond_mii_polling_interval = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_mii_polling_interval};
			my $bond_up_delay             = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_up_delay};
			my $bond_down_delay           = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_down_delay};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "bond_uuid",                 value1  => $bond_uuid, 
				name2  => "bond_name",                 value2  => $bond_name, 
				name3  => "bond_mode",                 value3  => $bond_mode, 
				name4  => "bond_primary_slave",        value4  => $bond_primary_slave, 
				name5  => "bond_primary_reselect",     value5  => $bond_primary_reselect, 
				name6  => "bond_active_slave",         value6  => $bond_active_slave, 
				name7  => "bond_mii_status",           value7  => $bond_mii_status, 
				name8  => "bond_mii_polling_interval", value8  => $bond_mii_polling_interval, 
				name9  => "bond_up_delay",             value9  => $bond_up_delay, 
				name10 => "bond_down_delay",           value10 => $bond_down_delay, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'bond_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::bond::bond_uuid::${bond_uuid}::seen", value1 => $an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::bond::bond_uuid::${bond_uuid}::exists", value1 => $an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::bond::modified_date::${modified_date}::bond_uuid::${bond_uuid}", value1 => $an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.bond
SET
    bond_name                 = ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    bond_mode                 = ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    bond_primary_slave        = ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    bond_primary_reselect     = ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    bond_active_slave         = ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    bond_mii_status           = ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    bond_mii_polling_interval = ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    bond_up_delay             = ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    bond_down_delay           = ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    modified_date             = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    bond_uuid      = ".$an->data->{sys}{use_db_fh}->quote($bond_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.bond
(
    bond_host_uuid, 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'bond_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.bond
(
    bond_host_uuid, 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen bond_uuid?
			} # foreach my $id 
		} # foreach my $bond_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load
# the schema. If the schema gets loaded, we'll check other databases for
# older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => "$THIS_FILE" }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='bond' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it
# against the just-read data. If anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in the old data. As we compare and UPDATE if needed, then we'll delete. If any are not found,
	# then it must be new and will be INSERTed. Any old records left over will have vanished.
	read_last_scan($an);
	
	# Read in last scan data (if any).
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	
	# Loop through the bonds I've seen
	foreach my $bond_name (sort {$a cmp $b} keys %{$an->data->{bond}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "bond_name", value1 => $bond_name, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Pull my new bond info into variables for readability.
		my $new_bond_mode                 = $an->data->{bond}{$bond_name}{mode};
		my $new_bond_primary_slave        = $an->data->{bond}{$bond_name}{primary_slave};
		my $new_bond_primary_reselect     = $an->data->{bond}{$bond_name}{primary_reselect};
		my $new_bond_active_slave         = $an->data->{bond}{$bond_name}{active_slave};
		my $new_bond_mii_status           = $an->data->{bond}{$bond_name}{mii_status};
		my $new_bond_mii_polling_interval = $an->data->{bond}{$bond_name}{mii_polling_interval};
		my $new_bond_up_delay             = $an->data->{bond}{$bond_name}{up_delay};
		my $new_bond_down_delay           = $an->data->{bond}{$bond_name}{down_delay};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "new_bond_mode",                 value1 => $new_bond_mode, 
			name2 => "new_bond_primary_slave",        value2 => $new_bond_primary_slave, 
			name3 => "new_bond_primary_reselect",     value3 => $new_bond_primary_reselect, 
			name4 => "new_bond_active_slave",         value4 => $new_bond_active_slave, 
			name5 => "new_bond_mii_status",           value5 => $new_bond_mii_status, 
			name6 => "new_bond_mii_polling_interval", value6 => $new_bond_mii_polling_interval, 
			name7 => "new_bond_up_delay",             value7 => $new_bond_up_delay, 
			name8 => "new_bond_down_delay",           value8 => $new_bond_down_delay, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Have I seen this bond before?
		if ($an->data->{sql}{$bond_name})
		{
			# Yup, look for changes.
			# Pull my old bond info into variables for readability.
			my $bond_uuid                     = $an->data->{sql}{$bond_name}{bond_uuid};
			my $old_bond_mode                 = $an->data->{sql}{$bond_name}{bond_mode};
			my $old_bond_primary_slave        = $an->data->{sql}{$bond_name}{bond_primary_slave};
			my $old_bond_primary_reselect     = $an->data->{sql}{$bond_name}{bond_primary_reselect};
			my $old_bond_active_slave         = $an->data->{sql}{$bond_name}{bond_active_slave};
			my $old_bond_mii_status           = $an->data->{sql}{$bond_name}{bond_mii_status};
			my $old_bond_mii_polling_interval = $an->data->{sql}{$bond_name}{bond_mii_polling_interval};
			my $old_bond_up_delay             = $an->data->{sql}{$bond_name}{bond_up_delay};
			my $old_bond_down_delay           = $an->data->{sql}{$bond_name}{bond_down_delay};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "bond_uuid",                     value1 => $bond_uuid, 
				name2 => "old_bond_mode",                 value2 => $old_bond_mode, 
				name3 => "old_bond_primary_slave",        value3 => $old_bond_primary_slave, 
				name4 => "old_bond_primary_reselect",     value4 => $old_bond_primary_reselect, 
				name5 => "old_bond_active_slave",         value5 => $old_bond_active_slave, 
				name6 => "old_bond_mii_status",           value6 => $old_bond_mii_status, 
				name7 => "old_bond_mii_polling_interval", value7 => $old_bond_mii_polling_interval, 
				name8 => "old_bond_up_delay",             value8 => $old_bond_up_delay, 
				name9 => "old_bond_down_delay",           value9 => $old_bond_down_delay, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Looks for changes in the bond itself before investigating the slaved interfaces.
			if (($new_bond_mode                 ne $old_bond_mode) or 
			    ($new_bond_primary_slave        ne $old_bond_primary_slave) or 
			    ($new_bond_primary_reselect     ne $old_bond_primary_reselect) or 
			    ($new_bond_active_slave         ne $old_bond_active_slave) or 
			    ($new_bond_mii_status           ne $old_bond_mii_status) ne 
			    ($new_bond_mii_polling_interval ne $old_bond_mii_polling_interval) or 
			    ($new_bond_up_delay             ne $old_bond_up_delay) ne 
			    ($new_bond_down_delay           ne $old_bond_down_delay))
			{
				# Something changed. Notify the user and then UPDATE.
				$an->Log->entry({log_level => 2, message_key => "scan_bond_log_0001", message_variables => {
					table		=>	"bond", 
					bond_name	=>	$bond_name, 
				}, file => $THIS_FILE, line => __LINE__});
				
				### The way things might change and what they might mean;
				# * Admin changed the mode... This should never happen in an Anvil! and is a
				#   warning level alert.
				#   * Anything other than mode=1 is NOT supported and is a critical alert.
				# * Admin changed the primary slave... This should never happen in an Anvil!
				#   and is a warning level alert.
				# * Admin changed the primary reselect policy. This should never happen in an
				#   Anvil! and is a warning level alert.
				# * The active slave changed. 
				#   * If going from X_link1 to X_link2, the primary link failed and the 
				#     backup took over.
				#   * If going from X_link2 to X_link1, the primary link recovered and has
				#     taken over again.
				# * The MII status changes.
				#   * If the new status is 'down', the entire bond is down and this is a 
				#     critical problem.
				#   * If the new status is 'up', at least one of the slaves has come back up.
				# * Admin changed the MII polling interval. This should never happen in an 
				#   Anvil! and is a warning level alert.
				# * The up delay changed. This is odd, but not necessarily a disaster, so it
				#   is a warning level alert.
				# * The down delay changed. Anything other than a '0' is a critical level 
				#   alert as a slow recovery can cause DRBD or corosync to declare the peer
				#   dead.
				
				### Create the alerts
				# * Admin changed the mode... This should never happen in an Anvil! and is a
				#   warning level alert.
				#   * Anything other than mode=1 is NOT supported and is a critical alert.
				if ($new_bond_mode ne $old_bond_mode)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_mode", value1 => $new_bond_mode, 
						name2 => "old_bond_mode", value2 => $old_bond_mode, 
					}, file => $THIS_FILE, line => __LINE__});
					
					my $say_new_bond_mode = "#!string!scan_bond_mode_${new_bond_mode}!#";
					my $say_old_bond_mode = "#!string!scan_bond_mode_${old_bond_mode}!#";
					
					# Tell the user.
					my $alert_title_key         = "an_alert_title_0004";
					my $alert_message_key       = "scan_bond_warning_0002";
					my $alert_message_variables = {
						bond_name		=>	$bond_name,
						new_value		=>	$say_new_bond_mode,
						old_value		=>	$say_old_bond_mode,
					};
					if ($new_bond_mode eq "0")
					{
						# The bond is Active/Passive, good.
						# This is a 'warning cleared' level alert.
						$alert_title_key   = "an_alert_title_0006";
						$alert_message_key = "scan_bond_warning_0001";
					}
					else
					{
						# WTF is the admin doing?!
						# The bond is Active/Passive, good.
						# This is a 'warning' level alert.
					}
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	$alert_title_key,
						alert_message_key	=>	$alert_message_key,
						alert_message_variables	=>	$alert_message_variables,
					});
				}
				
				# * Admin changed the primary slave... This should never happen in an Anvil!
				#   but might be because of a coming maintenance or to avoid a known flaky 
				#   cable until the replacement comes.
				if ($new_bond_primary_slave ne $old_bond_primary_slave)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_primary_slave", value1 => $new_bond_primary_slave, 
						name2 => "old_bond_primary_slave", value2 => $old_bond_primary_slave, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Tell the user.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_bond_warning_0003",
						alert_message_variables	=>	{
							bond_name		=>	$bond_name,
							new_value		=>	$new_bond_primary_slave,
							old_value		=>	$old_bond_primary_slave,
						},
					});
				}
				
				# * Admin changed the primary reselect policy. This generally should never 
				#   happen in an Anvil! and is a warning level alert.
				if ($new_bond_primary_reselect ne $old_bond_primary_reselect)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_primary_reselect", value1 => $new_bond_primary_reselect, 
						name2 => "old_bond_primary_reselect", value2 => $old_bond_primary_reselect, 
					}, file => $THIS_FILE, line => __LINE__});
					
					my $say_old_bond_primary_reselect = "#!string!scan_bond_reselect_${old_bond_primary_reselect}!#";
					my $say_new_bond_primary_reselect = "#!string!scan_bond_reselect_${new_bond_primary_reselect}!#";
					
					# There are three modes:
					# * always  or 0 (default)
					# * better  or 1
					# * failure or 2
					
					# Tell the user.
					my $alert_title_key         = "an_alert_title_0004";
					my $alert_message_key       = "scan_bond_warning_0007";
					my $alert_message_variables = {
						bond_name		=>	$bond_name,
						new_value		=>	$say_new_bond_primary_reselect,
						old_value		=>	$say_old_bond_primary_reselect,
					};
					if (($new_bond_primary_reselect eq "0") or ($new_bond_primary_reselect eq "always"))
					{
						$alert_message_key = "scan_bond_warning_0004";
					}
					elsif (($new_bond_primary_reselect eq "1") or ($new_bond_primary_reselect eq "better"))
					{
						$alert_message_key = "scan_bond_warning_0005";
					}
					elsif (($new_bond_primary_reselect eq "2") or ($new_bond_primary_reselect eq "failure"))
					{
						$alert_message_key = "scan_bond_warning_0006";
					}
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	$alert_title_key,
						alert_message_key	=>	$alert_message_key,
						alert_message_variables	=>	$alert_message_variables,
					});
				}
				
				# * The active slave changed. 
				#   * If going from X_link1 to X_link2, the primary link failed and the 
				#     backup took over.
				#   * If going from X_link2 to X_link1, the primary link recovered and has
				#     taken over again.
				if ($new_bond_active_slave ne $old_bond_active_slave)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_active_slave", value1 => $new_bond_active_slave, 
						name2 => "old_bond_active_slave", value2 => $old_bond_active_slave, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Tell the user.
					my $alert_title_key         = "an_alert_title_0004";
					my $alert_message_key       = "scan_bond_warning_0010";
					my $alert_message_variables = {
						bond_name		=>	$bond_name,
						new_value		=>	$new_bond_active_slave,
						old_value		=>	$old_bond_active_slave,
					};
					if ($new_bond_active_slave =~ /1$/)
					{
						# Returned to normal
						$alert_title_key   = "an_alert_title_0006";
						$alert_message_key = "scan_bond_warning_0008";
					}
					elsif ($new_bond_active_slave =~ /2$/)
					{
						# Using backup, probably lost the primary.
						$alert_message_key = "scan_bond_warning_0009";
					}
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	$alert_title_key,
						alert_message_key	=>	$alert_message_key,
						alert_message_variables	=>	$alert_message_variables,
					});
				}
				
				# * The MII status changes.
				#   * If the new status is 'down', the entire bond is down and this is a 
				#     critical problem.
				#   * If the new status is 'up', at least one of the slaves has come back up.
				if ($new_bond_mii_status ne $old_bond_mii_status)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_mii_status", value1 => $new_bond_mii_status, 
						name2 => "old_bond_mii_status", value2 => $old_bond_mii_status, 
					}, file => $THIS_FILE, line => __LINE__});
					
					my $say_new_bond_mii_status = $new_bond_mii_status;
					if    ($say_new_bond_mii_status eq "up")   { $say_new_bond_mii_status = "#!string!scan_bond_state_0001!#"; }
					elsif ($say_new_bond_mii_status eq "down") { $say_new_bond_mii_status = "#!string!scan_bond_state_0002!#"; }
					
					my $say_old_bond_mii_status = $old_bond_mii_status;
					if    ($say_old_bond_mii_status eq "up")   { $say_old_bond_mii_status = "#!string!scan_bond_state_0001!#"; }
					elsif ($say_old_bond_mii_status eq "down") { $say_old_bond_mii_status = "#!string!scan_bond_state_0002!#"; }
					
					# Tell the user
					my $alert_title_key         = "an_alert_title_0005";
					my $alert_message_key       = "scan_bond_warning_0013";
					my $alert_message_variables = {
						bond_name		=>	$bond_name,
						new_value		=>	$say_new_bond_mii_status,
						old_value		=>	$say_old_bond_mii_status,
					};
					if ($new_bond_mii_status eq "up")
					{
						# OK now.
						$alert_title_key   = "an_alert_title_0007";
						$alert_message_key = "scan_bond_warning_0011";
					}
					elsif ($new_bond_mii_status eq "down")
					{
						$alert_message_key = "scan_bond_warning_0012";
						
						### TODO: If this is the 'ifn_bond1', see if 'bcn_bond1' is
						###       'up' and, if so, migrate our servers off.
					}
					$an->Alert->register_alert({
						alert_level		=>	"critical", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	$alert_title_key,
						alert_message_key	=>	$alert_message_key,
						alert_message_variables	=>	$alert_message_variables,
					});
				}
				
				# * Admin changed the MII polling interval. This should never happen in an 
				#   Anvil! and is a warning level alert.
				if ($new_bond_mii_polling_interval ne $old_bond_mii_polling_interval)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_mii_polling_interval", value1 => $new_bond_mii_polling_interval, 
						name2 => "old_bond_mii_polling_interval", value2 => $old_bond_mii_polling_interval, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Tell the user
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_bond_warning_0014",
						alert_message_variables	=>	{
							bond_name		=>	$bond_name,
							new_value		=>	$new_bond_mii_polling_interval,
							old_value		=>	$old_bond_mii_polling_interval,
						},
					});
				}
				
				# * The up delay changed. This is odd, but not necessarily a disaster, so it
				#   is a warning level alert.
				if ($new_bond_up_delay ne $old_bond_up_delay)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_up_delay", value1 => $new_bond_up_delay, 
						name2 => "old_bond_up_delay", value2 => $old_bond_up_delay, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Tell the user
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_bond_warning_0015",
						alert_message_variables	=>	{
							bond_name		=>	$bond_name,
							new_value		=>	$new_bond_up_delay,
							old_value		=>	$old_bond_up_delay,
						},
					});
				}
				
				# * The down delay changed. Anything other than a '0' is a critical level 
				#   alert as a slow recovery can cause DRBD or corosync to declare the peer
				#   dead.
				if ($new_bond_down_delay ne $old_bond_down_delay)
				{
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "new_bond_down_delay", value1 => $new_bond_down_delay, 
						name2 => "old_bond_down_delay", value2 => $old_bond_down_delay, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Tell the user
					my $alert_title_key         = "an_alert_title_0005";
					my $alert_message_key       = "scan_bond_warning_0016";
					my $alert_message_variables = {
						bond_name		=>	$bond_name,
						new_value		=>	$new_bond_down_delay,
						old_value		=>	$old_bond_down_delay,
					};
					if ($new_bond_down_delay eq "0")
					{
						# OK, back to sanity
						$alert_title_key   = "an_alert_title_0007";
						$alert_message_key = "scan_bond_warning_0017";
					}
					$an->Alert->register_alert({
						alert_level		=>	"critical", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	$alert_title_key,
						alert_message_key	=>	$alert_message_key,
						alert_message_variables	=>	$alert_message_variables,
					});
				}
				
				# Now UPDATE the database.
				my $query = "
UPDATE 
    bond 
SET 
    bond_mode                 = ".$an->data->{sys}{use_db_fh}->quote($new_bond_mode).", 
    bond_primary_slave        = ".$an->data->{sys}{use_db_fh}->quote($new_bond_primary_slave).", 
    bond_primary_reselect     = ".$an->data->{sys}{use_db_fh}->quote($new_bond_primary_reselect).", 
    bond_active_slave         = ".$an->data->{sys}{use_db_fh}->quote($new_bond_active_slave).", 
    bond_mii_status           = ".$an->data->{sys}{use_db_fh}->quote($new_bond_mii_status).", 
    bond_mii_polling_interval = ".$an->data->{sys}{use_db_fh}->quote($new_bond_mii_polling_interval).", 
    bond_up_delay             = ".$an->data->{sys}{use_db_fh}->quote($new_bond_up_delay).", 
    bond_down_delay           = ".$an->data->{sys}{use_db_fh}->quote($new_bond_down_delay).", 
    modified_date             = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    bond_uuid      = ".$an->data->{sys}{use_db_fh}->quote($bond_uuid)." 
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
			
			# Now look at the slaved interfaces. We'll do the same thing; Loop through the 
			# interfaces we saw in our scan, UPDATEing existing ones if changed, INSERTing new
			# ones and then deleting them. If any left, then it means that slave disappeared.
			foreach my $bond_interface_name (sort {$a cmp $b} keys %{$an->data->{bond}{$bond_name}{slave}})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "bond_interface_name", value1 => $bond_interface_name, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Pull my new bond interface info into variables for readability.
				my $new_bond_interface_mii_status     = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mii_status};
				my $new_bond_interface_speed          = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{speed};
				my $new_bond_interface_duplex         = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{duplex};
				my $new_bond_interface_failure_count  = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{failure_count};
				my $new_bond_interface_mac            = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mac};
				my $new_bond_interface_slave_queue_id = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{slave_queue_id};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
					name1 => "new_bond_interface_mii_status",     value1 => $new_bond_interface_mii_status, 
					name2 => "new_bond_interface_speed",          value2 => $new_bond_interface_speed, 
					name3 => "new_bond_interface_duplex",         value3 => $new_bond_interface_duplex, 
					name4 => "new_bond_interface_failure_count",  value4 => $new_bond_interface_failure_count, 
					name5 => "new_bond_interface_mac",            value5 => $new_bond_interface_mac, 
					name6 => "new_bond_interface_slave_queue_id", value6 => $new_bond_interface_slave_queue_id, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}", value1 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name})
				{
					### It existed before, look for changes.
					# Pull my old bond interface info into variables for readability.
					my $old_bond_interface_mii_status     = $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_mii_status};
					my $old_bond_interface_speed          = $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_speed};
					my $old_bond_interface_duplex         = $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_duplex};
					my $old_bond_interface_failure_count  = $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_failure_count};
					my $old_bond_interface_mac            = $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_mac};
					my $old_bond_interface_slave_queue_id = $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_slave_queue_id};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
						name1 => "old_bond_interface_mii_status",     value1 => $old_bond_interface_mii_status, 
						name2 => "old_bond_interface_speed",          value2 => $old_bond_interface_speed, 
						name3 => "old_bond_interface_duplex",         value3 => $old_bond_interface_duplex, 
						name4 => "old_bond_interface_failure_count",  value4 => $old_bond_interface_failure_count, 
						name5 => "old_bond_interface_mac",            value5 => $old_bond_interface_mac, 
						name6 => "old_bond_interface_slave_queue_id", value6 => $old_bond_interface_slave_queue_id, 
					}, file => $THIS_FILE, line => __LINE__});
					
					if (($new_bond_interface_mii_status     ne $old_bond_interface_mii_status) or 
					    ($new_bond_interface_speed          ne $old_bond_interface_speed) or 
					    ($new_bond_interface_duplex         ne $old_bond_interface_duplex) or 
					    ($new_bond_interface_failure_count  ne $old_bond_interface_failure_count) or 
					    ($new_bond_interface_mac            ne $old_bond_interface_mac) or 
					    ($new_bond_interface_slave_queue_id ne $old_bond_interface_slave_queue_id))
					{
						# Something indeed changed. Notify the user and UPDATE.
						$an->Log->entry({log_level => 2, message_key => "scan_bond_log_0001", message_variables => {
							table		=>	"bond_interface", 
							bond_name	=>	$bond_interface_name, 
						}, file => $THIS_FILE, line => __LINE__});
						
						### The way things might change and what they might mean;
						# * The MII status changed.
						#   * 'up' -> 'down'         = Link failed, warning level 
						#                              alert
						#   * 'up' -> 'going back'   = Link dropped but quickly came
						#                              back
						#   * 'down' -> 'up'         = Link recovered quickly... Too
						#                              quickly, warning level alert.
						#   * 'down' -> 'going back' = Link is recovering.
						#   * 'going back' -> 'down' = Link failed again when 
						#                              recovering. This is normal 
						#                              when a switch is booting up.
						#   * 'going back' -> 'up'   = Link has recovered.
						# * Link speed has changed, this is a warning level alert. 
						#   * If the mii status is 'down', this is normally 'unknown'.
						#   * If the mii state is 'going back' or 'up', check to see
						#     what the fastest it was in the past. 
						#     * If it is lower, then the network cable might be 
						#       failing.
						#     * If it is the same, it's returned to normal.
						#     * If it is faster, the NIC was probably upgraded.
						# * Link duplex has changed, this is a warning level alert.
						#   * If the MII state is 'down', this will be 'unknown'.
						#   * If the duplex is now 'full', then it's fine.
						#   * If the duplex is now 'half', then the cable is probably
						#     failing.
						# * Link failure count has changed.
						#   * In the new value is '0', the bond reset.
						#   * If the MII state is 'down' or 'going back', this is 
						#     normal.
						# * The MAC address has changed. This almost certainly means
						#   the NIC was replaced.
						# * The slave queue ID changed, which should never happen in
						#   an Anvil! and so is a warning. This is usually '0' and,
						#   if changed, may be the sign of an admin trying to do 
						#   complex networking by biasing some traffic to the slaved
						#   interface with the non-0 queue ID.
						
						### Create the alerts
						# * The MII status changed.
						#   * 'up' -> 'down'         = Link failed, warning level 
						#                              alert
						#   * 'up' -> 'going back'   = Link dropped but quickly came
						#                              back
						#   * 'down' -> 'up'         = Link recovered quickly... Too
						#                              quickly, warning level alert.
						#   * 'down' -> 'going back' = Link is recovering.
						#   * 'going back' -> 'down' = Link failed again when 
						#                              recovering. This is normal 
						#                              when a switch is booting up.
						#   * 'going back' -> 'up'   = Link has recovered.
						if ($new_bond_interface_mii_status ne $old_bond_interface_mii_status)
						{
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "new_bond_interface_mii_status", value1 => $new_bond_interface_mii_status, 
								name2 => "old_bond_interface_mii_status", value2 => $old_bond_interface_mii_status, 
							}, file => $THIS_FILE, line => __LINE__});
							
							# Sort out what to call the new status.
							my $say_old_bond_interface_mii_status = $old_bond_interface_mii_status;
							if    ($say_old_bond_interface_mii_status eq "up")         { $say_old_bond_interface_mii_status = "#!string!scan_bond_state_0001!#"; }
							elsif ($say_old_bond_interface_mii_status eq "down")       { $say_old_bond_interface_mii_status = "#!string!scan_bond_state_0002!#"; }
							elsif ($say_old_bond_interface_mii_status eq "going back") { $say_old_bond_interface_mii_status = "#!string!scan_bond_state_0003!#"; }
							
							my $say_new_bond_interface_mii_status = $new_bond_interface_mii_status;
							if    ($say_new_bond_interface_mii_status eq "up")         { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0001!#"; }
							elsif ($say_new_bond_interface_mii_status eq "down")       { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0002!#"; }
							elsif ($say_new_bond_interface_mii_status eq "going back") { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0003!#"; }
							
							# Tell the user
							my $alert_title_key         = "an_alert_title_0004";
							my $alert_message_key       = "scan_bond_warning_0018";
							my $alert_message_variables = {
								bond_name		=>	$bond_name, 
								interface_name		=>	$bond_interface_name, 
								new_value		=>	$say_new_bond_interface_mii_status, 
								old_value		=>	$say_old_bond_interface_mii_status, 
							};
							if (($old_bond_interface_mii_status eq "up") && ($new_bond_interface_mii_status eq "down"))
							{
								# Lost the link
								$alert_message_key = "scan_bond_warning_0019";
							}
							elsif (($old_bond_interface_mii_status eq "up") && ($new_bond_interface_mii_status eq "going back"))
							{
								# Dropped and recovered between the last scan
								# and this one.
								$alert_message_key = "scan_bond_warning_0020";
							}
							elsif (($old_bond_interface_mii_status eq "down") && ($new_bond_interface_mii_status eq "up"))
							{
								# A link that was down came up very quickly,
								# bypassing the updelay. This can happen if
								# the other link went down while this 
								# interface was 'going back'.
								$alert_title_key   = "an_alert_title_0006";
								$alert_message_key = "scan_bond_warning_0021";
							}
							elsif (($old_bond_interface_mii_status eq "down") && ($new_bond_interface_mii_status eq "going back"))
							{
								# The link is recovering
								if ($bond_interface_name eq $new_bond_primary_slave)
								{
									# Primary link recovering.
									$alert_message_key = "scan_bond_warning_0022";
								}
								else
								{
									# Backup link recovering.
									$alert_message_key = "scan_bond_warning_0023";
								}
							}
							elsif (($old_bond_interface_mii_status eq "going back") && ($new_bond_interface_mii_status eq "down"))
							{
								# The link is failed again or the switch it
								# is plugged into is booting.
								$alert_message_key = "scan_bond_warning_0024";
							}
							elsif (($old_bond_interface_mii_status eq "going back") && ($new_bond_interface_mii_status eq "up"))
							{
								# The link has recovered (updelay expired or
								# other link dropped).
								$alert_title_key   = "an_alert_title_0006";
								$alert_message_key = "scan_bond_warning_0025";
							}
							$an->Alert->register_alert({
								alert_level		=>	"warning", 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	$alert_title_key,
								alert_message_key	=>	$alert_message_key,
								alert_message_variables	=>	$alert_message_variables,
							});
						}
						
						# * Link speed has changed, this is a warning level alert. 
						#   * If the mii status is 'down', this is normally 'unknown'.
						#   * If the mii state is 'going back' or 'up', check to see
						#     what the fastest it was in the past. 
						#     * If it is lower, then the network cable might be 
						#       failing.
						#     * If it is the same, it's returned to normal.
						#     * If it is faster, the NIC was probably upgraded.
						if ($new_bond_interface_speed ne $old_bond_interface_speed)
						{
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "new_bond_interface_speed", value1 => $new_bond_interface_speed, 
								name2 => "old_bond_interface_speed", value2 => $old_bond_interface_speed, 
							}, file => $THIS_FILE, line => __LINE__});
							
							# Get human-readable strings
							my $say_new_bond_interface_speed = translate_link_speed($an, $new_bond_interface_speed);
							my $say_old_bond_interface_speed = translate_link_speed($an, $old_bond_interface_speed);
							
							# Tell the user
							my $alert_level             = "warning";
							my $alert_title_key         = "an_alert_title_0004";
							my $alert_message_key       = "scan_bond_warning_0026";
							my $alert_message_variables = {
								bond_name		=>	$bond_name, 
								interface_name		=>	$bond_interface_name, 
								new_value		=>	$say_new_bond_interface_speed, 
								old_value		=>	$say_old_bond_interface_speed, 
							};
							
							if ($new_bond_interface_speed eq "-1")
							{
								# Lost the link
								$alert_message_key = "scan_bond_warning_0027";
							}
							else
							{
								# We have an actual new interface speed. See
								# if the new speed is equal or greater than
								# the previously fastest speed for the given
								# MAC address.
								my $query = "
SELECT 
    bond_interface_speed 
FROM 
    history.bond_interface 
WHERE 
    bond_interface_id = (
        SELECT 
            c.bond_interface_id 
        FROM 
            hosts a, 
            bond b, 
            bond_interface c 
        WHERE 
            a.host_uuid = b.bond_host_uuid 
        AND 
            b.bond_uuid = c.bond_interface_bond_uuid 
        AND 
            a.host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
        AND 
            c.bond_interface_name = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)."
    ) 
AND 
    bond_interface_mac = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_mac)." 
ORDER BY 
    bond_interface_speed ASC 
LIMIT 1
;";
								$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
									name1 => "query", value1 => $query, 
								}, file => $THIS_FILE, line => __LINE__});
								my $prior_fastest_link_speed = $an->DB->do_db_query({query => $query})->[0]->[0];
								$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
									name1 => "prior_fastest_link_speed", value1 => $prior_fastest_link_speed, 
								}, file => $THIS_FILE, line => __LINE__});
								
								if ($new_bond_interface_speed > $prior_fastest_link_speed)
								{
									# The controller was upgraded
									$alert_title_key   = "an_alert_title_0006";
									$alert_message_key = "scan_bond_warning_0028";
								}
								elsif ($new_bond_interface_speed == $prior_fastest_link_speed)
								{
									# Link came back up at the normal 
									# link speed
									$alert_title_key   = "an_alert_title_0006";
									$alert_message_key = "scan_bond_warning_0029";
								}
								elsif ($new_bond_interface_speed < $prior_fastest_link_speed)
								{
									# Link came up at a lower speed, 
									# cable might be bad.
									my $say_prior_fastest_link_speed = translate_link_speed($an, $prior_fastest_link_speed);
									$alert_level       = "critical";
									$alert_title_key   = "an_alert_title_0005";
									$alert_message_key = "scan_bond_warning_0030";
									$alert_message_variables = {
										bond_name		=>	$bond_name, 
										interface_name		=>	$bond_interface_name, 
										new_value		=>	$say_new_bond_interface_speed, 
										old_value		=>	$say_old_bond_interface_speed, 
										prior_fastest		=>	$say_prior_fastest_link_speed,
									};
								}
							}
							$an->Alert->register_alert({
								alert_level		=>	$alert_level, 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	$alert_title_key,
								alert_message_key	=>	$alert_message_key,
								alert_message_variables	=>	$alert_message_variables,
							});
						}
						
						# * Link duplex has changed, this is a warning level alert.
						#   * If the MII state is 'down', this will be 'unknown'.
						#   * If the duplex is now 'full', then it's fine.
						#   * If the duplex is now 'half', then the cable is probably
						#     failing.
						if ($new_bond_interface_duplex ne $old_bond_interface_duplex)
						{
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "new_bond_interface_duplex", value1 => $new_bond_interface_duplex, 
								name2 => "old_bond_interface_duplex", value2 => $old_bond_interface_duplex, 
							}, file => $THIS_FILE, line => __LINE__});
							
							my $say_new_bond_interface_duplex = $new_bond_interface_duplex;
							if    ($say_new_bond_interface_duplex =~ /full/i)    { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0005!#"; }
							elsif ($say_new_bond_interface_duplex =~ /half/i)    { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0006!#"; }
							elsif ($say_new_bond_interface_duplex =~ /unknown/i) { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0004!#"; }
							
							my $say_old_bond_interface_duplex = $old_bond_interface_duplex;
							if    ($say_old_bond_interface_duplex =~ /full/i)    { $say_old_bond_interface_duplex = "#!string!scan_bond_state_0005!#"; }
							elsif ($say_old_bond_interface_duplex =~ /half/i)    { $say_old_bond_interface_duplex = "#!string!scan_bond_state_0006!#"; }
							elsif ($say_old_bond_interface_duplex =~ /unknown/i) { $say_old_bond_interface_duplex = "#!string!scan_bond_state_0004!#"; }
							
							# Tell the user
							my $alert_level             = "warning";
							my $alert_title_key         = "an_alert_title_0004";
							my $alert_message_key       = "scan_bond_warning_0031";
							my $alert_message_variables = {
								bond_name		=>	$bond_name, 
								interface_name		=>	$bond_interface_name, 
								new_value		=>	$say_new_bond_interface_duplex, 
								old_value		=>	$say_old_bond_interface_duplex, 
							};
							if ($new_bond_interface_duplex eq "full")
							{
								# Returned to normal.
								$alert_title_key   = "an_alert_title_0006";
								$alert_message_key = "scan_bond_warning_0032";
							}
							elsif ($new_bond_interface_duplex eq "half")
							{
								# Not good...
								$alert_level       = "critical";
								$alert_title_key   = "an_alert_title_0005";
								$alert_message_key = "scan_bond_warning_0033";
							}
							elsif ($new_bond_interface_duplex =~ /Unknown/i)
							{
								# Link is down
								$alert_message_key = "scan_bond_warning_0034";
							}
							$an->Alert->register_alert({
								alert_level		=>	$alert_level, 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	$alert_title_key,
								alert_message_key	=>	$alert_message_key,
								alert_message_variables	=>	$alert_message_variables,
							});
						}
						
						# * Link failure count has changed.
						#   * In the new value is '0', the bond reset.
						#   * If the MII state is 'down' or 'going back', this is 
						#     normal.
						if ($new_bond_interface_failure_count ne $old_bond_interface_failure_count)
						{
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "new_bond_interface_failure_count", value1 => $new_bond_interface_failure_count, 
								name2 => "old_bond_interface_failure_count", value2 => $old_bond_interface_failure_count, 
							}, file => $THIS_FILE, line => __LINE__});
							
							# Tell the user
							my $alert_title_key         = "an_alert_title_0004";
							my $alert_message_key       = "scan_bond_warning_0035";
							my $alert_message_variables = {
								bond_name		=>	$bond_name, 
								interface_name		=>	$bond_interface_name, 
								new_value		=>	$new_bond_interface_failure_count, 
								old_value		=>	$old_bond_interface_failure_count, 
							};
							if ($new_bond_interface_failure_count eq "0")
							{
								# Bond was reset
								$alert_message_key = "scan_bond_warning_0036";
							}
							elsif ($new_bond_interface_failure_count > $old_bond_interface_failure_count)
							{
								# Failure count has risen
								$alert_message_key = "scan_bond_warning_0037";
							}
							$an->Alert->register_alert({
								alert_level		=>	"warning", 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	$alert_title_key,
								alert_message_key	=>	$alert_message_key,
								alert_message_variables	=>	$alert_message_variables,
							});
						}
						
						# * The MAC address has changed. This almost certainly means
						#   the NIC was replaced.
						if ($new_bond_interface_mac ne $old_bond_interface_mac)
						{
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "new_bond_interface_mac", value1 => $new_bond_interface_mac, 
								name2 => "old_bond_interface_mac", value2 => $old_bond_interface_mac, 
							}, file => $THIS_FILE, line => __LINE__});
							
							# Tell the user
							$an->Alert->register_alert({
								alert_level		=>	"notice", 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	"an_alert_title_0003",
								alert_message_key	=>	"scan_bond_warning_0038",
								alert_message_variables	=>	{
									bond_name		=>	$bond_name, 
									interface_name		=>	$bond_interface_name, 
									new_value		=>	$new_bond_interface_mac, 
									old_value		=>	$old_bond_interface_mac, 
								},
							});
						}
						
						# * The slave queue ID changed, which should never happen in
						#   an Anvil! and so is a warning. This is usually '0' and,
						#   if changed, may be the sign of an admin trying to do 
						#   complex networking by biasing some traffic to the slaved
						#   interface with the non-0 queue ID.
						if ($new_bond_interface_slave_queue_id ne $old_bond_interface_slave_queue_id)
						{
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "new_bond_interface_slave_queue_id", value1 => $new_bond_interface_slave_queue_id, 
								name2 => "old_bond_interface_slave_queue_id", value2 => $old_bond_interface_slave_queue_id, 
							}, file => $THIS_FILE, line => __LINE__});
							
							# Tell the user
							$an->Alert->register_alert({
								alert_level		=>	"notice", 
								alert_agent_name	=>	"$THIS_FILE",
								alert_title_key		=>	"an_alert_title_0003",
								alert_message_key	=>	"scan_bond_warning_0039",
								alert_message_variables	=>	{
									bond_name		=>	$bond_name, 
									interface_name		=>	$bond_interface_name, 
									new_value		=>	$new_bond_interface_slave_queue_id, 
									old_value		=>	$old_bond_interface_slave_queue_id, 
								},
							});
						}
						
						# Now UPDATE the database.
						my $query = "
UPDATE 
    bond_interface 
SET 
    bond_interface_mii_status     = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_mii_status).", 
    bond_interface_speed          = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_speed).", 
    bond_interface_duplex         = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_duplex).", 
    bond_interface_failure_count  = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_failure_count).", 
    bond_interface_mac            = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_mac).", 
    bond_interface_slave_queue_id = ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_slave_queue_id).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    bond_interface_id = 
    (
        SELECT 
            c.bond_interface_id 
        FROM 
            hosts a, 
            bond b, 
            bond_interface c 
        WHERE 
            a.host_uuid = b.bond_host_uuid 
        AND 
            b.bond_uuid = c.bond_interface_bond_uuid 
        AND 
            a.host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
        AND 
            c.bond_interface_name = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)."
    )
;";
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
					}
				}
				else
				{
					### New interface, INSERT
					# Status
					my $say_new_bond_interface_mii_status = $new_bond_interface_mii_status;
					if    ($say_new_bond_interface_mii_status eq "up")         { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0001!#"; }
					elsif ($say_new_bond_interface_mii_status eq "down")       { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0002!#"; }
					elsif ($say_new_bond_interface_mii_status eq "going back") { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0003!#"; }
					
					# Speed
					my $say_new_bond_interface_speed = translate_link_speed($an, $new_bond_interface_speed);
					
					# Duplex
					my $say_new_bond_interface_duplex = $new_bond_interface_duplex;
					if    ($say_new_bond_interface_duplex =~ /full/i)    { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0005!#"; }
					elsif ($say_new_bond_interface_duplex =~ /half/i)    { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0006!#"; }
					elsif ($say_new_bond_interface_duplex =~ /unknown/i) { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0004!#"; }
					
					# Create the alert
					$an->Alert->register_alert({
						alert_level		=>	"notice", 
						alert_agent_name	=>	"$THIS_FILE",
						alert_title_key		=>	"an_alert_title_0003",
						alert_message_key	=>	"scan_bond_warning_0040",
						alert_message_variables	=>	{
							bond_name		=>	$bond_name, 
							interface_name		=>	$bond_interface_name, 
							mii_status		=>	$say_new_bond_interface_mii_status, 
							speed			=>	$say_new_bond_interface_speed, 
							duplex			=>	$say_new_bond_interface_duplex, 
							failure_count		=>	$new_bond_interface_failure_count, 
							mac			=>	uc($new_bond_interface_mac), 
							slave_queue_id		=>	$new_bond_interface_slave_queue_id, 
						},
					});
					
					# Now record it.
					my $query = "
INSERT INTO 
    bond_interface
(
    bond_interface_bond_uuid, 
    bond_interface_name, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_interface_slave_queue_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
				}
				
				# Now delete it so I don't see it when looking for strays.
				delete $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name};
			}
			
			# See if any interfaces from before are left. If they are, change their
			# 'bond_interface_mii_status' to 'DELETED' but don't actually delete them in case
			# they come back later.
			foreach my $bond_interface_name (sort {$a cmp $b} keys %{$an->data->{sql}{$bond_name}{bond_interface_name}})
			{
				# Iz gone back to itz peoples...
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_agent_name	=>	"$THIS_FILE",
					alert_title_key		=>	"an_alert_title_0004",
					alert_message_key	=>	"scan_bond_warning_0041",
					alert_message_variables	=>	{
						bond_name		=>	$bond_name, 
						interface_name		=>	$bond_interface_name, 
					},
				});
				
				# Update
				my $query = "
UPDATE 
    bond_interface 
SET 
    bond_interface_mii_status = 'DELETED', 
    modified_date             = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    bond_interface_id = 
    (
        SELECT 
            c.bond_interface_id 
        FROM 
            hosts a, 
            bond b, 
            bond_interface c 
        WHERE 
            a.host_uuid = b.bond_host_uuid 
        AND 
            b.bond_uuid = c.bond_interface_bond_uuid 
        AND 
            a.host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
        AND 
            c.bond_interface_name = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)."
    )
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
		}
		else
		{
			### It's a new bond, INSERT it and all its slaved interfaces.
			# Generate a new UUID for this bond.
			my $new_bond_uuid = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
			
			# Mode
			my $say_new_bond_mode = "#!string!scan_bond_mode_${new_bond_mode}!#";
			
			# Primary reselect policy.
			my $say_new_bond_primary_reselect = "#!string!scan_bond_reselect_${new_bond_primary_reselect}!#";
			
			# MII status
			my $say_new_bond_mii_status = $new_bond_mii_status;
			if    ($say_new_bond_mii_status eq "up")   { $say_new_bond_mii_status = "#!string!scan_bond_state_0001!#"; }
			elsif ($say_new_bond_mii_status eq "down") { $say_new_bond_mii_status = "#!string!scan_bond_state_0002!#"; }
			
			# Tell 
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scan_bond_warning_0042",
				alert_message_variables	=>	{
					bond_name		=>	$bond_name, 
					mode			=>	$say_new_bond_mode, 
					primary_slave		=>	$new_bond_primary_slave, 
					primary_reselect	=>	$say_new_bond_primary_reselect, 
					active_slave		=>	$new_bond_active_slave, 
					mii_status		=>	$say_new_bond_mii_status, 
					mii_polling_interval	=>	$new_bond_mii_polling_interval, 
					up_delay		=>	$new_bond_up_delay, 
					down_delay		=>	$new_bond_down_delay, 
				},
			});
			
			# Do the INSERT.
			my $query = "
INSERT INTO 
    bond
(
    bond_host_uuid, 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_mode).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_primary_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_primary_reselect).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_active_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_mii_polling_interval).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_up_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_down_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Now add the nodes.
			foreach my $bond_interface_name (sort {$a cmp $b} keys %{$an->data->{bond}{$bond_name}{slave}})
			{
				my $bond_interface_mii_status     = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mii_status};
				my $bond_interface_speed          = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{speed};
				my $bond_interface_duplex         = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{duplex};
				my $bond_interface_failure_count  = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{failure_count};
				my $bond_interface_mac            = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mac};
				my $bond_interface_slave_queue_id = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{slave_queue_id};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
					name1 => "bond_interface_name",           value1 => $bond_interface_name, 
					name2 => "bond_interface_speed",          value2 => $bond_interface_speed, 
					name3 => "bond_interface_duplex",         value3 => $bond_interface_duplex, 
					name4 => "bond_interface_failure_count",  value4 => $bond_interface_failure_count, 
					name5 => "bond_interface_mac",            value5 => $bond_interface_mac, 
					name6 => "bond_interface_slave_queue_id", value6 => $bond_interface_slave_queue_id, 
				}, file => $THIS_FILE, line => __LINE__});
			
				# Status
				my $say_new_bond_interface_mii_status = $bond_interface_mii_status;
				if    ($say_new_bond_interface_mii_status eq "up")         { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0001!#"; }
				elsif ($say_new_bond_interface_mii_status eq "down")       { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0002!#"; }
				elsif ($say_new_bond_interface_mii_status eq "going back") { $say_new_bond_interface_mii_status = "#!string!scan_bond_state_0003!#"; }
				
				# Speed
				my $say_new_bond_interface_speed = translate_link_speed($an, $bond_interface_speed);
				
				# Duplex
				my $say_new_bond_interface_duplex = $bond_interface_duplex;
				if    ($say_new_bond_interface_duplex =~ /full/i)    { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0005!#"; }
				elsif ($say_new_bond_interface_duplex =~ /half/i)    { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0006!#"; }
				elsif ($say_new_bond_interface_duplex =~ /unknown/i) { $say_new_bond_interface_duplex = "#!string!scan_bond_state_0004!#"; }
				
				# Create the alert
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_agent_name	=>	"$THIS_FILE",
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_bond_warning_0040",
					alert_message_variables	=>	{
						bond_name		=>	$bond_name, 
						interface_name		=>	$bond_interface_name, 
						mii_status		=>	$say_new_bond_interface_mii_status, 
						speed			=>	$say_new_bond_interface_speed, 
						duplex			=>	$say_new_bond_interface_duplex, 
						failure_count		=>	$bond_interface_failure_count, 
						mac			=>	uc($bond_interface_mac), 
						slave_queue_id		=>	$bond_interface_slave_queue_id, 
					},
				});
				
				my $query = "
INSERT INTO 
    bond_interface
(
    bond_interface_name, 
    bond_interface_bond_uuid, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
		}
		
		# Now delete it so we don't see it later
		delete $an->data->{sql}{$bond_name};
	}
	
	# Now see if we have any bonds from this scan left. If so, they've disappeared. Set their 
	# 'bond_mii_status' to 'DELETED', but don't actually delete it in case it comes back later.
	foreach my $bond_name (sort {$a cmp $b} keys %{$an->data->{sql}})
	{
		# Bye bye Mr. or Ms. bond.
		my $bond_uuid = $an->data->{sql}{$bond_name}{bond_uuid};
		$an->Alert->register_alert({
			alert_level		=>	"warning", 
			alert_agent_name	=>	"$THIS_FILE",
			alert_title_key		=>	"an_alert_title_0004",
			alert_message_key	=>	"scan_bond_warning_0043",
			alert_message_variables	=>	{
				bond_name		=>	$bond_name, 
			},
		});
		
		my $query = "
UPDATE 
    public.bond
SET
    bond_mii_status = 'DELETED', 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    bond_uuid      = ".$an->data->{sys}{use_db_fh}->quote($bond_uuid)." 
;";
		# Now record the query in the array
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "id", value1 => $id, 
		}, file => $THIS_FILE, line => __LINE__});
		push @{$an->data->{sys}{sql}}, $query;
	}
	
	# Now commit the changes.
	commit_sql($an);
	
	return(0);
}

### TODO: Move this into the Math or Convert module
# This takes a raw link speed and translates it into a string.
sub translate_link_speed
{
	my ($an, $interface_speed) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "translate_link_speed", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "interface_speed", value1 => $interface_speed 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $say_interface_speed = $interface_speed;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_interface_speed", value1 => $say_interface_speed, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if (($interface_speed =~ /Unknown/) or ($interface_speed eq "-1"))
	{
		$say_interface_speed = "#!string!scan_bond_state_0004!#";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "say_interface_speed", value1 => $say_interface_speed, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($interface_speed >= 1000000000000)
	{
		# Tbps
		$say_interface_speed /= 1000000000000;
		$say_interface_speed = sprintf("%.3f", $say_interface_speed);
		$say_interface_speed =~ s/0+$//;
		$say_interface_speed =~ s/\.$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "say_interface_speed", value1 => $say_interface_speed, 
		}, file => $THIS_FILE, line => __LINE__});
		$say_interface_speed = $an->String->get({
			key		=>	"tools_suffix_0026",
			variables	=>	{
				speed		=>	$say_interface_speed,
			},
		});
	}
	elsif ($interface_speed >= 1000000000)
	{
		# Gbps
		$say_interface_speed /= 1000000000;
		$say_interface_speed = sprintf("%.3f", $say_interface_speed);
		$say_interface_speed =~ s/0+$//;
		$say_interface_speed =~ s/\.$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "say_interface_speed", value1 => $say_interface_speed, 
		}, file => $THIS_FILE, line => __LINE__});
		$say_interface_speed = $an->String->get({
			key		=>	"tools_suffix_0025",
			variables	=>	{
				speed		=>	$say_interface_speed,
			},
		});
	}
	elsif ($interface_speed >= 1000000)
	{
		# Mbps
		$say_interface_speed /= 1000000;
		$say_interface_speed = sprintf("%.2f", $say_interface_speed);
		$say_interface_speed =~ s/0+$//;
		$say_interface_speed =~ s/\.$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "say_interface_speed", value1 => $say_interface_speed, 
		}, file => $THIS_FILE, line => __LINE__});
		$say_interface_speed = $an->String->get({
			key		=>	"tools_suffix_0024",
			variables	=>	{
				speed		=>	$say_interface_speed,
			},
		});
	}
	elsif ($interface_speed >= 1000)
	{
		# Kbps
		$say_interface_speed /= 1000;
		$say_interface_speed = sprintf("%.1f", $say_interface_speed);
		$say_interface_speed =~ s/0+$//;
		$say_interface_speed =~ s/\.$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "say_interface_speed", value1 => $say_interface_speed, 
		}, file => $THIS_FILE, line => __LINE__});
		$say_interface_speed = $an->String->get({
			key		=>	"tools_suffix_0023",
			variables	=>	{
				speed		=>	$say_interface_speed,
			},
		});
	}
	elsif ($interface_speed =~ /^\d+$/)
	{
		# bps
		$say_interface_speed = $an->String->get({
			key		=>	"tools_suffix_0022",
			variables	=>	{
				speed		=>	$say_interface_speed,
			},
		});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_interface_speed", value1 => $say_interface_speed, 
	}, file => $THIS_FILE, line => __LINE__});
	return($say_interface_speed);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}, source => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If any entries are found, this will get set to '0'.
	my $new   = 1;
	my $query = "
SELECT 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay 
FROM 
    bond 
WHERE 
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query});
	foreach my $row (@{$results})
	{
		my $bond_uuid                 = $row->[0];
		my $bond_name                 = $row->[1];
		my $bond_mode                 = $row->[2];
		my $bond_primary_slave        = $row->[3];
		my $bond_primary_reselect     = $row->[4];
		my $bond_active_slave         = $row->[5];
		my $bond_mii_status           = $row->[6];
		my $bond_mii_polling_interval = $row->[7];
		my $bond_up_delay             = $row->[8];
		my $bond_down_delay           = $row->[9];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
			name1  => "bond_uuid",                 value1  => $bond_uuid, 
			name2  => "bond_name",                 value2  => $bond_name, 
			name3  => "bond_mode",                 value3  => $bond_mode, 
			name4  => "bond_primary_slave",        value4  => $bond_primary_slave, 
			name5  => "bond_primary_reselect",     value5  => $bond_primary_reselect, 
			name6  => "bond_active_slave",         value6  => $bond_active_slave, 
			name7  => "bond_mii_status",           value7  => $bond_mii_status, 
			name8  => "bond_mii_polling_interval", value8  => $bond_mii_polling_interval, 
			name9  => "bond_up_delay",             value9  => $bond_up_delay, 
			name10 => "bond_down_delay",           value10 => $bond_down_delay, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Push the data into the hash for later comparison
		$an->data->{sql}{$bond_name}{bond_uuid}                 = $bond_uuid;
		$an->data->{sql}{$bond_name}{bond_mode}                 = $bond_mode;
		$an->data->{sql}{$bond_name}{bond_primary_slave}        = $bond_primary_slave;
		$an->data->{sql}{$bond_name}{bond_primary_reselect}     = $bond_primary_reselect;
		$an->data->{sql}{$bond_name}{bond_active_slave}         = $bond_active_slave;
		$an->data->{sql}{$bond_name}{bond_mii_status}           = $bond_mii_status;
		$an->data->{sql}{$bond_name}{bond_mii_polling_interval} = $bond_mii_polling_interval;
		$an->data->{sql}{$bond_name}{bond_up_delay}             = $bond_up_delay;
		$an->data->{sql}{$bond_name}{bond_down_delay}           = $bond_down_delay;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
			name1 => "sql::${bond_name}::bond_uuid",                 value1 => $an->data->{sql}{$bond_name}{bond_uuid}, 
			name2 => "sql::${bond_name}::bond_mode",                 value2 => $an->data->{sql}{$bond_name}{bond_mode}, 
			name3 => "sql::${bond_name}::bond_primary_slave",        value3 => $an->data->{sql}{$bond_name}{bond_primary_slave}, 
			name4 => "sql::${bond_name}::bond_primary_reselect",     value4 => $an->data->{sql}{$bond_name}{bond_primary_reselect}, 
			name5 => "sql::${bond_name}::bond_active_slave",         value5 => $an->data->{sql}{$bond_name}{bond_active_slave}, 
			name6 => "sql::${bond_name}::bond_mii_status",           value6 => $an->data->{sql}{$bond_name}{bond_mii_status}, 
			name7 => "sql::${bond_name}::bond_mii_polling_interval", value7 => $an->data->{sql}{$bond_name}{bond_mii_polling_interval}, 
			name8 => "sql::${bond_name}::bond_up_delay",             value8 => $an->data->{sql}{$bond_name}{bond_up_delay}, 
			name9 => "sql::${bond_name}::bond_down_delay",           value9 => $an->data->{sql}{$bond_name}{bond_down_delay}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Read in the slaved interfaces for this bond.
		my $query = "
SELECT 
    bond_interface_name, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id 
FROM 
    bond_interface 
WHERE 
    bond_interface_bond_uuid = ".$an->data->{sys}{use_db_fh}->quote($bond_uuid)."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		my $results = $an->DB->do_db_query({query => $query});
		foreach my $row (@{$results})
		{
			my $bond_interface_name           = $row->[0]; 
			my $bond_interface_mii_status     = $row->[1]; 
			my $bond_interface_speed          = $row->[2]; 
			my $bond_interface_duplex         = $row->[3]; 
			my $bond_interface_failure_count  = $row->[4]; 
			my $bond_interface_mac            = $row->[5]; 
			my $bond_interface_slave_queue_id = $row->[6];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
				name1 => "bond_interface_name",           value1 => $bond_interface_name, 
				name2 => "bond_interface_mii_status",     value2 => $bond_interface_mii_status, 
				name3 => "bond_interface_speed",          value3 => $bond_interface_speed, 
				name4 => "bond_interface_duplex",         value4 => $bond_interface_duplex, 
				name5 => "bond_interface_failure_count",  value5 => $bond_interface_failure_count, 
				name6 => "bond_interface_mac",            value6 => $bond_interface_mac, 
				name7 => "bond_interface_slave_queue_id", value7 => $bond_interface_slave_queue_id, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Push the data into the hash for later comparison
			$an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_mii_status}     = $bond_interface_mii_status;
			$an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_speed}          = $bond_interface_speed;
			$an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_duplex}         = $bond_interface_duplex;
			$an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_failure_count}  = $bond_interface_failure_count;
			$an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_mac}            = $bond_interface_mac;
			$an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_slave_queue_id} = $bond_interface_slave_queue_id;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}::bond_interface_mii_status",     value1 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_mii_status}, 
				name2 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}::bond_interface_speed",          value2 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_speed}, 
				name3 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}::bond_interface_duplex",         value3 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_duplex}, 
				name4 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}::bond_interface_failure_count",  value4 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_failure_count}, 
				name5 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}::bond_interface_mac",            value5 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_mac}, 
				name6 => "sql::${bond_name}::bond_interface_name::${bond_interface_name}::bond_interface_slave_queue_id", value6 => $an->data->{sql}{$bond_name}{bond_interface_name}{$bond_interface_name}{bond_interface_slave_queue_id}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		$new = 0;
	}
	
	return($new);
}

# This looks rgmanager's 'bond' and, if it is found, parse it.
sub parse_bonds
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "parse_bond", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $return_code = 1;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::proc_bond", value1 => $an->data->{path}{proc_bond},
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{proc_bond})
	{
		local(*DIRECTORY);
		opendir(DIRECTORY, $an->data->{path}{proc_bond});
		while(my $file = readdir(DIRECTORY))
		{
			next if $file eq ".";
			next if $file eq "..";
			
			# There is a bug where an almost-empty 'bond0' 
			# interface file is created, we want to ignore that.
			next if $file eq "bond0";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "file", value1 => $file,
			}, file => $THIS_FILE, line => __LINE__});
			
			# OK, parse
			my $full_path = $an->data->{path}{proc_bond}."/$file";
			my $bond_name = $file;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "full_path", value1 => $full_path, 
				name2 => "bond_name", value2 => $bond_name,
			}, file => $THIS_FILE, line => __LINE__});
			if (-r $full_path)
			{
				# Woot!
				my $bond_interface_name = "";
				my $shell_call          = $full_path;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => "$shell_call", 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => "$line"
					}, file => $THIS_FILE, line => __LINE__});
					
					# Core bonding details
					if (not $bond_interface_name)
					{
						if ($line =~ /Bonding Mode: .*? \((.*?)\)/)
						{
							# We want to store the mode as the numberical type.
							$an->data->{bond}{$bond_name}{mode} = $1;
							$an->data->{bond}{$bond_name}{mode} = translate_mode_name_to_number($an, $an->data->{bond}{$bond_name}{mode});
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::mode", value1 => $an->data->{bond}{$bond_name}{mode}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Primary Slave: (.*?) \(primary_reselect (.*?)\)/)
						{
							$an->data->{bond}{$bond_name}{primary_slave}    = $1;
							$an->data->{bond}{$bond_name}{primary_reselect} = $2;
							
							# Convert the reselect name to a number.
							$an->data->{bond}{$bond_name}{primary_reselect} = translate_reselect_policy_name_to_number($an, $an->data->{bond}{$bond_name}{primary_reselect});
							
							$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
								name1 => "bond::${bond_name}::primary_slave",    value1 => $an->data->{bond}{$bond_name}{primary_slave}, 
								name2 => "bond::${bond_name}::primary_reselect", value2 => $an->data->{bond}{$bond_name}{primary_reselect}, 
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Currently Active Slave: (.*)$/)
						{
							$an->data->{bond}{$bond_name}{active_slave} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::active_slave", value1 => $an->data->{bond}{$bond_name}{active_slave}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /MII Status: (.*)$/)
						{
							$an->data->{bond}{$bond_name}{mii_status} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::mii_status", value1 => $an->data->{bond}{$bond_name}{mii_status}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /MII Polling Interval \(ms\): (\d+)$/)
						{
							$an->data->{bond}{$bond_name}{mii_polling_interval} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::mii_polling_interval", value1 => $an->data->{bond}{$bond_name}{mii_polling_interval}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Up Delay \(ms\): (\d+)$/)
						{
							$an->data->{bond}{$bond_name}{up_delay} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::up_delay", value1 => $an->data->{bond}{$bond_name}{up_delay}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Down Delay \(ms\): (\d+)$/)
						{
							$an->data->{bond}{$bond_name}{down_delay} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::down_delay", value1 => $an->data->{bond}{$bond_name}{down_delay}
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
					if ($line =~ /Slave Interface: (.*)$/)
					{
						$bond_interface_name = $1;
						$return_code         = 0;
						next;
					}
					if (($bond_interface_name) && (not $line))
					{
						$bond_interface_name = "";
						next;
					}
					
					# Slave details
					if ($bond_interface_name)
					{
						if ($line =~ /MII Status: (.*)$/)
						{
							$an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mii_status} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::slave::${bond_interface_name}::mii_status", value1 => $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mii_status}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Speed: (.*)$/)
						{
							# Convert to bps for the DB
							my $speed = $1;
							$an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{speed} = convert_to_bps($an, $speed);
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::slave::${bond_interface_name}::speed", value1 => $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{speed}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Duplex: (.*)$/)
						{
							$an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{duplex} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::slave::${bond_interface_name}::duplex", value1 => $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{duplex}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Link Failure Count: (\d+)$/)
						{
							$an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{failure_count} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::slave::${bond_interface_name}::failure_count", value1 => $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{failure_count}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Permanent HW addr: (.*)$/)
						{
							$an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mac} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::slave::${bond_interface_name}::mac", value1 => $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mac}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Slave queue ID: (.*)$/)
						{
							# I really don't need this, but maybe
							# someday...
							$an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{slave_queue_id} = $1;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond_name}::slave::${bond_interface_name}::slave_queue_id", value1 => $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{slave_queue_id}
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
				}
				close $file_handle;
			}
		}
	}
	else
	{
		# Not in use.
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0005", message_key => "scan_bond_message_0003", file => $THIS_FILE, line => __LINE__});
		$return_code = 1;
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "return_code", value1 => $return_code
	}, file => $THIS_FILE, line => __LINE__});
	
	return($return_code);
}

### TODO: Move to AN::Convert and add more sanity checks
# This converts a bit-rate speed to Mbps
sub convert_to_bps
{
	my ($an, $say_speed) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "convert_to_bps", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "say_speed", value1 => $say_speed 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $speed     = "";
	
	$say_speed = lc($say_speed);
	$say_speed =~ s/,//g;
	$say_speed =~ s/ //g;
	
	if ($say_speed =~ /^(\d+)$/)
	{
		$speed = $1;
	}
	elsif ($say_speed =~ /(\d+)kbps/i)
	{
		$speed = $1;
		$speed *= 1000;
	}
	elsif ($say_speed =~ /(\d+)mbps/i)
	{
		$speed = $1;
		$speed *= 1000000;
	}
	elsif ($say_speed =~ /(\d+)gbps/i)
	{
		$speed = $1;
		$speed *= 1000000000;
	}
	elsif ($say_speed =~ /(\d+)tbps/i)
	{
		$speed = $1;
		$speed *= 1000000000000;
	}
	else
	{
		# The database column is 'numeric', so if this contains any non-digit characters, convert it
		# to '-1' which we'll interpret as 'Unknown'.
		$speed = -1;
	}
	
	return($speed);
}

# This translates the reselect policy name to it's numerical equivalent.
sub translate_reselect_policy_name_to_number
{
	my ($an, $reselect_name) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "translate_reselect_policy_name_to_number", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "reselect_name", value1 => $reselect_name 
	}, file => $THIS_FILE, line => __LINE__});
	
	# See the '2. Bonding Driver Options' -> 'primary_reselect' section here:
	# - https://www.kernel.org/doc/Documentation/networking/bonding.txt
	# Number | Name          | Long name / Description
	# -------+---------------+---------------------------------------------------------------------
	#  0     | always        | Always switch back to the primary interface
	#  1     | better        | Switch to the interface with the higher bitrate or duplex
	#  2     | failure       | Use the primary on start, but one switched, stay.
	# -------+---------------+---------------------------------------------------------------------
	my $reselect_number = "";
	if    ($reselect_name eq "always")  { $reselect_number = 0; }
	elsif ($reselect_name eq "better")  { $reselect_number = 1; }
	elsif ($reselect_name eq "failure") { $reselect_number = 2; }
	
	return($reselect_number);
}

# This translates the bond mode name to it's numberical equivalent.
sub translate_mode_name_to_number
{
	my ($an, $mode_name) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "translate_mode_name_to_number", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "mode_name", value1 => $mode_name 
	}, file => $THIS_FILE, line => __LINE__});
	
	# See the 'mode' section here: https://www.kernel.org/doc/Documentation/networking/bonding.txt
	# Number | Name          | Long name / Description
	# -------+---------------+---------------------------------------------------------------------
	#  0     | balance-rr    | Round-robin
	#  1     | active-backup | Active/Backup
	#  2     | balance-xor   | XOR (boolean XOR'ed source MAC with target MAC)
	#  3     | broadcast     | All packets go down all slaves
	#  4     | 802.3ad       | Dynamic link-aggregation groups according to RFC 802.3ad
	#  5     | balance-tlb   | Adaptive transmit load balancing
	#  6     | balance-alb   | Adaptive load balancing: balance-tlb + receive load balancing (rlb)
	# -------+---------------+---------------------------------------------------------------------
	
	my $mode = "";
	if    ($mode_name eq "balance-rr")    { $mode = 0; }
	elsif ($mode_name eq "active-backup") { $mode = 1; }
	elsif ($mode_name eq "balance-xor")   { $mode = 2; }
	elsif ($mode_name eq "broadcast")     { $mode = 3; }
	elsif ($mode_name eq "802.3ad")       { $mode = 4; }
	elsif ($mode_name eq "balance-tlb")   { $mode = 5; }
	elsif ($mode_name eq "balance-alb")   { $mode = 6; }
	
	return($mode);
}

# This translates the numerical bonding mode to a string get.
sub translate_mode_number_to_string_key
{
	my ($an, $mode_number) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "translate_mode_number_to_string_key", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "mode_number", value1 => "$mode_number" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $string_key = "";
	if    ($mode_number == 0) { $string_key = "scan_bond_mode_0"; }
	elsif ($mode_number == 1) { $string_key = "scan_bond_mode_1"; }
	elsif ($mode_number == 2) { $string_key = "scan_bond_mode_2"; }
	elsif ($mode_number == 3) { $string_key = "scan_bond_mode_3"; }
	elsif ($mode_number == 4) { $string_key = "scan_bond_mode_4"; }
	elsif ($mode_number == 5) { $string_key = "scan_bond_mode_5"; }
	elsif ($mode_number == 6) { $string_key = "scan_bond_mode_6"; }
	
	return($string_key);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "exit_code", value1 => "$exit_code" 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit($exit_code);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "${THIS_FILE}_message_0002"})."\n";

	return(0);
}
