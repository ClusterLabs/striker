#!/usr/bin/perl
# 
# This is a ScanCore agent for monitoring bonded network interfaces. It is
# designed for active/passive (mode=1) bonds. Other modes have not been tested
# and may or may not work.
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - Passed in host name was not found in the database.
# 
# NOTE:
#  - Call: [fence_tool ls | grep master | awk '{print $3}'] to see which node
#    is the fence master and use this node only to try and recover failed
#    services.
# 

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		# This will store the data read in when parsing bonds.
		bond		=>	{},
		path		=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it ScanCore, too.
			host_uuid		=>	"/etc/striker/host.uuid",
			log_file		=>	"/var/log/striker.log",
			#log_file		=>	"/var/log/$THIS_FILE.log",
			proc_bond		=>	"/proc/net/bonding",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"$scancore_directory/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		# This is used so that the user can set the language in on
		# striker.conf variable.
		scancore		=>	{
			language		=>	"en_CA",
			log_level		=>	2,
			log_language		=>	"en_CA",
		},
		sys		=>	{
			# This will get set by AN::Tools::DB->connect_to_databases()
			bond_uuid_query		=>	"",
			sql			=>	[],
		},
	}
});

# Set some defaults
$an->default_language    ($an->data->{scancore}{language});
$an->default_log_language($an->data->{scancore}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});

# Set the log level.
$an->Log->level($an->data->{scancore}{log_level});

# Read my stuff
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
$an->String->read_words({file => $an->data->{path}{strings}});
$an->String->read_words({file => $an->data->{path}{core_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for
# help.
print $an->String->get({key => "scan_bond_message_0001"}), "\n";
get_switches($an);

# Read in bond. If it returns '1', then bond wasn't found and we will
# exit.
if (parse_bonds($an))
{
	# No bonds found, exit.
	nice_exit($an, 1);
}

# I'll need to loop through the DBs and ensure our schema is loaded for each
# one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({ log_level => 2, message_key => "scancore_log_0005", message_variables => {
	connections	=>	$connections,
}, file => $THIS_FILE, line => __LINE__});

# Setup some repeatedly used subqueries for easier use later.
$an->data->{sys}{bond_uuid_query}         = "SELECT bond_uuid FROM bond WHERE bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."";
$an->data->{sys}{bond_interface_id_query} = "SELECT b.bond_interface_id FROM bond a, bond_interface b WHERE a.bond_uuid = b.bond_interface_id AND b.bond_interface_bond_uuid = (".$an->data->{sys}{bond_uuid_query}.") AND ";

# Do the loading of the schemas and copying data from more up to date DBs if
# the DB was loaded.
prep_databases($an);

# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
nice_exit($an, 0);

###############################################################################
# Functions                                                                   #
###############################################################################

# This looks at each DB's 'updated' table to see if any are behind. If any are,
# it will update the tables based on the time the last entry was made for a
# given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Update bond and interfaces
		update_db_bond($an);
		update_db_bond_interface($an);
	}
	
	return(0);
}

# Update the bond_interface table
sub update_db_bond_interface
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_bond_interface", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'bond_interface' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    a.bond_interface_name, 
    a.bond_interface_bond_uuid, 
    a.bond_interface_mii_status, 
    a.bond_interface_speed, 
    a.bond_interface_duplex, 
    a.bond_interface_failure_count, 
    a.bond_interface_mac, 
    a.bond_interface_slave_queue_id, 
    a.modified_date 
FROM 
    history.bond_interface a, 
    public.bond b
WHERE
    a.bond_interface_bond_uuid = b.bond_uuid
AND
    b.bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $bond_interface_name           = $row->[0];
			my $bond_interface_bond_uuid      = $row->[1];
			my $bond_interface_mii_status     = $row->[2];
			my $bond_interface_speed          = $row->[3];
			my $bond_interface_duplex         = $row->[4];
			my $bond_interface_failure_count  = $row->[5];
			my $bond_interface_mac            = $row->[6];
			my $bond_interface_slave_queue_id = $row->[7];
			my $modified_date                 = $row->[8];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "bond_interface_name",           value1 => $bond_interface_name, 
				name2 => "bond_interface_bond_uuid",      value2 => $bond_interface_bond_uuid, 
				name3 => "bond_interface_mii_status",     value3 => $bond_interface_mii_status, 
				name4 => "bond_interface_speed",          value4 => $bond_interface_speed, 
				name5 => "bond_interface_duplex",         value5 => $bond_interface_duplex, 
				name6 => "bond_interface_failure_count",  value6 => $bond_interface_failure_count, 
				name7 => "bond_interface_mac",            value7 => $bond_interface_mac, 
				name8 => "bond_interface_slave_queue_id", value8 => $bond_interface_slave_queue_id, 
				name9 => "modified_date",                 value9 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name} = {
				bond_interface_bond_uuid	=>	$bond_interface_bond_uuid, 
				bond_interface_mii_status	=>	$bond_interface_mii_status, 
				bond_interface_speed		=>	$bond_interface_speed, 
				bond_interface_duplex		=>	$bond_interface_duplex, 
				bond_interface_failure_count	=>	$bond_interface_failure_count, 
				bond_interface_mac		=>	$bond_interface_mac, 
				bond_interface_slave_queue_id	=>	$bond_interface_slave_queue_id, 
			};
			$an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen}     = 0;
			$an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name} = {
				bond_interface_bond_uuid	=>	$bond_interface_bond_uuid, 
				bond_interface_mii_status	=>	$bond_interface_mii_status, 
				bond_interface_speed		=>	$bond_interface_speed, 
				bond_interface_duplex		=>	$bond_interface_duplex, 
				bond_interface_failure_count	=>	$bond_interface_failure_count, 
				bond_interface_mac		=>	$bond_interface_mac, 
				bond_interface_slave_queue_id	=>	$bond_interface_slave_queue_id, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{bond_interface}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $bond_interface_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}})
		{
			my $bond_interface_bond_uuid      = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_bond_uuid};
			my $bond_interface_mii_status     = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_mii_status};
			my $bond_interface_speed          = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_speed};
			my $bond_interface_duplex         = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_duplex};
			my $bond_interface_failure_count  = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_failure_count};
			my $bond_interface_mac            = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_mac};
			my $bond_interface_slave_queue_id = $an->data->{db_data}{unified}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}{bond_interface_slave_queue_id};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "bond_interface_name",           value1 => $bond_interface_name, 
				name2 => "bond_interface_bond_uuid",      value2 => $bond_interface_bond_uuid, 
				name3 => "bond_interface_mii_status",     value3 => $bond_interface_mii_status, 
				name4 => "bond_interface_speed",          value4 => $bond_interface_speed, 
				name5 => "bond_interface_duplex",         value5 => $bond_interface_duplex, 
				name6 => "bond_interface_failure_count",  value6 => $bond_interface_failure_count, 
				name7 => "bond_interface_mac",            value7 => $bond_interface_mac, 
				name8 => "bond_interface_slave_queue_id", value8 => $bond_interface_slave_queue_id, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'bond_interface_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::bond_interface::bond_interface_name::${bond_interface_name}::seen", value1 => $an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::bond_interface::bond_interface_name::${bond_interface_name}::exists", value1 => $an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{bond_interface}{bond_interface_name}{$bond_interface_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::bond_interface::modified_date::${modified_date}::bond_interface_name::${bond_interface_name}", value1 => $an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.bond_interface
SET
    bond_interface_mii_status     = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    bond_interface_speed          = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    bond_interface_duplex         = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    bond_interface_failure_count  = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    bond_interface_mac            = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    bond_interface_slave_queue_id = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    bond_interface_name      = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)." 
AND 
    bond_interface_bond_uuid = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.bond_interface
(
    bond_interface_name, 
    bond_interface_bond_uuid, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'bond_interface_name' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{bond_interface}{modified_date}{$modified_date}{bond_interface_name}{$bond_interface_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.bond_interface
(
    bond_interface_id, 
    bond_interface_name, 
    bond_interface_bond_uuid, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    (
        SELECT 
            bond_interface_id 
        FROM 
            public.bond_interface 
        WHERE 
            bond_interface_bond_uuid = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid)." 
        AND 
            bond_interface_name = ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name)."
    ), 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen bond_interface_name?
			} # foreach my $id 
		} # foreach my $bond_interface_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'bond' table.
sub update_db_bond
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_bond", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'bond' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
FROM 
    history.bond
WHERE
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $bond_uuid                 = $row->[0];
			my $bond_name                 = $row->[1];
			my $bond_mode                 = $row->[2];
			my $bond_primary_slave        = $row->[3];
			my $bond_primary_reselect     = $row->[4];
			my $bond_active_slave         = $row->[5];
			my $bond_mii_status           = $row->[6];
			my $bond_mii_polling_interval = $row->[7];
			my $bond_up_delay             = $row->[8];
			my $bond_down_delay           = $row->[9];
			my $modified_date             = $row->[10];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0011", message_variables => {
				name1  => "bond_uuid",                 value1  => $bond_uuid, 
				name2  => "bond_name",                 value2  => $bond_name, 
				name3  => "bond_mode",                 value3  => $bond_mode, 
				name4  => "bond_primary_slave",        value4  => $bond_primary_slave, 
				name5  => "bond_primary_reselect",     value5  => $bond_primary_reselect, 
				name6  => "bond_active_slave",         value6  => $bond_active_slave, 
				name7  => "bond_mii_status",           value7  => $bond_mii_status, 
				name8  => "bond_mii_polling_interval", value8  => $bond_mii_polling_interval, 
				name9  => "bond_up_delay",             value9  => $bond_up_delay, 
				name10 => "bond_down_delay",           value10 => $bond_down_delay, 
				name11 => "modified_date",             value11 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### There can only be one entry per host, so we don't have a subhash.
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid} = {
				bond_name			=>	$bond_name, 
				bond_mode			=>	$bond_mode, 
				bond_primary_slave		=>	$bond_primary_slave, 
				bond_primary_reselect		=>	$bond_primary_reselect, 
				bond_active_slave		=>	$bond_active_slave, 
				bond_mii_status			=>	$bond_mii_status, 
				bond_mii_polling_interval	=>	$bond_mii_polling_interval, 
				bond_up_delay			=>	$bond_up_delay, 
				bond_down_delay			=>	$bond_down_delay, 
			};
			$an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid} = {
				bond_name			=>	$bond_name, 
				bond_mode			=>	$bond_mode, 
				bond_primary_slave		=>	$bond_primary_slave, 
				bond_primary_reselect		=>	$bond_primary_reselect, 
				bond_active_slave		=>	$bond_active_slave, 
				bond_mii_status			=>	$bond_mii_status, 
				bond_mii_polling_interval	=>	$bond_mii_polling_interval, 
				bond_up_delay			=>	$bond_up_delay, 
				bond_down_delay			=>	$bond_down_delay, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{bond}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $bond_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}})
		{
			my $bond_name                 = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_name};
			my $bond_mode                 = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_mode};
			my $bond_primary_slave        = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_primary_slave};
			my $bond_primary_reselect     = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_primary_reselect};
			my $bond_active_slave         = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_active_slave};
			my $bond_mii_status           = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_mii_status};
			my $bond_mii_polling_interval = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_mii_polling_interval};
			my $bond_up_delay             = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_up_delay};
			my $bond_down_delay           = $an->data->{db_data}{unified}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}{bond_down_delay};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "bond_uuid",                 value1  => $bond_uuid, 
				name2  => "bond_name",                 value2  => $bond_name, 
				name3  => "bond_mode",                 value3  => $bond_mode, 
				name4  => "bond_primary_slave",        value4  => $bond_primary_slave, 
				name5  => "bond_primary_reselect",     value5  => $bond_primary_reselect, 
				name6  => "bond_active_slave",         value6  => $bond_active_slave, 
				name7  => "bond_mii_status",           value7  => $bond_mii_status, 
				name8  => "bond_mii_polling_interval", value8  => $bond_mii_polling_interval, 
				name9  => "bond_up_delay",             value9  => $bond_up_delay, 
				name10 => "bond_down_delay",           value10 => $bond_down_delay, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'bond_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::bond::bond_uuid::${bond_uuid}::seen", value1 => $an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::bond::bond_uuid::${bond_uuid}::exists", value1 => $an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{bond}{bond_uuid}{$bond_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::bond::modified_date::${modified_date}::bond_uuid::${bond_uuid}", value1 => $an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.bond
SET
    bond_name                 = ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    bond_mode                 = ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    bond_primary_slave        = ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    bond_primary_reselect     = ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    bond_active_slave         = ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    bond_mii_status           = ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    bond_mii_polling_interval = ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    bond_up_delay             = ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    bond_down_delay           = ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    modified_date             = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    bond_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    bond_uuid      = ".$an->data->{sys}{use_db_fh}->quote($bond_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.bond
(
    bond_host_uuid, 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'bond_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{bond}{modified_date}{$modified_date}{bond_uuid}{$bond_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.bond
(
    bond_host_uuid, 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).",
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen bond_uuid?
			} # foreach my $id 
		} # foreach my $bond_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load
# the schema. If the schema gets loaded, we'll check other databases for
# older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => "$THIS_FILE" }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='bond' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it
# against the just-read data. If anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in last scan data (if any).
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	if (read_last_scan($an))
	{
		# No record found, INSERT everything.
		foreach my $bond_name (sort {$a cmp $b} keys %{$an->data->{bond}})
		{
			# Pull my bond info into variables for readability.
			my $bond_uuid                 = $an->Get->uuid() or $an->Alert->error({fatal => 1, title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => "$THIS_FILE", line => __LINE__});;
			my $bond_mode                 = $an->data->{bond}{$bond_name}{mode};
			my $bond_primary_slave        = $an->data->{bond}{$bond_name}{primary_slave};
			my $bond_primary_reselect     = $an->data->{bond}{$bond_name}{primary_reselect};
			my $bond_active_slave         = $an->data->{bond}{$bond_name}{active_slave};
			my $bond_mii_status           = $an->data->{bond}{$bond_name}{mii_status};
			my $bond_mii_polling_interval = $an->data->{bond}{$bond_name}{mii_polling_interval};
			my $bond_up_delay             = $an->data->{bond}{$bond_name}{up_delay};
			my $bond_down_delay           = $an->data->{bond}{$bond_name}{down_delay};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "bond_name",                 value1 => $bond_name, 
				name2 => "bond_mode",                 value2 => $bond_mode, 
				name3 => "bond_primary_slave",        value3 => $bond_primary_slave, 
				name4 => "bond_primary_reselect",     value4 => $bond_primary_reselect, 
				name5 => "bond_active_slave",         value5 => $bond_active_slave, 
				name6 => "bond_mii_status",           value6 => $bond_mii_status, 
				name7 => "bond_mii_polling_interval", value7 => $bond_mii_polling_interval, 
				name8 => "bond_up_delay",             value8 => $bond_up_delay, 
				name9 => "bond_down_delay",           value9 => $bond_down_delay, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Create the query
			my $query = "
INSERT INTO 
    bond
(
    bond_host_uuid, 
    bond_uuid, 
    bond_name, 
    bond_mode, 
    bond_primary_slave, 
    bond_primary_reselect, 
    bond_active_slave, 
    bond_mii_status, 
    bond_mii_polling_interval, 
    bond_up_delay, 
    bond_down_delay, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mode).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_primary_reselect).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_active_slave).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_mii_polling_interval).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_up_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_down_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# Now add the nodes.
			foreach my $bond_interface_name (sort {$a cmp $b} keys %{$an->data->{bond}{$bond_name}{slave}})
			{
				my $bond_interface_mii_status     = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mii_status};
				my $bond_interface_speed          = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{speed};
				my $bond_interface_duplex         = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{duplex};
				my $bond_interface_failure_count  = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{failure_count};
				my $bond_interface_mac            = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{mac};
				my $bond_interface_slave_queue_id = $an->data->{bond}{$bond_name}{slave}{$bond_interface_name}{slave_queue_id};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
					name1 => "bond_interface_name",           value1 => $bond_interface_name, 
					name2 => "bond_interface_speed",          value2 => $bond_interface_speed, 
					name3 => "bond_interface_duplex",         value3 => $bond_interface_duplex, 
					name4 => "bond_interface_failure_count",  value4 => $bond_interface_failure_count, 
					name5 => "bond_interface_mac",            value5 => $bond_interface_mac, 
					name6 => "bond_interface_slave_queue_id", value6 => $bond_interface_slave_queue_id, 
				}, file => $THIS_FILE, line => __LINE__});
			
				my $query = "
INSERT INTO 
    public.bond_interface
(
    bond_interface_name, 
    bond_interface_bond_uuid, 
    bond_interface_mii_status, 
    bond_interface_speed, 
    bond_interface_duplex, 
    bond_interface_failure_count, 
    bond_interface_mac, 
    bond_interface_slave_queue_id, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mii_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_speed).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_duplex).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_failure_count).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_mac).", 
    ".$an->data->{sys}{use_db_fh}->quote($bond_interface_slave_queue_id).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
		}
	}
	else
	{
		# Previous records exist, so look for changes.
		
	}
	
	# Now commit the changes.
	commit_sql($an);
	
	return(0);
}

# This commits the SQL queries in '$an->data->{sys}{sql}', if any.
sub commit_sql
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "commit_sql", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $count = @{$an->data->{sys}{sql}};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::sql #", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if (@{$an->data->{sys}{sql}} > 0)
	{
		$an->DB->do_db_write({query => $an->data->{sys}{sql}});
		$an->data->{sys}{sql} = [];
	}
	
	return($count);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Couple of variables to make the code cleaner
	my $id        = $an->data->{sys}{read_db_id};
	my $host_name = $an->hostname;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "id",        value1 => $id, 
		name2 => "host_name", value2 => $host_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# This calls up the entry for this host. If no entry is found, 'new'
	# gets set to '1' and the main function won't bother looking for
	# changes and directly INSERT the scanned data.
	my $new   = 0;
=pod
	my $query = "
SELECT 
    a.bond_quorate, 
    a.bond_cluster_name 
FROM 
    bond a, 
    hosts b 
WHERE 
    a.bond_host_uuid = b.host_uuid 
AND 
    b.host_name = ".$an->data->{sys}{use_db_fh}->quote($host_name).";
";
	# TODO: This query should only ever return one row, but this fact
	#       should be explicitely checked for.
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "query",        value1 => $query, 
		name2 => "results->[0]", value2 => $results->[0], 
	}, file => $THIS_FILE, line => __LINE__});
	if ($results->[0])
	{
		# We've got an entry in the 'bond' table, so now we'll look
		# for data in the node and services tables.
		my ($bond_quorate, $bond_cluster_name) = @{$results->[0]};
		
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "bond_quorate",      value1 => $bond_quorate, 
			name2 => "bond_cluster_name", value2 => $bond_cluster_name
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{bond}{sql}{bond}{bond_quorate}      = $bond_quorate ? "TRUE" : "FALSE";
		$an->data->{bond}{sql}{bond}{bond_cluster_name} = $bond_cluster_name;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "bond::sql::bond::bond_quorate",      value1 => $an->data->{bond}{sql}{bond}{bond_quorate}, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "bond::sql::bond::bond_cluster_name", value1 => $an->data->{bond}{sql}{bond}{bond_cluster_name}
		}, file => $THIS_FILE, line => __LINE__});
		
		my $query = "
SELECT 
    a.bond_node_name, 
    a.bond_node_cluster_id, 
    a.bond_node_status 
FROM 
    bond_node a, 
    bond b, 
    hosts c 
WHERE 
    a.bond_node_bond_uuid = b.bond_uuid 
AND 
    b.bond_host_uuid = c.host_uuid 
AND 
    c.host_name = ".$an->data->{sys}{use_db_fh}->quote($host_name).";
";
		
		my $results = $an->DB->do_db_query({query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "query",   value1 => $query, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $array_reference (@{$results})
		{
			my ($bond_node_name, $bond_node_cluster_id, $bond_node_status) = @{$array_reference};
			
			# Record the values directly as we received them.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "bond_node_name",       value1 => $bond_node_name, 
				name2 => "bond_node_cluster_id", value2 => $bond_node_cluster_id, 
				name3 => "bond_node_status",     value3 => $bond_node_status
			}, file => $THIS_FILE, line => __LINE__});
			
			# Push them into the hash
			$an->data->{bond}{sql}{bond_node}{$bond_node_name} = {
			    a.bond_node_cluster_id	=>	$bond_node_cluster_id,
			    a.bond_node_status	=>	$bond_node_status,
			};
			
			# Record the now-in-the-hash data.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bond::sql::bond_node::${bond_node_name}::bond_node_cluster_id", value1 => $an->data->{bond}{sql}{bond_node}{$bond_node_name}{bond_node_cluster_id}, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bond::sql::bond_node::${bond_node_name}::bond_node_status",     value1 => $an->data->{bond}{sql}{bond_node}{$bond_node_name}{bond_node_status}
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Now pull our the services
		$query = "
SELECT 
    a.bond_interface_name, 
    a.bond_interface_host, 
    a.bond_interface_status, 
    a.bond_interface_is_vm 
FROM 
    bond_interface a, 
    bond b, 
    hosts c 
WHERE 
    a.bond_interface_bond_uuid = b.bond_uuid 
AND 
    b.bond_host_uuid = c.host_uuid 
AND 
    c.host_name = ".$an->data->{sys}{use_db_fh}->quote($host_name).";
";
		$results = $an->DB->do_db_query({query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "query",   value1 => $query, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $array_reference (@{$results})
		{
			my ($bond_interface_name, $bond_interface_host, $bond_interface_status, $bond_interface_is_vm) = @{$array_reference};
			
			# Record the values directly as we received them.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "bond_interface_name",   value1 => $bond_interface_name, 
				name2 => "bond_interface_host",   value2 => $bond_interface_host, 
				name3 => "bond_interface_status", value3 => $bond_interface_status, 
				name4 => "bond_interface_is_vm",  value4 => $bond_interface_is_vm
			}, file => $THIS_FILE, line => __LINE__});
			
			# Push them into the hash
			$bond_interface_is_vm = $bond_interface_is_vm ? "TRUE" : "FALSE";
			$an->data->{bond}{sql}{bond_interface}{$bond_interface_name} = {
			    a.bond_interface_host	=>	$bond_interface_host, 
			    a.bond_interface_status	=>	$bond_interface_status, 
			    a.bond_interface_is_vm	=>	$bond_interface_is_vm
			};
			
			# Record the now-in-the-hash data.
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bond::sql::bond_interface::${bond_interface_name}::bond_interface_host",   value1 => $an->data->{bond}{sql}{bond_interface}{$bond_interface_name}{bond_interface_host}, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bond::sql::bond_interface::${bond_interface_name}::bond_interface_status", value1 => $an->data->{bond}{sql}{bond_interface}{$bond_interface_name}{bond_interface_status}, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "bond::sql::bond_interface::${bond_interface_name}::bond_interface_is_vm",  value1 => $an->data->{bond}{sql}{bond_interface}{$bond_interface_name}{bond_interface_is_vm}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	else
	{
		# Looks like this is the first run ever.
		$new = 1;
	}
=cut
	
	$new = 1;
	return($new);
}

# This looks rgmanager's 'bond' and, if it is found, parse it.
sub parse_bonds
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "parse_bond", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $return_code = 1;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "path::proc_bond", value1 => $an->data->{path}{proc_bond},
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{proc_bond})
	{
		local(*DIRECTORY);
		opendir(DIRECTORY, $an->data->{path}{proc_bond});
		while(my $file = readdir(DIRECTORY))
		{
			next if $file eq ".";
			next if $file eq "..";
			
			# There is a bug where an almost-empty 'bond0' 
			# interface file is created, we want to ignore that.
			next if $file eq "bond0";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "file", value1 => $file,
			}, file => $THIS_FILE, line => __LINE__});
			
			# OK, parse
			my $full_path = $an->data->{path}{proc_bond}."/$file";
			my $bond      = $file;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "full_path", value1 => $full_path, 
				name2 => "bond",      value2 => $bond,
			}, file => $THIS_FILE, line => __LINE__});
			if (-r $full_path)
			{
				# Woot!
				my $interface  = "";
				my $shell_call = $full_path;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => "$shell_call", 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line =  $_;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => "$line"
					}, file => $THIS_FILE, line => __LINE__});
					
					# Core bonding details
					if (not $interface)
					{
						if ($line =~ /Bonding Mode: .*? \((.*?)\)/)
						{
							# We want to store the mode as the numberical type.
							my $mode = $1;
							$an->data->{bond}{$bond}{mode} = translate_mode_name_to_number($an, $mode);
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::mode", value1 => $an->data->{bond}{$bond}{mode}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Primary Slave: (.*?) \(primary_reselect (.*?)\)/)
						{
							$an->data->{bond}{$bond}{primary_slave}    = $1;
							$an->data->{bond}{$bond}{primary_reselect} = $2;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "bond::${bond}::primary_slave",    value1 => $an->data->{bond}{$bond}{primary_slave}, 
								name2 => "bond::${bond}::primary_reselect", value2 => $an->data->{bond}{$bond}{primary_reselect}, 
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Currently Active Slave: (.*)$/)
						{
							$an->data->{bond}{$bond}{active_slave} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::active_slave", value1 => $an->data->{bond}{$bond}{active_slave}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /MII Status: (.*)$/)
						{
							$an->data->{bond}{$bond}{mii_status} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::mii_status", value1 => $an->data->{bond}{$bond}{mii_status}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /MII Polling Interval \(ms\): (\d+)$/)
						{
							$an->data->{bond}{$bond}{mii_polling_interval} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::mii_polling_interval", value1 => $an->data->{bond}{$bond}{mii_polling_interval}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Up Delay \(ms\): (\d+)$/)
						{
							$an->data->{bond}{$bond}{up_delay} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::up_delay", value1 => $an->data->{bond}{$bond}{up_delay}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Down Delay \(ms\): (\d+)$/)
						{
							$an->data->{bond}{$bond}{down_delay} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::down_delay", value1 => $an->data->{bond}{$bond}{down_delay}
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
					if ($line =~ /Slave Interface: (.*)$/)
					{
						$interface   = $1;
						$return_code = 0;
						next;
					}
					if (($interface) && (not $line))
					{
						$interface = "";
						next;
					}
					
					# Slave details
					if ($interface)
					{
						if ($line =~ /MII Status: (.*)$/)
						{
							$an->data->{bond}{$bond}{slave}{$interface}{mii_status} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::slave::${interface}::mii_status", value1 => $an->data->{bond}{$bond}{slave}{$interface}{mii_status}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Speed: (.*)$/)
						{
							# Convert to bps for the DB
							my $speed = $1;
							$an->data->{bond}{$bond}{slave}{$interface}{speed} = convert_to_bps($an, $speed);
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::slave::${interface}::speed", value1 => $an->data->{bond}{$bond}{slave}{$interface}{speed}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Duplex: (.*)$/)
						{
							$an->data->{bond}{$bond}{slave}{$interface}{duplex} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::slave::${interface}::duplex", value1 => $an->data->{bond}{$bond}{slave}{$interface}{duplex}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Link Failure Count: (\d+)$/)
						{
							$an->data->{bond}{$bond}{slave}{$interface}{failure_count} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::slave::${interface}::failure_count", value1 => $an->data->{bond}{$bond}{slave}{$interface}{failure_count}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Permanent HW addr: (.*)$/)
						{
							$an->data->{bond}{$bond}{slave}{$interface}{mac} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::slave::${interface}::mac", value1 => $an->data->{bond}{$bond}{slave}{$interface}{mac}
							}, file => $THIS_FILE, line => __LINE__});
						}
						if ($line =~ /Slave queue ID: (.*)$/)
						{
							# I really don't need this, but maybe
							# someday...
							$an->data->{bond}{$bond}{slave}{$interface}{slave_queue_id} = $1;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "bond::${bond}::slave::${interface}::slave_queue_id", value1 => $an->data->{bond}{$bond}{slave}{$interface}{slave_queue_id}
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
				}
				close $file_handle;
			}
		}
	}
	else
	{
		# Not installed.
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0005", message_key => "scan_bond_message_0003", file => $THIS_FILE, line => __LINE__});
		$return_code = 1;
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "return_code", value1 => $return_code
	}, file => $THIS_FILE, line => __LINE__});
	
	return($return_code);
}

### TODO: Move to AN::Convert and add more sanity checks
# This converts a bit-rate speed to Mbps
sub convert_to_bps
{
	my ($an, $say_speed) = @_;
	my $speed     = "";
	
	$say_speed = lc($say_speed);
	$say_speed =~ s/,//g;
	$say_speed =~ s/ //g;
	if ($say_speed =~ /^(\d+)$/)
	{
		$speed = $1;
	}
	elsif ($say_speed =~ /(\d+)kbps/i)
	{
		$speed = $1;
		$speed *= 1000;
	}
	elsif ($say_speed =~ /(\d+)mbps/i)
	{
		$speed = $1;
		$speed *= 1000000;
	}
	elsif ($say_speed =~ /(\d+)gbps/i)
	{
		$speed = $1;
		$speed *= 1000000000;
	}
	elsif ($say_speed =~ /(\d+)tbps/i)
	{
		$speed = $1;
		$speed *= 1000000000000;
	}
	
	return($speed);
}

# This translates the bond mode name to it's numberical number.
sub translate_mode_name_to_number
{
	my ($an, $mode_name) = @_;
	
	# See the 'mode' section here: https://www.kernel.org/doc/Documentation/networking/bonding.txt
	# Number | Name          | Long name / Description
	# -------+---------------+---------------------------------------------------------------------
	#  0     | balance-rr    | Round-robin
	#  1     | active-backup | Active/Backup
	#  2     | balance-xor   | XOR (boolean XOR'ed source MAC with target MAC)
	#  3     | broadcast     | All packets go down all slaves
	#  4     | 802.3ad       | Dynamic link-aggregation groups according to RFC 802.3ad
	#  5     | balance-tlb   | Adaptive transmit load balancing
	#  6     | balance-alb   | Adaptive load balancing: balance-tlb + receive load balancing (rlb)
	# -------+---------------+---------------------------------------------------------------------
	
	my $mode = "";
	if    ($mode_name eq "balance-rr")    { $mode = 0; }
	elsif ($mode_name eq "active-backup") { $mode = 1; }
	elsif ($mode_name eq "balance-xor")   { $mode = 2; }
	elsif ($mode_name eq "broadcast")     { $mode = 3; }
	elsif ($mode_name eq "802.3ad")       { $mode = 4; }
	elsif ($mode_name eq "balance-tlb")   { $mode = 5; }
	elsif ($mode_name eq "balance-alb")   { $mode = 6; }
	
	return($mode);
}

### TODO: Make this a method
# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory", }, message_key => "tools_log_0003", message_variables => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		$an->data->{dbh}{$id}->disconnect if $an->data->{dbh}{$id};
	}
	
	exit($exit_code);
}

### TODO: Move this into AN::Tools
# This collects the command line switches
sub get_switches
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_switches", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $last_argument = "";
	foreach my $argument (@ARGV)
	{
		if ($last_argument eq "raw")
		{
			# Don't process anything.
			$an->data->{switches}{raw} .= " $argument";
		}
		elsif ($argument =~ /^-/)
		{
			# If the argument is just '--', appeand everything
			# after it to 'raw'.
			$an->data->{sys}{switch_count}++;
			if ($argument eq "--")
			{
				$last_argument             = "raw";
				$an->data->{switches}{raw} = "";
			}
			else
			{
				($last_argument) = ($argument =~ /^-{1,2}(.*)/)[0];
				if ($last_argument =~ /=/)
				{
					# Break up the variable/value.
					($last_argument, my $value) = (split /=/, $last_argument, 2);
					$an->data->{switches}{$last_argument} = $value;
				}
				else
				{
					$an->data->{switches}{$last_argument} = "#!SET!#";
				}
			}
		}
		else
		{
			if ($last_argument)
			{
				$an->data->{switches}{$last_argument} = $argument;
				$last_argument                        = "";
			}
			else
			{
				# Got a value without an argument.
				$an->data->{switches}{error} = 1;
			}
		}
	}
	# Clean up the initial space added to 'raw'.
	if ($an->data->{switches}{raw})
	{
		$an->data->{switches}{raw} =~ s/^ //;
	}
	
	# Debug
	foreach my $variable (sort {$a cmp $b} keys %{$an->data->{switches}})
	{
		$an->Log->entry({
			log_level	=>	2,
			message_key	=>	"scancore_log_0010",
			message_variables	=>	{
				variable	=>	$variable,
				value		=>	$an->data->{switches}{$variable},
			},
			file		=>	$THIS_FILE,
			line		=>	__LINE__,
			log_to		=>	$an->data->{path}{log_file},
		});
	}
	
	# If the user has asked for help, print the usage info.
	if (($an->data->{switches}{h}) or ($an->data->{switches}{help}) or ($an->data->{switches}{'?'}))
	{
		print_usage($an);
		exit(0);
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "${THIS_FILE}_message_0002"}), "\n";

	return(0);
}
