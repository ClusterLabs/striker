#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released under the terms of the GNU GPL 
# version 2.
#
# ScanCore Scan Agent that tests ssh access to a target by simply logging in and sending 'echo 1'. This is
# preferable to ping access when testing access to machines behind a firewall, or machines that ignore ICMP
# ping packets.
# 
# Configuration is to add the following to striker.conf;
# 
# ====
# scan-remote-access::target::<id>::host     = <user>@<name_or_ip>:<port>
# scan-remote-access::target::<id>::password = <secret>
# ====
#
# The <id> can be any alpha-numeric string or number that is unique from other entries. Any number of entries
# can be added, but the checks will be performed sequentially. So in a case where multiple targets are slow
# to respond, this  agent could run for some time.
# 
# The 'host' can be an IP address or a resolvable host name. Optionally, you can specify ':xx' to specify a
# non-standard port to use for SSH. When no suffix is used, port 22 is used.
# 
# The 'host' can, optionally, have a user to connect as. When not specified, the 'root' user is used.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - 
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
no warnings 'recursion';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

### TODO: Rework this whole agent...
# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		sys			=>	{
			# When a lock is requested, this is set to the time the lock was set. 
			# DB->do_db_write() and DB->do_db_read() will check this and if its age is >50% of
			# scancore::locking::reap_age, it will renew the lock.
			local_lock_active	=>	0,
			sql			=>	[],
		},
		scancore		=>	{
			archive			=>	{
				directory		=>	"/var/ScanCore/archives/",
				division		=>	60000,
				trigger			=>	100000,
				count			=>	50000,
				dump_file_header	=>	"
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = history, pg_catalog;
",
			},
		},
		# These are values the user might set in striker.conf
		'scan-remote-access'	=>	{
			disable			=>	0,
			language			=>	"en_CA",
			log_file			=>	"/var/log/ScanCore.log",
			log_level			=>	1,
			log_language			=>	"en_CA",
			log_db_transactions		=>	0,
		},
		targets			=>	{},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{$THIS_FILE}{language});
$an->default_log_language($an->data->{$THIS_FILE}{log_language});
$an->default_log_file    ($an->data->{$THIS_FILE}{log_file});

# Set the log level.
$an->Log->level($an->data->{$THIS_FILE}{log_level});
$an->Log->db_transactions(1) if $an->data->{$THIS_FILE}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

# Help?
if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or
    ($an->data->{switches}{help}))
{
	# Help!
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Exit if we're disabled.
if ($an->data->{$THIS_FILE}{disable})
{
	$an->nice_exit({exit_code => 1});
}

print $an->String->get({key => "scan_remote_access_message_0001"})."\n";

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 3, message_key => "notice_message_0013", message_variables => { connections => $connections }, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { uuid => $an->data->{sys}{host_uuid} }, code => 255, file => $THIS_FILE, line => __LINE__});
}

# Before proceeding, do we have any targets to scan?
my $target_count = 0;
if (exists $an->data->{'scan-remote-access'}{target})
{
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{'scan-remote-access'}{target}})
	{
		my $user     = "root";
		my $port     = 22;
		my $host     = $an->data->{'scan-remote-access'}{target}{$id}{host};
		my $password = $an->data->{'scan-remote-access'}{target}{$id}{password};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",   value1 => $id, 
			name2 => "host", value2 => $host, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($host =~ /^(.*?):(\d+)$/)
		{
			$host = $1;
			$port = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "host", value1 => $host, 
				name2 => "port", value2 => $port, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		if ($host =~ /^(.*?)@(.*)$/)
		{
			$user = $1;
			$host = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "user", value1 => $user, 
				name2 => "host", value2 => $host, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		$target_count++;
		$an->data->{'scan-remote-access'}{target}{$id}{access} = 0;
		my $access = check_access($an, $user, $host, $port, $password);
		
		$an->data->{'scan-remote-access'}{target}{$id}{access} = $access;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "scan-remote-access::target::${id}::access", value1 => $an->data->{'scan-remote-access'}{target}{$id}{access}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
}

$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
	name1 => "target_count", value1 => $target_count, 
}, file => $THIS_FILE, line => __LINE__});
if (not $target_count)
{
	# Nothing to do, exit.
	if ($an->data->{switches}{'prep-db'})
	{
		if ($connections)
		{
			prep_databases($an);
		}
		else
		{
			# Failed
			$an->Log->entry({log_level => 1, message_key => "scancore_warning_0031", file => $THIS_FILE, line => __LINE__});
			print $an->String->get({key => "scancore_warning_0031"})."\n";
		}
	}
	$an->nice_exit({exit_code => 0});
}

### Still alive? Time for work!
print $an->String->get({key => "scan_remote_access_log_0001"})."\n";

# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Archive, if needed.
archive_if_needed($an);

### TODO: Add this...
# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This looks at each DB's 'updated' table entry to see if any tables are behind. If any are, it will update
# the tables based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Make a note in the databases that we're starting an update and ask it to wait 10 seconds 
		# before returning to give other instances time to finish their scans. (our scans end quickly
		# enough).
		#$an->DB->set_update_db_flag({set => time, 'wait' => 10});
		
		# Update remote_access
		update_db_remote_access($an);
		
		# Release the lock
		$an->DB->locking({release => 1});
		
		# Clear the update flag.
		#$an->DB->set_update_db_flag({set => 0});
	}
	
	return(0);
}

# Update the 'remote_access' table.
sub update_db_remote_access
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_remote_access" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'remote_access' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    remote_access_uuid, 
    remote_access_target_name, 
    remote_access_target_access, 
    modified_date 
FROM 
    history.remote_access 
WHERE 
    remote_access_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $remote_access_uuid          = $row->[0];
			my $remote_access_target_name   = $row->[1];
			my $remote_access_target_access = $row->[2];
			my $modified_date               = $row->[3];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "remote_access_uuid",          value1 => $remote_access_uuid, 
				name2 => "remote_access_target_name",   value2 => $remote_access_target_name, 
				name3 => "remote_access_target_access", value3 => $remote_access_target_access, 
				name4 => "modified_date",               value4 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid} = {
				remote_access_target_name	=>	$remote_access_target_name, 
				remote_access_target_access	=>	$remote_access_target_access, 
			};
			$an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid} = {
				remote_access_target_name	=>	$remote_access_target_name, 
				remote_access_target_access	=>	$remote_access_target_access, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{remote_access}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $remote_access_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}})
		{
			my $remote_access_target_name   = $an->data->{db_data}{unified}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid}{remote_access_target_name};
			my $remote_access_target_access = $an->data->{db_data}{unified}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid}{remote_access_target_access};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "remote_access_uuid",          value1 => $remote_access_uuid, 
				name2 => "remote_access_target_name",   value2 => $remote_access_target_name, 
				name3 => "remote_access_target_access", value3 => $remote_access_target_access, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'remote_access_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::remote_access::remote_access_uuid::${remote_access_uuid}::seen", value1 => $an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::remote_access::remote_access_uuid::${remote_access_uuid}::exists", value1 => $an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{remote_access}{remote_access_uuid}{$remote_access_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::remote_access::modified_date::${modified_date}::remote_access_uuid::${remote_access_uuid}", value1 => $an->data->{db_data}{$id}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.remote_access 
SET
    remote_access_target_name   = ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_name).", 
    remote_access_target_access = ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_access).", 
    modified_date               = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    remote_access_host_uuid     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    remote_access_uuid          = ".$an->data->{sys}{use_db_fh}->quote($remote_access_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.remote_access 
(
    remote_access_host_uuid, 
    remote_access_uuid, 
    remote_access_target_name, 
    remote_access_target_access, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'remote_access_uuid' before, so it is just a question of 
					# whether the entry for the current timestamp exists in the history 
					# schema.
					if (not $an->data->{db_data}{$id}{remote_access}{modified_date}{$modified_date}{remote_access_uuid}{$remote_access_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.remote_access 
(
    remote_access_host_uuid, 
    remote_access_uuid, 
    remote_access_target_name, 
    remote_access_target_access, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen remote_access_uuid?
			} # foreach my $id 
		} # foreach my $remote_access_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks for access to the target. 
sub check_access
{
	my ($an, $user, $host, $port, $password) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_access" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "user", value1 => $user, 
		name2 => "host", value2 => $host, 
		name3 => "port", value3 => $port, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
		name1 => "password", value1 => $password, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $access = $an->Check->access({
			user     => $user,
			target   => $host,
			port     => $port,
			password => $password,
		});
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "access", value1 => $access, 
	}, file => $THIS_FILE, line => __LINE__});
	return($access);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_last_scan" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: This might be useful later
	# Make sure I don't have any stray data for this machine.
	#delete $an->data->{sql}{$machine};
	
	# Read in existing data, if any.
	my $query = "
SELECT 
    remote_access_uuid,
    remote_access_target_name, 
    remote_access_target_access 
FROM 
    remote_access 
WHERE 
    remote_access_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $remote_access_uuid          = $row->[0];
		my $remote_access_target_name   = $row->[1]; 
		my $remote_access_target_access = $row->[2];
		
		$an->data->{sql}{$remote_access_target_name}{remote_access_uuid}          = $remote_access_uuid;
		$an->data->{sql}{$remote_access_target_name}{remote_access_target_access} = $remote_access_target_access ? $remote_access_target_access : "NULL";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "sql::${remote_access_target_name}::remote_access_uuid",          value1 => $an->data->{sql}{$remote_access_target_name}{remote_access_uuid}, 
			name2 => "sql::${remote_access_target_name}::remote_access_target_access", value2 => $an->data->{sql}{$remote_access_target_name}{remote_access_target_access}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return($count);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "find_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read the last state of any targets we already know about
	read_last_scan($an);
	
	# As we loop through each target, we'll see if we already we know about this system and, if so, if it
	# just came back or left.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{'scan-remote-access'}{target}})
	{
		my $remote_access_uuid              = "";
		my $remote_access_target_name       = $an->data->{'scan-remote-access'}{target}{$id}{host};
		my $new_remote_access_target_access = $an->data->{'scan-remote-access'}{target}{$id}{access};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "id",                              value1 => $id, 
			name2 => "remote_access_target_name",       value2 => $remote_access_target_name, 
			name3 => "new_remote_access_target_access", value3 => $new_remote_access_target_access, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (exists $an->data->{sql}{$remote_access_target_name}{remote_access_uuid})
		{
			# Exists. Changed?
			   $remote_access_uuid              = $an->data->{sql}{$remote_access_target_name}{remote_access_uuid};
			my $old_remote_access_target_access = $an->data->{sql}{$remote_access_target_name}{remote_access_target_access};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "remote_access_uuid",              value1 => $remote_access_uuid, 
				name2 => "old_remote_access_target_access", value2 => $old_remote_access_target_access, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($new_remote_access_target_access ne $old_remote_access_target_access)
			{
				# It has changed, update it.
				my $query = "
UPDATE 
    remote_access 
SET
    remote_access_target_access = ".$an->data->{sys}{use_db_fh}->quote($new_remote_access_target_access).", 
    modified_date               = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    remote_access_uuid          = ".$an->data->{sys}{use_db_fh}->quote($remote_access_uuid)."
;
";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
				
				# This is an warning-level alert.
				my $title_key   = "an_alert_title_0004";
				my $message_key = "scan_remote_access_message_0004";
				if ($new_remote_access_target_access)
				{
					# We've got access now.
					$title_key   = "an_alert_title_0006";
					$message_key = "scan_remote_access_message_0003";
				}
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	$title_key,
					alert_message_key	=>	$message_key,
					alert_message_variables	=>	{
						target			=>	$remote_access_target_name,
					},
				});
			}
		}
		else
		{
			# New record, INSERT it.
			my $remote_access_uuid = $an->Get->uuid() or $an->Alert->error({title_key => "error_title_0020", message_key => "error_message_0024", code => 2, file => $THIS_FILE, line => __LINE__});;
			my $query              = "
INSERT INTO 
    remote_access 
(
    remote_access_uuid, 
    remote_access_host_uuid, 
    remote_access_target_name, 
    remote_access_target_access, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($remote_access_target_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_remote_access_target_access).",  
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			my $message_key = "scan_remote_access_message_0006";
			if ($new_remote_access_target_access)
			{
				# We've got access.
				$message_key = "scan_remote_access_message_0005";
			}
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0004",
				alert_message_key	=>	$message_key,
				alert_message_variables	=>	{
					target			=>	$remote_access_target_name,
				},
			});
		}
	}
	
	# Now commit the changes.
	$an->DB->commit_sql({source => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This will archive stuff in the 'history' schema, if needed.
sub archive_if_needed
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_if_needed" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If the 'trigger' is '0', archiving is disabled.
	if (not $an->data->{scancore}{archive}{trigger})
	{
		return(1);
	}
	
	### NOTE: If a ScanCore db server was offline when an archive ran, when it returns, it's records will
	###       sync back, triggering a sooner-than-expected subsequent archive. This shouldn't happen 
	###       often, and the complexity of tracking archive dates is such that we'll not try to account
	###       for these cases. 
	### TODO: What we can do later is, when we write the restore stuff, build in a dedupe function.
	
	### Process:
	# 1. Count the records in history for each table, restricting the results to those from this host 
	#    (save for special tables like 'server') and if the number of records is greater than 
	#    'scancore::archive::trigger', start an archive.
	# 2. Set/update the 'archive_date' state.
	# 3. Lock the database.
	# 4. Select 'modified_date' from history.foo, offset by 
	#    ('scancore::archive::trigger' - 'scancore::archive::count').
	# 5. Make sure the 'scancore::archive::directory' exists, creating it if needed.
	# 6. Select all records older that the 'modified_date', write them to a file and then DELETE those
	#    records from the database.
	
	# Update the archive path, if set by a user. Also verify that there are sane archive values.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "path::scancore_archive",       value1 => $an->data->{path}{scancore_archive}, 
		name2 => "scancore::archive::directory", value2 => $an->data->{scancore}{archive}{directory}, 
		name3 => "scancore::archive::trigger",   value3 => $an->data->{scancore}{archive}{trigger}, 
		name4 => "scancore::archive::count",     value4 => $an->data->{scancore}{archive}{count}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{archive}{directory} =~ /\/.*/)
	{
		$an->data->{path}{scancore_archive} = $an->data->{scancore}{archive}{directory};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "path::scancore_archive", value1 => $an->data->{path}{scancore_archive}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{trigger}) or ($an->data->{scancore}{archive}{trigger} =~ /\D/))
	{
		$an->data->{scancore}{archive}{trigger} = 100000;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::trigger", value1 => $an->data->{scancore}{archive}{trigger}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{count}) or ($an->data->{scancore}{archive}{count} =~ /\D/))
	{
		$an->data->{scancore}{archive}{count} = 50000;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::count", value1 => $an->data->{scancore}{archive}{count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	if (not -e $an->data->{path}{scancore_archive})
	{
		my $shell_call = $an->data->{path}{'mkdir'}." -p '".$an->data->{path}{scancore_archive}."'";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Did it work?
		if (not -e $an->data->{path}{scancore_archive})
		{
			# Nope. :(
			$an->Alert->warning({message_key => "scancore_warning_0030", message_variables => { directory => $an->data->{path}{scancore_archive} }, quiet => 1, file => $THIS_FILE, line => __LINE__});
			return(1);
		}
	}
	
	# This is pretty simple... Just one table
	$an->data->{archive}{table} = {
		remote_access	=>	{
			archive_date	=>	"",
			host_column	=>	"remote_access_host_uuid",
			offset		=>	0,
		},
	};
	my $archive_needed = 0;
	foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "table", value1 => $table, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $query = "
SELECT 
    COUNT(*) 
FROM 
    history.$table 
WHERE 
    ".$an->data->{archive}{table}{$table}{host_column}." = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $records = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		   $records = 0 if not defined $records;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "records", value1 => $records, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($records > $an->data->{scancore}{archive}{trigger})
		{
			   $archive_needed                             = 1;
			my $records_to_save                            = ($an->data->{scancore}{archive}{trigger} - $an->data->{scancore}{archive}{count});
			my $offset                                     = $records - $records_to_save;
			   $an->data->{archive}{table}{$table}{offset} = $offset;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "archive_needed",                   value1 => $archive_needed, 
				name2 => "records_to_save",                  value2 => $records_to_save, 
				name3 => "archive::table::${table}::offset", value3 => $an->data->{archive}{table}{$table}{offset}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I have something to archive, do so now.
	if ($archive_needed)
	{
		# This will store the files to compress after we release the locks.
		my $compress = [];
		
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Now loop through the table(s) that need to be archived.
		foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
		{
			next if not $an->data->{archive}{table}{$table}{offset};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "table", value1 => $table, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Now to do the archive.
			if ($table eq "remote_access")
			{
				$an->DB->archive_table({
					table        => $table, 
					offset       => $an->data->{archive}{table}{$table}{offset}, 
					conditionals => { $an->data->{archive}{table}{$table}{host_column} => $an->data->{sys}{host_uuid} },
					columns      => ["remote_access_uuid", "remote_access_host_uuid", "remote_access_target_name", "remote_access_target_access"],
				});
			}
		}
		
		### TODO: Make this less of a hackish mc-hackington...
		# VACUUM FULL, if the database is on this machine. I need to do this from the command line 
		# because the user we connect as isn't allowed to do it. We'll also only vacuum our DB.
		my $db_name = "";
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "id",                        value1 => $id, 
				name2 => "scancore::db::${id}::host", value2 => $an->data->{scancore}{db}{$id}{host}, 
				name3 => "hostname",                  value3 => $an->hostname, 
				name4 => "short_hostname",            value4 => $an->short_hostname, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($an->data->{scancore}{db}{$id}{host} eq $an->hostname) or ($an->data->{scancore}{db}{$id}{host} eq $an->short_hostname))
			{
				$db_name = $an->data->{scancore}{db}{$id}{name};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "db_name",                   value1 => $db_name, 
					name2 => "scancore::db::${id}::name", value2 => $an->data->{scancore}{db}{$id}{name}, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		if ($db_name)
		{
			my $start      = time;
			my $shell_call = $an->data->{path}{su}." - postgres -c \"".$an->data->{path}{psql}." $db_name -c 'VACUUM FULL;'\"";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "start",      value1 => $start, 
				name2 => "shell_call", value2 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			my $finished = time - $start;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "finished", value1 => $finished, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Release the lock
		$an->DB->locking({release => 1});
	}
	
	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load the schema. If the schema gets
# loaded, we'll check other databases for older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => $THIS_FILE }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='remote_access' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_remote_access_message_0002"})."\n";

	return(0);
}
