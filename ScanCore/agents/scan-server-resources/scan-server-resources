#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released under the terms of the GNU GPL 
# version 2.
#
# This agent tries to read the resources on a server. 
# 
# This agent will only run if one or more targets are specifically configured in striker.conf. 
# 
# Configuration is to add the following to striker.conf;
# 
# ====
# scan-server-resources::target::<id>::host		= <name_or_ip>{:<port>}
# ====
# 
# The <id> can be any alpha-numeric string or number that is unique from other entries. Any number of entries
# can be added, but the checks will be performed sequentially. So in a case where multiple targets are slow
# to respond, this agent could run for some time.
# 
# The 'host' can be an IP address or a resolvable host name. Optionally, a port can be specified with the 
# suffix '<name_or_ip>:<port>'. The default port is 26845.
# 
# https://alteeve.ca
# 
# Exit Codes:
# 0   - Success
# 1   - 
# 
# 255 - The host's UUID isn't in the hosts table yet, ScanCore itself hasn't been run.

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;
use IO::Socket::INET;
no warnings 'recursion';

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}
my $scancore_directory = ($running_directory =~ /^(.*?)\/agents\/$THIS_FILE$/)[0];

### TODO: Rework this whole agent...
# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path			=>	{
			core_strings		=>	"$scancore_directory/ScanCore.xml",
			sql			=>	"$running_directory/$THIS_FILE.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			strings			=>	"$running_directory/$THIS_FILE.xml",
		},
		sys			=>	{
			# When a lock is requested, this is set to the time the lock was set. 
			# DB->do_db_write() and DB->do_db_read() will check this and if its age is >50% of
			# scancore::locking::reap_age, it will renew the lock.
			local_lock_active	=>	0,
			sql			=>	[],
			# Showing updates about a server's disks or CPUs need to be reported in order.
			alert_sort		=>	0,
		},
		scancore		=>	{
			archive			=>	{
				directory		=>	"/var/ScanCore/archives/",
				division		=>	60000,
				trigger			=>	100000,
				count			=>	50000,
				dump_file_header	=>	"
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = history, pg_catalog;
",
			},
			servers			=>	{
				reboots_are_warning	=>	0,
			},
		},
		# These are values the user might set in striker.conf
		'scan-server-resources'	=>	{
			'an-ssrw-port'		=>	26845,
			disable			=>	0,
			language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_level		=>	1,
			log_language		=>	"en_CA",
			log_db_transactions	=>	0,
			count			=>	3,
			# If the amount of free space on disk drops below this percentage, we'll throw a 
			# warning.
			free_disk_space_low_warning =>	10,
			free_disk_space_low_clear =>	20,
			# If the amount of free RAM drops below this percentage, we'll throw a warning.
			free_ram_low_warning	=>	20,
			# If the free RAM percentage climbs above this, and a warning was sent earlier, it
			# will be cleared.
			free_ram_low_clear	=>	30,
			# If the amount of free swap drops below this percentage, we'll throw a warning.
			free_swap_low_warning	=>	20,
			# If the free swap percentage climbs above this, and a warning was sent earlier, it
			# will be cleared.
			free_swap_low_clear	=>	30,
		},
		targets			=>	{},
	},
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{$THIS_FILE}{language});
$an->default_log_language($an->data->{$THIS_FILE}{log_language});
$an->default_log_file    ($an->data->{$THIS_FILE}{log_file});

# Set the log level.
$an->Log->level($an->data->{$THIS_FILE}{log_level});
$an->Log->db_transactions(1) if $an->data->{$THIS_FILE}{log_db_transactions};

# Read in the language strings.
$an->Storage->read_words({file => $an->data->{path}{strings}});
$an->Storage->read_words({file => $an->data->{path}{core_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# Get the switches before printing anything in case the user is asking for help.
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

# Help?
if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or
    ($an->data->{switches}{help}))
{
	# Help!
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

# Exit if we're disabled.
if ($an->data->{$THIS_FILE}{disable})
{
	$an->nice_exit({exit_code => 1});
}

print $an->String->get({key => "scan_server_resources_message_0001"})."\n";

# I'll need to loop through the DBs and ensure our schema is loaded for each one.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
$an->Log->entry({log_level => 2, message_key => "notice_message_0013", message_variables => { connections => $connections }, file => $THIS_FILE, line => __LINE__});

# Make sure this host's UUID is in the 'hosts' table. If the user is running this directly without first
# running ScanCore, it won't be.
if (not $an->DB->verify_host_uuid())
{
	# ScanCore hasn't run, this host isn't in the 'hosts' table.
	$an->Alert->error({title_key => "an_0003", message_key => "scancore_error_0020", message_variables => { uuid => $an->data->{sys}{host_uuid} }, code => 255, file => $THIS_FILE, line => __LINE__});
}

# Before proceeding, do we have any targets to scan?
my $target_count = 0;
if (exists $an->data->{'scan-server-resources'}{target})
{
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{'scan-server-resources'}{target}})
	{
		$target_count++;
		my $host = $an->data->{'scan-server-resources'}{target}{$id}{host};
		my $port = $an->data->{'scan-server-resources'}{'an-ssrw-port'};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "host",         value1 => $host, 
			name2 => "port",         value2 => $port, 
			name3 => "target_count", value3 => $target_count, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# If the host has a port suffix, break it off.
		if ($host =~ /^(.*?):(\d+)$/)
		{
			$host = $1;
			$port = $2;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "host", value1 => $host, 
				name2 => "port", value2 => $port, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Mark that we saw it in the config file so that if we fail to connect, we'll know the 
		# difference between removed from config and just not reachable.
		gather_details($an, $host, $port, $id);
	}
}

$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
	name1 => "target_count", value1 => $target_count, 
}, file => $THIS_FILE, line => __LINE__});
if (not $target_count)
{
	# Nothing to do, exit.
	if ($an->data->{switches}{'prep-db'})
	{
		if ($connections)
		{
			prep_databases($an);
		}
		else
		{
			# Failed
			$an->Log->entry({log_level => 1, message_key => "scancore_warning_0031", file => $THIS_FILE, line => __LINE__});
			print $an->String->get({key => "scancore_warning_0031"})."\n";
		}
	}
	$an->nice_exit({exit_code => 0});
}

### Still alive? Time for work!
# Do the loading of the schemas and copying data from more up to date DBs if the DB was loaded.
prep_databases($an);

# Archive, if needed.
archive_if_needed($an);

### TODO: Add this...
# Look to see if any databases need to be updated.
update_db($an);

# Look for changes.
find_changes($an);

# Update the database
$an->DB->update_time({file => $THIS_FILE});

# Clean up and go away.
$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This looks at each DB's 'updated' table entry to see if any tables are behind. If any are, it will update
# the tables based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Make a note in the databases that we're starting an update and ask it to wait 10 seconds 
		# before returning to give other instances time to finish their scans. (our scans end quickly
		# enough).
		#$an->DB->set_update_db_flag({set => time, 'wait' => 10});
		
		# Update server_resources
		update_db_server_resources($an);
		update_db_server_resource_disks($an);
		update_db_server_resource_cpus($an);
		
		# Release the lock
		$an->DB->locking({release => 1});
		
		# Clear the update flag.
		#$an->DB->set_update_db_flag({set => 0});
	}
	
	return(0);
}

# Update the 'update_db_server_resource_disks' table.
sub update_db_server_resource_disks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_server_resource_disks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'update_db_server_resource_disks' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    server_resource_disk_uuid, 
    server_resource_disk_server_resource_uuid,
    server_resource_disk_mount_point, 
    server_resource_disk_filesystem, 
    server_resource_disk_options, 
    server_resource_disk_size, 
    server_resource_disk_used, 
    modified_date 
FROM 
    history.server_resource_disks 
WHERE 
    server_resource_disk_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $server_resource_disk_uuid                 =         $row->[0];
			my $server_resource_disk_server_resource_uuid =         $row->[1];
			my $server_resource_disk_mount_point          =         $row->[2];
			my $server_resource_disk_filesystem           = defined $row->[3] ? $row->[3] : "NULL";
			my $server_resource_disk_options              = defined $row->[4] ? $row->[4] : "NULL";
			my $server_resource_disk_size                 =         $row->[5];
			my $server_resource_disk_used                 =         $row->[6];
			my $modified_date                             =         $row->[7];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "server_resource_disk_uuid",                 value1 => $server_resource_disk_uuid, 
				name2 => "server_resource_disk_server_resource_uuid", value2 => $server_resource_disk_server_resource_uuid, 
				name3 => "server_resource_disk_mount_point",          value3 => $server_resource_disk_mount_point, 
				name4 => "server_resource_disk_filesystem",           value4 => $server_resource_disk_filesystem, 
				name5 => "server_resource_disk_options",              value5 => $server_resource_disk_options, 
				name6 => "server_resource_disk_size",                 value6 => $server_resource_disk_size, 
				name7 => "server_resource_disk_used",                 value7 => $server_resource_disk_used, 
				name8 => "modified_date",                             value8 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid} = {
				server_resource_disk_server_resource_uuid	=>	$server_resource_disk_server_resource_uuid, 
				server_resource_disk_mount_point		=>	$server_resource_disk_mount_point, 
				server_resource_disk_filesystem			=>	$server_resource_disk_filesystem, 
				server_resource_disk_options			=>	$server_resource_disk_options, 
				server_resource_disk_size			=>	$server_resource_disk_size, 
				server_resource_disk_used			=>	$server_resource_disk_used, 
			};
			$an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid} = {
				server_resource_disk_server_resource_uuid	=>	$server_resource_disk_server_resource_uuid, 
				server_resource_disk_mount_point		=>	$server_resource_disk_mount_point, 
				server_resource_disk_filesystem			=>	$server_resource_disk_filesystem, 
				server_resource_disk_options			=>	$server_resource_disk_options, 
				server_resource_disk_size			=>	$server_resource_disk_size, 
				server_resource_disk_used			=>	$server_resource_disk_used, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{server_resource_disks}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $server_resource_disk_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}})
		{
			my $server_resource_disk_server_resource_uuid = $an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}{server_resource_disk_server_resource_uuid};
			my $server_resource_disk_mount_point          = $an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}{server_resource_disk_mount_point};
			my $server_resource_disk_filesystem           = $an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}{server_resource_disk_filesystem};
			my $server_resource_disk_options              = $an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}{server_resource_disk_options};
			my $server_resource_disk_size                 = $an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}{server_resource_disk_size};
			my $server_resource_disk_used                 = $an->data->{db_data}{unified}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}{server_resource_disk_used};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
				name1 => "server_resource_disk_uuid",                 value1 => $server_resource_disk_uuid, 
				name2 => "server_resource_disk_server_resource_uuid", value2 => $server_resource_disk_server_resource_uuid, 
				name3 => "server_resource_disk_mount_point",          value3 => $server_resource_disk_mount_point, 
				name4 => "server_resource_disk_filesystem",           value4 => $server_resource_disk_filesystem, 
				name5 => "server_resource_disk_options",              value5 => $server_resource_disk_options, 
				name6 => "server_resource_disk_size",                 value6 => $server_resource_disk_size, 
				name7 => "server_resource_disk_used",                 value7 => $server_resource_disk_used, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'server_resource_disk_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::server_resource_disks::server_resource_disk_uuid::${server_resource_disk_uuid}::seen", value1 => $an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::server_resource_disks::server_resource_disk_uuid::${server_resource_disk_uuid}::exists", value1 => $an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{server_resource_disks}{server_resource_disk_uuid}{$server_resource_disk_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::server_resource_disks::modified_date::${modified_date}::server_resource_disk_uuid::${server_resource_disk_uuid}", value1 => $an->data->{db_data}{$id}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.server_resource_disks 
SET
    server_resource_disk_server_resource_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_server_resource_uuid).",
    server_resource_disk_mount_point          = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_mount_point).", 
    server_resource_disk_filesystem           = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_filesystem).", 
    server_resource_disk_options              = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_options).", 
    server_resource_disk_size                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_size).", 
    server_resource_disk_used                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_used).", 
    modified_date                             = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    server_resource_disk_host_uuid            = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    server_resource_disk_uuid                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.server_resource_disks 
(
    server_resource_disk_host_uuid, 
    server_resource_disk_uuid, 
    server_resource_disk_server_resource_uuid, 
    server_resource_disk_mount_point, 
    server_resource_disk_filesystem, 
    server_resource_disk_options, 
    server_resource_disk_size, 
    server_resource_disk_used, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_mount_point).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_filesystem).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_options).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'server_resource_disk_uuid' before, so it is just a question of 
					# whether the entry for the current timestamp exists in the history 
					# schema.
					if (not $an->data->{db_data}{$id}{server_resource_disks}{modified_date}{$modified_date}{server_resource_disk_uuid}{$server_resource_disk_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.server_resource_disks 
(
    server_resource_disk_host_uuid, 
    server_resource_disk_uuid, 
    server_resource_disk_server_resource_uuid, 
    server_resource_disk_mount_point, 
    server_resource_disk_filesystem, 
    server_resource_disk_options, 
    server_resource_disk_size, 
    server_resource_disk_used, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_mount_point).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_filesystem).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_options).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen server_resource_disk_uuid?
			} # foreach my $id 
		} # foreach my $server_resource_disk_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'update_db_server_resource_cpus' table.
sub update_db_server_resource_cpus
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_server_resource_cpus" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'update_db_server_resource_cpus' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    server_resource_cpu_uuid, 
    server_resource_cpu_server_resource_uuid,
    server_resource_cpu_number, 
    server_resource_cpu_load, 
    modified_date 
FROM 
    history.server_resource_cpus 
WHERE 
    server_resource_cpu_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $server_resource_cpu_uuid                 = $row->[0];
			my $server_resource_cpu_server_resource_uuid = $row->[1];
			my $server_resource_cpu_number               = $row->[2];
			my $server_resource_cpu_load                 = $row->[3];
			my $modified_date                            = $row->[7];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
				name1 => "server_resource_cpu_uuid",                 value1 => $server_resource_cpu_uuid, 
				name2 => "server_resource_cpu_server_resource_uuid", value2 => $server_resource_cpu_server_resource_uuid, 
				name3 => "server_resource_cpu_number",               value3 => $server_resource_cpu_number, 
				name4 => "server_resource_cpu_load",                 value4 => $server_resource_cpu_load, 
				name5 => "modified_date",                            value5 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid} = {
				server_resource_cpu_server_resource_uuid	=>	$server_resource_cpu_server_resource_uuid, 
				server_resource_cpu_number			=>	$server_resource_cpu_number, 
				server_resource_cpu_load			=>	$server_resource_cpu_load, 
			};
			$an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid} = {
				server_resource_cpu_server_resource_uuid	=>	$server_resource_cpu_server_resource_uuid, 
				server_resource_cpu_number			=>	$server_resource_cpu_number, 
				server_resource_cpu_load			=>	$server_resource_cpu_load, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{server_resource_cpus}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $server_resource_cpu_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}})
		{
			my $server_resource_cpu_server_resource_uuid = $an->data->{db_data}{unified}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{server_resource_cpu_server_resource_uuid};
			my $server_resource_cpu_number               = $an->data->{db_data}{unified}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{server_resource_cpu_number};
			my $server_resource_cpu_load                 = $an->data->{db_data}{unified}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{server_resource_cpu_load};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "server_resource_cpu_uuid",                 value1 => $server_resource_cpu_uuid, 
				name2 => "server_resource_cpu_server_resource_uuid", value2 => $server_resource_cpu_server_resource_uuid, 
				name3 => "server_resource_cpu_number",               value3 => $server_resource_cpu_number, 
				name4 => "server_resource_cpu_load",                 value4 => $server_resource_cpu_load, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'server_resource_cpu_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::server_resource_cpus::server_resource_cpu_uuid::${server_resource_cpu_uuid}::seen", value1 => $an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::server_resource_cpus::server_resource_cpu_uuid::${server_resource_cpu_uuid}::exists", value1 => $an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{server_resource_cpus}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::server_resource_cpus::modified_date::${modified_date}::server_resource_cpu_uuid::${server_resource_cpu_uuid}", value1 => $an->data->{db_data}{$id}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.server_resource_cpus 
SET
    server_resource_cpu_server_resource_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_server_resource_uuid).",
    server_resource_cpu_number               = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_number).", 
    server_resource_cpu_load                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_load).", 
    modified_date                            = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    server_resource_cpu_host_uuid            = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    server_resource_cpu_uuid                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.server_resource_cpus 
(
    server_resource_cpu_host_uuid, 
    server_resource_cpu_uuid, 
    server_resource_cpu_server_resource_uuid, 
    server_resource_cpu_number, 
    server_resource_cpu_load, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_load).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'server_resource_cpu_uuid' before, so it is just a question of 
					# whether the entry for the current timestamp exists in the history 
					# schema.
					if (not $an->data->{db_data}{$id}{server_resource_cpus}{modified_date}{$modified_date}{server_resource_cpu_uuid}{$server_resource_cpu_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.server_resource_cpus 
(
    server_resource_cpu_host_uuid, 
    server_resource_cpu_uuid, 
    server_resource_cpu_server_resource_uuid, 
    server_resource_cpu_number, 
    server_resource_cpu_load, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_load).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen server_resource_cpu_uuid?
			} # foreach my $id 
		} # foreach my $server_resource_cpu_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'server_resources' table.
sub update_db_server_resources
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_server_resources" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'server_resource' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    server_resource_uuid, 
    server_resource_target_access, 
    server_resource_host_name, 
    server_resource_os, 
    server_resource_boot_time, 
    server_resource_ram_size, 
    server_resource_ram_used, 
    server_resource_swap_size, 
    server_resource_swap_used, 
    server_resource_note, 
    modified_date 
FROM 
    history.server_resources 
WHERE 
    server_resource_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $server_resource_uuid          =         $row->[0];
			my $server_resource_target_access =         $row->[1];
			my $server_resource_host_name     =         $row->[2];
			my $server_resource_os            =         $row->[3];
			my $server_resource_boot_time     =         $row->[4];
			my $server_resource_ram_size      =         $row->[5];
			my $server_resource_ram_used      =         $row->[6];
			my $server_resource_swap_size     =         $row->[7];
			my $server_resource_swap_used     =         $row->[8];
			my $server_resource_note          = defined $row->[9]  ? $row->[9]  : "NULL", 
			my $modified_date                 =         $row->[10];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0011", message_variables => {
				name1  => "server_resource_uuid",          value1  => $server_resource_uuid, 
				name2  => "server_resource_target_access", value2  => $server_resource_target_access, 
				name3  => "server_resource_host_name",     value3  => $server_resource_host_name, 
				name4  => "server_resource_os",            value4  => $server_resource_os, 
				name5  => "server_resource_boot_time",     value5  => $server_resource_boot_time, 
				name6  => "server_resource_ram_size",      value6  => $server_resource_ram_size, 
				name7  => "server_resource_ram_used",      value7  => $server_resource_ram_used, 
				name8  => "server_resource_swap_size",     value8  => $server_resource_swap_size, 
				name9  => "server_resource_swap_used",     value9  => $server_resource_swap_used, 
				name10 => "server_resource_note",          value10 => $server_resource_note, 
				name11 => "modified_date",                 value11 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid} = {
				server_resource_target_access	=>	$server_resource_target_access, 
				server_resource_host_name	=>	$server_resource_host_name, 
				server_resource_os		=>	$server_resource_os, 
				server_resource_boot_time	=>	$server_resource_boot_time, 
				server_resource_ram_size	=>	$server_resource_ram_size, 
				server_resource_ram_used	=>	$server_resource_ram_used, 
				server_resource_swap_size	=>	$server_resource_swap_size, 
				server_resource_swap_used	=>	$server_resource_swap_used, 
				server_resource_note		=>	$server_resource_note, 
			};
			$an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid} = {
				server_resource_target_access	=>	$server_resource_target_access, 
				server_resource_host_name	=>	$server_resource_host_name, 
				server_resource_os		=>	$server_resource_os, 
				server_resource_boot_time	=>	$server_resource_boot_time, 
				server_resource_ram_size	=>	$server_resource_ram_size, 
				server_resource_ram_used	=>	$server_resource_ram_used, 
				server_resource_swap_size	=>	$server_resource_swap_size, 
				server_resource_swap_used	=>	$server_resource_swap_used, 
				server_resource_note		=>	$server_resource_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{server_resources}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $server_resource_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}})
		{
			my $server_resource_target_access = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_target_access};
			my $server_resource_host_name     = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_host_name};
			my $server_resource_os            = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_os};
			my $server_resource_boot_time     = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_boot_time};
			my $server_resource_ram_size     = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_size};
			my $server_resource_ram_used     = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_used};
			my $server_resource_swap_size    = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_size};
			my $server_resource_swap_used    = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_used};
			my $server_resource_note         = $an->data->{db_data}{unified}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}{server_resource_note};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
				name1  => "server_resource_uuid",          value1  => $server_resource_uuid, 
				name2  => "server_resource_target_access", value2  => $server_resource_target_access, 
				name3  => "server_resource_host_name",     value3  => $server_resource_host_name, 
				name4  => "server_resource_os",            value4  => $server_resource_os, 
				name5  => "server_resource_boot_time",     value5  => $server_resource_boot_time, 
				name6  => "server_resource_ram_size",      value6  => $server_resource_ram_size, 
				name7  => "server_resource_ram_used",      value7  => $server_resource_ram_used, 
				name8  => "server_resource_swap_size",     value8  => $server_resource_swap_size, 
				name9  => "server_resource_swap_used",     value9  => $server_resource_swap_used, 
				name10 => "server_resource_note",          value10 => $server_resource_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'server_resource_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::server_resources::server_resource_uuid::${server_resource_uuid}::seen", value1 => $an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::server_resources::server_resource_uuid::${server_resource_uuid}::exists", value1 => $an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{server_resources}{server_resource_uuid}{$server_resource_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::server_resources::modified_date::${modified_date}::server_resource_uuid::${server_resource_uuid}", value1 => $an->data->{db_data}{$id}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.server_resources 
SET
    server_resource_target_access = ".$an->data->{sys}{use_db_fh}->quote($server_resource_target_access).", 
    server_resource_host_name     = ".$an->data->{sys}{use_db_fh}->quote($server_resource_host_name).", 
    server_resource_os            = ".$an->data->{sys}{use_db_fh}->quote($server_resource_os).", 
    server_resource_boot_time     = ".$an->data->{sys}{use_db_fh}->quote($server_resource_boot_time).", 
    server_resource_ram_size      = ".$an->data->{sys}{use_db_fh}->quote($server_resource_ram_size).", 
    server_resource_ram_used      = ".$an->data->{sys}{use_db_fh}->quote($server_resource_ram_used).", 
    server_resource_swap_size     = ".$an->data->{sys}{use_db_fh}->quote($server_resource_swap_size).", 
    server_resource_swap_used     = ".$an->data->{sys}{use_db_fh}->quote($server_resource_swap_used).", 
    server_resource_note          = ".$an->data->{sys}{use_db_fh}->quote($server_resource_note).", 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    server_resource_host_uuid     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    server_resource_uuid          = ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.server_resources 
(
    server_resource_host_uuid, 
    server_resource_uuid, 
    server_resource_target_access, 
    server_resource_host_name, 
    server_resource_os, 
    server_resource_boot_time, 
    server_resource_ram_size, 
    server_resource_ram_used, 
    server_resource_swap_size, 
    server_resource_swap_used, 
    server_resource_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_target_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_os).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_boot_time).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_ram_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_ram_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_swap_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_swap_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'server_resource_uuid' before, so it is just a question of 
					# whether the entry for the current timestamp exists in the history 
					# schema.
					if (not $an->data->{db_data}{$id}{server_resources}{modified_date}{$modified_date}{server_resource_uuid}{$server_resource_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.server_resources 
(
    server_resource_host_uuid, 
    server_resource_uuid, 
    server_resource_target_access, 
    server_resource_host_name, 
    server_resource_os, 
    server_resource_boot_time, 
    server_resource_ram_size, 
    server_resource_ram_used, 
    server_resource_swap_size, 
    server_resource_swap_used, 
    server_resource_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_target_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_os).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_boot_time).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_ram_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_ram_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_swap_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_swap_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen server_resource_uuid?
			} # foreach my $id 
		} # foreach my $server_resource_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This calls the target and reads in the resources XML.
sub gather_details
{
	my ($an, $host, $port, $id) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_access" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "host", value1 => $host, 
		name2 => "port", value2 => $port, 
		name3 => "id",   value3 => $id, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $protocol  = "tcp";
	my $variables = { target => $host, port => $port };
	$an->Log->entry({log_level => 2, message_key => "scan_server_resources_log_0001", message_variables => $variables, file => $THIS_FILE, line => __LINE__});
	print $an->String->get({key => "scan_server_resources_log_0001", variables => $variables})."\n";
	
	# Don't make this fatal. We'll just mark is as "no access" and skip it if it fails
	my $target_access = $host.":".$port;
	my $socket        = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $port, Proto => $protocol) or $an->Alert->warning({message_key => "warning_message_0018", message_variables => { target => $host, port => $port, protocol => $protocol, error => $! }, quiet => 0, file => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "socket", value1 => $socket, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not $socket)
	{
		# Mark it as offline so that we can update it if needed.
		$an->data->{'server-resources'}{offline}{$target_access} = "id:".$id;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "server-resources::offline::$target_access", value1 => $an->data->{'server-resources'}{offline}{$target_access}, 
		}, file => $THIS_FILE, line => __LINE__});
		return(0);
	}

	my $access = 0;
	my $output = "";
	print $socket "GET\n";
	while(<$socket>)
	{
		chomp;
		my $line = $_;
		
		# There are a few XML syntax bugs in the client. This fixes them until we can fix the daemon.
		$line =~ s/<ram (.*)">/<ram $1"\/>/;
		$line =~ s/<swap (.*)">/<swap $1"\/>/;
		$line =~ s/<cores count=(\d+)>/<cores count="$1"\/>/;
		if ($line =~ /<\/server>/)
		{
			$access = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "access", value1 => $access, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		$output .= $line."\n";
	}
	$socket->close();
	chomp $output;
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "output", value1 => $output, 
		name2 => "access", value2 => $access, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($access)
	{
		my $xml  = XML::Simple->new();
		my $data = $xml->XMLin($output, KeyAttr => {node => 'name'}, ForceArray => 1);
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "data", value1 => $data,
		}, file => $THIS_FILE, line => __LINE__});
		
		my $server_uuid = $data->{uuid};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "server_uuid", value1 => $server_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Strip the .X off the boot tome.
		$data->{boot_time} =~ s/\.\d+$//;
		
		$an->data->{'server-resources'}{server}{$server_uuid}{access}     = $target_access;
		$an->data->{'server-resources'}{server}{$server_uuid}{boot_time}  = $data->{boot_time};
		$an->data->{'server-resources'}{server}{$server_uuid}{host_name}  = $data->{host_name};
		$an->data->{'server-resources'}{server}{$server_uuid}{host_os}    = $data->{os};
		$an->data->{'server-resources'}{server}{$server_uuid}{ram_used}   = $data->{memory}->[0]->{ram}->[0]->{used};
		$an->data->{'server-resources'}{server}{$server_uuid}{ram_total}  = $data->{memory}->[0]->{ram}->[0]->{total};
		$an->data->{'server-resources'}{server}{$server_uuid}{swap_used}  = $data->{memory}->[0]->{swap}->[0]->{used};
		$an->data->{'server-resources'}{server}{$server_uuid}{swap_total} = $data->{memory}->[0]->{swap}->[0]->{total};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "server-resources::server::${server_uuid}::access",     value1 => $an->data->{'server-resources'}{server}{$server_uuid}{access},
			name2 => "server-resources::server::${server_uuid}::boot_time",  value2 => $an->data->{'server-resources'}{server}{$server_uuid}{boot_time},
			name3 => "server-resources::server::${server_uuid}::host_name",  value3 => $an->data->{'server-resources'}{server}{$server_uuid}{host_name},
			name4 => "server-resources::server::${server_uuid}::host_os",    value4 => $an->data->{'server-resources'}{server}{$server_uuid}{host_os},
			name5 => "server-resources::server::${server_uuid}::ram_total",  value5 => $an->data->{'server-resources'}{server}{$server_uuid}{ram_total}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'server-resources'}{server}{$server_uuid}{ram_total} }).")",
			name6 => "server-resources::server::${server_uuid}::ram_used",   value6 => $an->data->{'server-resources'}{server}{$server_uuid}{ram_used}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'server-resources'}{server}{$server_uuid}{ram_used} }).")",
			name7 => "server-resources::server::${server_uuid}::swap_total", value7 => $an->data->{'server-resources'}{server}{$server_uuid}{swap_total}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'server-resources'}{server}{$server_uuid}{swap_total} }).")",
			name8 => "server-resources::server::${server_uuid}::swap_used",  value8 => $an->data->{'server-resources'}{server}{$server_uuid}{swap_used}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'server-resources'}{server}{$server_uuid}{swap_used} }).")",
		}, file => $THIS_FILE, line => __LINE__});
		
		# Get the disks
		foreach my $array_ref (@{$data->{disks}->[0]->{drive}})
		{
			# I strip off the colon and slash from windows drive letters.
			my $disk_name =  $array_ref->{name};
			   $disk_name =~ s/:\\$//;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "disk_name", value1 => $disk_name,
			}, file => $THIS_FILE, line => __LINE__});
			
			# We ignore optical drives
			next if $array_ref->{options} =~ /cdrom/;
			
			$an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{filesystem} = defined $array_ref->{filesystem} ? $array_ref->{filesystem} : "";
			$an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{options}    = defined $array_ref->{options}    ? $array_ref->{options}    : "";
			$an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{used}       = defined $array_ref->{used}       ? $array_ref->{used}       : 0;
			$an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{total}      = defined $array_ref->{size}       ? $array_ref->{size}       : 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "server-resources::server::${server_uuid}::disk::${disk_name}::filesystem", value1 => $an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{filesystem},
				name2 => "server-resources::server::${server_uuid}::disk::${disk_name}::options",    value2 => $an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{options},
				name3 => "server-resources::server::${server_uuid}::disk::${disk_name}::total",      value3 => $an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{total}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{total} }).")",
				name4 => "server-resources::server::${server_uuid}::disk::${disk_name}::used",       value4 => $an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{used}." (".$an->Readable->bytes_to_hr({'bytes' => $an->data->{'server-resources'}{server}{$server_uuid}{disk}{$disk_name}{used} }).")",
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Get the CPU(s)
		foreach my $array_ref (@{$data->{cpu}->[0]->{cpu}})
		{
			my $cpu_number =  $array_ref->{number};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cpu_number", value1 => $cpu_number,
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{'server-resources'}{server}{$server_uuid}{cpu}{$cpu_number}{load} = defined $array_ref->{load} ? $array_ref->{load} : "--";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "server-resources::server::${server_uuid}::cpu::${cpu_number}::load", value1 => $an->data->{'server-resources'}{server}{$server_uuid}{cpu}{$cpu_number}{load},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "access", value1 => $access, 
	}, file => $THIS_FILE, line => __LINE__});
	return($access);
}

# This reads in the last scan's data.
sub read_last_scan
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "read_last_scan" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in existing data, if any.
	my $query = "
SELECT 
    server_resource_uuid,
    server_resource_target_access, 
    server_resource_host_name, 
    server_resource_os, 
    server_resource_boot_time, 
    server_resource_ram_size, 
    server_resource_ram_used, 
    server_resource_swap_size, 
    server_resource_swap_used, 
    server_resource_note 
FROM 
    server_resources 
WHERE 
    server_resource_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $server_resource_uuid          =         $row->[0];
		my $server_resource_target_access =         $row->[1];
		my $server_resource_host_name     =         $row->[2];
		my $server_resource_os            =         $row->[3];
		my $server_resource_boot_time     =         $row->[4];
		my $server_resource_ram_size      =         $row->[5];
		my $server_resource_ram_used      =         $row->[6];
		my $server_resource_swap_size     =         $row->[7];
		my $server_resource_swap_used     =         $row->[8];
		my $server_resource_note          = defined $row->[9] ? $row->[9] : "";
		
		$an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid} = {
			server_resource_target_access => $server_resource_target_access,
			server_resource_host_name     => $server_resource_host_name,
			server_resource_os            => $server_resource_os,
			server_resource_boot_time     => $server_resource_boot_time,
			server_resource_ram_size      => $server_resource_ram_size,
			server_resource_ram_used      => $server_resource_ram_used,
			server_resource_swap_size     => $server_resource_swap_size,
			server_resource_swap_used     => $server_resource_swap_used,
			server_resource_note          => $server_resource_note,
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
			name1 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_target_access", value1 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_target_access}, 
			name2 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_host_name",     value2 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_host_name}, 
			name3 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_os",            value3 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_os}, 
			name4 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_boot_time",     value4 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_boot_time}, 
			name5 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_ram_size",      value5 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_size}, 
			name6 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_ram_used",      value6 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_used}, 
			name7 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_swap_size",     value7 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_size}, 
			name8 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_swap_used",     value8 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_used}, 
			name9 => "sql::server_resources::server_resource_uuid::${server_resource_uuid}::server_resource_note",          value9 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_note}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# Get the Disks for this server
	$query = "
SELECT 
    server_resource_disk_uuid, 
    server_resource_disk_server_resource_uuid,
    server_resource_disk_mount_point,
    server_resource_disk_filesystem,
    server_resource_disk_options,
    server_resource_disk_size,
    server_resource_disk_used
FROM 
    server_resource_disks 
WHERE 
    server_resource_disk_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."

;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $server_resource_disk_uuid                 = $row->[0];
		my $server_resource_disk_server_resource_uuid = $row->[1];
		my $server_resource_disk_mount_point          = $row->[2];
		my $server_resource_disk_filesystem           = $row->[3];
		my $server_resource_disk_options              = $row->[4];
		my $server_resource_disk_size                 = $row->[5];
		my $server_resource_disk_used                 = $row->[6];
		
		$an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_disk_server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point} = {
			server_resource_disk_uuid        => $server_resource_disk_uuid, 
			server_resource_disk_mount_point => $server_resource_disk_mount_point,
			server_resource_disk_filesystem  => $server_resource_disk_filesystem,
			server_resource_disk_options     => $server_resource_disk_options,
			server_resource_disk_size        => $server_resource_disk_size,
			server_resource_disk_used        => $server_resource_disk_used,
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
			name1 => "sql::server_resources::server_resource_uuid::${server_resource_disk_server_resource_uuid}::server_resource_disk_mount_point::${server_resource_disk_mount_point}::server_resource_disk_uuid",       value1 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_disk_server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_uuid}, 
			name2 => "sql::server_resources::server_resource_uuid::${server_resource_disk_server_resource_uuid}::server_resource_disk_mount_point::${server_resource_disk_mount_point}::server_resource_disk_filesystem", value2 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_disk_server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_filesystem}, 
			name3 => "sql::server_resources::server_resource_uuid::${server_resource_disk_server_resource_uuid}::server_resource_disk_mount_point::${server_resource_disk_mount_point}::server_resource_disk_options",    value3 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_disk_server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_options}, 
			name4 => "sql::server_resources::server_resource_uuid::${server_resource_disk_server_resource_uuid}::server_resource_disk_mount_point::${server_resource_disk_mount_point}::server_resource_disk_size",       value4 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_disk_server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_size}, 
			name5 => "sql::server_resources::server_resource_uuid::${server_resource_disk_server_resource_uuid}::server_resource_disk_mount_point::${server_resource_disk_mount_point}::server_resource_disk_used",       value5 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_disk_server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_used}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	# Get the CPU cores for this server
	$query = "
SELECT 
    server_resource_cpu_uuid, 
    server_resource_cpu_server_resource_uuid,
    server_resource_cpu_number, 
    server_resource_cpu_load
FROM 
    server_resource_cpus 
WHERE 
    server_resource_cpu_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."

;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $server_resource_cpu_uuid                 = $row->[0];
		my $server_resource_cpu_server_resource_uuid = $row->[1];
		my $server_resource_cpu_number               = $row->[2]; 
		my $server_resource_cpu_load                 = $row->[3];
		
		$an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_cpu_server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number} = {
			server_resource_cpu_uuid => $server_resource_cpu_uuid,
			server_resource_cpu_load => $server_resource_cpu_load,
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "sql::server_resources::server_resource_uuid::${server_resource_cpu_server_resource_uuid}::server_resource_cpu_number::${server_resource_cpu_number}::server_resource_cpu_uuid", value1 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_cpu_server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number}{server_resource_cpu_uuid}, 
			name2 => "sql::server_resources::server_resource_uuid::${server_resource_cpu_server_resource_uuid}::server_resource_cpu_number::${server_resource_cpu_number}::server_resource_cpu_load", value2 => $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_cpu_server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number}{server_resource_cpu_load}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	undef $results;
	
	return(0);
}

# This reads in the last scan data from one of the databases and compares it against the just-read data. If 
# anything changed, register an alert.
sub find_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "find_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read the last state of any targets we already know about
	read_last_scan($an);
	
	# As we loop through each target, we'll see if we already we know about this system and, if so, if it
	# just came back or left.
	foreach my $server_resource_uuid (sort {$a cmp $b} keys %{$an->data->{'server-resources'}{server}})
	{
		my $new_server_resource_target_access = $an->data->{'server-resources'}{server}{$server_resource_uuid}{access}; 
		my $new_server_resource_host_name     = $an->data->{'server-resources'}{server}{$server_resource_uuid}{host_name}; 
		my $new_server_resource_os            = $an->data->{'server-resources'}{server}{$server_resource_uuid}{host_os};
		my $new_server_resource_boot_time     = $an->data->{'server-resources'}{server}{$server_resource_uuid}{boot_time};
		my $new_server_resource_ram_size      = $an->data->{'server-resources'}{server}{$server_resource_uuid}{ram_total};
		my $new_server_resource_ram_used      = $an->data->{'server-resources'}{server}{$server_resource_uuid}{ram_used};
		my $new_server_resource_swap_size     = $an->data->{'server-resources'}{server}{$server_resource_uuid}{swap_total};
		my $new_server_resource_swap_used     = $an->data->{'server-resources'}{server}{$server_resource_uuid}{swap_used};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "new_server_resource_target_access", value1 => $new_server_resource_target_access, 
			name2 => "new_server_resource_host_name",     value2 => $new_server_resource_host_name, 
			name3 => "new_server_resource_os",            value3 => $new_server_resource_os, 
			name4 => "new_server_resource_boot_time",     value4 => $new_server_resource_boot_time, 
			name5 => "new_server_resource_ram_size",      value5 => $new_server_resource_ram_size, 
			name6 => "new_server_resource_ram_used",      value6 => $new_server_resource_ram_used, 
			name7 => "new_server_resource_swap_size",     value7 => $new_server_resource_swap_size, 
			name8 => "new_server_resource_swap_used",     value8 => $new_server_resource_swap_used, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# We'll reference the target in any alerts below
		my $say_target =  $new_server_resource_target_access;
		   $say_target =~ s/:(\d+)$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "say_target", value1 => $say_target, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (exists $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid})
		{
			# Exists. Changed?
			my $old_server_resource_target_access = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_target_access};
			my $old_server_resource_host_name     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_host_name};
			my $old_server_resource_os            = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_os};
			my $old_server_resource_boot_time     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_boot_time};
			my $old_server_resource_ram_size      = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_size};
			my $old_server_resource_ram_used      = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_used};
			my $old_server_resource_swap_size     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_size};
			my $old_server_resource_swap_used     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_used};
			my $old_server_resource_note          = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_note};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
				name1 => "old_server_resource_target_access", value1 => $old_server_resource_target_access, 
				name2 => "old_server_resource_host_name",     value2 => $old_server_resource_host_name, 
				name3 => "old_server_resource_os",            value3 => $old_server_resource_os, 
				name4 => "old_server_resource_boot_time",     value4 => $old_server_resource_boot_time, 
				name5 => "old_server_resource_ram_size",      value5 => $old_server_resource_ram_size, 
				name6 => "old_server_resource_ram_used",      value6 => $old_server_resource_ram_used, 
				name7 => "old_server_resource_swap_size",     value7 => $old_server_resource_swap_size, 
				name8 => "old_server_resource_swap_used",     value8 => $old_server_resource_swap_used, 
				name9 => "old_server_resource_note",          value9 => $old_server_resource_note, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# We'll set this to '1' if we need to update the DB.
			my $changes = 0;
			
			# If I am here, the server was accessible. So if the 'note' was 'OFFLINE', the server
			# is back now. If it was 'DELETED', we're monitoring it again.
			if ($old_server_resource_note eq "OFFLINE")
			{
				# Yup. This isn't major as it's almost certainly done by the user. We'll mark
				# it as 'warning' though just so that people know we've seen the change.
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0006",
					alert_message_key	=>	"scan_server_resources_message_0016",
					alert_message_variables	=>	{
						host_name		=>	$new_server_resource_host_name,
						target			=>	$new_server_resource_target_access, 
					},
				});
			
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($old_server_resource_note eq "DELETED")
			{
				# Yup. This isn't major as it's almost certainly done by the user. We'll mark
				# it as 'warning' though just so that people know we've seen the change.
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0006",
					alert_message_key	=>	"scan_server_resources_message_0019",
					alert_message_variables	=>	{
						host_name		=>	$new_server_resource_host_name,
						access			=>	$new_server_resource_target_access, 
					},
				});
			
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the IP address/port we reach the server on changed?
			if ($new_server_resource_target_access ne $old_server_resource_target_access)
			{
				# Yup. This isn't major as it's almost certainly done by the user. We'll mark
				# it as 'warning' though just so that people know we've seen the change.
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0008",
					alert_message_key	=>	"scan_server_resources_message_0015",
					alert_message_variables	=>	{
						host_name		=>	$new_server_resource_host_name,
						old_access		=>	$old_server_resource_target_access,
						new_access		=>	$new_server_resource_target_access, 
					},
				});
			
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the host name changed?
			if ($new_server_resource_host_name ne $old_server_resource_host_name)
			{
				# Yup. This isn't major as it's almost certainly done by the user.
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_server_resources_message_0003",
					alert_message_variables	=>	{
						old_host_name		=>	$old_server_resource_host_name,
						new_host_name		=>	$new_server_resource_host_name,
					},
				});
			
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			# Has the OS changed?
			if ($new_server_resource_os ne $old_server_resource_os)
			{
				# Yup. This wsa likely from an OS update.
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_server_resources_message_0004",
					alert_message_variables	=>	{
						old_host_os		=>	$old_server_resource_os,
						new_host_os		=>	$new_server_resource_os,
					},
				});
				
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the server's boot time changed?
			if ($new_server_resource_boot_time ne $old_server_resource_boot_time)
			{
				# It has. Lets see if it was less than 60 seconds change.
				my $report     = 0;
				my $difference = 0;
				if ($new_server_resource_boot_time > $old_server_resource_boot_time)
				{
					$difference = $new_server_resource_boot_time - $old_server_resource_boot_time;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "difference", value1 => $difference, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($old_server_resource_boot_time > $new_server_resource_boot_time)
				{
					$difference = $old_server_resource_boot_time - $new_server_resource_boot_time;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "difference", value1 => $difference, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				else
				{
					# Something is wrong. Just send a generic "It changed" message.
					$report = 1;
				}

				if (($difference) && ($difference > 60))
				{
					# Looks like the guest rebooted.
					$report = 1;
				}
				
				if ($report)
				{
					my $alert_level = "notice";
					my $title_key   = "an_alert_title_0003";
					if ($an->data->{scancore}{servers}{reboots_are_warning})
					{
						$alert_level = "warning";
						$title_key   = "an_alert_title_0004";
					}
					$an->Alert->register_alert({
						alert_level		=>	$alert_level, 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	$title_key,
						alert_message_key	=>	"scan_server_resources_message_0005",
						alert_message_variables	=>	{
							old_boot_time		=>	$old_server_resource_boot_time,
							new_boot_time		=>	$new_server_resource_boot_time,
						},
					});
				}
				
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the RAM size changed?
			if ($new_server_resource_ram_size ne $old_server_resource_ram_size)
			{
				# This is almost always done by an admin, so we'll make it a notice.
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_server_resources_message_0006",
					alert_message_variables	=>	{
						old_ram_size		=>	$an->Readable->bytes_to_hr({'bytes' => $old_server_resource_ram_size }),
						old_ram_size_bytes	=>	$an->Readable->comma($old_server_resource_ram_size),
						new_ram_size		=>	$an->Readable->bytes_to_hr({'bytes' => $new_server_resource_ram_size }),
						new_ram_size_bytes	=>	$an->Readable->comma($new_server_resource_ram_size),
					},
				});
				
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the amount of RAM used changed? This is almost the case.
			if ($new_server_resource_ram_used ne $old_server_resource_ram_used)
			{
				# This is almost always done by an admin, so we'll make it info.
				$an->Alert->register_alert({
					alert_level		=>	"info", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0002",
					alert_message_key	=>	"scan_server_resources_message_0007",
					alert_message_variables	=>	{
						old_ram_used		=>	$an->Readable->bytes_to_hr({'bytes' => $old_server_resource_ram_used }),
						old_ram_used_bytes	=>	$an->Readable->comma($old_server_resource_ram_used),
						new_ram_used		=>	$an->Readable->bytes_to_hr({'bytes' => $new_server_resource_ram_used }),
						new_ram_used_bytes	=>	$an->Readable->comma($new_server_resource_ram_used),
					},
				});
				
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the Swap size changed?
			if ($new_server_resource_swap_size ne $old_server_resource_swap_size)
			{
				# This is almost always done by an admin, so we'll make it a notice.
				$an->Alert->register_alert({
					alert_level		=>	"notice", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0003",
					alert_message_key	=>	"scan_server_resources_message_0008",
					alert_message_variables	=>	{
						old_swap_size		=>	$an->Readable->bytes_to_hr({'bytes' => $old_server_resource_swap_size}),
						old_swap_size_bytes	=>	$an->Readable->comma($old_server_resource_swap_size),
						new_swap_size		=>	$an->Readable->bytes_to_hr({'bytes' => $new_server_resource_swap_size}),
						new_swap_size_bytes	=>	$an->Readable->comma($new_server_resource_swap_size),
					},
				});
				
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Has the amount of Swap used changed? This is almost the case.
			if ($new_server_resource_swap_used ne $old_server_resource_swap_used)
			{
				# This is almost always done by an admin, so we'll make it info.
				$an->Alert->register_alert({
					alert_level		=>	"info", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0002",
					alert_message_key	=>	"scan_server_resources_message_0009",
					alert_message_variables	=>	{
						old_swap_used		=>	$an->Readable->bytes_to_hr({'bytes' => $old_server_resource_swap_used }),
						old_swap_used_bytes	=>	$an->Readable->comma($old_server_resource_swap_size),
						new_swap_used		=>	$an->Readable->bytes_to_hr({'bytes' => $new_server_resource_swap_used }),
						new_swap_used_bytes	=>	$an->Readable->comma($new_server_resource_swap_size),
					},
				});
				
				$changes = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "changes", value1 => $changes, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now, if the available RAM drops below 20%, send an alert. If it is above 30%, clear
			# it in case it was lower before. For swap, we'll throw an alert if less than 90% is
			# used because any swap use is a good sign that more RAM is needed. We don't throw at
			# >0% because sometimes something will use a bit of swap for whatever reason.
			my $free_ram_percent  = 100 - ($an->Math->round({number => (100 * ($new_server_resource_ram_used / $new_server_resource_ram_size))}));
			my $free_swap_percent = 100 - ($an->Math->round({number => (100 * ($new_server_resource_swap_used / $new_server_resource_swap_size))}));
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "free_ram_percent",                             value1 => $free_ram_percent, 
				name2 => "scan-server-resources::free_ram_low_warning",  value2 => $an->data->{'scan-server-resources'}{free_ram_low_warning}, 
				name3 => "scan-server-resources::free_ram_low_clear",    value3 => $an->data->{'scan-server-resources'}{free_ram_low_clear}, 
				name4 => "free_swap_percent",                            value4 => $free_swap_percent, 
				name5 => "scan-server-resources::free_swap_low_warning", value5 => $an->data->{'scan-server-resources'}{free_swap_low_warning}, 
				name6 => "scan-server-resources::free_swap_low_clear",   value6 => $an->data->{'scan-server-resources'}{free_swap_low_clear}, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Check RAM
			if ($free_ram_percent < $an->data->{'scan-server-resources'}{free_ram_low_warning})
			{
				# Running low. Have we seen this before?
				my $set = $an->Alert->check_alert_sent({
					type			=>	"warning",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$server_resource_uuid:free_ram",
					alert_name		=>	"free_ram_low",
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
				
				# If set, alert the user.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "set", value1 => $set, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($set)
				{
					# This is the first time we've dropped this low, send an alert.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_server_resources_message_0010",
						alert_message_variables	=>	{
							server_host_name	=>	$new_server_resource_host_name,
							low_warning_percent	=>	$an->data->{'scan-server-resources'}{free_ram_low_warning},
							free_percent		=>	$free_ram_percent,
						},
					});
				}
			}
			elsif ($free_ram_percent > $an->data->{'scan-server-resources'}{free_ram_low_clear})
			{
				# Clear any existing warning.
				my $clear = $an->Alert->check_alert_sent({
					type			=>	"clear",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$server_resource_uuid:free_ram",
					alert_name		=>	"free_ram_low",
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
				
				# If set, alert the user.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "clear", value1 => $clear, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($clear)
				{
					# This is the first time we climbed. Send an alert and then register the 
					# entry in the database's 'temperature' table.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0006",
						alert_message_key	=>	"scan_server_resources_message_0011",
						alert_message_variables	=>	{
							server_host_name	=>	$new_server_resource_host_name,
							low_warning_clear	=>	$an->data->{'scan-server-resources'}{free_ram_low_clear},
							free_percent		=>	$free_ram_percent,
						},
					});
				}
			}
			
			# Check Swap
			if ($free_swap_percent < $an->data->{'scan-server-resources'}{free_swap_low_warning})
			{
				# Running low. Have we seen this before?
				my $set = $an->Alert->check_alert_sent({
					type			=>	"warning",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$server_resource_uuid:free_swap",
					alert_name		=>	"free_swap_low",
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
				
				# If set, alert the user.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "set", value1 => $set, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($set)
				{
					# This is the first time we've dropped this low, send an alert.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_server_resources_message_0012",
						alert_message_variables	=>	{
							server_host_name	=>	$new_server_resource_host_name,
							low_warning_percent	=>	$an->data->{'scan-server-resources'}{free_swap_low_warning},
							free_percent		=>	$free_swap_percent,
						},
					});
				}
			}
			elsif ($free_swap_percent > $an->data->{'scan-server-resources'}{free_swap_low_clear})
			{
				# Clear any existing warning.
				my $clear = $an->Alert->check_alert_sent({
					type			=>	"clear",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$server_resource_uuid:free_swap",
					alert_name		=>	"free_swap_low",
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
				
				# If set, alert the user.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "clear", value1 => $clear, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($clear)
				{
					# This is the first time we climbed. Send an alert and then register the 
					# entry in the database's 'temperature' table.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0006",
						alert_message_key	=>	"scan_server_resources_message_0013",
						alert_message_variables	=>	{
							server_host_name	=>	$new_server_resource_host_name,
							low_warning_clear	=>	$an->data->{'scan-server-resources'}{free_swap_low_clear},
							free_percent		=>	$free_swap_percent,
						},
					});
				}
			}
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "changes", value1 => $changes, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($changes)
			{
				# It has changed, update it.
				my $query = "
UPDATE 
    server_resources 
SET
    server_resource_target_access = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_target_access).", 
    server_resource_host_name     = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_host_name).", 
    server_resource_os            = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_os).", 
    server_resource_boot_time     = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_boot_time).", 
    server_resource_ram_size      = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_ram_size).", 
    server_resource_ram_used      = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_ram_used).", 
    server_resource_swap_size     = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_swap_size).", 
    server_resource_swap_used     = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_swap_used).", 
    server_resource_note          = 'ONLINE', 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_uuid          = ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid)."
;
";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
			
			# Now check to see if any disks changed or were added.
			foreach my $server_resource_disk_mount_point (sort {$a cmp $b} keys %{$an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}})
			{
				my $new_server_resource_disk_filesystem = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{filesystem};
				my $new_server_resource_disk_options    = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{options};
				my $new_server_resource_disk_size       = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{total};
				my $new_server_resource_disk_used       = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{used};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
					name1 => "server_resource_disk_mount_point",    value1 => $server_resource_disk_mount_point, 
					name2 => "new_server_resource_disk_filesystem", value2 => $new_server_resource_disk_filesystem, 
					name3 => "new_server_resource_disk_options",    value3 => $new_server_resource_disk_options, 
					name4 => "new_server_resource_disk_size",       value4 => $new_server_resource_disk_size, 
					name5 => "new_server_resource_disk_used",       value5 => $new_server_resource_disk_used, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $changes                = 0;
				my $new_free_space         = $new_server_resource_disk_size - $new_server_resource_disk_used;
				my $new_say_free           = $an->Readable->bytes_to_hr({'bytes' => $new_free_space});
				my $new_say_size           = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_disk_size});
				my $new_say_used           = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_disk_used});
				my $new_free_space_percent = 100 - ($an->Math->round({number => (100 * ($new_server_resource_disk_used / $new_server_resource_disk_size))}));
				$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
					name1 => "new_free_space",         value1 => $new_free_space, 
					name2 => "new_say_free",           value2 => $new_say_free, 
					name3 => "new_say_size",           value3 => $new_say_size, 
					name4 => "new_say_used",           value4 => $new_say_used, 
					name5 => "new_free_space_percent", value5 => $new_free_space_percent, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if (exists $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_uuid})
				{
					# Check for updates
					my $server_resource_disk_uuid           = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_uuid};
					my $old_server_resource_disk_filesystem = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_filesystem};
					my $old_server_resource_disk_options    = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_options};
					my $old_server_resource_disk_size       = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_size};
					my $old_server_resource_disk_used       = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_used};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
						name1 => "server_resource_disk_uuid",           value1 => $server_resource_disk_uuid, 
						name2 => "old_server_resource_disk_filesystem", value2 => $old_server_resource_disk_filesystem, 
						name3 => "old_server_resource_disk_options",    value3 => $old_server_resource_disk_options, 
						name4 => "old_server_resource_disk_size",       value4 => $old_server_resource_disk_size, 
						name5 => "old_server_resource_disk_used",       value5 => $old_server_resource_disk_used, 
					}, file => $THIS_FILE, line => __LINE__});
					
					my $old_say_size = $an->Readable->bytes_to_hr({'bytes' => $old_server_resource_disk_size});
					my $old_say_used = $an->Readable->bytes_to_hr({'bytes' => $old_server_resource_disk_used});
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "old_say_size", value1 => $old_say_size, 
						name2 => "old_say_used", value2 => $old_say_used, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Has the filesystem changed? This should rarely happen unless the 
					# disk was reformatted, which a user would be aware of.
					if ($new_server_resource_disk_filesystem ne $old_server_resource_disk_filesystem)
					{
						# It changed. Set a warning-level 'important' alert, just to 
						# show them we saw the change.
						$an->Alert->register_alert({
							alert_level		=>	"warning", 
							alert_sort		=>	$an->data->{sys}{alert_sort}++,
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	"an_alert_title_0008",
							alert_message_key	=>	"scan_server_resources_message_0024",
							alert_message_variables	=>	{
								host_name		=>	$new_server_resource_host_name, 
								mount_point		=>	$server_resource_disk_mount_point,
								target			=>	$say_target,
								old_filesystem		=>	$old_server_resource_disk_filesystem,
								new_filesystem		=>	$new_server_resource_disk_filesystem,
							},
						});
						
						$changes = 1;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "changes", value1 => $changes, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					
					# Check to see if the mount options have changed.
					if ($new_server_resource_disk_options ne $old_server_resource_disk_options)
					{
						# This is a warning because if could be a sign of an FS 
						# remounting read-only. If the old option was 'DELETED',
						# then the disk just came back.
						my $title_key   = "an_alert_title_0004";
						my $message_key = "scan_server_resources_message_0025";
						if ($old_server_resource_disk_options eq "DELETED")
						{
							$title_key   = "an_alert_title_0006";
							$message_key = "scan_server_resources_message_0033";
							
							# Clear the old warning.
							my $clear = $an->Alert->check_alert_sent({
								type			=>	"clear",
								alert_sent_by		=>	$THIS_FILE,
								alert_record_locator	=>	"$server_resource_disk_uuid:deleted_disk",
								alert_name		=>	"deleted_disk",
								modified_date		=>	$an->data->{sys}{db_timestamp},
							});
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "clear", value1 => $clear, 
							}, file => $THIS_FILE, line => __LINE__});
						}
						$an->Alert->register_alert({
							alert_level		=>	"warning", 
							alert_sort		=>	$an->data->{sys}{alert_sort}++,
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	$title_key,
							alert_message_key	=>	$message_key,
							alert_message_variables	=>	{
								host_name		=>	$new_server_resource_host_name, 
								mount_point		=>	$server_resource_disk_mount_point,
								target			=>	$say_target,
								old_options		=>	$old_server_resource_disk_options,
								new_options		=>	$new_server_resource_disk_options,
							},
						});
						
						$changes = 1;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "changes", value1 => $changes, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					
					# Has the overall disk size changed?
					if ($new_server_resource_disk_size ne $old_server_resource_disk_size)
					{
						# Did it grow or shrink? The default message is a generic "it
						# changed" alert. If we see a grow or shrink, we'll change 
						# the title to 'Important' instead of 'Warning'.
						my $title_key   = "an_alert_title_0004";
						my $message_key = "scan_server_resources_message_0026";
						if ($new_server_resource_disk_size > $old_server_resource_disk_size)
						{
							# It grew
							$title_key   = "an_alert_title_0008";
							$message_key = "scan_server_resources_message_0027";
						}
						elsif ($new_server_resource_disk_size < $old_server_resource_disk_size)
						{
							# It shrunk
							$title_key   = "an_alert_title_0008";
							$message_key = "scan_server_resources_message_0028";
						}
						$an->Alert->register_alert({
							alert_level		=>	"warning", 
							alert_sort		=>	$an->data->{sys}{alert_sort}++,
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	$title_key,
							alert_message_key	=>	$message_key,
							alert_message_variables	=>	{
								host_name		=>	$new_server_resource_host_name, 
								mount_point		=>	$server_resource_disk_mount_point,
								target			=>	$say_target,
								old_size		=>	$an->Readable->comma($old_server_resource_disk_size),
								old_size_hr		=>	$old_say_size,
								new_size		=>	$an->Readable->comma($new_server_resource_disk_size),
								new_size_hr		=>	$new_say_size,
							},
						});
						
						$changes = 1;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "changes", value1 => $changes, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					
					# The space used will almost always change. So by default, it's an 
					# info-level alert. However, we will check to see if the free space
					# shrunk small enough to trigger an alert, or grew enough to clear an
					# old low-disk alert.
					if ($new_server_resource_disk_used ne $old_server_resource_disk_used)
					{
						# Changed. This will almost always be the case, so it's info level.
						my $alert_level = "info";
						my $title_key   = "an_alert_title_0002";
						my $message_key = "scan_server_resources_message_0029";
						if ($new_free_space_percent < $an->data->{'scan-server-resources'}{free_disk_space_low_warning})
						{
							# It's low, throw a low-disk warning.
							my $set = $an->Alert->check_alert_sent({
								type			=>	"warning",
								alert_sent_by		=>	$THIS_FILE,
								alert_record_locator	=>	"$server_resource_disk_uuid:low_disk_space",
								alert_name		=>	"low_disk_space",
								modified_date		=>	$an->data->{sys}{db_timestamp},
							});
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "set", value1 => $set, 
							}, file => $THIS_FILE, line => __LINE__});
							
							if ($set)
							{
								# Throw a warning
								$alert_level = "warning";
								$title_key   = "an_alert_title_0004";
								$message_key = "scan_server_resources_message_0030";
							}
						}
						elsif ($new_free_space_percent > $an->data->{'scan-server-resources'}{free_disk_space_low_clear})
						{
							# It's high enough to clear a low-disk warning.
							my $clear = $an->Alert->check_alert_sent({
								type			=>	"clear",
								alert_sent_by		=>	$THIS_FILE,
								alert_record_locator	=>	"$server_resource_disk_uuid:low_disk_space",
								alert_name		=>	"low_disk_space",
								modified_date		=>	$an->data->{sys}{db_timestamp},
							});
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "clear", value1 => $clear, 
							}, file => $THIS_FILE, line => __LINE__});
							
							if ($clear)
							{
								# Clear the warning
								$alert_level = "warning";
								$title_key   = "an_alert_title_0006";
								$message_key = "scan_server_resources_message_0031";
							}
						}
						$an->Alert->register_alert({
							alert_level		=>	$alert_level, 
							alert_sort		=>	$an->data->{sys}{alert_sort}++,
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	$title_key,
							alert_message_key	=>	$message_key,
							alert_message_variables	=>	{
								host_name		=>	$new_server_resource_host_name, 
								mount_point		=>	$server_resource_disk_mount_point,
								target			=>	$say_target,
								old_used		=>	$an->Readable->comma($old_server_resource_disk_used),
								old_used_hr		=>	$old_say_used,
								new_used		=>	$an->Readable->comma($new_server_resource_disk_used),
								new_used_hr		=>	$new_say_used,
							},
						});
						
						$changes = 1;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "changes", value1 => $changes, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					
					# Save changes?
					if ($changes)
					{
						# Yup.
						my $query = "
UPDATE 
    server_resource_disks 
SET
    server_resource_disk_server_resource_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    server_resource_disk_host_uuid            = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    server_resource_disk_mount_point          = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_mount_point).", 
    server_resource_disk_filesystem           = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_filesystem).", 
    server_resource_disk_options              = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_options).", 
    server_resource_disk_size                 = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_size).", 
    server_resource_disk_used                 = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_used).", 
    modified_date                              = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_disk_uuid                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_uuid)."
;
";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
					}
				}
				else
				{
					# New disk, save it.
					save_new_disk($an, $new_server_resource_host_name, $say_target, $server_resource_uuid, $server_resource_disk_mount_point);
				}
				
				# Delete this disk from SQL hash.
				delete $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point};
			}
			
			# Check to see if any disks were deleted.
			foreach my $server_resource_disk_mount_point (sort {$a cmp $b} keys %{$an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}})
			{
				# Deleted disk, update the filesystem 'options' to 'DELETED'.
				my $server_resource_disk_uuid = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_disk_mount_point}{$server_resource_disk_mount_point}{server_resource_disk_uuid};
				my $set = $an->Alert->check_alert_sent({
					type			=>	"warning",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$server_resource_disk_uuid:deleted_disk",
					alert_name		=>	"deleted_disk",
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "set", value1 => $set, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($set)
				{
					# Throw a warning and updated the mount options to be 'DELETED'.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_server_resources_message_0013",
						alert_message_variables	=>	{
							host_name		=>	$new_server_resource_host_name,
							mount_point		=>	$server_resource_disk_mount_point,
						},
					});
					
					my $query = "
UPDATE 
    server_resource_disks 
SET
    server_resource_disk_options = 'DELETED', 
    modified_date                 = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_disk_uuid    = ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_uuid)."
;
";
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query, 
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
				}
			}
			
			# Now check CPUs.
			foreach my $server_resource_cpu_number (sort {$a cmp $b} keys %{$an->data->{'server-resources'}{server}{$server_resource_uuid}{cpu}})
			{
				my $server_resource_cpu_uuid     = $an->Get->uuid();
				my $new_server_resource_cpu_load = $an->data->{'server-resources'}{server}{$server_resource_uuid}{cpu}{$server_resource_cpu_number}{load};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "server_resource_cpu_uuid",     value1 => $server_resource_cpu_uuid, 
					name2 => "server_resource_cpu_number",   value2 => $server_resource_cpu_number, 
					name3 => "new_server_resource_cpu_load", value3 => $new_server_resource_cpu_load, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $changes = 0;
				
				# Do we know about this CPU?
				if (exists $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number}{server_resource_cpu_uuid})
				{
					# Check for updates
					my $server_resource_cpu_uuid     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number}{server_resource_cpu_uuid};
					my $old_server_resource_cpu_load = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number}{server_resource_cpu_load};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "server_resource_cpu_uuid",     value1 => $server_resource_cpu_uuid, 
						name2 => "old_server_resource_cpu_load", value2 => $old_server_resource_cpu_load, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Has the load on the CPU changed? This is usually "yes" and not a concern.
					if ($new_server_resource_cpu_load ne $old_server_resource_cpu_load)
					{
						my $alert_level = "info";
						my $title_key   = "an_alert_title_0002";
						my $message_key = "scan_server_resources_message_0034";
						if ($old_server_resource_cpu_load eq "DELETED")
						{
							$alert_level = "warning";
							$title_key   = "an_alert_title_0006";
							$message_key = "scan_server_resources_message_0035";
							
							# Clear the old warning.
							my $clear = $an->Alert->check_alert_sent({
								type			=>	"clear",
								alert_sent_by		=>	$THIS_FILE,
								alert_record_locator	=>	"$server_resource_cpu_uuid:deleted_cpu",
								alert_name		=>	"deleted_cpu",
								modified_date		=>	$an->data->{sys}{db_timestamp},
							});
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "clear", value1 => $clear, 
							}, file => $THIS_FILE, line => __LINE__});
						}
						$an->Alert->register_alert({
							alert_level		=>	$alert_level, 
							alert_sort		=>	$an->data->{sys}{alert_sort}++,
							alert_agent_name	=>	$THIS_FILE,
							alert_title_key		=>	$title_key,
							alert_message_key	=>	$message_key,
							alert_message_variables	=>	{
								number			=>	$server_resource_cpu_number, 
								target			=>	$say_target, 
								host_name		=>	$new_server_resource_host_name, 
								old_load		=>	$old_server_resource_cpu_load,
								new_load		=>	$new_server_resource_cpu_load,
							},
						});
						
						$changes = 1;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "changes", value1 => $changes, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					
					# Save changes?
					if ($changes)
					{
						# Yup.
						my $query = "
UPDATE 
    server_resource_cpus 
SET
    server_resource_cpu_server_resource_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    server_resource_cpu_host_uuid            = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    server_resource_cpu_number               = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_number).", 
    server_resource_cpu_load                 = ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_cpu_load).", 
    modified_date                             = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_cpu_uuid                 = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_uuid)."
;
";
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query, 
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{sys}{sql}}, $query;
					}
				}
				else
				{
					# New cpu, save it.
					save_new_cpu($an, $new_server_resource_host_name, $say_target, $server_resource_uuid, $server_resource_cpu_number);
				}
				
				# Delete this cpu from SQL hash.
				delete $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number};
			}
			
			# Check to see if any cpus were deleted.
			foreach my $server_resource_cpu_number (sort {$a cmp $b} keys %{$an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_cpu_number}})
			{
				# Deleted cpu, update the filesystem 'options' to 'DELETED'.
				my $server_resource_cpu_uuid = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_cpu_number}{$server_resource_cpu_number}{server_resource_cpu_uuid};
				my $set = $an->Alert->check_alert_sent({
					type			=>	"warning",
					alert_sent_by		=>	$THIS_FILE,
					alert_record_locator	=>	"$server_resource_cpu_uuid:deleted_cpu",
					alert_name		=>	"deleted_cpu",
					modified_date		=>	$an->data->{sys}{db_timestamp},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "set", value1 => $set, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($set)
				{
					# Throw a warning and updated the load to be 'DELETED'.
					$an->Alert->register_alert({
						alert_level		=>	"warning", 
						alert_sort		=>	$an->data->{sys}{alert_sort}++,
						alert_agent_name	=>	$THIS_FILE,
						alert_title_key		=>	"an_alert_title_0004",
						alert_message_key	=>	"scan_server_resources_message_0036",
						alert_message_variables	=>	{
							host_name		=>	$new_server_resource_host_name,
							target			=>	$say_target,
							cpu_number		=>	$server_resource_cpu_number,
						},
					});
					
					my $query = "
UPDATE 
    server_resource_cpus 
SET
    server_resource_cpu_load = 'DELETED', 
    modified_date             = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_cpu_uuid = ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_uuid)."
;
";
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query, 
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{sys}{sql}}, $query;
				}
			}
			
			delete $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid};
		}
		else
		{
			### NOTE: We DO NOT create a UUID! It was generated by the target server.
			# New record, INSERT it.
			my $query = "
INSERT INTO 
    server_resources 
(
    server_resource_uuid, 
    server_resource_host_uuid, 
    server_resource_target_access, 
    server_resource_host_name, 
    server_resource_os, 
    server_resource_boot_time, 
    server_resource_ram_size, 
    server_resource_ram_used, 
    server_resource_swap_size, 
    server_resource_swap_used, 
    server_resource_note, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_target_access).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_os).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_boot_time).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_ram_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_ram_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_swap_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_swap_used).", 
    'ONLINE', 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query, 
			}, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{sql}}, $query;
			
			# This isn't really a warning, but we register it as such to let people know the 
			# server is now being monitored, as per the new config.
			my $say_ram_size   = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_ram_size});
			my $say_ram_used   = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_ram_used});
			my $say_swap_size  = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_swap_size});
			my $say_swap_used  = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_swap_used});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "say_ram_size",  value1 => $say_ram_size, 
				name2 => "say_ram_used",  value2 => $say_ram_used, 
				name3 => "say_swap_size", value3 => $say_swap_size, 
				name4 => "say_swap_used", value4 => $say_swap_used, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_sort		=>	$an->data->{sys}{alert_sort}++,
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0008",
				alert_message_key	=>	"scan_server_resources_message_0014",
				alert_message_variables	=>	{
					server_resource_host_name	=>	$new_server_resource_host_name, 
					server_resource_target_access	=>	$new_server_resource_target_access,
					server_resource_uuid		=>	$server_resource_uuid, 
					server_resource_os		=>	$new_server_resource_os, 
					server_resource_boot_time	=>	$new_server_resource_boot_time,
					server_resource_ram_size	=>	$say_ram_size, 
					server_resource_ram_used	=>	$say_ram_used, 
					server_resource_swap_size	=>	$say_swap_size, 
					server_resource_swap_used	=>	$say_swap_used, 
				},
			});
			
			# If the server wasn't previously accessible, clear the old alert.
			my $clear = $an->Alert->check_alert_sent({
				type			=>	"clear",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	"$new_server_resource_target_access:no_access",
				alert_name		=>	"no_access",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "clear", value1 => $clear, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Now record the disk(s).
			foreach my $server_resource_disk_mount_point (sort {$a cmp $b} keys %{$an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}})
			{
				save_new_disk($an, $new_server_resource_host_name, $say_target, $server_resource_uuid, $server_resource_disk_mount_point);
			}
			
			# And record the CPUs.
			foreach my $server_resource_cpu_number (sort {$a cmp $b} keys %{$an->data->{'server-resources'}{server}{$server_resource_uuid}{cpu}})
			{
				save_new_cpu($an, $new_server_resource_host_name, $say_target, $server_resource_uuid, $server_resource_cpu_number);
			}
			delete $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid};
		}
	}
	
	# Now, any servers we read from the DB that remain are either offline, or have been removed from the
	# config.
	foreach my $server_resource_uuid (keys %{$an->data->{sql}{server_resources}{server_resource_uuid}})
	{
		# Exists. Changed?
		my $old_server_resource_target_access = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_target_access};
		my $old_server_resource_host_name     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_host_name};
		my $old_server_resource_os            = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_os};
		my $old_server_resource_boot_time     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_boot_time};
		my $old_server_resource_ram_size      = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_size};
		my $old_server_resource_ram_used      = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_ram_used};
		my $old_server_resource_swap_size     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_size};
		my $old_server_resource_swap_used     = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_swap_used};
		my $old_server_resource_note          = $an->data->{sql}{server_resources}{server_resource_uuid}{$server_resource_uuid}{server_resource_note};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0009", message_variables => {
			name1 => "old_server_resource_target_access", value1 => $old_server_resource_target_access, 
			name2 => "old_server_resource_host_name",     value2 => $old_server_resource_host_name, 
			name3 => "old_server_resource_os",            value3 => $old_server_resource_os, 
			name4 => "old_server_resource_boot_time",     value4 => $old_server_resource_boot_time, 
			name5 => "old_server_resource_ram_size",      value5 => $old_server_resource_ram_size, 
			name6 => "old_server_resource_ram_used",      value6 => $old_server_resource_ram_used, 
			name7 => "old_server_resource_swap_size",     value7 => $old_server_resource_swap_size, 
			name8 => "old_server_resource_swap_used",     value8 => $old_server_resource_swap_used, 
			name9 => "old_server_resource_note",          value9 => $old_server_resource_note, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# If I know this server, update it's note to OFFLINE. 
		if (exists $an->data->{'server-resources'}{offline}{$old_server_resource_target_access})
		{
			# The server is in our configuration, so it must have gone offline. Is this the first
			# time we've seen it go offline?
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "old_server_resource_note", value1 => $old_server_resource_note, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($old_server_resource_note ne "OFFLINE")
			{
				# Yup.
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0004",
					alert_message_key	=>	"scan_server_resources_message_0017",
					alert_message_variables	=>	{
						access			=>	$old_server_resource_target_access, 
						host_name		=>	$old_server_resource_host_name,
					},
				});
				
				my $query = "
UPDATE 
    server_resources 
SET
    server_resource_note = 'OFFLINE', 
    modified_date         = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_uuid  = ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid)."
;
";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
			
			# Delete the key so that we know we've processed this offline server.
			delete $an->data->{'server-resources'}{offline}{$old_server_resource_target_access};
		}
		else
		{
			# This server is no longer being monitored. Is this the first time that's happened?
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "old_server_resource_note", value1 => $old_server_resource_note, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($old_server_resource_note ne "DELETED")
			{
				# Yup.
				$an->Alert->register_alert({
					alert_level		=>	"warning", 
					alert_sort		=>	$an->data->{sys}{alert_sort}++,
					alert_agent_name	=>	$THIS_FILE,
					alert_title_key		=>	"an_alert_title_0004",
					alert_message_key	=>	"scan_server_resources_message_0018",
					alert_message_variables	=>	{
						access			=>	$old_server_resource_target_access, 
						host_name		=>	$old_server_resource_host_name,
					},
				});
				
				my $query = "
UPDATE 
    server_resources 
SET
    server_resource_note = 'DELETED', 
    modified_date         = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})." 
WHERE 
    server_resource_uuid  = ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid)."
;
";
				$query =~ s/'NULL'/NULL/g;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				push @{$an->data->{sys}{sql}}, $query;
			}
		}
	}
	
	# Finally, see if we marked any servers as offline that also weren't in the database yet. This might
	# be a sign of a user-configuration mistake (or the new server just isn't on).
	foreach my $server_resource_target_access (keys %{$an->data->{'server-resources'}{offline}})
	{
		# Only send the alert once.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "server_resource_target_access", value1 => $server_resource_target_access, 
		}, file => $THIS_FILE, line => __LINE__});
		my $set = $an->Alert->check_alert_sent({
			type			=>	"warning",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	"$server_resource_target_access:no_access",
			alert_name		=>	"no_access",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		
		# If set, alert the user.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "set", value1 => $set, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($set)
		{
			# This is the first time we've dropped this low, send an alert.
			my $say_host = $server_resource_target_access;
			my $say_port = $an->data->{'scan-server-resources'}{'an-ssrw-port'};
			my $say_id   = ($an->data->{'server-resources'}{offline}{$server_resource_target_access} =~ /id:(.*)$/)[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "say_host", value1 => $say_host, 
				name2 => "say_port", value2 => $say_port, 
				name3 => "say_id",   value3 => $say_id, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($say_host =~ /^(.*?):(\d+)$/)
			{
				$say_host = $1;
				$say_port = $2;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "say_host", value1 => $say_host, 
					name2 => "say_port", value2 => $say_port, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_sort		=>	$an->data->{sys}{alert_sort}++,
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0004",
				alert_message_key	=>	"scan_server_resources_message_0020",
				alert_message_variables	=>	{
					host			=>	$say_host,
					port			=>	$say_port,
					id			=>	$say_id,
				},
			});
		}
	}
	
	# Now commit the changes.
	$an->DB->commit_sql({source => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This saves a new CPU
sub save_new_cpu
{
	my ($an, $new_server_resource_host_name, $say_target, $server_resource_uuid, $server_resource_cpu_number) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "save_new_cpu" }, message_key => "an_variables_0004", message_variables => { 
		name1 => "new_server_resource_host_name", value1 => $new_server_resource_host_name, 
		name2 => "say_target",                    value2 => $say_target, 
		name3 => "server_resource_uuid",          value3 => $server_resource_uuid, 
		name4 => "server_resource_cpu_number",   value4 => $server_resource_cpu_number, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $server_resource_cpu_uuid     = $an->Get->uuid();
	my $new_server_resource_cpu_load = $an->data->{'server-resources'}{server}{$server_resource_uuid}{cpu}{$server_resource_cpu_number}{load};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "server_resource_cpu_uuid",     value1 => $server_resource_cpu_uuid, 
		name2 => "server_resource_cpu_number",   value2 => $server_resource_cpu_number, 
		name3 => "new_server_resource_cpu_load", value3 => $new_server_resource_cpu_load, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Assemble the INSERT
	my $query = "
INSERT INTO 
    server_resource_cpus 
(
    server_resource_cpu_uuid, 
    server_resource_cpu_server_resource_uuid,
    server_resource_cpu_host_uuid,
    server_resource_cpu_number,
    server_resource_cpu_load,
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_cpu_number).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_cpu_load).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
	$query =~ s/'NULL'/NULL/g;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	push @{$an->data->{sys}{sql}}, $query;
	
	$an->Alert->register_alert({
		alert_level		=>	"warning", 
		alert_sort		=>	$an->data->{sys}{alert_sort}++,
		alert_agent_name	=>	$THIS_FILE,
		alert_title_key		=>	"an_alert_title_0008",
		alert_message_key	=>	"scan_server_resources_message_0022",
		alert_message_variables	=>	{
			host_name		=>	$new_server_resource_host_name, 
			target			=>	$say_target,
			number			=>	$server_resource_cpu_number,
			load			=>	$new_server_resource_cpu_load,
		},
	});
	
	return(0);
}

# This saves a new disk, sending an alert if the free space is already low.
sub save_new_disk
{
	my ($an, $new_server_resource_host_name, $say_target, $server_resource_uuid, $server_resource_disk_mount_point) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "save_new_disk" }, message_key => "an_variables_0004", message_variables => { 
		name1 => "new_server_resource_host_name",     value1 => $new_server_resource_host_name, 
		name2 => "say_target",                        value2 => $say_target, 
		name3 => "server_resource_uuid",              value3 => $server_resource_uuid, 
		name4 => "server_resource_disk_mount_point", value4 => $server_resource_disk_mount_point, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $server_resource_disk_uuid           = $an->Get->uuid();
	my $new_server_resource_disk_filesystem = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{filesystem};
	my $new_server_resource_disk_options    = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{options};
	my $new_server_resource_disk_size       = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{total};
	my $new_server_resource_disk_used       = $an->data->{'server-resources'}{server}{$server_resource_uuid}{disk}{$server_resource_disk_mount_point}{used};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
		name1 => "server_resource_disk_uuid",           value1 => $server_resource_disk_uuid, 
		name2 => "new_server_resource_disk_filesystem", value2 => $new_server_resource_disk_filesystem, 
		name3 => "new_server_resource_disk_options",    value3 => $new_server_resource_disk_options, 
		name4 => "new_server_resource_disk_size",       value4 => $new_server_resource_disk_size, 
		name5 => "new_server_resource_disk_used",       value5 => $new_server_resource_disk_used, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Assemble the INSERT
	my $query = "
INSERT INTO 
    server_resource_disks 
(
    server_resource_disk_uuid, 
    server_resource_disk_server_resource_uuid,
    server_resource_disk_host_uuid,
    server_resource_disk_mount_point,
    server_resource_disk_filesystem,
    server_resource_disk_options,
    server_resource_disk_size,
    server_resource_disk_used,
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_resource_disk_mount_point).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_filesystem).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_options).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_size).", 
    ".$an->data->{sys}{use_db_fh}->quote($new_server_resource_disk_used).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);";
	$query =~ s/'NULL'/NULL/g;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	push @{$an->data->{sys}{sql}}, $query;
	
	my $free_space         = $new_server_resource_disk_size - $new_server_resource_disk_used;
	my $say_free           = $an->Readable->bytes_to_hr({'bytes' => $free_space});
	my $say_size           = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_disk_size});
	my $say_used           = $an->Readable->bytes_to_hr({'bytes' => $new_server_resource_disk_used});
	my $free_space_percent = 100 - ($an->Math->round({number => (100 * ($new_server_resource_disk_used / $new_server_resource_disk_size))}));
	$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
		name1 => "free_space",         value1 => $free_space, 
		name2 => "say_free",           value2 => $say_free, 
		name3 => "say_size",           value3 => $say_size, 
		name4 => "say_used",           value4 => $say_used, 
		name5 => "free_space_percent", value5 => $free_space_percent, 
	}, file => $THIS_FILE, line => __LINE__});
	$an->Alert->register_alert({
		alert_level		=>	"warning", 
		alert_sort		=>	$an->data->{sys}{alert_sort}++,
		alert_agent_name	=>	$THIS_FILE,
		alert_title_key		=>	"an_alert_title_0008",
		alert_message_key	=>	"scan_server_resources_message_0021",
		alert_message_variables	=>	{
			host_name		=>	$new_server_resource_host_name, 
			target			=>	$say_target,
			mount_point		=>	$server_resource_disk_mount_point,
			filesystem		=>	$new_server_resource_disk_filesystem,
			options			=>	$new_server_resource_disk_options,
			size			=>	$say_size,
			used			=>	$say_used,
			percent_free		=>	$free_space_percent,
		},
	});
	
	# If this disk is already low on space, throw an warning.
	if ($free_space_percent < $an->data->{'scan-server-resources'}{free_disk_space_low_warning})
	{
		# 'set' will always be '1' because this is new, but it will prevent 
		# the next scan repeating the alarm.
		my $set = $an->Alert->check_alert_sent({
			type			=>	"warning",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	"$server_resource_disk_uuid:low_disk_space",
			alert_name		=>	"low_disk_space",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "set", value1 => $set, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->Alert->register_alert({
			alert_level		=>	"warning", 
			alert_sort		=>	$an->data->{sys}{alert_sort}++,
			alert_agent_name	=>	$THIS_FILE,
			alert_title_key		=>	"an_alert_title_0004",
			alert_message_key	=>	"scan_server_resources_message_0023",
			alert_message_variables	=>	{
				mount_point		=>	$server_resource_disk_mount_point,
				host_name		=>	$new_server_resource_host_name,
				target			=>	$say_target,
				free_space		=>	$say_free,
				free_space_percent	=>	$free_space_percent,
			},
		});
	}

	return(0);
}

# This will archive stuff in the 'history' schema, if needed.
sub archive_if_needed
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "archive_if_needed" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If the 'trigger' is '0', archiving is disabled.
	if (not $an->data->{scancore}{archive}{trigger})
	{
		return(1);
	}
	
	### NOTE: If a ScanCore db server was offline when an archive ran, when it returns, it's records will
	###       sync back, triggering a sooner-than-expected subsequent archive. This shouldn't happen 
	###       often, and the complexity of tracking archive dates is such that we'll not try to account
	###       for these cases. 
	### TODO: What we can do later is, when we write the restore stuff, build in a dedupe function.
	
	### Process:
	# 1. Count the records in history for each table, restricting the results to those from this host 
	#    (save for special tables like 'server') and if the number of records is greater than 
	#    'scancore::archive::trigger', start an archive.
	# 2. Set/update the 'archive_date' state.
	# 3. Lock the database.
	# 4. Select 'modified_date' from history.foo, offset by 
	#    ('scancore::archive::trigger' - 'scancore::archive::count').
	# 5. Make sure the 'scancore::archive::directory' exists, creating it if needed.
	# 6. Select all records older that the 'modified_date', write them to a file and then DELETE those
	#    records from the database.
	
	# Update the archive path, if set by a user. Also verify that there are sane archive values.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "path::scancore_archive",       value1 => $an->data->{path}{scancore_archive}, 
		name2 => "scancore::archive::directory", value2 => $an->data->{scancore}{archive}{directory}, 
		name3 => "scancore::archive::trigger",   value3 => $an->data->{scancore}{archive}{trigger}, 
		name4 => "scancore::archive::count",     value4 => $an->data->{scancore}{archive}{count}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{archive}{directory} =~ /\/.*/)
	{
		$an->data->{path}{scancore_archive} = $an->data->{scancore}{archive}{directory};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::scancore_archive", value1 => $an->data->{path}{scancore_archive}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{trigger}) or ($an->data->{scancore}{archive}{trigger} =~ /\D/))
	{
		$an->data->{scancore}{archive}{trigger} = 100000;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::trigger", value1 => $an->data->{scancore}{archive}{trigger}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{count}) or ($an->data->{scancore}{archive}{count} =~ /\D/))
	{
		$an->data->{scancore}{archive}{count} = 50000;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::count", value1 => $an->data->{scancore}{archive}{count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	if (not -e $an->data->{path}{scancore_archive})
	{
		my $shell_call = $an->data->{path}{'mkdir'}." -p '".$an->data->{path}{scancore_archive}."'";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Did it work?
		if (not -e $an->data->{path}{scancore_archive})
		{
			# Nope. :(
			$an->Alert->warning({message_key => "scancore_warning_0030", message_variables => { directory => $an->data->{path}{scancore_archive} }, quiet => 1, file => $THIS_FILE, line => __LINE__});
			return(1);
		}
	}
	
	# This is pretty simple... Just one table
	$an->data->{archive}{table} = {
		server_resources	=>	{
			archive_date		=>	"",
			host_column		=>	"server_resource_host_uuid",
			offset			=>	0,
		},
		server_resource_disks	=>	{
			archive_date		=>	"",
			host_column		=>	"server_resource_disk_host_uuid",
			offset			=>	0,
		},
		server_resource_cpus	=>	{
			archive_date		=>	"",
			host_column		=>	"server_resource_cpu_host_uuid",
			offset			=>	0,
		},
	};
	my $archive_needed = 0;
	foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "table", value1 => $table, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $query = "
SELECT 
    COUNT(*) 
FROM 
    history.$table 
WHERE 
    ".$an->data->{archive}{table}{$table}{host_column}." = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $records = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		   $records = 0 if not defined $records;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "records", value1 => $records, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($records > $an->data->{scancore}{archive}{trigger})
		{
			   $archive_needed                             = 1;
			my $records_to_save                            = ($an->data->{scancore}{archive}{trigger} - $an->data->{scancore}{archive}{count});
			my $offset                                     = $records - $records_to_save;
			   $an->data->{archive}{table}{$table}{offset} = $offset;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "archive_needed",                   value1 => $archive_needed, 
				name2 => "records_to_save",                  value2 => $records_to_save, 
				name3 => "archive::table::${table}::offset", value3 => $an->data->{archive}{table}{$table}{offset}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I have something to archive, do so now.
	if ($archive_needed)
	{
		# This will store the files to compress after we release the locks.
		my $compress = [];
		
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Now loop through the table(s) that need to be archived.
		foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
		{
			next if not $an->data->{archive}{table}{$table}{offset};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "table", value1 => $table, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Now to do the archive.
			if ($table eq "server_resources")
			{
				$an->DB->archive_table({
					table        => $table, 
					offset       => $an->data->{archive}{table}{$table}{offset}, 
					conditionals => { $an->data->{archive}{table}{$table}{host_column} => $an->data->{sys}{host_uuid} },
					columns      => ["server_resource_uuid", "server_resource_host_uuid", "server_resource_target_access", "server_resource_host_name", "server_resource_os", "server_resource_boot_time", "server_resource_ram_size", "server_resource_ram_used", "server_resource_swap_size", "server_resource_swap_used"],
				});
			}
			elsif ($table eq "server_resource_disks")
			{
				$an->DB->archive_table({
					table        => $table, 
					offset       => $an->data->{archive}{table}{$table}{offset}, 
					conditionals => { $an->data->{archive}{table}{$table}{host_column} => $an->data->{sys}{host_uuid} },
					columns      => ["server_resource_disk_uuid", "server_resource_disk_server_resource_uuid", "server_resource_disk_host_uuid", "server_resource_disk_mount_point", "server_resource_disk_filesystem", "server_resource_disk_options", "server_resource_disk_size", "server_resource_disk_used"],
				});
			}
			elsif ($table eq "server_resource_cpus")
			{
				$an->DB->archive_table({
					table        => $table, 
					offset       => $an->data->{archive}{table}{$table}{offset}, 
					conditionals => { $an->data->{archive}{table}{$table}{host_column} => $an->data->{sys}{host_uuid} },
					columns      => ["server_resource_cpu_uuid", "server_resource_cpu_server_resource_uuid", "server_resource_cpu_host_uuid", "server_resource_cpu_number", "server_resource_cpu_load"],
				});
			}
		}
		
		### TODO: Make this less of a hackish mc-hackington...
		# VACUUM FULL, if the database is on this machine. I need to do this from the command line 
		# because the user we connect as isn't allowed to do it. We'll also only vacuum our DB.
		my $db_name = "";
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "id",                        value1 => $id, 
				name2 => "scancore::db::${id}::host", value2 => $an->data->{scancore}{db}{$id}{host}, 
				name3 => "hostname",                  value3 => $an->hostname, 
				name4 => "short_hostname",            value4 => $an->short_hostname, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($an->data->{scancore}{db}{$id}{host} eq $an->hostname) or ($an->data->{scancore}{db}{$id}{host} eq $an->short_hostname))
			{
				$db_name = $an->data->{scancore}{db}{$id}{name};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "db_name",                   value1 => $db_name, 
					name2 => "scancore::db::${id}::name", value2 => $an->data->{scancore}{db}{$id}{name}, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		if ($db_name)
		{
			my $start      = time;
			my $shell_call = $an->data->{path}{su}." - postgres -c \"".$an->data->{path}{psql}." $db_name -c 'VACUUM FULL;'\"";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "start",      value1 => $start, 
				name2 => "shell_call", value2 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			my $finished = time - $start;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "finished", value1 => $finished, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Release the lock
		$an->DB->locking({release => 1});
	}
	
	return(0);
}

# This checks to see if this agent's databases tables exist and, if not, load the schema. If the schema gets
# loaded, we'll check other databases for older information and load it.
sub prep_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0016", message_variables => { agent => $THIS_FILE }, file => $THIS_FILE, line => __LINE__});
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
	{
		my $query = "SELECT COUNT(*) FROM pg_catalog.pg_tables WHERE tablename='server_resources' AND schemaname='public';";
		#                     The actual query -----------------.        .------- Row 0
		#                        Query this DB --.              |        |    .-- Columns 0
		my $count = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Need to load the database schema.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0017", file => $THIS_FILE, line => __LINE__});
			$an->DB->load_schema({id => $id, file => $an->data->{path}{sql}});
			
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_sort		=>	$an->data->{sys}{alert_sort}++,
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0002",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
					agent			=>	$THIS_FILE,
				},
			});
		}
		else
		{
			# Table exists, schema load is not needed.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0018", file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	print $an->String->get({key => "scan_server_resources_message_0002"})."\n";

	return(0);
}
