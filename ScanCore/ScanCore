#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - Failed to connect to any database.
# 2  - Error preparing a database query.
# 3  - Failed to read a file.
# 4  - Failed to get an ID when initializing a database.
# 5  - Used too much RAM, exited to avoid a problem.
# 6  - Another copy of ScanCore is running.
# 7  - The UUID for this host was not read (or not read correctly).
# 8  - Bad alert config in striker.conf
# 
# TODO:
# - Record the hostname to a file and check the current host name with the one
#   on file. If it differs, update the appropriate 'hosts' table in the DBs
# - Have DB.pm return an error code and have ScanCore exit if a query fails.
#         
# BUG:
# - 
# 
# NOTE: Because each DB may use different serial IDs for various DBs, they 
#       can't be used to directly UPDATE or reference when INSERTing values. So
#       instead, we use the hostname as the "global" common variable amoungst 
#       DBs and then divine each DB's individual table/column IDs from it. This
#       means we can do UPDATE and INSERTs into all DBs with one query, but it
#       makes those queries... awkward. It also means that the user changing
#       the hostname *MUST* be caught by ScanCore via a cache file in order to
#       alter the hosts -> host_name column without losing the host_uuid.
#       
#       I'm open to better ideas...
#       
# =============================================================================
=pod
Steps to setup ScanCore DB:

# Striker
yum install postgresql94-server

# Database setup
/etc/init.d/postgresql-9.4 initdb
/etc/init.d/postgresql-9.4 start
chkconfig postgresql-9.4 on
su - postgres -c "psql template1 -c \"ALTER ROLE postgres WITH PASSWORD 'secret';\""
echo *:*:*:postgres:secret > /var/lib/pgsql/.pgpass
chown postgres:postgres /var/lib/pgsql/.pgpass
chmod 600 /var/lib/pgsql/.pgpass
sed -i.bak '/# TYPE  DATABASE/a host\tall\tall\t10.20.0.0\/16\tmd5\nhost\tall\tall\t10.250.0.0\/16\tmd5' /var/lib/pgsql/9.4/data/pg_hba.conf 
sed -i 's/local   all         all                               ident/local   all         all                               md5/' /var/lib/pgsql/9.4/data/pg_hba.conf 
sed -i.bak "s/#listen_addresses = 'localhost'/listen_addresses = '*'/" /var/lib/pgsql/9.4/data/postgresql.conf
chown postgres:postgres /var/lib/pgsql/9.4/data/*
/etc/init.d/postgresql-9.4 restart
su - postgres -c "createuser --no-superuser --createdb --no-createrole striker"
su - postgres -c "psql template1 -c \"ALTER ROLE striker WITH PASSWORD 'secret';\""
su - postgres -c "createdb --owner striker scancore"
su postgres -c "psql scancore"

# ScanCore clients
yum install perl-DBI perl-DBD-Pg perl-CGI perl-TermReadKey perl-XML-Simple perl-Net-SSH2 


----

# Reset DB
su - postgres -c "dropdb scancore"
su - postgres -c "createdb --owner admin scancore"
su postgres -c "psql scancore"


Sync checks;

Base:
SELECT * FROM hosts ORDER BY modified_date DESC, host_name ASC; SELECT * FROM history.hosts ORDER BY modified_date DESC, host_name ASC;
SELECT * FROM agents ORDER BY modified_date DESC, agent_name ASC; SELECT * FROM history.agents ORDER BY modified_date DESC, agent_name ASC;
SELECT * FROM alerts ORDER BY modified_date DESC, alert_uuid ASC; SELECT alert_uuid, alert_host_uuid, alert_agent_name AS name, alert_level AS level, alert_title_key, alert_title_variables AS title_vars, alert_message_key, alert_message_variables, modified_date FROM history.alerts ORDER BY modified_date DESC, alert_uuid ASC;
SELECT * FROM ram_used ORDER BY modified_date DESC, ram_used_by ASC; SELECT * FROM history.ram_used ORDER BY modified_date DESC, ram_used_by ASC;
SELECT * FROM power ORDER BY modified_date DESC, power_agent_name ASC; SELECT * FROM history.power ORDER BY modified_date DESC, power_agent_name ASC;
SELECT * FROM temperature ORDER BY modified_date DESC, temperature_agent_name ASC; SELECT * FROM history.temperature ORDER BY modified_date DESC, temperature_agent_name ASC;

scan_clustat;
SELECT * FROM clustat ORDER BY modified_date DESC, clustat_uuid ASC; SELECT * FROM history.clustat ORDER BY modified_date DESC, clustat_uuid ASC;
SELECT a.host_name, b.clustat_uuid, c.clustat_node_name, c.clustat_node_cluster_id, c.clustat_node_status, c.modified_date  FROM hosts a, clustat b, clustat_node c WHERE a.host_uuid = b.clustat_host_uuid AND b.clustat_uuid = c.clustat_node_clustat_uuid ORDER BY c.modified_date DESC, clustat_node_name ASC; SELECT a.host_name, b.clustat_uuid, c.clustat_node_name, c.clustat_node_cluster_id, c.clustat_node_status, c.modified_date  FROM hosts a, clustat b, history.clustat_node c WHERE a.host_uuid = b.clustat_host_uuid AND b.clustat_uuid = c.clustat_node_clustat_uuid ORDER BY c.modified_date DESC, clustat_node_name ASC;
SELECT a.host_name, b.clustat_uuid, c.clustat_service_name, c.clustat_service_host, c.clustat_service_status, c.clustat_service_notes AS notes, c.modified_date  FROM hosts a, clustat b, clustat_service c WHERE a.host_uuid = b.clustat_host_uuid AND b.clustat_uuid = c.clustat_service_clustat_uuid ORDER BY c.modified_date DESC, clustat_service_name ASC; SELECT a.host_name, b.clustat_uuid, c.clustat_service_name, c.clustat_service_host, c.clustat_service_status, c.clustat_service_notes AS notes, c.modified_date  FROM hosts a, clustat b, history.clustat_service c WHERE a.host_uuid = b.clustat_host_uuid AND b.clustat_uuid = c.clustat_service_clustat_uuid ORDER BY c.modified_date DESC, clustat_service_name ASC;

scan_bond;
SELECT a.host_name, b.bond_uuid, b.bond_name, b.bond_mode AS mode, b.bond_primary_slave AS primary, b.bond_primary_reselect AS reselect, b.bond_active_slave AS active, b.bond_mii_status AS mii, b.bond_mii_polling_interval AS poll, b.bond_up_delay AS updelay, b.bond_down_delay AS downdelay, b.modified_date FROM hosts a, bond b WHERE a.host_uuid = b.bond_host_uuid ORDER BY b.modified_date DESC, a.host_name ASC, b.bond_name ASC; SELECT a.host_name, b.bond_uuid, b.bond_name, b.bond_mode AS mode, b.bond_primary_slave AS primary, b.bond_primary_reselect AS reselect, b.bond_active_slave AS active, b.bond_mii_status AS mii, b.bond_mii_polling_interval AS poll, b.bond_up_delay AS updelay, b.bond_down_delay AS downdelay, b.modified_date FROM hosts a, history.bond b WHERE a.host_uuid = b.bond_host_uuid ORDER BY b.modified_date DESC, a.host_name ASC, b.bond_name ASC;
SELECT a.host_name, b.bond_name, c.bond_interface_id AS id, c.bond_interface_name AS name, c.bond_interface_mii_status AS mii, c.bond_interface_speed AS speed, c.bond_interface_duplex AS duplex, c.bond_interface_failure_count AS fail, c.bond_interface_mac, c.bond_interface_slave_queue_id AS queueid, c.modified_date FROM hosts a, bond b, bond_interface c WHERE a.host_uuid = b.bond_host_uuid AND b.bond_uuid = c.bond_interface_bond_uuid ORDER BY c.modified_date DESC, b.bond_name ASC, c.bond_interface_name ASC; SELECT a.host_name, b.bond_name, c.bond_interface_id AS id, c.bond_interface_name AS name, c.bond_interface_mii_status AS mii, c.bond_interface_speed AS speed, c.bond_interface_duplex AS duplex, c.bond_interface_failure_count AS fail, c.bond_interface_mac, c.bond_interface_slave_queue_id AS queueid, c.modified_date FROM hosts a, bond b, history.bond_interface c WHERE a.host_uuid = b.bond_host_uuid AND b.bond_uuid = c.bond_interface_bond_uuid ORDER BY c.modified_date DESC, b.bond_name ASC, c.bond_interface_name ASC;

scan_apc_ups;
SELECT a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, b.apc_ups_ip, b.apc_ups_ac_restore_delay AS acdelay, b.apc_ups_shutdown_delay AS offdelay, b.apc_ups_firmware_version AS firmware, b.apc_ups_health AS health, b.apc_ups_high_transfer_voltage AS highv, b.apc_ups_low_transfer_voltage AS lowv, b.apc_ups_last_transfer_reason AS xfer, b.apc_ups_manufactured_date AS oemdate, b.apc_ups_model AS model, b.apc_ups_temperature_units AS tunit, b.apc_ups_nmc_firmware_version AS nmcfw, b. apc_ups_nmc_serial_number AS nmcsn, b.apc_ups_nmc_mac_address AS mac, b.modified_date FROM hosts a, apc_ups b WHERE a.host_uuid = b.apc_ups_host_uuid ORDER BY b.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC; SELECT b.history_id AS hid, a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, b.apc_ups_ip, b.apc_ups_ac_restore_delay AS acdelay, b.apc_ups_shutdown_delay AS offdelay, b.apc_ups_firmware_version AS firmware, b.apc_ups_health AS health, b.apc_ups_high_transfer_voltage AS highv, b.apc_ups_low_transfer_voltage AS lowv, b.apc_ups_last_transfer_reason AS xfer, b.apc_ups_manufactured_date AS oemdate, b.apc_ups_model AS model, b.apc_ups_temperature_units AS tunit, b.apc_ups_nmc_firmware_version AS nmcfw, b. apc_ups_nmc_serial_number AS nmcsn, b.apc_ups_nmc_mac_address AS mac, b.modified_date FROM hosts a, history.apc_ups b WHERE a.host_uuid = b.apc_ups_host_uuid ORDER BY b.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC;
SELECT a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, c.apc_ups_battery_id AS id, c.apc_ups_battery_replacement_date AS replace, c.apc_ups_battery_health AS health, c.apc_ups_battery_model AS mn, c.apc_ups_battery_percentage_charge AS charge, c. apc_ups_battery_last_replacement_date AS replaced, c.apc_ups_battery_state AS state, c.apc_ups_battery_temperature AS temp, c.apc_ups_battery_alarm_temperature AS hightemp, c.apc_ups_battery_voltage AS volt, c.modified_date FROM hosts a, apc_ups b, apc_ups_battery c WHERE a.host_uuid = b.apc_ups_host_uuid AND b.apc_ups_uuid = c.apc_ups_battery_apc_ups_uuid ORDER BY c.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC; SELECT c.history_id AS hid, a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, c.apc_ups_battery_id AS id, c.apc_ups_battery_replacement_date AS replace, c.apc_ups_battery_health AS health, c.apc_ups_battery_model AS mn, c.apc_ups_battery_percentage_charge AS charge, c. apc_ups_battery_last_replacement_date AS replaced, c.apc_ups_battery_state AS state, c.apc_ups_battery_temperature AS temp, c.apc_ups_battery_alarm_temperature AS hightemp, c.apc_ups_battery_voltage AS volt, c.modified_date FROM hosts a, apc_ups b, history.apc_ups_battery c WHERE a.host_uuid = b.apc_ups_host_uuid AND b.apc_ups_uuid = c.apc_ups_battery_apc_ups_uuid ORDER BY c.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC;
SELECT a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, c.apc_ups_input_frequency AS freq, c.apc_ups_input_sensitivity AS sensitivity, c.apc_ups_input_voltage AS inv, apc_ups_input_1m_maximum_input_voltage AS max1mvin, c.apc_ups_input_1m_minimum_input_voltage AS min1mvin, c.modified_date FROM hosts a, apc_ups b, apc_ups_input c WHERE a.host_uuid = b.apc_ups_host_uuid AND b.apc_ups_uuid = c.apc_ups_input_apc_ups_uuid ORDER BY c.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC; SELECT c.history_id AS hid, a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, c.apc_ups_input_frequency AS freq, c.apc_ups_input_sensitivity AS sensitivity, c.apc_ups_input_voltage AS inv, apc_ups_input_1m_maximum_input_voltage AS max1mvin, c.apc_ups_input_1m_minimum_input_voltage AS min1mvin, c.modified_date FROM hosts a, apc_ups b, history.apc_ups_input c WHERE a.host_uuid = b.apc_ups_host_uuid AND b.apc_ups_uuid = c.apc_ups_input_apc_ups_uuid ORDER BY c.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC;
SELECT a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, c.apc_ups_output_load_percentage AS loadpct, c.apc_ups_output_time_on_batteries AS timeonbat, c.apc_ups_output_estimated_runtime AS runtime, c.apc_ups_output_frequency AS freq, c.apc_ups_output_voltage AS volt, c.apc_ups_output_total_output AS totalkwh, c.modified_date FROM hosts a, apc_ups b, apc_ups_output c WHERE a.host_uuid = b.apc_ups_host_uuid AND b.apc_ups_uuid = c.apc_ups_output_apc_ups_uuid ORDER BY c.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC; SELECT c.history_id AS hid, a.host_name, b.apc_ups_serial_number AS sn, b.apc_ups_name, c.apc_ups_output_load_percentage AS loadpct, c.apc_ups_output_time_on_batteries AS timeonbat, c.apc_ups_output_estimated_runtime AS runtime, c.apc_ups_output_frequency AS freq, c.apc_ups_output_voltage AS volt, c.apc_ups_output_total_output AS totalkwh, c.modified_date FROM hosts a, apc_ups b, history.apc_ups_output c WHERE a.host_uuid = b.apc_ups_host_uuid AND b.apc_ups_uuid = c.apc_ups_output_apc_ups_uuid ORDER BY c.modified_date DESC, a.host_name ASC, b.apc_ups_name ASC;

scan_ipmitool;
SELECT a.host_name, b.ipmitool_sensor_host, b.ipmitool_sensor_name AS name, b.ipmitool_sensor_units AS units, b.ipmitool_sensor_status AS state, b.ipmitool_sensor_high_critical AS high_crit, b.ipmitool_sensor_high_warning AS high_warn, b.ipmitool_sensor_low_critical AS low_crit, b.ipmitool_sensor_low_warning AS low_warn, b.modified_date FROM hosts a, ipmitool b WHERE a.host_uuid = b.ipmitool_host_uuid ORDER BY b.modified_date DESC, a.host_name ASC, b.ipmitool_sensor_host ASC, b.ipmitool_sensor_name ASC;

SELECT a.host_name, b.ipmitool_sensor_host, b.ipmitool_sensor_name AS name, c.ipmitool_value_sensor_value AS value, b.ipmitool_sensor_units AS units, b.ipmitool_sensor_status AS state, b.ipmitool_sensor_high_critical AS high_crit, b.ipmitool_sensor_high_warning AS high_warn, b.ipmitool_sensor_low_critical AS low_crit, b.ipmitool_sensor_low_warning AS low_warn, b.modified_date FROM hosts a, ipmitool b, ipmitool_value c WHERE a.host_uuid = b.ipmitool_host_uuid AND b.ipmitool_uuid = c.ipmitool_value_ipmitool_uuid ORDER BY b.modified_date DESC, a.host_name ASC, b.ipmitool_sensor_host ASC, b.ipmitool_sensor_name ASC;


=cut
# =============================================================================

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			agents_directory	=>	"$running_directory/agents",
			cp			=>	"/bin/cp",
			email_directory		=>	"/var/log/alert_emails",
			fence_agents		=>	"/usr/sbin",
			# under this directory will be a file called 
			# ".<node_name>" for each node. This contains the 
			# string 'health = [ok,warning,critical]. This is used
			# to indicate to the peer our state and controls how
			# 'safe_anvil_shutdown' behaves.
			health_file		=>	"/shared/status",
			# This stores this node's UUID. It is used to track all our sensor data in the 
			# database. If you change this here, change it in the agents, too.
			host_uuid		=>	"/etc/striker/host.uuid",
			log_file		=>	"/var/log/striker.log",
			mailx			=>	"/bin/mailx",
			# This is the path to Striker's cache directory. It is
			# used by striker dashboards when they want to reboot a
			# node that is in emergency-stop and the environment is
			# safe again.
			node_cache		=>	"/var/www/home/cache", 
			postfix_init		=>	"/etc/init.d/postfix",
			postfix_main		=>	"/etc/postfix/main.cf",
			postfix_relay_file	=>	"/etc/postfix/relay_password",
			postmap			=>	"/usr/sbin/postmap",
			safe_anvil_shutdown	=>	"/sbin/striker/safe_anvil_shutdown",
			scancore_strings	=>	"$running_directory/ScanCore.xml",
			scancore_sql		=>	"$running_directory/ScanCore.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"/sbin/striker/Data/strings.xml",
			uuidgen			=>	"/usr/bin/uuidgen",
		},
		# Things set here are meant to be overwritable by the user in striker.conf.
		scancore			=>	{
			# Set to '1' to add the footer warning that the email
			# did not come from alteeve.ca
			append_email_footer	=>	0,
			disable			=>	{
				power_shutdown		=>	0,
				thermal_shutdown	=>	0,
			},
			# This gets set to 'dashboard' if we determine this is a dashboard machine.
			i_am_a			=>	"",
			language		=>	"en_CA",
			log_level		=>	2,
			log_language		=>	"en_CA",
			maximum_ram		=>	(512 * 1048576),
			# When both/all UPSes powering a node switch to batteries, their remaining hold-up 
			# time will be checked and the strongest will be compared against this value. If the
			# remaining runtime of the strongest ups is below this time, 'safe_anvil_shutdown' 
			# will be invoked.
			minimum_ups_runtime	=>	600,
			minimum_safe_charge	=>	45,
			temperature		=>	{
				# This is the weight given to each thermal sensor by default.
				default_sensor_weight	=>	1,
				# The sum of the critical temperature weights must exceed this value to cause
				# a shut down.
				shutdown_limit		=>	5,
			},
			thermal_reboot_delay	=>	{
				'1'			=>	600,
				'2'			=>	1800,
				'3'			=>	3600,
				'4'			=>	7200,
				more			=>	21600,
			},
			sleep_time		=>	30,
		},
		strings_read			=>	{},
		sys		=>	{
			agents			=>	[],
			# This gets the config ID(s) of any initialized databases.
			db_initialized		=>	{},
			db_timestamp		=>	"",			# This will hold the timestamp used to set 'modified_date' on all DB records.
			# This stores the local machine's ScanCore UUID.
			host_uuid		=>	"",
			# This gets set to '1' once we know this host is in the DB.
			host_is_in_db		=>	0,
			# This looks like a lot, but 'pmap' kinda sucks and reports shared memory, so to even
			# start a program lists 120 MiB+ used. I will make it smarter later.
			program_name		=>	$THIS_FILE,
			read_db_id		=>	"",
			use_db_fh		=>	"",
		},
		tools		=>	{
			boot_nodes	=>	{
				enabled		=>	1,
			},
		},
	}
});

# Set some defaults
$an->default_language    ($an->data->{scancore}{language});
$an->default_log_language($an->data->{scancore}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});

# Set the log level.
$an->Log->level($an->data->{scancore}{log_level});

# Read my stuff
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Has the user disabled ScanCore?
exit(0) if not $an->data->{scancore}{enabled};

# Read in strings now.
$an->String->read_words({file => $an->data->{path}{scancore_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Should I live?
avoid_duplicate_run($an);

# Number 5 is Alive!
print $an->String->get({key => "scancore_message_0001"}), "\n";

# Get (create if needed) my UUID.
prep_local_uuid($an);

# Connect to the database(s). This is different from the in-loop connection in that failing to connect to any
# databases right off the bad will cause the program to bail out.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
if (not $connections)
{
	# Failed to connect to any database.
	print $an->String->get({
		key		=>	"scancore_message_0002",
		variables	=>	{
			title		=>	$an->String->get({key => "scancore_title_0003"}),
			message		=>	$an->String->get({key => "scancore_message_0004"}),
		},
	}), "\n";
	
	# TODO: Send an email.
	
	exit(1);
}

# Before we can process or sync alerts, we need to make sure we've read in the strings files for any
# agents that have registered alerts (pending or historical).
load_agent_strings($an);

# Update the database before we do anything else.
update_db($an);

# Make sure this node is in the database and the host name is up to date.
add_hostname_to_databases($an);
check_hostname_for_changes($an);

# Tell the user we've started.
$an->Alert->register_alert({
	alert_level		=>	"notice", 
	alert_agent_name	=>	"$THIS_FILE",
	alert_title_key		=>	"an_alert_title_0003",
	alert_message_key	=>	"scancore_log_0066",
});
$an->Log->entry({log_level => 1, message_key => "scancore_log_0066", file => $THIS_FILE, line => __LINE__});

# Check for and process alert that may have not been sent when we last ran as well as the 'we've started'
# alert above.
process_alerts($an, 1);

# Run the agents we find.
$an->Log->entry({
	log_level	=>	2,
	title_key	=>	"scancore_title_0005",
	message_key	=>	"scancore_log_0011",	# Entering the scan loop
	file		=>	$THIS_FILE,
	line		=>	__LINE__,
	log_to		=>	$an->data->{path}{log_file},
});

# Disconnect from databases... We'll reconnect inside the loop.
$an->DB->disconnect_from_databases();
while(1)
{
	# Re-read the configuration and words files.
	$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
	$an->String->read_words({file => $an->data->{path}{scancore_strings}});
	$an->String->read_words({file => $an->data->{path}{striker_strings}});
	load_agent_strings($an);
	
	# Calculate the sum and see if it has changed.
	#calculate_scancore_sum($an);
	
	# Has the user disabled ScanCore?
	if (not $an->data->{scancore}{enabled})
	{
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0065", file => $THIS_FILE, line => __LINE__});
		my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
		if ($connections)
		{
			# Log that we're exiting on being disabled.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scancore_log_0065",
				alert_message_variables	=>	"",
			});
			process_alerts($an, 0);
			$an->DB->disconnect_from_databases();
		}
		exit(0);
	}
	
	# TODO: Calc the md5s of ScanCore's core files and if they change, exit when the scan runs at x:x4
	#       or x:x9 minutes so that it restarts and misses the fewest possible scans.
	
	# Connect to the databases.
	my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
	if ($connections)
	{
		# Look to see if any databases need to be updated.
		update_db($an);
		
		# Has the host name changed?
		check_hostname_for_changes($an);
		
		# If I initialized a database, send an alert.
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{sys}{db_initialized}})
		{
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0001",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
				},
			});
			delete $an->data->{sys}{db_initialized}{$id};
		}
		
		# Call all agents
		call_agents($an);
		
		# Analyze results and take any necessary actions.
		analyze_results($an);
	}
	else
	{
		# Failed to connect to any database. This isn't fatal though...
		# Send an alert email if we haven't already, sleep.
		print "$THIS_FILE ".__LINE__."; get: [scancore_message_0002]\n";
		print $an->String->get({
			key		=>	"scancore_message_0002",
			variables	=>	{
				title		=>	$an->String->get({key => "scancore_title_0003"}),
				message		=>	$an->String->get({key => "scancore_message_0004"}),
			},
		}), "\n";
	}
	
	# Check for and process alerts
	process_alerts($an, 0);
	
	# Do the end-of-scan checks to see if we need to power off, boot
	# others, set/alter health flags, etc.
	do_post_scan_checks($an);
	
	# Record the time
	$an->DB->update_time({file => $THIS_FILE});
	
	# Check RAM usage and bail if it looks like we're leaking.
	check_ram_usage($an);
	
	# Disconnect from databases.
	$an->DB->disconnect_from_databases();
	
	# Visual break in the log file
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "scancore::sleep_time",                     value1 => $an->data->{scancore}{sleep_time}, 
		name2 => "----------------------------------------", value2 => "----------------------------------------"
	}, file => $THIS_FILE, line => __LINE__});
	
	# Sleep.
	$an->Log->entry({
		log_level	=>	3,
		title_key	=>	"scancore_title_0001",
		message_key	=>	"scancore_log_0012",	# Sleeping for X seconds.
		message_variables	=>	{
			sleep_time	=>	$an->data->{scancore}{sleep_time},
		},
		file		=>	$THIS_FILE,
		line		=>	__LINE__,
		log_to		=>	$an->data->{path}{log_file},
	});
	sleep $an->data->{scancore}{sleep_time};
}

# This should never be hit...
nice_exit($an);

###############################################################################
# Functions                                                                   #
###############################################################################

# Get (create if needed) my UUID.
sub prep_local_uuid
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "prep_local_uuid" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Does it exist?
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::host_uuid", value1 => $an->data->{path}{host_uuid}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not -e $an->data->{path}{host_uuid})
	{
		# Nope. What about the parent directory? Split the path from 
		# the file name.
		my ($directory, $file) = ($an->data->{path}{host_uuid} =~ /^(.*)\/(.*)/);
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "directory", value1 => $directory, 
			name2 => "file",      value2 => $file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Check the directory now
		if (not -e $directory)
		{
			# The directory needs to be created.
			mkdir $directory or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0019", message_variables => {
				directory => $directory, 
				error     => $! 
			}, code => 2, file => "$THIS_FILE", line => __LINE__});
			
			# Set the mode
			my $directory_mode = 0775;
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0046", message_variables => {
				directory_mode => sprintf("%04o", $directory_mode), 
			}, file => $THIS_FILE, line => __LINE__});
			chmod $directory_mode, $an->data->{path}{email_directory};
		}
		
		### I don't use AN::Get->uuid() because I need to write to the file anyway, so I can do both
		### in one step.
		# Now create the UUID.
		my $shell_call = $an->data->{path}{uuidgen}." > ".$an->data->{path}{host_uuid};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			# There should never be any output, but just in case...
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	
	# Now read in the UUID.
	$an->Get->uuid({get => 'host_uuid'});
	
	# Verify I have a good UUID.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::host_uuid", value1 => $an->data->{sys}{host_uuid}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{host_uuid} !~ /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/)
	{
		# derp
		$an->Log->entry({log_level => 0, message_key => "scancore_error_0017", file => $THIS_FILE, line => __LINE__});
		exit(7);
	}
	
	return($an->data->{sys}{host_uuid});
}

sub do_post_scan_checks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "do_post_scan_checks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# What we do here strongly depends on whether we're a node or a
	# dashboard. 
	# 
	# If we're a node, we will withdraw and shut down if the UPS power is 
	# depleted past a certain point or if temperatures go outside 
	# acceptible ranges. If any sensor diviates, we set our "sick" flag and
	# ensure it's clear if we're A-OK.
	# 
	# If this is a dashboard, we never shutdown. Instead, we will watch the
	# nodes configured in our /etc/striker/striker.conf and if they're 
	# offline and the host shut itself down, we'll watch the UPSes and
	# temperature sensors. If/when things are good, we'll boot the nodes
	# back up.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not $an->data->{scancore}{i_am_a})
	{
		# What am I?
		my $query = "SELECT host_type FROM hosts WHERE host_name = ".$an->data->{sys}{use_db_fh}->quote($an->hostname).";";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->data->{scancore}{i_am_a} = $an->DB->do_db_query({query => $query})->[0]->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{i_am_a} eq "dashboard")
	{
		# Do the dashboard stuff.
		do_post_scan_dashboard_tasks($an);
	}
	else
	{
		# Do the node stuff.
		do_post_scan_node_tasks($an);
	}
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0061", file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

# This will read it's /etc/striker/striker.conf file and for each node it sees,
# it will reference it's cache to check it's power status. If the node if off,
# it will check hosts -> host_emergency_stop and if it is TRUE, check to see if
# it is safe to boot the nodes back up.
sub do_post_scan_dashboard_tasks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "do_post_scan_dashboard_tasks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# So first thing, see if any nodes are in emergency_stop. If not, there
	# is nothing further for us to do. We order by host name to be sure to
	# boot node 1 first, when both are recoverable. 'Tis but a minor thing,
	# but hey, why not.
	my $query = "
SELECT 
    host_uuid, 
    host_name, 
    host_emergency_stop, 
    host_stop_reason 
FROM 
    hosts 
WHERE 
    host_type = 'node' 
ORDER BY 
    host_name;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query});
	my $count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		# At least one node is in an emergency-off state. See if we can
		# recover it and if it is safe to do so.
		
		# First step is to read in any/all cache files. If we don't
		# have a cache directory, then we're done.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::node_cache", value1 => $an->data->{path}{node_cache}
		}, file => $THIS_FILE, line => __LINE__});
		if (-d $an->data->{path}{node_cache})
		{
			# This will be stuck onto the start of fence agents that don't have a full path.
			my $fence_path = $an->data->{path}{fence_agents};
			
			# So we do have a cache directory. What about actual cache files?
			local(*DIRECTORY);
			opendir(DIRECTORY, $an->data->{path}{node_cache});
			while(my $file = readdir(DIRECTORY))
			{
				next if $file eq ".";
				next if $file eq "..";
				next if $file !~ /cache_.*?\.striker/;
				my $full_path = $an->data->{path}{node_cache}."/$file";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "full_path", value1 => "$full_path"
				}, file => $THIS_FILE, line => __LINE__});
				if (-r $full_path)
				{
					# Woot!
					my $in_hosts       = 0;
					my $shell_call     = $full_path;
					my ($anvil, $node) = ($full_path =~ /cache_(.*?)_(.*?)\.striker/);
					$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
						name1 => "in_hosts",   value1 => "$in_hosts", 
						name2 => "shell_call", value2 => "$shell_call", 
						name3 => "anvil",      value3 => "$anvil", 
						name4 => "node",       value4 => "$node", 
					}, file => $THIS_FILE, line => __LINE__});
					open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
					while(<$file_handle>)
					{
						chomp;
						my $line =  $_;
						   $line =~ s/\s+/ /g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "line", value1 => "$line"
						}, file => $THIS_FILE, line => __LINE__});
						
						if ($line eq "#! start hosts !#")
						{
							$in_hosts = 1;
							next;
						}
						if ($line eq "#! end hosts !#")
						{
							$in_hosts = 1;
							next;
						}
						if (($in_hosts) && ($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+(.*)/))
						{
							my $this_ip   = $1;
							my $this_host = $2;
							$an->data->{cache}{$node}{host}{$this_host}{ip} = $this_ip;
							$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
								name1 => "cache::${node}::host::${this_host}::ip", value1 => $an->data->{cache}{$node}{host}{$this_host}{ip}
							}, file => $THIS_FILE, line => __LINE__});
						}
						else
						{
							next if $line !~ /=/;
							my ($variable, $value) = (split/=/, $line, 2);
							$variable =~ s/^\s+//;
							$variable =~ s/\s+$//;
							$value    =~ s/^\s+//;
							$value    =~ s/\s+$//;
							
							# Stick the full path onto the 'power_check_command'.
							if ($variable eq "power_check_command")
							{
								$value =~ s/^fence/$fence_path\/fence/;
							}
							
							$an->data->{cache}{$node}{info}{$variable} = $value;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "cache::${node}::info::${variable}", value1 => $an->data->{cache}{$node}{info}{$variable}
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
					close $file_handle;
				}
			}
			
			# I might be able to boot up nodes that are down, so I
			# want to now read in the 'power' and 'temperature' 
			# tables. As I loop through the downed nodes, I will 
			# pull their particulars and decide on a case by case
			# basis if it is safe to boot them back up.
			
			# First, read in the power table.
			read_power_table($an);
			
			# Now read in the temperature table.
			read_temperature_table($an);
			
			# Now that I've read in my cache files, start looking
			# at the nodes that are down.
			foreach my $row (@{$results})
			{
				my $host_uuid           = $row->[0];
				my $host_name           = $row->[1];
				my $host_emergency_stop = $row->[2];
				my $host_stop_reason    = $row->[3] ? $row->[2] : "";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
					name1 => "host_uuid",                value1 => $host_uuid, 
					name2 => "host_name",                value2 => $host_name, 
					name3 => "host_emergency_stop",      value3 => $host_emergency_stop, 
					name4 => "host_stop_reason",         value4 => $host_stop_reason, 
					name5 => "path::node_cache",         value5 => $an->data->{path}{node_cache}, 
					name6 => "ref: cache::${host_name}", value6 => ref($an->data->{cache}{$host_name}),
				}, file => $THIS_FILE, line => __LINE__});
				
				### TODO: Should we make it a config option to let the user decide if they
				###       want to boot a node while a dashboard is in 'warning'?
				
				# Make sure our own temperature is good.
				my $my_temperature_is_ok = check_node_temperature_health($an, $an->hostname);
				
				# See if the power is safe enough to boot this node.
				my $power_is_safe       = check_node_power_health      ($an, $host_name);
				my $temperature_is_safe = check_node_temperature_health($an, $host_name);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
					name1 => "power_is_safe",              value1 => $power_is_safe, 
					name2 => "temperature_is_safe",        value2 => $temperature_is_safe, 
					name3 => "my_temperature_is_ok",       value3 => $my_temperature_is_ok, 
					name4 => "tools::boot_nodes::enabled", value4 => $an->data->{tools}{boot_nodes}{enabled}
				}, file => $THIS_FILE, line => __LINE__});
				
				# If 'host_stop_reason' is 'clean', don't boot. Otherwise, if the power and 
				# temperature is good, try to boot the node!
				if ($host_stop_reason eq "clean")
				{
					# Leave it off.
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0063", message_variables => {
						node => $host_name, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif (not $an->data->{tools}{boot_nodes}{enabled})
				{
					# Booting is disabled.
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0069", message_variables => {
						node => $host_name, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif ($host_stop_reason =~ /^\d+$/)
				{
					# Timed reboot. See if the timer has expired.
					if (time > $host_stop_reason)
					{
						# Time to boot.
						$an->Log->entry({log_level => 2, message_key => "scancore_log_0067", message_variables => {
							node => $host_name, 
						}, file => $THIS_FILE, line => __LINE__});
						boot_node($an, $host_name, $host_uuid);
					}
					else
					{
						# Not yet time to boot.
						my $time_left = $host_stop_reason - time;
						$an->Log->entry({log_level => 2, message_key => "scancore_log_0068", message_variables => {
							node		=>	$host_name, 
							time_left	=>	$time_left
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
				elsif (not $an->data->{tools}{boot_nodes}{enabled})
				{
					# Booting nodes was disabled by the user.
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0064", message_variables => {
						node => $host_name, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				elsif (($power_is_safe) && ($temperature_is_safe) && ($my_temperature_is_ok))
				{
					# Okie!
					#print "I would have booted the node, but I'm lazy.\n";
					boot_node($an, $host_name, $host_uuid);
				}
				else
				{
					# Not ready to boot yet.
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0062", message_variables => {
						node => $host_name, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		else
		{
			# I don't have any cache files, so ya, no bueno.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0057", file => $THIS_FILE, line => __LINE__});
		}
	}
	else
	{
		# No nodes are in emergency-off, so nothing more to do.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0056", file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This is called when the environment is safe enough to boot a node that was
# put into emergency-stop. If the cache file gave us the power_check_command
# and we can reach the node's IPMI, we'll boot it.
sub boot_node
{
	my ($an, $node, $host_uuid) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "boot_node" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "node",      value1 => "$node", 
		name2 => "host_uuid", value2 => "$host_uuid",
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do I have the node's 'power_check_command'?
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "cache::${node}::info::power_check_command", value1 => $an->data->{cache}{$node}{info}{power_check_command}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{cache}{$node}{info}{power_check_command})
	{
		# Fantastic! Check the power state to see if the node is
		# already online. This can happen is the other Striker 
		# dashboard got to the node faster than us.
		my $boot_node  = 0;
		my $shell_call = $an->data->{cache}{$node}{info}{power_check_command}." -o status; echo rc:\$? 2>&1 |";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($line =~ /^rc:(\d+)$/)
			{
				my $rc = $1;
				# The return code is defined here: 
				# https://fedorahosted.org/cluster/wiki/FenceAgentAPI#agent_ops
				# 
				# 0 - The fence device is reachable and the
				#     port is in the on state.
				# 1 - The fence device could not be reached.
				# 2 - The fence device is reachable and the
				#     port is in the off state.
				$boot_node = 1 if $rc eq "2";
				$an->Log->entry({log_level => 1, message_key => "an_variables_0002", message_variables => {
					name1 => "rc",        value1 => $rc, 
					name2 => "boot_node", value2 => $boot_node,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		
		# So? Are we good to go?
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "boot_node", value1 => $boot_node,
		}, file => $THIS_FILE, line => __LINE__});
		if ($boot_node)
		{
			# About darn time!
			my $shell_call = $an->data->{cache}{$node}{info}{power_check_command}." -o on; echo rc:\$? 2>&1 |";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($line =~ /^rc:(\d+)$/)
				{
					my $rc = $1;
					# 0 - The operation was successful
					# 1 - Not successful or verification 
					#     could not be performed. This 
					#     includes inability to contact the
					#     fence device at any point. 
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "rc", value1 => $rc, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($rc eq "0")
					{
						# Booted!
						$an->Log->entry({log_level => 2, message_key => "scancore_log_0059", message_variables => {
							node	=>	$node,
						}, file => $THIS_FILE, line => __LINE__});
						
						# Clear the 'emergency_stop' flag.
						my $query = "
UPDATE 
    hosts 
SET 
    host_emergency_stop = FALSE, 
    host_stop_reason = NULL
WHERE 
    host_uuid = ".$an->data->{sys}{use_db_fh}->quote($host_uuid)."
;";
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "query", value1 => $query
						}, file => $THIS_FILE, line => __LINE__});
						$an->DB->do_db_write({query => $query});
					}
					else
					{
						# Maybe not booted.
						$an->Log->entry({log_level => 1, message_key => "scancore_log_0060", message_variables => {
							node		=>	$node,
							shell_call	=>	$shell_call, 
							rc		=>	$rc
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
			close $file_handle;
		}
	}
	else
	{
		# Nope :(
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0058", message_variables => {
			node	=>	$node,
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This pulls in the list of UPSes powering the given node and checks to see if they are healthy enough to 
# power the node.
sub check_node_power_health
{
	my ($an, $node) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_power_health" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "node", value1 => "$node" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $power_is_safe = 0;
	
	# This will hold the percentag charge of the strongest UPS powering the
	# node that has input power.
	my $highest_charge = 0;
	
	# Read in the names of the UPSes watched by this node.
	my $query = "
SELECT 
    power_ups_name 
FROM 
    power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query});
	foreach my $row (@{$results})
	{
		my $power_ups_name = $row->[0];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "power_ups_name", value1 => $power_ups_name, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do I know about this UPS?
		if (ref($an->data->{power}{$power_ups_name}))
		{
			# Yup!
			my $power_on_battery        = $an->data->{power}{$power_ups_name}{power_on_battery};
			my $power_charge_percentage = $an->data->{power}{$power_ups_name}{power_charge_percentage};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "power_on_battery",        value1 => $power_on_battery, 
				name2 => "power_charge_percentage", value2 => $power_charge_percentage,
			}, file => $THIS_FILE, line => __LINE__});
			
			$power_on_battery = 1 if $power_on_battery eq "TRUE";
			$power_on_battery = 0 if $power_on_battery eq "FALSE";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "power_on_battery", value1 => $power_on_battery, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ((not $power_on_battery) && ($power_charge_percentage > $highest_charge))
			{
				$highest_charge = $power_charge_percentage;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "highest_charge", value1 => $highest_charge, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	# Now, do I have a UPS above the minimum charge percentage?
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "scancore::minimum_safe_charge", value1 => $an->data->{scancore}{minimum_safe_charge}, 
		name2 => "highest_charge",                value2 => $highest_charge, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($highest_charge > $an->data->{scancore}{minimum_safe_charge})
	{
		# Yup, bueno!
		$power_is_safe = 1;
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "power_is_safe", value1 => $power_is_safe
	}, file => $THIS_FILE, line => __LINE__});
	return($power_is_safe);
}

# This pulls in the list of temperatures for the given node and checks to see 
# if they are healthy enough to power the node back up.
sub check_node_temperature_health
{
	my ($an, $node) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_temperature_health" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "node", value1 => "$node" 
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: When this is called against a dashboard without IPMI, it will
	###       always return OK.
	# This will get set to '0' if the temperature is not OK.
	my $temperature_is_safe = 1;
	
	# Read in all of the temperature entries for this node 
	my $query = "
SELECT 
    temperature_agent_name, 
    temperature_sensor_name, 
    temperature_state 
FROM 
    temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($node).";
";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query});
	foreach my $row (@{$results})
	{
		# If any are in 'warning' or 'critical', set the
		# 'temperature_is_safe' variable to '0'.
		my $temperature_agent_name  = $row->[0];
		my $temperature_sensor_name = $row->[1];
		my $temperature_state       = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "temperature_agent_name",  value1 => $temperature_agent_name, 
			name2 => "temperature_sensor_name", value2 => $temperature_sensor_name, 
			name3 => "temperature_state",       value3 => $temperature_state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($temperature_state ne "ok")
		{
			$temperature_is_safe = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "temperature_is_safe",  value1 => $temperature_is_safe, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	### Make sure that, if the sensors are OK, that we've waited the 
	### required amount of time. If not, set the 'temperature_is_safe' to
	### '0' to prevent booting.
	
	# When a node has gone into emergency stop because of an 
	# over-temperature event, we want to give it time to cool down before
	# we boot it back up.
	# 
	# Likewise, if we rebooted it and it went back down quickly, give it
	# more time before starting it back up. We do this by reading in how
	# many times the node went into thermal shutdown over the last six 
	# hours. The number of returned shut-downs will determine how long I
	# wait before booting the node back up.
	# 
	# The default schedule is:
	# Reboots | Wait until boot
	# --------+-----------------
	#  1      | 10m
	#  2      | 30m
	#  3      | 60m
	#  4      | 120m
	#  >4     | 6h
	# --------+-----------------
	# 
	# NOTE: When a node is off, we can't read most of it's sensors, but I
	#       usually can read 'Ambient' and 'Systemboard'. So before
	#       starting the node, check with these values and make sure 
	#       they're ok. If either are still in warning territory, stay off
	#       no matter what.
	#       
	# To determine the number or reboots, do the following query:
	# 
	# TODO: This will catch power-loss reboots. For now, we aren't going to
	#       worry about this because it is unlikely it would happen at the
	#       same time and even if it did, the consequences aren't that big.
	#       This could be a wrong assumption though, so revisit this later
	#       once testing is under way.
	#     
	# NOTE: As time passes, we may slip into a period where the node starts
	#       rebooting more often until the count goes back up. We may need
	#       to read the time stamps of the last day and analyze the reboot
	#       times later.
	# 
	if ($temperature_is_safe)
	{
		# How often have I shut down?
		my $last_shutdown = 0;
		my $query         = "
SELECT 
    round(extract(epoch from modified_date))
FROM 
    history.hosts 
WHERE 
    host_name = ".$an->data->{sys}{use_db_fh}->quote($node)." 
AND 
    host_emergency_stop = TRUE 
AND 
    host_stop_reason = 'temperature' 
AND 
    modified_date > (now() - interval '6h')
ORDER BY 
    modified_date ASC;
";
		# There should always be at least one.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		my $results        = $an->DB->do_db_query({query => $query});
		my $shutdown_count = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shutdown_count", value1 => $shutdown_count
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$last_shutdown = $row->[0];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "last_shutdown", value1 => $last_shutdown
			}, file => $THIS_FILE, line => __LINE__});
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "last_shutdown", value1 => $last_shutdown
		}, file => $THIS_FILE, line => __LINE__});
		
		# Now I know when the node last shut down and how many times it
		# shut down in the last 6 hours. 
		# 
		# Now, how long should we wait and has it been that long since
		# the last shutdown?
		my $delay = 0;
		if ($shutdown_count > 4)
		{
			# 6 hours
			$delay = $an->data->{scancore}{thermal_reboot_delay}{more};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 4)
		{
			# 2 hours
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'4'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 3)
		{
			# 1 hour
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'3'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 2)
		{
			# 30 minutes
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'2'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 1)
		{
			# 10 minutes
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'1'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# No delay
			$delay = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Now, see if the last reboot time is more than delay time ago.
		if ($delay)
		{
			my $last_shutdown_was = (time - $last_shutdown);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "last_shutdown_was", value1 => $last_shutdown_was, 
				name2 => "delay",             value2 => $delay, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($last_shutdown_was < $delay)
			{
				# Wait longer.
				$temperature_is_safe = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "temperature_is_safe", value1 => $temperature_is_safe
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "temperature_is_safe", value1 => $temperature_is_safe
	}, file => $THIS_FILE, line => __LINE__});
	return($temperature_is_safe);
}

# TODO: This is still to be written...
sub read_temperature_table
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "read_temperature_table" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	
	return(0);
}

# This reads in all of the entries in the 'power' table that this host knows
# about. This will be used by 'do_post_scan_dashboard_tasks()' to see if the 
# node can be booted is it is in an emergency-stop condition because of power
# loss.
sub read_power_table
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_power_table" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, read in the UPS information that I know. The records for the
	# nodes will be stale if they're off so they're not any use to us.
	my $query = "
SELECT 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage 
FROM 
    power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";
";
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $power_ups_name          = $row->[0];
		my $power_on_battery        = $row->[1] ? "TRUE" : "FALSE";
		my $power_seconds_left      = $row->[2];
		my $power_charge_percentage = $row->[3];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "power_ups_name",          value1 => $power_ups_name, 
			name2 => "power_on_battery",        value2 => $power_on_battery, 
			name3 => "power_seconds_left",      value3 => $power_seconds_left, 
			name4 => "power_charge_percentage", value4 => $power_charge_percentage, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Shovel it into the hash
		$an->data->{power}{$power_ups_name} = {
			power_on_battery	=>	$power_on_battery, 
			power_seconds_left	=>	$power_seconds_left, 
			power_charge_percentage	=>	$power_charge_percentage 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "power::${power_ups_name}::power_on_battery",        value1 => $an->data->{power}{$power_ups_name}{power_on_battery}, 
			name2 => "power::${power_ups_name}::power_seconds_left",      value2 => $an->data->{power}{$power_ups_name}{power_seconds_left}, 
			name3 => "power::${power_ups_name}::power_charge_percentage", value3 => $an->data->{power}{$power_ups_name}{power_charge_percentage}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This will check the 'power' and 'temperature' tables. If the UPSes found in
# the local '/etc/hosts' file are both running on batteries, their remaining
# run time is checked. 
sub do_post_scan_node_tasks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "do_post_scan_node_tasks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $hostname       = $an->hostname;
	my $short_hostname = $an->short_hostname;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "hostname",       value1 => $hostname, 
		name2 => "short_hostname", value2 => $short_hostname, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my ($node_power_ok) = check_node_power($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_power_ok", value1 => $node_power_ok,
	}, file => $THIS_FILE, line => __LINE__});
	
	my ($node_temperature_ok) = check_node_temperature($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_temperature_ok", value1 => $node_temperature_ok,
	}, file => $THIS_FILE, line => __LINE__});
	
	### TODO: Enable load shedding where, if the power is out for > 5 
	###       minutes and/or if the temperature has climbed into warning
	###       on both nodes for > 5 minutes, consolidate the VMs by 
	###       migrating servers from the node with the lease guests to the
	###       node with the most guests (to minimize migration time) and 
	###       then power off the node. To this, I will need to know who my
	###       peer is and read in the UPS and thermal data for both of us,
	###       looking at the times that we both went into a 'warning' 
	###       state.
	
	# OK, if both are '1', make sure our health file is set to 'OK'. If 
	# either returned '2', make sure our health file is set to 'Warning'.
	# If either returned '3', set the health file to 'Critical' and set the
	# hosts -> host_emergency_stop to TRUE and then call 
	# 'safe_anvil_shutdown'.
	if (($node_power_ok eq "3") || ($node_temperature_ok eq "3"))
	{
		# Set the health to 'Critical'.
		update_health_file($an, 3);
		
		# Why exactly are we shutting down?
		my $host_stop_reason = $node_power_ok eq "3" ? "power" : "temperature";
		
		# Update hosts to set host_emergency_stop to TRUE
		my $query = "
UPDATE 
    hosts 
SET 
    host_emergency_stop = TRUE, 
    host_stop_reason    = ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query});
		
		my $do_shutdown = 1;
		my $message_key = "scancore_error_0015";
		if ((($host_stop_reason eq "power")       && ($an->data->{scancore}{disable}{power_shutdown})) or 
		    (($host_stop_reason eq "temperature") && ($an->data->{scancore}{disable}{thermal_shutdown})))
		{
			# Shutdown has been disabled.
			$do_shutdown = 0;
			$message_key = "scancore_error_0016";
		}
		# Send our final email.
		$an->Alert->register_alert({
			alert_level		=>	"critical", 
			alert_agent_name	=>	"$THIS_FILE",
			alert_title_key		=>	"an_alert_title_0005",
			alert_message_key	=>	$message_key,
			alert_message_variables	=>	{
				node			=>	$an->hostname,
			},
		});
		
		# Send the email
		process_alerts($an, 0);
		if ($do_shutdown)
		{
			# And now die via 'safe_anvil_shutdown'. We should be dead 
			# before this exits. So ya, so long and thanks for all the
			# fish.
			my $shell_call = $an->data->{path}{safe_anvil_shutdown}." 2>&1 |";
			open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$line =~ s/\n//g;
				$line =~ s/\r//g;
				$an->Log->entry({log_level => 1, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			# Why are we still alive? die already.
			exit(255);
		}
		else
		{
			# We're not going to die, so record that we've warned the user.
			my $cleared = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	$an->hostname,
				alert_name		=>	"shutdown_should_have_happened",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
		}
	}
	elsif (($node_power_ok eq "2") || ($node_temperature_ok eq "2"))
	{
		### We're sick
		# Set the health to 'Warning'.
		update_health_file($an, 2);
		
		# Tell the user that we're no longer a migration target.
		my $set = $an->Alert->check_alert_sent({
			type			=>	"warning",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	$an->hostname,
			alert_name		=>	"node_sick",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		if ($set)
		{
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0004",
				alert_message_key	=>	"scancore_warning_0012",
				alert_message_variables	=>	{
					node			=>	$an->hostname,
				},
			});
			
			# Send the email
			process_alerts($an, 0);
		}
	}
	else
	{
		### We're healthy
		# Set the health to 'OK'.
		update_health_file($an, 1);
		
		# If we were previously sick, tell the user that we're OK now.
		my $cleared_node_sick = $an->Alert->check_alert_sent({
			type			=>	"clear",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	$an->hostname,
			alert_name		=>	"node_sick",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		my $cleared_poweroff = $an->Alert->check_alert_sent({
			type			=>	"clear",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	$an->hostname,
			alert_name		=>	"shutdown_should_have_happened",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		if ($cleared_node_sick)
		{
			# Tell the user that we're OK.
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_agent_name	=>	"$THIS_FILE",
				alert_title_key		=>	"an_alert_title_0006",
				alert_message_key	=>	"scancore_warning_0013",
				alert_message_variables	=>	{
					node			=>	$an->hostname,
				},
			});
			
			# Send the email
			process_alerts($an, 0);
		}
	}
	
	return(0);
}

# This looks to see if the directory '/shared/status' exists. If it does, we 
# assume the cluster is up and will create or update 
# '/shared/status.<node_short_name>' to have 'health = [ok|warning|critical]
# depending on the passed-in health level.
sub update_health_file
{
	my ($an, $health_level) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_health_file" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "health_level", value1 => "$health_level" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $health_file = $an->data->{path}{health_file}."/.".$an->short_hostname;
	my $say_health  = "health = ok\n";
	   $say_health  = "health = warning\n"  if $health_level eq "2";
	   $say_health  = "health = critical\n" if $health_level eq "3";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "health_file", value1 => $health_file, 
		name2 => "say_health",  value2 => $say_health, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if (-d $an->data->{path}{health_file})
	{
		# Cluster is up, write the file.
		my $shell_call = $health_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# We don't die if we fail to write. If the system needs to 
		# poweroff, this is not the time to be exiting on small errors.
		open (my $file_handle, ">$shell_call") or $an->Alert->error({fatal => 0, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		print $file_handle $say_health;
		close $file_handle;
	}
	else
	{
		# Can't write, cluster may be down (in which case, we aren't a
		# migration target anyway so it hardly matters).
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0054", message_variables => {
			health_file => $health_file, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This pulls the data on the various temperature sensors. If all are within
# acceptible ranges, '1' will be returned. If any are in warning or critical
# state, '2' will be returned. If enough are critical to trigger power-down,
# '3' will be returned.
sub check_node_temperature
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_temperature" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# 1 == OK, 2 == Warning, 3 == Critical (should shut down)
	my $node_temperature_ok   = 1;
	my $default_sensor_weight = $an->data->{scancore}{temperature}{default_sensor_weight} ? $an->data->{scancore}{temperature}{default_sensor_weight} : 1;
	my $shutdown_threshold    = $an->data->{scancore}{temperature}{shutdown_limit}        ? $an->data->{scancore}{temperature}{shutdown_limit}        : 5;
	my $total_sensor_weight   = 0;
	
	# Read in the temperature values for this machine.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "node_temperature_ok",   value1 => $node_temperature_ok,
		name2 => "default_sensor_weight", value2 => $default_sensor_weight,
		name3 => "shutdown_threshold",    value3 => $shutdown_threshold,
		name4 => "total_sensor_weight",   value4 => $total_sensor_weight,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Pull in all the thermal sensors for this host. If any are returned,
	# 'node_temperature_ok' will get set to '2'. If any are critical, their
	# weight will be added to 'total_sensor_weight'. If the final weight is
	# higher than 'shutdown_threshold', 'node_temperature_ok' will get set
	# to '3'.
	my $query = "
SELECT 
    temperature_agent_name, 
    temperature_sensor_name, 
    temperature_state 
FROM 
    temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($an->hostname).";
";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	
	# If there are no results, then mark power as always OK because #yolo
	my $sensor_count = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sensor_count", value1 => $sensor_count
	}, file => $THIS_FILE, line => __LINE__});
	if (not $sensor_count)
	{
		# No sensors are high, we're done.
		return($node_temperature_ok);
	}
	
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $temperature_agent_name  = $row->[0];
		my $temperature_sensor_name = $row->[1];
		my $temperature_state       = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "temperature_agent_name",  value1 => $temperature_agent_name,
			name2 => "temperature_sensor_name", value2 => $temperature_sensor_name,
			name3 => "temperature_state",       value3 => $temperature_state,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If this is a sensor that is 'ok', skip it. Otherwise, we'll
		# set the 'node_temperature_ok' to '2' (which may get set to
		# '3' after these checks are done.
		next if $temperature_state eq "ok";
		$node_temperature_ok = 2;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_temperature_ok", value1 => $node_temperature_ok,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If it is critical, find this sensor's weight and add it to 
		# the total.
		if ($temperature_state =~ /critical/)
		{
			# Get the weight of the sensor.
			my $this_sensor_weight = $default_sensor_weight;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "total_sensor_weight",                                                       value1 => $total_sensor_weight, 
				name2 => "this_sensor_weight",                                                        value2 => $this_sensor_weight,
				name3 => "${temperature_agent_name}::thresholds::${temperature_sensor_name}::weight", value3 => $an->data->{$temperature_agent_name}{thresholds}{$temperature_sensor_name}{weight},
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{$temperature_agent_name}{thresholds}{$temperature_sensor_name}{weight})
			{
				$this_sensor_weight = $an->data->{$temperature_agent_name}{thresholds}{$temperature_sensor_name}{weight};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "this_sensor_weight", value1 => $this_sensor_weight,
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			$total_sensor_weight += $this_sensor_weight;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "total_sensor_weight", value1 => $total_sensor_weight,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "total_sensor_weight", value1 => $total_sensor_weight,
		name2 => "shutdown_threshold",  value2 => $shutdown_threshold,
	}, file => $THIS_FILE, line => __LINE__});
	if ($total_sensor_weight > $shutdown_threshold)
	{
		$node_temperature_ok = 3;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_temperature_ok", value1 => $node_temperature_ok,
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_temperature_ok", value1 => $node_temperature_ok,
	}, file => $THIS_FILE, line => __LINE__});
	return($node_temperature_ok);
}

# This pulls the data on the UPSes associated with this node and returns '1' if
# at least one of the UPSes has power, '2' if neither do but the hold-up time 
# of at least one is above minimum and '3' if both are on batteries and below
# the minimum hold-up time.
sub check_node_power
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_power" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $node_power_ok       = 1;
	my $a_ups_has_input     = 0;
	my $highest_holdup_time = 0;
	my $minimum_ups_runtime = $an->data->{scancore}{minimum_ups_runtime};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "node_power_ok",       value1 => $node_power_ok,
		name2 => "a_ups_has_input",     value2 => $a_ups_has_input,
		name3 => "highest_holdup_time", value3 => $highest_holdup_time,
		name4 => "minimum_ups_runtime", value4 => $minimum_ups_runtime,
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, see if my UPSes have input power. If not:
	# * See which has the longest hold-up time. If one of them is above the
	#   minimum hold-up time, set our health to '2/warning'.
	# * If the strongest is too low, set our health to '3/critical' and
	#   shut down.
	my $query = "
SELECT 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left 
FROM 
    power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	
	# If there are no results, then mark power as always OK because #yolo
	my $ups_count = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "ups_count", value1 => $ups_count
	}, file => $THIS_FILE, line => __LINE__});
	if (not $ups_count)
	{
		return(0);
	}
	
	# NOTE: I know I could sort by remaining hold-up time and/or filter by
	#       which UPS is on batteries, but slurping it all in makes it 
	#       easier to debug with everything in perl.
	my $last_agent = "";
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $power_ups_name     = $row->[0];
		my $power_on_battery   = $row->[1];
		my $power_seconds_left = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "power_ups_name",     value1 => $power_ups_name,
			name2 => "power_on_battery",   value2 => $power_on_battery,
			name3 => "power_seconds_left", value3 => $power_seconds_left,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record the highest hold-up time.
		if ($power_seconds_left > $highest_holdup_time)
		{
			$highest_holdup_time = $power_seconds_left;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "highest_holdup_time", value1 => $highest_holdup_time,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Are we on batteries?
		if ($power_on_battery)
		{
			# Well poop.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "power_seconds_left",  value1 => $power_seconds_left,
				name2 => "highest_holdup_time", value2 => $highest_holdup_time,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# We've got input power, sweeeet.
			$a_ups_has_input = 1;
			$node_power_ok   = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "node_power_ok", value1 => $node_power_ok,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	$results = "";
	
	# Now, if no UPS has input power, see if the highest holdup time 
	# exceeds the minimum required to avoid a shut down.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "a_ups_has_input", value1 => $a_ups_has_input,
	}, file => $THIS_FILE, line => __LINE__});
	if ($a_ups_has_input)
	{
		$node_power_ok = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_power_ok", value1 => $node_power_ok,
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# No input power from mains...
		$node_power_ok = 2;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "node_power_ok",       value1 => $node_power_ok,
			name2 => "minimum_ups_runtime", value2 => $minimum_ups_runtime, 
			name3 => "highest_holdup_time", value3 => $highest_holdup_time, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($minimum_ups_runtime > $highest_holdup_time)
		{
			# Time to go zzz
			$node_power_ok = 3;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "node_power_ok", value1 => $node_power_ok,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_power_ok", value1 => $node_power_ok,
	}, file => $THIS_FILE, line => __LINE__});
	return ($node_power_ok);
}

# This looks at any agents and reads in their strings XML files.
sub load_agent_strings
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "load_agent_strings" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through the agents directory and call each agent. Record how long it takes and note the exit 
	# code, then record the run-data in the database.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::agents_directory", value1 => $an->data->{path}{agents_directory}
	}, file => $THIS_FILE, line => __LINE__});
	scan_directory($an, $an->data->{path}{agents_directory});
	
	# Now loop through the agents I found and try calling them.
	foreach my $agent (sort {$a cmp $b} @{$an->data->{sys}{agents}})
	{
		### TODO: Put a time limit on these...
		my $strings =  $agent.".xml";
		   $agent   =~ s/^.*\///;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "agent",   value1 => $agent, 
			name2 => "strings", value2 => $strings, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ((-e $strings) && (-r $strings))
		{
			# Read the strings file.
			$an->String->read_words({file => $strings});
		}
	}
	$an->data->{sys}{agents} = [];
	
	return(0);
}

# This reads in the 'alerts' table and generates the emails/log file entries as needed.
sub process_alerts
{
	my ($an, $first_run) = @_;
	$first_run = 0 if not defined $first_run;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_alerts", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "first_run", value1 => $first_run
	}, file => $THIS_FILE, line => __LINE__});
	
	# Read in all pending alerts
	my $query = "
SELECT 
    alert_uuid, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    modified_date
FROM 
    alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		# One or more records were found.
		my $alert_uuid              = $row->[0]; 
		my $alert_agent_name        = $row->[1]; 
		my $alert_level             = $row->[2]; 
		my $alert_title_key         = $row->[3]; 
		my $alert_title_variables   = $row->[4]; 
		my $alert_message_key       = $row->[5]; 
		my $alert_message_variables = $row->[6]; 
		my $modified_date           = $row->[7]; 
		$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
			name1 => "alert_uuid",              value1 => $alert_uuid, 
			name2 => "alert_agent_name",        value2 => $alert_agent_name, 
			name3 => "alert_level",             value3 => $alert_level, 
			name4 => "alert_title_key",         value4 => $alert_title_key, 
			name5 => "alert_title_variables",   value5 => $alert_title_variables, 
			name6 => "alert_message_key",       value6 => $alert_message_key, 
			name7 => "alert_message_variables", value7 => $alert_message_variables, 
			name8 => "modified_date",           value8 => $alert_message_variables, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Sometimes alerts are sent by modules. In those cases, ignore them.
		$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid} = {
			alert_level             => $alert_level, 
			alert_title_key         => $alert_title_key, 
			alert_title_variables   => $alert_title_variables, 
			alert_message_key       => $alert_message_key, 
			alert_message_variables => $alert_message_variables,
			modified_date           => $modified_date
		};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
			name1 => "db::alerts::agent_name::${alert_agent_name}::alert_uuid::${alert_uuid}::alert_level",             value1 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_level},
			name2 => "db::alerts::agent_name::${alert_agent_name}::alert_uuid::${alert_uuid}::alert_title_key",         value2 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_title_key},
			name3 => "db::alerts::agent_name::${alert_agent_name}::alert_uuid::${alert_uuid}::alert_title_variables",   value3 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_title_variables},
			name4 => "db::alerts::agent_name::${alert_agent_name}::alert_uuid::${alert_uuid}::alert_message_key",       value4 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_message_key},
			name5 => "db::alerts::agent_name::${alert_agent_name}::alert_uuid::${alert_uuid}::alert_message_variables", value5 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_message_variables},
			name6 => "db::alerts::agent_name::${alert_agent_name}::alert_uuid::${alert_uuid}::modified_date",           value6 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{modified_date},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Process alerts, if any.
	if (ref($an->data->{db}{alerts}{agent_name}))
	{
		# Sort out who is getting which alerts.
		foreach my $integer (sort {$a cmp $b} keys %{$an->data->{alerts}{recipient}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "integer",                              value1 => $integer,
				name2 => "alerts::recipient::${integer}::email", value2 => $an->data->{alerts}{recipient}{$integer}{email},
				name3 => "alerts::recipient::${integer}::file",  value3 => $an->data->{alerts}{recipient}{$integer}{file},
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{alerts}{recipient}{$integer}{email})
			{
				# Email recipient
				send_email($an, $an->data->{alerts}{recipient}{$integer}{email});
			}
			elsif ($an->data->{alerts}{recipient}{$integer}{file})
			{
				# Write to a file
				record_alert_to_file($an, $an->data->{alerts}{recipient}{$integer}{file});
			}
			else
			{
				# Bad entry
				$an->Log->entry({log_level => 3, message_key => "scancore_log_0051", file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# All done, delete the public.alerts entries.
		$query = "DELETE FROM alerts WHERE alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query});
		
		# Delete the alerts from memory.
		delete $an->data->{db}{alerts};
		
		# Mark that an alert was sent
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0053", file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# No alerts
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0052", file => $THIS_FILE, line => __LINE__}) if not $first_run;
	}
	
	return(0);
}

# This sends any pending alerts to a give recipient, if applicable.
sub send_email
{
	my ($an, $variables) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "send_email" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "variables", value1 => "$variables" 
	}, file => $THIS_FILE, line => __LINE__});
	
	# The 'subject' will hold the highest alert seen and be used to 
	# generate a proper email subject prior to dispatching the email 
	# proper.
	my $subject  = 5;
	my $body     = "";
	my $name     = "";
	my $email    = "";
	my $language = $an->data->{scancore}{language};
	my $level    = "warning";
	my $units    = "metric";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "language", value1 => $language, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $pair (split/,/, $variables)
	{
		next if not $pair;
		my ($variable, $value) = ($pair =~ /^(.*?)="(.*)"/);
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "variable", value1 => $variable, 
			name2 => "value",    value2 => $value, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if    ($variable eq "name")     { $name     = $value; }
		elsif ($variable eq "email")    { $email    = $value; }
		elsif ($variable eq "language") { $language = $value; }
		elsif ($variable eq "level")    { $level    = $value; }
		elsif ($variable eq "units")    { $units    = $value; }
		else
		{
			# Invalid entry.
			$an->Log->entry({log_level => 1, message_key => "scancore_warning_0009", message_variables => {
				variable => $variable, 
				value    => $value, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
		name1 => "name",     value1 => $name, 
		name2 => "email",    value2 => $email, 
		name3 => "language", value3 => $language, 
		name4 => "level",    value4 => $level, 
		name5 => "units",    value5 => $units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Convert the user's log level to a numeric number for easier comparison.
	$level = $an->Alert->convert_level_name_to_number({level => $level});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "level", value1 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Generate the title key.
	my $lowest_level = 5;
	foreach my $alert_agent_name (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "alert_agent_name", value1 => $alert_agent_name, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_uuid (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_uuid", value1 => $alert_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $alert_level             = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_level};
			my $alert_title_key         = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_title_key};
			my $alert_title_variables   = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_title_variables};
			my $alert_message_key       = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_message_key};
			my $alert_message_variables = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_message_variables};
			
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "alert_level",             value1 => $alert_level, 
				name2 => "alert_title_key",         value2 => $alert_title_key, 
				name3 => "alert_title_variables",   value3 => $alert_title_variables, 
				name4 => "alert_message_key",       value4 => $alert_message_key, 
				name5 => "alert_message_variables", value5 => $alert_message_variables, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$alert_level = $an->Alert->convert_level_name_to_number({level => $alert_level});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "alert_level",  value1 => $alert_level, 
				name2 => "lowest_level", value2 => $lowest_level, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($alert_level < $lowest_level)
			{
				$lowest_level = $alert_level;
			}
			
			# Record the alert level if it's higher than we saw
			# before.
			$subject = $alert_level if $subject > $alert_level;
			
			# The conversion of C to F is handled in 
			# translate_sensor_{name,value}() functions.
			my $title   = get_string_from_double_bang($an, $language, $alert_title_key, $alert_title_variables, $units);
			my $message = get_string_from_double_bang($an, $language, $alert_message_key, $alert_message_variables, $units);
			if ($level >= $alert_level)
			{
				#print "$THIS_FILE ".__LINE__."; Sending alert: [$alert_uuid] to: [$name <$email>] in the language: [$language]...\n";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "title",   value1 => $title, 
					name2 => "message", value2 => $message, 
				}, file => $THIS_FILE, line => __LINE__});
				$body .= $an->String->get({
					language	=>	$language,
					key		=>	"scancore_email_0005",
					variables	=>	{
						title		=>	$title,
						message		=>	$message
					},
				})."\n\n";
			}
			else
			{
				# Ignored
				$an->Log->entry({log_level => 3, message_key => "scancore_log_0050", message_variables => {
					user       => "$name <$email>",
					alert_uuid => $alert_uuid, 
					title      => $title,
					message    => $message
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	# Generate the email body.
	my $subject_line = $an->String->get({
		language	=>	$language,
		key		=>	"scancore_email_0004",
		variables	=>	{
			hostname	=>	$an->hostname,
		},
	});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "subject", value1 => $subject, 
	}, file => $THIS_FILE, line => __LINE__});
	my $say_subject = $an->String->get({
		language	=>	$language,
		key		=>	"scancore_email_0001",
		variables	=>	{
			level		=>	"#!string!an_alert_subject_".sprintf("%04d", $lowest_level)."!#",
			subject		=>	$subject_line,
		},
	});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "say_subject", value1 => $say_subject, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# The footer is a generic message tell the user not to yell at us for spamming them. (hey, you laugh,
	# but managers will get these emails...)
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::append_email_footer", value1 => $an->data->{scancore}{append_email_footer}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{append_email_footer})
	{
		$body .= $an->String->get({
			language	=>	$language,
			key		=>	"scancore_email_0003",
			variables	=>	{
				hostname	=>	$an->hostname,
			},
		});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "body", value1 => $body, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Now assemble the message.
	my $say_to = "$name <$email>";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "smtp::username", value1 => $an->data->{smtp}{username},
		name2 => "say_to",         value2 => $say_to, 
		name3 => "say_subject",    value3 => $say_subject,
		name4 => "body",           value4 => $body,
	}, file => $THIS_FILE, line => __LINE__});
	my $email_body = $an->String->get({
		language	=>	$language,
		key		=>	"scancore_email_0002",
		variables	=>	{
			from		=>	$an->data->{smtp}{username},
			to		=>	$say_to,
			subject		=>	$say_subject,
			body		=>	$body,
		},
	});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "email_body", value1 => $email_body,
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, see if the relay file needs to be updated.
	check_email_configuration($an);
	
	# Select a known_free email file name.
	my $email_file = $an->data->{path}{email_directory}."/".get_date($an).".1";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "email_file", value1 => $email_file,
	}, file => $THIS_FILE, line => __LINE__});
	my $file_ok = 0;
	until ($file_ok)
	{
		if (-e $email_file)
		{
			my ($file, $suffix) = ($email_file =~ /^(.*?)\.(\d+)$/);
			$suffix++;
			$email_file = "$file.$suffix\n";
			# Make sure I'm not sending more than 10/sec...
			if ($suffix > 10)
			{
				# Given the precision of the date coming from
				# pgsql, there must be something wrong.
				$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0014", message_variables => { 
					file => $email_file, 
				}, code => 2, file => "$THIS_FILE", line => __LINE__});
			}
		}
		else
		{
			$file_ok = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "email_file", value1 => $email_file,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Write out the email file.
	my $shell_call = $email_file;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	print $file_handle $email_body;
	close $file_handle;
	
	# Now send the email.
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0049", message_variables => {
		file => $email_file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	$shell_call = $an->data->{path}{mailx}." -t < $email_file 2>&1 |";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	return(0);
}

# This gets the current date and time from one of the databases.
sub get_date
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_date" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $query = "SELECT now();";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date =  $an->DB->do_db_query({query => $query})->[0]->[0];
	   $date =~ s/ /_/g;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date
	}, file => $THIS_FILE, line => __LINE__});
	
	return($date);
}

# This records entries from alerts to a file, if applicable.
sub record_alert_to_file
{
	my ($an, $variables) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "record_alert_to_file" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "variables", value1 => "$variables" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $messages = "";
	my $file     = "";
	my $language = $an->data->{scancore}{language};
	my $level    = "warning";
	my $units    = "metric";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "language", value1 => $language, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $pair (split/,/, $variables)
	{
		next if not $pair;
		my ($variable, $value) = ($pair =~ /^(.*?)="(.*)"/);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "variable", value1 => $variable, 
			name2 => "value",    value2 => $value, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if    ($variable eq "file")     { $file     = $value; }
		elsif ($variable eq "language") { $language = $value; }
		elsif ($variable eq "level")    { $level    = $value; }
		elsif ($variable eq "units")    { $units    = $value; }
		else
		{
			# Invalid entry.
			$an->Log->entry({log_level => 0, message_key => "scancore_warning_0010", message_variables => {
				variable => $variable, 
				value    => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			exit(8);
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "file",     value1 => $file, 
		name2 => "language", value2 => $language, 
		name3 => "level",    value3 => $level, 
		name4 => "units",    value4 => $units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Convert the user's log level to a numeric number for easier
	# comparison.
	$level = $an->Alert->convert_level_name_to_number({level => $level});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "level", value1 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Loop through all the alerts and prep the relevant ones to be written
	# to the file.
	foreach my $alert_agent_name (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "alert_agent_name", value1 => $alert_agent_name, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_uuid (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_uuid", value1 => $alert_uuid, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $alert_level             = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_level};
			my $alert_title_key         = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_title_key};
			my $alert_title_variables   = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_title_variables};
			my $alert_message_key       = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_message_key};
			my $alert_message_variables = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{alert_message_variables};
			my $modified_date           = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_uuid}{$alert_uuid}{modified_date};
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "alert_level",             value1 => $alert_level, 
				name2 => "alert_title_key",         value2 => $alert_title_key, 
				name3 => "alert_title_variables",   value3 => $alert_title_variables, 
				name4 => "alert_message_key",       value4 => $alert_message_key, 
				name5 => "alert_message_variables", value5 => $alert_message_variables, 
				name6 => "modified_date",           value6 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$alert_level = $an->Alert->convert_level_name_to_number({level => $alert_level});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_level", value1 => $alert_level, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($level >= $alert_level)
			{
				my $title    =  get_string_from_double_bang($an, $language, $alert_title_key, $alert_title_variables, $units);
				my $message  =  get_string_from_double_bang($an, $language, $alert_message_key, $alert_message_variables, $units);
				my $say_date =  $modified_date;
				   $say_date =~ s/(\d+-\d+-\d+ \d+:\d+:\d+)\.\d+(.*)$/$1 (GMT$2)/;
				
				my $string = $an->String->get({
					key			=>	"scancore_log_0033",
					variables		=>	{
						date			=>	$say_date,
						alert_agent_name	=>	$alert_agent_name,
						title			=>	$title, 
						message			=>	$message, 
					},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "string", value1 => $string, 
				}, file => $THIS_FILE, line => __LINE__});
				$messages .= "$string\n";
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0032", message_variables => {
		file => $file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Append to the log file.
	my $shell_call = ">>$file";
	open (my $filehandle, "$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	print $filehandle $messages;
	close $filehandle;
	
	return(0);
}

# This checks the local postfix and mail relay data and updates if needed.
sub check_email_configuration
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_email_configuration" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Checking to see of the email relay file needs to be created or updated.
	my $write_relay_file = 0;
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0034", message_variables => {
		postfix_relay_file => $an->data->{path}{postfix_relay_file}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{postfix_relay_file})
	{
		# It exists, reading it.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0035", file => $THIS_FILE, line => __LINE__});
		my $shell_call = $an->data->{path}{postfix_relay_file};
		open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^\[(.*?)\]:(\d+)\s(.*?):(.*)$/)
			{
				my $server   = $1;
				my $port     = $2;
				my $username = $3;
				my $password = $4;
				
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "server",       value1 => $server, 
					name2 => "smtp::server", value2 => $an->data->{smtp}{server},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "port",       value1 => $port, 
					name2 => "smtp::port", value2 => $an->data->{smtp}{port},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "username",       value1 => $username, 
					name2 => "smtp::username", value2 => $an->data->{smtp}{username},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "password",       value1 => $password, 
					name2 => "smtp::password", value2 => $an->data->{smtp}{password},
				}, file => $THIS_FILE, line => __LINE__});
				if (($server   ne $an->data->{smtp}{server}) ||
				    ($port     ne $an->data->{smtp}{port}) ||
				    ($username ne $an->data->{smtp}{username}) ||
				    ($password ne $an->data->{smtp}{password}))
				{
					# Changes made
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0036", file => $THIS_FILE, line => __LINE__});
					$write_relay_file = 1;
				}
				else
				{
					# No change
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0047", file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		close $file_handle;
	}
	else
	{
		# Relay file doesn't exist at all, so this might be an upgrade.
		# As such, check that the programs we need are installed.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0037", file => $THIS_FILE, line => __LINE__});
		$write_relay_file = 1;
	}
	
	# (Re)write the relay file now, if needed.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "write_relay_file", value1 => $write_relay_file, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($write_relay_file)
	{
		# Write the new relay file.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0034", message_variables => {
			postfix_relay_file => $an->data->{path}{postfix_relay_file}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $shell_call   = $an->data->{path}{postfix_relay_file};
		my $postfix_line = "[".$an->data->{smtp}{server}."]:".$an->data->{smtp}{port}." ".$an->data->{smtp}{username}.":".$an->data->{smtp}{password};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call",   value1 => $shell_call, 
			name2 => "postfix_line", value2 => $postfix_line,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		print $file_handle "$postfix_line\n";
		close $file_handle;
		
		# Generate the binary version.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0039", file => $THIS_FILE, line => __LINE__});
		$shell_call = $an->data->{path}{postmap}." ".$an->data->{path}{postfix_relay_file}." 2>&1 |";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# If I am writing the file, there is a chance that postfix
		# hasn't been configured yet. So check it and, if needed,
		# fix it.
		my $backup_file = $an->data->{path}{postfix_main}.".anvil";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "backup_file", value1 => $backup_file, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not -e $backup_file)
		{
			# Backup the original.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0034", message_variables => {
				source      => $an->data->{path}{postfix_main},
				destination =>  $backup_file,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $shell_call = $an->data->{path}{cp}." --archive --no-clobber --verbose ".$an->data->{path}{postfix_main}." $backup_file 2>&1 |";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		else
		{
			# Already backed up
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0040", file => $THIS_FILE, line => __LINE__});
		}
		
		# Now update the postfix main.cf file by reading it in and
		# replacing the variables we want to update, then writing it
		# all back out.
		my $postfix_main = "";
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0041", message_variables => {
			postfix_main => $an->data->{path}{postfix_main}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$shell_call = $an->data->{path}{postfix_main};
		open ($file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			
			# Avoid duplicates
			next if $line =~ /^relayhost = \[/;
			next if $line =~ /^smtp_use_tls =/;
			next if $line =~ /^smtp_sasl_auth_enable =/;
			next if $line =~ /^smtp_sasl_password_maps =/;
			next if $line =~ /^smtp_sasl_security_options =/;
			next if $line =~ /^smtp_tls_CAfile =/;
			
			if ($line =~ /#relayhost = \[an.ip.add.ress\]/)
			{
				# Insert the mail relay configuration here.
				$an->Log->entry({log_level => 3, message_key => "scancore_log_0042", file => $THIS_FILE, line => __LINE__});
				# TODO: Find out how to support non-secure mail
				#       servers.
				# TODO: Experiment if I really need to define
				#       the mail server and IP both here and in
				#       the relay file.
				$postfix_main .= "$line\n";
				$postfix_main .= "relayhost = [".$an->data->{smtp}{server}."]:".$an->data->{smtp}{port}."\n";
				$postfix_main .= "smtp_use_tls = yes\n";
				$postfix_main .= "smtp_sasl_auth_enable = yes\n";
				$postfix_main .= "smtp_sasl_password_maps = hash:".$an->data->{path}{postfix_relay_file}."\n";
				$postfix_main .= "smtp_sasl_security_options =\n";
				$postfix_main .= "smtp_tls_CAfile = /etc/pki/tls/certs/ca-bundle.crt\n";
			}
			else
			{
				$postfix_main .= "$line\n";
			}
		}
		close $file_handle;
		
		# Write out the new version.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0043", message_variables => {
			postfix_main => $an->data->{path}{postfix_main}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record the config in the main log
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "postfix_main", value1 => $postfix_main, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the actual write...
		$shell_call = $an->data->{path}{postfix_main};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call",   value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		print $file_handle $postfix_main;
		close $file_handle;
		
		# Reload postfix
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0044", file => $THIS_FILE, line => __LINE__});
		$shell_call = $an->data->{path}{postfix_init}." restart 2>&1 |";
		open ($file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\n//g;
			$line =~ s/\r//g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		sleep 2;
	}
	
	# Make sure the mail alerts directory exists and create it if not.
	if (-e $an->data->{path}{email_directory})
	{
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0055", message_variables => {
			email_directory => $an->data->{path}{email_directory}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Need to create it.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0045", message_variables => {
			email_directory => $an->data->{path}{email_directory}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		mkdir $an->data->{path}{email_directory} or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0019", message_variables => {
								directory => $an->data->{path}{email_directory}, 
								error     => $! 
							}, code => 2, file => "$THIS_FILE", line => __LINE__});
		
		# Set the mode
		my $directory_mode = 0775;
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0046", message_variables => {
			directory_mode => sprintf("%04o", $directory_mode), 
		}, file => $THIS_FILE, line => __LINE__});
		chmod $directory_mode, $an->data->{path}{email_directory};
	}
	
	return(0);
}

# This converts the string keys and variables stored in the alerts table 
# (flanked with '!!') to strings. It also handles the special 'sensor' data and
# will convert metric to imperial values as needed.
sub get_string_from_double_bang
{
	my ($an, $language, $key, $variables, $units) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "get_string_from_double_bang" }, message_key => "an_variables_0004", message_variables => { 
		name1 => "language",  value1 => $language, 
		name2 => "key",       value2 => $key,  
		name3 => "variables", value3 => $variables, 
		name4 => "units",     value4 => $units
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($variables)
	{
		my $hash = {};
		foreach my $pair (split/,/, $variables)
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "pair", value1 => $pair, 
			}, file => $THIS_FILE, line => __LINE__});
			next if not $pair;
			my ($variable, $value) = ($pair =~ /^!!(.*?)!(.*)!!$/);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "variable", value1 => $variable, 
				name2 => "value",    value2 => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			die "$THIS_FILE ".__LINE__."; No variable parsed from: [$pair]\n" if not defined $variable;
			die "$THIS_FILE ".__LINE__."; No value parsed from: [$pair]\n"    if not defined $value;
			
			# If the value is one of the special sensor name or 
			# value strings, translate it.
			if ($variable eq "sensor_name") 
			{
				my ($sensor_name, $sensor_units) = ($value =~ /name=(.*?):units=(.*)$/);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "sensor_name",  value1 => $sensor_name, 
					name2 => "sensor_units", value2 => $sensor_units, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$value = translate_sensor_name($an, $sensor_name, $sensor_units);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			# Catch 'sensor_value', 'new_sensor_value' and 
			# 'old_sensor_value'.
			elsif ($variable =~ /sensor_value/)
			{
				my ($sensor_value, $sensor_units) = ($value =~ /value=(.*?):units=(.*)$/);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "sensor_value", value1 => $sensor_value, 
					name2 => "sensor_units", value2 => $sensor_units, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$value = translate_sensor_value($an, $sensor_value, $sensor_units, $units);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			$hash->{$variable} = $value;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "hash->{$variable}", value1 => $hash->{$variable}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		$variables = $hash;
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "language",  value1 => $language, 
		name2 => "key",       value2 => $key, 
		name3 => "variables", value3 => $variables, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $string = $an->String->get({
		language  => $language,
		key       => $key,
		variables => $variables
	});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "string", value1 => $string, 
	}, file => $THIS_FILE, line => __LINE__});
	return($string);
}

# This and translate_sensor_value() are special functions used to translate 
# PMI sensor data into a user's chosen language and units (metric v. imperial).
sub translate_sensor_name
{
	my ($an, $ipmitool_sensor_name, $ipmitool_sensor_units) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "translate_sensor_name", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "ipmitool_sensor_name",  value1 => $ipmitool_sensor_name, 
		name2 => "ipmitool_sensor_units", value2 => $ipmitool_sensor_units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $say_sensor_name = $ipmitool_sensor_name;
	
	# Now, if it's a sensor we know, we'll not use the base units but
	# instead five it a proper name. We'll translate the value after.
	my $say_units = $ipmitool_sensor_units;
	if ($ipmitool_sensor_units eq "C")
	{
		if ($say_sensor_name eq "Ambient")
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0001"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /CPU(\d+)/)
		{
			my $cpu       = $1;
			   $say_units = $an->String->get({
				key	=>	"scan_ipmitool_sensor_name_0003",
				variables	=>	{
					cpu		=>	$cpu,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /DIMM-(.*)/)
		{
			my $module    = $1;
			   $say_units = $an->String->get({
				key	=>	"scan_ipmitool_sensor_name_0006",
				variables	=>	{
					module		=>	$module,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Systemboard/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0023"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "V")
	{
		if ($say_sensor_name =~ /BATT (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0002", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /CPU(\d+) (\d+\.?\d+?)V/)
		{
			my $cpu       = $1;
			my $voltage   = $2;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0004", 
				variables	=>	{
					cpu		=>	$cpu,
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /ICH (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0013", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /IOH (\d+\.?\d+?)V AUX/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0014", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /IOH (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0015", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /iRMC (\d+\.?\d+?)V STBY/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0016", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /LAN (\d+\.?\d+?)V STBY/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0017", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /MAIN (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0018", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /STBY (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0022", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "W")
	{
		if ($say_sensor_name =~ /CPU(\d+) Power/)
		{
			my $cpu       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0005", 
				variables	=>	{
					cpu		=>	$cpu,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Fan Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0010"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /HDD Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0011"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Memory Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0019"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /PSU(\d+) Power/)
		{
			my $psu       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0020", 
				variables	=>	{
					psu		=>	$psu,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Total Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0024"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "%")
	{
		if ($say_sensor_name =~ /I2C(\d+) error ratio/)
		{
			my $channel   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0012", 
				variables	=>	{
					channel		=>	$channel,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /SEL Level/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0021"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "RPM")
	{
		if ($say_sensor_name =~ /FAN(\d+) PSU(\d+)/)
		{
			my $fan       = $1;
			my $psu       = $2;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0007", 
				variables	=>	{
					psu		=>	$psu,
					fan		=>	$fan,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /FAN(\d+) PSU/)
		{
			my $fan       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0008", 
				variables	=>	{
					fan		=>	$fan,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /FAN(\d+) SYS/)
		{
			my $fan       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0009", 
				variables	=>	{
					fan		=>	$fan,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_sensor_name",  value1 => $say_sensor_name, 
	}, file => $THIS_FILE, line => __LINE__});
	return($say_sensor_name)
}

# This and translate_sensor_name() are special functions used to translate 
# PMI sensor data into a user's chosen language and units (metric v. imperial).
sub translate_sensor_value
{
	my ($an, $ipmitool_value_sensor_value, $ipmitool_sensor_units, $units) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "translate_sensor_value", }, message_key => "an_variables_0003", message_variables => { 
		name1 => "ipmitool_value_sensor_value", value1 => $ipmitool_value_sensor_value, 
		name2 => "ipmitool_sensor_units",       value2 => $ipmitool_sensor_units, 
		name3 => "units",                       value3 => $units, 
	}, file => $THIS_FILE, line => __LINE__});
	$units = "metric" if not $units;
	
	# Translate the sensor units.
	my $say_units = $ipmitool_sensor_units;
	if    ($say_units eq "C")
	{
		if ($units eq "metric")
		{
			# Leave as C
			$say_units = $an->String->get({key => "tools_suffix_0010"});
		}
		else
		{
			# Convert to F
			$say_units                   = $an->String->get({key => "tools_suffix_0012"});
			$ipmitool_value_sensor_value = $an->Convert->convert_to_fahrenheit({temperature => $ipmitool_value_sensor_value});
		}
	} # Always C at this time
	elsif ($say_units eq "%")   { $say_units = $an->String->get({key => "tools_suffix_0016"}); }
	elsif ($say_units eq "W")   { $say_units = $an->String->get({key => "tools_suffix_0017"}); } # watts
	elsif ($say_units eq "V")   { $say_units = $an->String->get({key => "tools_suffix_0018"}); } # vDC is always assumed, may need to update this later.
	elsif ($say_units eq "RPM") { $say_units = $an->String->get({key => "tools_suffix_0021"}); } # rotations per minute.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_units", value1 => $say_units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Put them together
	my $say_sensor_value = "$ipmitool_value_sensor_value $say_units";
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_sensor_value", value1 => $say_sensor_value, 
	}, file => $THIS_FILE, line => __LINE__});
	return($say_sensor_value);
}

# This looks at each DB's 'updated' table to see if any are behind. If any are,
# it will update the tables based on the time the last entry was made for a
# given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Something somewhere is out of sync. So start with updating
		# the core tables. The agents will take care of their own.
		
		### NOTE: Don't bother with COUNT(*) checks, that is not a good indication of being up to 
		###       date or not.
		
		# Update (and commit) the hosts table
		update_db_hosts($an);
		
		# Now update the rest of the ScanCore tables.
		update_db_agents($an);
		update_db_ram_used($an);
		update_db_alerts($an);
		update_db_temperature($an);
		update_db_power($an);
	}
	
	return(0);
}

# Update the 'ram_used' table.
sub update_db_ram_used
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_ram_used" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'ram_used' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
FROM 
    history.ram_used 
WHERE 
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $ram_used_by    = $row->[0];
			my $ram_used_bytes = $row->[1];
			my $modified_date  = $row->[2];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "ram_used_by",    value1 => $ram_used_by, 
				name2 => "ram_used_bytes", value2 => $ram_used_bytes, 
				name3 => "modified_date",  value3 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_by}{$ram_used_by} = {
				ram_used_bytes	=>	$ram_used_bytes,
			};
			$an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{'exists'} = 1;
			$an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{seen}     = 0;
			$an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_by}{$ram_used_by} = {
				ram_used_bytes	=>	$ram_used_bytes,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{ram_used}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $ram_used_by (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_by}})
		{
			my $ram_used_bytes = $an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_by}{$ram_used_by}{ram_used_bytes};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "ram_used_by",    value1 => $ram_used_by, 
				name2 => "ram_used_bytes", value2 => $ram_used_bytes, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'ram_used_by' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::ram_used::ram_used_by::${ram_used_by}::seen", value1 => $an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::ram_used::ram_used_by::${ram_used_by}::exists", value1 => $an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{ram_used}{ram_used_by}{$ram_used_by}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::ram_used::modified_date::${modified_date}::ram_used_by::${ram_used_by}", value1 => $an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_by}{$ram_used_by}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_by}{$ram_used_by})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.ram_used
SET
    ram_used_bytes = ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    modified_date  = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ram_used_host_uuid  = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($ram_used_by)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.ram_used
(
    ram_used_host_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'ram_used_by' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_by}{$ram_used_by})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.ram_used
(
    ram_used_id, 
    ram_used_host_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
) VALUES (
    (
        SELECT 
            ram_used_id 
        FROM 
            public.ram_used 
        WHERE 
            ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($ram_used_by)." 
        AND 
            ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
    ), 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen ram_used_by?
			} # foreach my $id 
		} # foreach my $ram_used_by ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (
			@{$an->data->{db_resync}{$id}{public}{sql}}, 
			@{$an->data->{db_resync}{$id}{history}{sql}}
		);
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the special 'temperature' table.
sub update_db_temperature
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_temperature" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'temperature' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    temperature_uuid, 
    temperature_agent_name, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
FROM 
    history.temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $temperature_uuid        = $row->[0];
			my $temperature_agent_name  = $row->[1]; 
			my $temperature_sensor_host = $row->[2]; 
			my $temperature_sensor_name = $row->[3];
			my $temperature_celsius     = $row->[4];
			my $temperature_state       = $row->[5];
			my $temperature_is          = $row->[6];
			my $modified_date           = $row->[7];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "temperature_uuid",        value1 => $temperature_uuid, 
				name2 => "temperature_agent_name",  value2 => $temperature_agent_name, 
				name3 => "temperature_sensor_host", value3 => $temperature_sensor_host, 
				name4 => "temperature_sensor_name", value4 => $temperature_sensor_name, 
				name5 => "temperature_celsius",     value5 => $temperature_celsius, 
				name6 => "temperature_state",       value6 => $temperature_state, 
				name7 => "temperature_is",          value7 => $temperature_is, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name} = {
				temperature_uuid	=>	$temperature_uuid, 
				temperature_sensor_host	=>	$temperature_sensor_host,
				temperature_sensor_name	=>	$temperature_sensor_name,
				temperature_celsius	=>	$temperature_celsius,
				temperature_state	=>	$temperature_state,
				temperature_is		=>	$temperature_is,
			};
			$an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen}     = 0;
			$an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name} = {
				temperature_uuid	=>	$temperature_uuid, 
				temperature_sensor_host	=>	$temperature_sensor_host,
				temperature_sensor_name	=>	$temperature_sensor_name,
				temperature_celsius	=>	$temperature_celsius,
				temperature_state	=>	$temperature_state,
				temperature_is		=>	$temperature_is,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{temperature}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $temperature_agent_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}})
		{
			my $temperature_uuid        = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_uuid};
			my $temperature_sensor_host = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_sensor_host};
			my $temperature_sensor_name = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_sensor_name};
			my $temperature_celsius     = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_celsius};
			my $temperature_state       = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_state};
			my $temperature_is          = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_is};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
				name1 => "temperature_uuid",        value1 => $temperature_uuid, 
				name2 => "temperature_agent_name",  value2 => $temperature_agent_name, 
				name3 => "temperature_sensor_host", value3 => $temperature_sensor_host, 
				name4 => "temperature_sensor_name", value4 => $temperature_sensor_name, 
				name5 => "temperature_celsius",     value5 => $temperature_celsius, 
				name6 => "temperature_state",       value6 => $temperature_state, 
				name7 => "temperature_is",          value7 => $temperature_is, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'temperature_agent_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::temperature::temperature_agent_name::${temperature_agent_name}::seen", value1 => $an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::temperature::temperature_agent_name::${temperature_agent_name}::exists", value1 => $an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::temperature::modified_date::${modified_date}::temperature_agent_name::${temperature_agent_name}", value1 => $an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.temperature
SET
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($temperature_agent_name).", 
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_host).", 
    temperature_sensor_name = ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_name).", 
    temperature_celsius     = ".$an->data->{sys}{use_db_fh}->quote($temperature_celsius).", 
    temperature_state       = ".$an->data->{sys}{use_db_fh}->quote($temperature_state).", 
    temperature_is          = ".$an->data->{sys}{use_db_fh}->quote($temperature_is).", 
    modified_date           = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    temperature_uuid        = ".$an->data->{sys}{use_db_fh}->quote($temperature_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.temperature
(
    temperature_uuid, 
    temperature_agent_name, 
    temperature_host_uuid, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($temperature_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_celsius).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_is).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'temperature_agent_name' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.temperature
(
    temperature_id, 
    temperature_agent_name, 
    temperature_host_uuid, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
) VALUES (
    (SELECT temperature_id FROM public.temperature WHERE temperature_uuid = ".$an->data->{sys}{use_db_fh}->quote($temperature_uuid)."), 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_celsius).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_is).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen temperature_agent_name?
			} # foreach my $id 
		} # foreach my $temperature_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the special 'power' table.
sub update_db_power
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_power" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'power' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    power_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
FROM 
    history.power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $power_uuid              = $row->[0]; 
			my $power_agent_name        = $row->[1]; 
			my $power_record_locator    = $row->[2]; 
			my $power_ups_name          = $row->[3]; 
			my $power_on_battery        = $row->[4] ? "TRUE" : "FALSE"; 
			my $power_seconds_left      = $row->[5]; 
			my $power_charge_percentage = $row->[6]; 
			my $modified_date           = $row->[7];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "power_uuid",              value1 => $power_uuid, 
				name2 => "power_agent_name",        value2 => $power_agent_name, 
				name3 => "power_record_locator",    value3 => $power_record_locator, 
				name4 => "power_ups_name",          value4 => $power_ups_name, 
				name5 => "power_on_battery",        value5 => $power_on_battery, 
				name6 => "power_seconds_left",      value6 => $power_seconds_left, 
				name7 => "power_charge_percentage", value7 => $power_charge_percentage, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name} = {
				power_uuid		=>	$power_uuid, 
				power_record_locator	=>	$power_record_locator,
				power_ups_name		=>	$power_ups_name,
				power_on_battery	=>	$power_on_battery,
				power_seconds_left	=>	$power_seconds_left,
				power_charge_percentage	=>	$power_charge_percentage,
			};
			
			$an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen}     = 0;
			$an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name} = {
				power_uuid		=>	$power_uuid, 
				power_record_locator	=>	$power_record_locator,
				power_ups_name		=>	$power_ups_name,
				power_on_battery	=>	$power_on_battery,
				power_seconds_left	=>	$power_seconds_left,
				power_charge_percentage	=>	$power_charge_percentage,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{power}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $power_agent_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}})
		{
			my $power_uuid              = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_uuid};
			my $power_record_locator    = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_record_locator};
			my $power_ups_name          = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_ups_name};
			my $power_on_battery        = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_on_battery};
			my $power_seconds_left      = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_seconds_left};
			my $power_charge_percentage = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_charge_percentage};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "power_uuid",              value1 => $power_uuid, 
				name2 => "power_agent_name",        value2 => $power_agent_name, 
				name3 => "power_record_locator",    value3 => $power_record_locator, 
				name4 => "power_ups_name",          value4 => $power_ups_name, 
				name5 => "power_on_battery",        value5 => $power_on_battery, 
				name6 => "power_seconds_left",      value6 => $power_seconds_left, 
				name7 => "power_charge_percentage", value7 => $power_charge_percentage, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'power_agent_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::power::power_agent_name::${power_agent_name}::seen", value1 => $an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::power::power_agent_name::${power_agent_name}::exists", value1 => $an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::power::modified_date::${modified_date}::power_agent_name::${power_agent_name}", value1 => $an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.power
SET
    power_ups_name          = ".$an->data->{sys}{use_db_fh}->quote($power_ups_name).", 
    power_on_battery        = ".$an->data->{sys}{use_db_fh}->quote($power_on_battery).", 
    power_seconds_left      = ".$an->data->{sys}{use_db_fh}->quote($power_seconds_left).", 
    power_charge_percentage = ".$an->data->{sys}{use_db_fh}->quote($power_charge_percentage).", 
    power_agent_name        = ".$an->data->{sys}{use_db_fh}->quote($power_agent_name).", 
    power_record_locator    = ".$an->data->{sys}{use_db_fh}->quote($power_record_locator).", 
    modified_date           = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    power_uuid = ".$an->data->{sys}{use_db_fh}->quote($power_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.power
(
    power_uuid, 
    power_host_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($power_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_record_locator).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_ups_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_on_battery).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_seconds_left).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_charge_percentage).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'power_agent_name' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.power
(
    power_uuid, 
    power_host_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($power_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_record_locator).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_ups_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_on_battery).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_seconds_left).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_charge_percentage).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen power_agent_name?
			} # foreach my $id 
		} # foreach my $power_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the alerts table.
sub update_db_alerts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_alerts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: Alerts get deleted once they're sent. So we don't care about the public schema here, only
	###       the history schema.
	
	# Now read in all the 'alerts' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# This will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    alert_uuid, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    modified_date 
FROM 
    history.alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $alert_uuid              = $row->[0]; 
			my $alert_agent_name        = $row->[1]; 
			my $alert_level             = $row->[2]; 
			my $alert_title_key         = $row->[3]; 
			my $alert_title_variables   = $row->[4]; 
			my $alert_message_key       = $row->[5]; 
			my $alert_message_variables = $row->[6]; 
			my $modified_date           = $row->[7];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
				name1 => "alert_uuid",              value1 => $alert_uuid, 
				name2 => "alert_agent_name",        value2 => $alert_agent_name, 
				name3 => "alert_level",             value3 => $alert_level, 
				name4 => "alert_title_key",         value4 => $alert_title_key, 
				name5 => "alert_title_variables",   value5 => $alert_title_variables, 
				name6 => "alert_message_key",       value6 => $alert_message_key, 
				name7 => "alert_message_variables", value7 => $alert_message_variables, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid} = {
				alert_agent_name	=>	$alert_agent_name, 
				alert_level		=>	$alert_level, 
				alert_title_key		=>	$alert_title_key, 
				alert_title_variables	=>	$alert_title_variables, 
				alert_message_key	=>	$alert_message_key, 
				alert_message_variables	=>	$alert_message_variables, 
			};
			$an->data->{db_data}{$id}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid} = {
				alert_agent_name	=>	$alert_agent_name, 
				alert_level		=>	$alert_level, 
				alert_title_key		=>	$alert_title_key, 
				alert_title_variables	=>	$alert_title_variables, 
				alert_message_key	=>	$alert_message_key, 
				alert_message_variables	=>	$alert_message_variables, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{alerts}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}})
		{
			my $alert_agent_name        = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_agent_name};
			my $alert_level             = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_level};
			my $alert_title_key         = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_title_key};
			my $alert_title_variables   = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_title_variables};
			my $alert_message_key       = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_message_key};
			my $alert_message_variables = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_message_variables};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
				name1 => "alert_uuid",              value1 => $alert_uuid, 
				name2 => "alert_agent_name",        value2 => $alert_agent_name, 
				name3 => "alert_level",             value3 => $alert_level, 
				name4 => "alert_title_key",         value4 => $alert_title_key, 
				name5 => "alert_title_variables",   value5 => $alert_title_variables, 
				name6 => "alert_message_key",       value6 => $alert_message_key, 
				name7 => "alert_message_variables", value7 => $alert_message_variables, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# If this is the first record, then a little consideration is needed... One 
				# of three things can happen;
				# 1. The record doesn't exist at all, INSERT
				# 2. The record exists, but is old. UPDATE
				# 3. The record exists and is up to date, ignore it.
				# Case 1 & 2 go to the public schema.
				# 
				# All other records are written directly to the history schema as needed.
				my $this_schema = "history";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "id",                                                                                 value1 => $id,
					name2 => "this_schema",                                                                        value2 => $this_schema, 
					name3 => "db_data::${id}::alerts::modified_date::${modified_date}::alert_uuid::${alert_uuid}", value3 => $an->data->{db_data}{$id}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid})
				{
					my $query = "
INSERT INTO 
    history.alerts
(
    alert_uuid, 
    alert_agent_name, 
    alert_host_uuid, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($alert_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_title_key).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_title_variables).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_message_key).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_message_variables).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
					# Now record the query in the array
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "id",    value1 => $id, 
						name2 => "query", value2 => $query
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{db_resync}{$id}{sql}}, $query;
				}
			} # foreach my $id 
		} # foreach my $alert_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the agents table.
sub update_db_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_agents" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'agents' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
FROM 
    history.agents
WHERE
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $agent_name      = $row->[0];
			my $agent_exit_code = $row->[1];
			my $agent_runtime   = $row->[2];
			my $modified_date   = $row->[3];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "agent_name",      value1 => $agent_name, 
				name2 => "agent_exit_code", value2 => $agent_exit_code, 
				name3 => "agent_runtime",   value3 => $agent_runtime, 
				name4 => "modified_date",   value4 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name} = {
				agent_exit_code		=>	$agent_exit_code,
				agent_runtime		=>	$agent_runtime,
			};
			$an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{seen}     = 0;
			$an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name} = {
				agent_exit_code		=>	$agent_exit_code,
				agent_runtime		=>	$agent_runtime,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{agents}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $agent_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_name}})
		{
			my $agent_exit_code = $an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name}{agent_exit_code};
			my $agent_runtime   = $an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name}{agent_runtime};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "agent_name",      value1 => $agent_name, 
				name2 => "agent_exit_code", value2 => $agent_exit_code, 
				name3 => "agent_runtime",   value3 => $agent_runtime, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'agent_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::agents::agent_name::${agent_name}::seen", value1 => $an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::agents::agent_name::${agent_name}::exists", value1 => $an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{agents}{agent_name}{$agent_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::agents::modified_date::${modified_date}::agent_name::${agent_name}", value1 => $an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.agents
SET
    agent_exit_code = ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    agent_runtime   = ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    agent_name      = ".$an->data->{sys}{use_db_fh}->quote($agent_name)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.agents
(
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'agent_name' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_name}{$agent_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.agents
(
    agent_id, 
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
) VALUES (
    (
        SELECT 
            agent_id 
        FROM 
            public.agents 
        WHERE 
            agent_name = ".$an->data->{sys}{use_db_fh}->quote($agent_name)."
        AND
            agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
    ), 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen agent_name?
			} # foreach my $id 
		} # foreach my $agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update (and commit) the hosts table
sub update_db_hosts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_hosts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: Everything depends on 'hosts' -> 'host_uuid', so we need to 
	###       update *AND* commit the changes before we leave this 
	###       function.
	
	# Now read in all the 'hosts' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    host_uuid, 
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    modified_date 
FROM 
    history.hosts
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $host_uuid           = $row->[0];
			my $host_name           = $row->[1];
			my $host_type           = $row->[2];
			my $host_emergency_stop = $row->[3] ? "TRUE" : "FALSE";
			my $host_stop_reason    = $row->[4];
			my $modified_date       = $row->[5];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "host_uuid",           value1 => $host_uuid, 
				name2 => "host_name",           value2 => $host_name, 
				name3 => "host_type",           value3 => $host_type, 
				name4 => "host_emergency_stop", value4 => $host_emergency_stop,
				name5 => "host_stop_reason",    value5 => $host_stop_reason, 
				name6 => "modified_date",       value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid} = {
				host_name		=>	$host_name, 
				host_type		=>	$host_type, 
				host_emergency_stop	=>	$host_emergency_stop, 
				host_stop_reason	=>	$host_stop_reason, 
			};
			
			$an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid} = {
				host_name		=>	$host_name, 
				host_type		=>	$host_type,
				host_emergency_stop	=>	$host_emergency_stop,
				host_stop_reason	=>	$host_stop_reason,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{hosts}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $host_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}})
		{
			my $host_name           = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_name};
			my $host_type           = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_type};
			my $host_emergency_stop = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_emergency_stop};
			my $host_stop_reason    = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_stop_reason};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "host_uuid",           value1 => $host_uuid, 
				name2 => "host_name",           value2 => $host_name, 
				name3 => "host_type",           value3 => $host_type, 
				name4 => "host_emergency_stop", value4 => $host_emergency_stop,
				name5 => "host_stop_reason",    value5 => $host_stop_reason, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'host_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::hosts::host_uuid::${host_uuid}::seen", value1 => $an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::hosts::host_uuid::${host_uuid}::exists", value1 => $an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::hosts::modified_date::${modified_date}::host_uuid::${host_uuid}", value1 => $an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.hosts 
SET
    host_name           = ".$an->data->{sys}{use_db_fh}->quote($host_name).", 
    host_type           = ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    host_emergency_stop = ".$an->data->{sys}{use_db_fh}->quote($host_emergency_stop).", 
    host_stop_reason    = ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    host_uuid = ".$an->data->{sys}{use_db_fh}->quote($host_uuid)." 
;";
							# Now record the query in the array
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.hosts
(
    host_uuid,  
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_emergency_stop).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'host_uuid' before, so it's just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.hosts
(
    host_uuid,  
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_emergency_stop).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen host_uuid?
			} # foreach my $id 
		} # foreach my $host_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks to see if the host name has changed.
sub check_hostname_for_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_hostname_for_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# What was the last recorded host name?
	my $query = "SELECT host_name FROM hosts WHERE host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $host_name = $an->DB->do_db_query({query => $query})->[0]->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "host_name", value1 => $host_name
	}, file => $THIS_FILE, line => __LINE__});
	
	# Has it changed?
	if ($host_name ne $an->hostname)
	{
		# Yup, updated.
		my $query = "
UPDATE 
    hosts
SET 
    host_name     = ".$an->data->{sys}{use_db_fh}->quote($an->hostname).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->DB->do_db_write({query => $query});
	}
	
	return(0);
}

# This checks to see if this node is in each database and, if not, adds it. It
# also will update the hostname if it has changed.
sub add_hostname_to_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "add_hostname_to_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Check for a hostname using our UUID.
	my $query = "SELECT host_name FROM hosts WHERE host_uuid=".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	#              The actual query -----------------.        .------- Row 0
	#                                                |        |    .-- Columns 0
	my $host_name = $an->DB->do_db_query({query => $query})->[0]->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "host_name", value1 => $host_name
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do I need to add or update?
	if (not $host_name)
	{
		### TODO: For now, we determine if this host is a node
		###       or dashboard by analyzing it's hostname. We
		###       will make this smarter later.
		my $host_name = $an->hostname;
		my $host_type = "node";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "sys::hostname", value1 => $an->hostname, 
			name2 => "host_name",     value2 => $host_name, 
			name3 => "host_type",     value3 => $host_type
		}, file => $THIS_FILE, line => __LINE__});
		
		if (($host_name =~ /striker/) || ($host_name =~ /dashboard/))
		{
			$host_type = "dashboard";
		}
		$an->data->{scancore}{i_am_a} = $host_type;
		
		# Add this host to the DB
		my $query = "
INSERT INTO 
    hosts 
(
    host_uuid, 
    host_name, 
    host_type, 
    host_emergency_stop, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_name).",
    ".$an->data->{sys}{use_db_fh}->quote($host_type).",
    FALSE, 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query});
	}
	else
	{
		# A record exists. Check to see if the 'host_emergency_stop' 
		# has been set and clear it, if so.
		my $query = "SELECT host_emergency_stop, host_stop_reason FROM hosts WHERE host_name=".$an->data->{sys}{use_db_fh}->quote($an->hostname).";";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1  => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		#                        The actual query -----------------.        .------- Row 0
		#                                                          |        |    .-- Columns 0
		my $host_emergency_stop = $an->DB->do_db_query({query => $query})->[0]->[0];
		my $host_stop_reason    = $an->DB->do_db_query({query => $query})->[0]->[1];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "host_emergency_stop", value1 => $host_emergency_stop, 
			name2 => "host_stop_reason",    value2 => $host_stop_reason
		}, file => $THIS_FILE, line => __LINE__});
		if (($host_emergency_stop) or ($host_stop_reason))
		{
			# Clear the stop data.
			my $query = "
UPDATE 
    hosts
SET 
    host_emergency_stop = FALSE, 
    host_stop_reason    = NULL, 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
			$an->DB->do_db_write({query => $query});
		}
	}
	$an->data->{sys}{host_is_in_db} = 1;
	
	return(0);
}

# This loops through the agents directory 
sub call_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "call_agents" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through the agents directory and call each agent. Record how long it takes and note the exit 
	# code, then record the run-data in the database.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::agents_directory", value1 => $an->data->{path}{agents_directory}
	}, file => $THIS_FILE, line => __LINE__});
	scan_directory($an, $an->data->{path}{agents_directory});
	
	# Now loop through the agents I found and try calling them.
	foreach my $agent (sort {$a cmp $b} @{$an->data->{sys}{agents}})
	{
		### TODO: Put a time limit on these...
		my $start_time =  time;
		my $say_agent  =  $agent;
		   $say_agent  =~ s/^.*\///;
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0015", message_variables => { agent => "$say_agent" }, file => $THIS_FILE, line => __LINE__});
		
		# I call these sequentially to minimize the load on the host.
		my $agent_rc   = "9999";
		my $shell_call = "$agent; echo rc:\$? 2>&1 |";
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0006", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => "$line"
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /rc:(\d+)/)
			{
				$agent_rc = $1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "agent_rc", value1 => "$agent_rc"
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => "$line"
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		my $runtime = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0020", message_variables => { 
			agent   => "$agent", 
			runtime => $runtime 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record this run in the DB.
		my $query = "
SELECT 
    COUNT(*) 
FROM 
    agents 
WHERE 
    agent_name = ".$an->data->{sys}{use_db_fh}->quote($say_agent)." 
AND
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;
";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1  => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		my $count = $an->DB->do_db_query({query => $query})->[0]->[0];	# (->[row]->[column])
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Add this agent to the DB
			my $query = "
INSERT INTO 
    agents 
(
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime,
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($say_agent).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_rc).", 
    ".$an->data->{sys}{use_db_fh}->quote($runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
			$an->DB->do_db_write({query => $query});
		}
		else
		{
			# It exists, update it.
			my $query = "
UPDATE 
    agents 
SET
    agent_exit_code = ".$an->data->{sys}{use_db_fh}->quote($agent_rc).", 
    agent_runtime   = ".$an->data->{sys}{use_db_fh}->quote($runtime).", 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND
    agent_name = ".$an->data->{sys}{use_db_fh}->quote($say_agent).";
";
			$an->DB->do_db_write({query => $query});
		}
	}
	
	# Clear the agent list.
	$an->data->{sys}{agents} = [];
	
	return(0);
}

# This checks the amount RAM used by ScanCore and exits if it exceeds a
# scancore::maximum_ram bytes. It looks for any process with our name and sums the
# RAM used.
sub check_ram_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_ram_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: Make this ___way___ smarter.
	# Call PS to get our (and any other duplicate copies of ScanCore) RAM 
	# usage.
	my $used_ram   = 0;
	my $shell_call = $an->data->{path}{ps}." aux 2>&1 |";
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0006", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => ">> line", value1 => "$line"
		}, file => $THIS_FILE, line => __LINE__});
		
		next if $line !~ /$THIS_FILE/;
		next if $line =~ /grep $THIS_FILE/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => "$line"
		}, file => $THIS_FILE, line => __LINE__});
		
		# Dig out the PID
		my $pid        =  ($line =~ /^.*?\s(\d+)\s/)[0];
		my ($pids_ram) =  $an->Get->get_ram_used_by_pid({pid => $pid});
		   $used_ram   += $pids_ram;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "pid",                   value1 => "$pid", 
			name2 => "pids_ram",              value2 => "$pids_ram", 
			name3 => "used_ram",              value3 => "$used_ram", 
			name4 => "scancore::maximum_ram", value4 => $an->data->{scancore}{maximum_ram}
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	# Records the RAM used.
	my $query = "
SELECT 
    ram_used_bytes 
FROM 
    ram_used 
WHERE 
    ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name})." 
AND
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $ram_used_bytes = $an->DB->do_db_query({query => $query})->[0]->[0];	# (->[row]->[column])
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "ram_used_bytes", value1 => $ram_used_bytes
	}, file => $THIS_FILE, line => __LINE__});
	if (not $ram_used_bytes)
	{
		# Add this agent to the DB
		my $query = "
INSERT INTO 
    ram_used 
(
    ram_used_host_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name}).", 
    ".$an->data->{sys}{use_db_fh}->quote($used_ram).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
		$an->DB->do_db_write({query => $query});
	}
	elsif ($ram_used_bytes ne $used_ram)
	{
		# It exists and the value has changed.
		my $query = "
UPDATE 
    ram_used 
SET
    ram_used_bytes = ".$an->data->{sys}{use_db_fh}->quote($used_ram).", 
    modified_date  = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name})." 
AND
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";
";
		$an->DB->do_db_write({query => $query});
	}
	else
	{
		# The amount of RAM used is unchanged.
		#print __LINE__."; The amount of RAM used by ".$an->data->{sys}{program_name}." is unchanged.\n";
	}
	
	if ($used_ram > $an->data->{scancore}{maximum_ram})
	{
		# Much, too much, much music!
		# err, too much RAM...
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0013", message_variables => { 
			used_ram    => $an->Readable->bytes_to_hr({'bytes' => $used_ram}), 
			maximum_ram => $an->Readable->bytes_to_hr({'bytes' => $an->data->{scancore}{maximum_ram}})
		}, code => 5, file => "$THIS_FILE", line => __LINE__});
	}
	
	return(0);
}

# This reads the 'results table' and looks for bad conditions
sub analyze_results
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "analyze_results" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in the 'alerts' table, using $an->data->{sys}{scan_time} as the
	# time to select after. 
	
	return(0);
}

# This digs through a directory looking for scan agents to call. It will dive
# into subdiretories as well. Anything it finds, it will record the path to
# sys::agents.
sub scan_directory
{
	my ($an, $directory) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "directory", value1 => "$directory" 
	}, file => $THIS_FILE, line => __LINE__});
	
	local(*DIRECTORY);
	opendir(DIRECTORY, $an->data->{path}{agents_directory});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		my $full_path = "$directory/$file";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "full_path", value1 => "$full_path"
		}, file => $THIS_FILE, line => __LINE__});
		if (-d $full_path)
		{
			# This is a directory, dive into it.
			scan_directory($an, $full_path);
		}
		elsif (-x $full_path)
		{
			# Now I only want to know if the file starts with 'scan-'
			next if $file !~ /^scan-/;
			
			# If I am still alive, I am looking at a scan agent!
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0014", message_variables => { agent => "$full_path" }, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{agents}}, $full_path;
		}
	}
	
	return(0);
}

# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit" }, message_key => "an_variables_0001", message_variables => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	$an->DB->disconnect_from_databases();
	
	exit(0);
}

# This causes the script to exit if another instance is already running.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $file_handle = IO::Handle->new();
	my $shell_call  = $an->data->{path}{pgrep}." $THIS_FILE 2>&1 |";
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0006", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while (<$file_handle>)
	{
		chomp;
		my $pid = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "pid", value1 => "$pid"
		}, file => $THIS_FILE, line => __LINE__});
		if ($pid ne $$)
		{
			# Another copy is running, exit.
			close $file_handle;
			$an->Log->entry({log_level => 3, message_key => "scancore_message_0003", file => $THIS_FILE, line => __LINE__});
			exit(6);
		}
	}
	close $file_handle;
	
	return (0);
}
