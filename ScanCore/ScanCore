#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - Failed to connect to any database.
# 2  - Error preparing a database query.
# 3  - Failed to read a file.
# 4  - Failed to get an ID when initializing a database.
# 5  - Used too much RAM, exited to avoid a problem.
# 6  - Another copy of ScanCore is running.
# 7  - The UUID for this host was not read (or not read correctly).
# 8  - Bad alert config in striker.conf
# 9  - Failed to enable ScanCore.
# 10 - Failed to disable ScanCore.
# 
# TODO:
#   
# - Add '--summary' to all agents where they will not compare values in that pass, but will alert on 
#   anomolous readings, and instead print a summary of all data in a nice screen.
# 
# - Have DB.pm return an error code and have ScanCore exit if a query fails.
# - Add a '--restart' option that touches a temp file and, if in a loop that file is found, delete it and 
#   then exit.
# 
# - Write a 'scan-usb' agent that monitored USB ports for things being plugged in or removed.
# - An agent to monitor LVM and another for DRBD would be good.
# - When examining UPS charge percentage when deciding if it is OK to boot, pull the last X readings and
#   average them. It is possible for a stray reading to report an unrealistically high charge percent on a
#   given scan.
#       

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;

# Disable buffering.
$| = 1;

# Figure out who and where I am.
my $THIS_FILE           =  ($0 =~ /^.*\/(.*)$/)[0];
my $running_directory   =  ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];
if (($running_directory =~ /^\./) && ($ENV{PWD}))
{
	$running_directory =~ s/^\./$ENV{PWD}/;
}

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			agents_directory	=>	"$running_directory/agents",
			scancore_strings	=>	"$running_directory/ScanCore.xml",
			scancore_sql		=>	"$running_directory/ScanCore.sql",
		},
		# Things set here are meant to be overwritable by the user in striker.conf.
		scancore			=>	{
			# Set to '1' to add the footer warning that the email did not come from alteeve.ca.
			append_email_footer	=>	0,
			archive			=>	{
				directory		=>	"/var/ScanCore/archives/",
				trigger			=>	100000,
				count			=>	50000,
				dump_file_header	=>	"
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = history, pg_catalog;
",
			},
			dashboard		=>	{
				dlm_hung_timeout	=>	0,
			},
			disable			=>	{
				boot_nodes		=>	0,
				load_shedding		=>	0,
				power_shutdown		=>	0,
				thermal_shutdown	=>	0,
				preventative_migration	=>	0,
			},
			# This gets set to 'dashboard' if we determine this is a dashboard machine.
			i_am_a			=>	"",
			language		=>	"en_CA",
			log_file		=>	"/var/log/ScanCore.log",
			log_level		=>	1,
			log_language		=>	"en_CA",
			log_db_transactions	=>	0,
			maximum_ram		=>	(512 * 1048576),
			# When both/all UPSes powering a node switch to batteries, their remaining hold-up 
			# time will be checked and the strongest will be compared against this value. If the
			# remaining runtime of the strongest ups is below this time, 'anvil-safe-stop' 
			# will be invoked.
			minimum_ups_runtime	=>	600,
			minimum_safe_charge	=>	45,
			power			=>	{
				load_shed_delay		=>	300,
			},
			temperature		=>	{
				# This is the weight given to each thermal sensor by default.
				default_sensor_weight	=>	1,
				load_shed_delay		=>	120,
				# The sum of the critical temperature weights must exceed this value to cause
				# a shut down.
				shutdown_limit		=>	5,
			},
			thermal_reboot_delay	=>	{
				'1'			=>	600,
				'2'			=>	1800,
				'3'			=>	3600,
				'4'			=>	7200,
				more			=>	21600,
			},
			sleep_time		=>	60,
			update_age_limit	=>	1200,
		},
		strings_read			=>	{},
		sys		=>	{
			# This will hold the UUID for the Anvil! this node is a member of
			anvil_uuid		=>	"",
			agents			=>	[],
			# This gets the config ID(s) of any initialized databases.
			db_initialized		=>	{},
			# This will hold the timestamp used to set 'modified_date' on all DB records.
			db_timestamp		=>	"",
			# If the program hits a significant error, this will be set to '1' causing the
			# program to exit at the end of the sweep.
			'exit'			=>	0,
			# This stores the local machine's ScanCore UUID.
			host_uuid		=>	"",
			# This gets set to '1' once we know this host is in the DB.
			host_is_in_db		=>	0,
			# When a lock is requested, this is set to the time the lock was set. 
			# DB->do_db_write() and DB->do_db_read() will check this and if its age is >50% of
			# scancore::locking::reap_age, it will renew the lock.
			local_lock_active	=>	0,
			# This looks like a lot, but 'pmap' kinda sucks and reports shared memory, so to even
			# start a program lists 120 MiB+ used. I will make it smarter later.
			program_name		=>	$THIS_FILE,
			read_db_id		=>	"",
			# These are used to avoid repeatedly logging that something has happened.
			reported		=>	{
				power_is_critical	=>	0,
				power_is_warning	=>	0,
				temperature_is_critical	=>	0,
				temperature_is_warning	=>	0,
			},
			use_db_fh		=>	"",
			user_set_log_level	=>	"",
		},
	}
});

# Read the config file
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});

# Set some defaults
$an->default_language    ($an->data->{scancore}{language});
$an->default_log_language($an->data->{scancore}{log_language});
$an->default_log_file    ($an->data->{scancore}{log_file});

# Set the log level.
$an->Log->level($an->data->{scancore}{log_level});
$an->Log->db_transactions(1) if $an->data->{scancore}{log_db_transactions};

# Read in strings now.
$an->Storage->read_words({file => $an->data->{path}{scancore_strings}});
$an->Storage->read_words({file => $an->data->{path}{striker_strings}});

# See if the user is forcing the issue
$an->Get->switches();
$an->Log->adjust_log_level({key => $THIS_FILE});

# Help?
if (($an->data->{switches}{h})   or 
    ($an->data->{switches}{'?'}) or
    ($an->data->{switches}{help}))
{
	# Help!
	print_usage($an);
	$an->nice_exit({exit_code => 0});
}

if ($an->data->{switches}{enable})
{
	my $rc   = update_configuration($an, "enable");
	my $exit = $rc ? 0 : 9;
	if ($rc eq "1")
	{
		# Tell the user that it was enabled.
		print $an->String->get({key => "scancore_message_0005"})."\n";
	}
	$an->nice_exit({exit_code => $exit});
}
elsif ($an->data->{switches}{disable})
{
	my $rc   = update_configuration($an, "disable");
	my $exit = $rc ? 0 : 10;
	if ($rc eq "1")
	{
		# Tell the user that it was disabled.
		print $an->String->get({key => "scancore_message_0006"})."\n";
	}
	$an->nice_exit({exit_code => $exit});
}
elsif (($an->data->{switches}{'state'}) or ($an->data->{switches}{status}))
{
	report_state($an);
	$an->nice_exit({exit_code => 0});
}
elsif ($an->data->{switches}{'clear-resync-flag'})
{
	$an->Log->entry({log_level => 1, message_key => "scancore_log_0093", file => $THIS_FILE, line => __LINE__});
	clear_resync_flag($an);
	$an->nice_exit({exit_code => 0});
}
elsif ($an->data->{switches}{force})
{
	$an->Log->entry({log_level => 1, message_key => "scancore_log_0070", file => $THIS_FILE, line => __LINE__});
	$an->data->{scancore}{enabled} = 1;
}

# Has the user disabled ScanCore?
$an->nice_exit({exit_code => 0}) if not $an->data->{scancore}{enabled};

# Number 5 is Alive!
#print $an->String->get({key => "scancore_message_0001"})."\n";

# Get (create if needed) my UUID.
$an->Storage->prep_uuid();

# Connect to the database(s). This is different from the in-loop connection in that failing to connect to any
# databases right off the bat will cause the program to bail out.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
if (not $connections)
{
	# Failed to connect to any database.
	print $an->String->get({key => "scancore_message_0002", variables => {
		title   => $an->String->get({key => "scancore_title_0003"}),
		message => $an->String->get({key => "scancore_message_0004"}),
	}})."\n";
	
	# TODO: Send an email.
	
	$an->nice_exit({exit_code => 1});
}

# Should I live?
avoid_duplicate_run($an);

# Before we can process or sync alerts, we need to make sure we've read in the strings files for any
# agents that have registered alerts (pending or historical).
load_agent_strings($an);

# Archive, if needed. 
archive_if_needed($an);

# Update the database before we do anything else.
update_db($an);

# Update our view of the anvil we're a part of
update_anvil_data($an);

# Make sure this node is in the database and the host name is up to date.
add_hostname_to_databases($an);
check_hostname_for_changes($an);

# Tell the user we've started.
$an->Alert->register_alert({
	alert_level		=>	"notice", 
	alert_agent_name	=>	$THIS_FILE,
	alert_title_key		=>	"an_alert_title_0003",
	alert_message_key	=>	"scancore_log_0066",
});
$an->Log->entry({log_level => 1, message_key => "scancore_log_0066", file => $THIS_FILE, line => __LINE__});

# Check for and process alert that may have not been sent when we last ran as well as the 'we've started'
# alert above.
process_alerts($an, 1);

# Run the agents we find.
$an->Log->entry({log_level => 2, title_key => "scancore_title_0005", message_key => "scancore_log_0011", file => $THIS_FILE, line => __LINE__,});

# Disconnect from databases... We'll reconnect inside the loop.
$an->DB->disconnect_from_databases();

# Now the run loop.
while(1)
{
	# Note the time
	my $start_time = time;
	
	# Re-read the configuration and words files.
	$an->Storage->read_conf   ({file => $an->data->{path}{striker_config}});
	$an->Storage->read_words  ({file => $an->data->{path}{scancore_strings}});
	$an->Storage->read_words  ({file => $an->data->{path}{striker_strings}});
	$an->Log->adjust_log_level({key  => $THIS_FILE});
	$an->data->{scancore}{enabled} = 1 if $an->data->{switches}{force};
	load_agent_strings($an);

	# Set the log level in case it was changed in the config file.
	$an->Log->level($an->data->{scancore}{log_level});
	
	# TODO: Calc the md5s of ScanCore's core files and if they change, exit.
	# Calculate the sum and see if it has changed.
	#calculate_scancore_sum($an);
	
	# Did the user disable ScanCore while it was sleeping?
	exit_if_disabled($an);
	
	# Connect to the databases.
	my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
	if ($connections)
	{
		# Look to see if any databases need to be updated.
		update_db($an);
		
		# Has the host name changed?
		check_hostname_for_changes($an);
		
		# Update our view of the anvil we're a part of
		update_anvil_data($an);
		
		# If I initialized a database, send an alert.
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{sys}{db_initialized}})
		{
			# Send an alert telling the user that we've initialized this database.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"notice_message_0001",
				alert_message_variables	=>	{
					name			=>	$an->data->{scancore}{db}{$id}{name},
					host			=>	$an->data->{scancore}{db}{$id}{host},
				},
			});
			delete $an->data->{sys}{db_initialized}{$id};
		}
		
		# Call all agents
		call_agents($an);
		
		# Analyze results and take any necessary actions.
		analyze_results($an);
	}
	else
	{
		# Failed to connect to any database. This isn't fatal though... Send an alert email if we 
		# haven't already, sleep.
		print "$THIS_FILE ".__LINE__."; get: [scancore_message_0002]\n";
		print $an->String->get({
			key		=>	"scancore_message_0002",
			variables	=>	{
				title		=>	$an->String->get({key => "scancore_title_0003"}),
				message		=>	$an->String->get({key => "scancore_message_0004"}),
			},
		})."\n";
	}
	
	# Check for and process alerts
	process_alerts($an, 0);
	
	# Do the end-of-scan checks to see if we need to power off, boot others, set/alter health flags, etc.
	do_post_scan_checks($an);
	
	# Record the time
	$an->DB->update_time({file => $THIS_FILE});
	
	# Check RAM usage and bail if it looks like we're leaking.
	check_ram_usage($an);
	
	# Archive, if needed.
	archive_if_needed($an);
	
	# Disconnect from databases.
	$an->DB->disconnect_from_databases();
	
	# Did the user disabled ScanCore while the agents were running (or was this a '--one-shot')?
	exit_if_one_shot($an);
	exit_if_disabled($an);
	
	# Exit if I hit an error.
	if ($an->data->{sys}{'exit'})
	{
		$an->Alert->warning({message_key => "scancore_warning_0024", quiet => 1, file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 0});
	}
	
	# Visual break in the log file
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "scancore::sleep_time",                     value1 => $an->data->{scancore}{sleep_time}, 
		name2 => "----------------------------------------", value2 => "----------------------------------------", 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Sleep.
	$an->Log->entry({log_level => 3, title_key => "scancore_title_0001", message_key => "scancore_log_0012", message_variables => {
		run_time   => (time - $start_time),
		sleep_time => $an->data->{scancore}{sleep_time},
	}, file => $THIS_FILE, line => __LINE__});
	sleep $an->data->{scancore}{sleep_time};
}

# This should never be hit...
$an->nice_exit({exit_code => 0});


#############################################################################################################
# Functions                                                                                                 #
#############################################################################################################

# This will archive stuff in the 'history' schema, if needed.
sub archive_if_needed
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "archive_if_needed" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# If the 'trigger' is '0', archiving is disabled.
	if (not $an->data->{scancore}{archive}{trigger})
	{
		return(1);
	}
	
	### NOTE: If a ScanCore db server was offline when an archive ran, when it returns, it's records will
	###       sync back, triggering a sooner-than-expected subsequent archive. This shouldn't happen 
	###       often, and the complexity of tracking archive dates is such that we'll not try to account
	###       for these cases. 
	### TODO: What we can do later is, when we write the restore stuff, build in a dedupe function.
	
	### Process:
	# 1. Count the records in history for each table, restricting the results to those from this host 
	#    (save for special tables like 'server') and if the number of records is greater than 
	#    'scancore::archive::trigger', start an archive.
	# 2. Set/update the 'archive_date' state.
	# 3. Lock the database.
	# 4. Select 'modified_date' from history.foo, offset by 
	#    ('scancore::archive::trigger' - 'scancore::archive::count').
	# 5. Make sure the 'scancore::archive::directory' exists, creating it if needed.
	# 6. Select all records older that the 'modified_date', write them to a file and then DELETE those
	#    records from the database.
	
	# Update the archive path, if set by a user. Also verify that there are sane archive values.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "path::scancore_archive",       value1 => $an->data->{path}{scancore_archive}, 
		name2 => "scancore::archive::directory", value2 => $an->data->{scancore}{archive}{directory}, 
		name3 => "scancore::archive::trigger",   value3 => $an->data->{scancore}{archive}{trigger}, 
		name4 => "scancore::archive::count",     value4 => $an->data->{scancore}{archive}{count}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{archive}{directory} =~ /\/.*/)
	{
		$an->data->{path}{scancore_archive} = $an->data->{scancore}{archive}{directory};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "path::scancore_archive", value1 => $an->data->{path}{scancore_archive}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{trigger}) or ($an->data->{scancore}{archive}{trigger} =~ /\D/))
	{
		$an->data->{scancore}{archive}{trigger} = 100000;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::trigger", value1 => $an->data->{scancore}{archive}{trigger}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	if ((not $an->data->{scancore}{archive}{count}) or ($an->data->{scancore}{archive}{count} =~ /\D/))
	{
		$an->data->{scancore}{archive}{count} = 50000;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::archive::count", value1 => $an->data->{scancore}{archive}{count}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	if (not -e $an->data->{path}{scancore_archive})
	{
		my $shell_call = $an->data->{path}{'mkdir'}." -p '".$an->data->{path}{scancore_archive}."'";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# Did it work?
		if (not -e $an->data->{path}{scancore_archive})
		{
			# Nope. :(
			$an->Alert->warning({message_key => "scancore_warning_0030", message_variables => { directory => $an->data->{path}{scancore_archive} }, quiet => 1, file => $THIS_FILE, line => __LINE__});
			return(1);
		}
	}
	
	# See if there was a request to archive records older than a certain date. If so, do it now.
	# TODO
	
	# Now lets look to archive certain fast-growing tables.
	# * agents
	# * alerts
	# * health
	# * power
	# * temperature
	# * ram_used
	# * hosts
	# * servers
	$an->data->{archive}{table} = {
		agents		=>	{
			archive_date	=>	"",
			host_column	=>	"agent_host_uuid",
			offset		=>	0,
		},
		alerts		=>	{
			archive_date	=>	"",
			host_column	=>	"alert_host_uuid",
			offset		=>	0,
		},
		health		=>	{
			archive_date	=>	"",
			host_column	=>	"health_host_uuid",
			offset		=>	0,
		},
		power		=>	{
			archive_date	=>	"",
			host_column	=>	"power_host_uuid",
			offset		=>	0,
		},
		temperature	=>	{
			archive_date	=>	"",
			host_column	=>	"temperature_host_uuid",
			offset		=>	0,
		},
		ram_used	=>	{
			archive_date	=>	"",
			host_column	=>	"ram_used_host_uuid",
			offset		=>	0,
		},
		hosts		=>	{
			archive_date	=>	"",
			host_column	=>	"",
			offset		=>	0,
		},
		servers		=>	{
			archive_date	=>	"",
			host_column	=>	"",
			offset		=>	0,
		},
	};
	my $archive_needed = 0;
	foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "table", value1 => $table, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $query = "
SELECT 
    COUNT(*) 
FROM 
    history.$table 
;";
		if ($an->data->{archive}{table}{$table}{host_column})
		{
			$query = "
SELECT 
    COUNT(*) 
FROM 
    history.$table 
WHERE 
    ".$an->data->{archive}{table}{$table}{host_column}." = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
			
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $records = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		   $records = 0 if not defined $records;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "records", value1 => $records, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($records > $an->data->{scancore}{archive}{trigger})
		{
			   $archive_needed                             = 1;
			my $records_to_save                            = ($an->data->{scancore}{archive}{trigger} - $an->data->{scancore}{archive}{count});
			my $offset                                     = $records - $records_to_save;
			   $an->data->{archive}{table}{$table}{offset} = $offset;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "archive_needed",                   value1 => $archive_needed, 
				name2 => "records_to_save",                  value2 => $records_to_save, 
				name3 => "archive::table::${table}::offset", value3 => $an->data->{archive}{table}{$table}{offset}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# If I have something to archive, do so now.
	if ($archive_needed)
	{
		# This will store the files to compress after we release the locks.
		my $compress = [];
		
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Now loop through the table(s) that need to be archived.
		foreach my $table (sort {$a cmp $b} keys %{$an->data->{archive}{table}})
		{
			next if not $an->data->{archive}{table}{$table}{offset};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "table", value1 => $table, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Now to do the archive.
			if ($table eq "agents")
			{
				my $archive_file = archive_agents($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "alerts")
			{
				my $archive_file = archive_alerts($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "health")
			{
				my $archive_file = archive_health($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "power")
			{
				my $archive_file = archive_power($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "temperature")
			{
				my $archive_file = archive_temperature($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "ram_used")
			{
				my $archive_file = archive_ram_used($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "servers")
			{
				my $archive_file = archive_servers($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
			elsif ($table eq "hosts")
			{
				my $archive_file = archive_hosts($an);
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "archive_file", value1 => $archive_file, 
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$compress}, $archive_file if $archive_file =~ /^\//;
			}
		}
		
		### TODO: Make this less of a hackish mc-hackington...
		# VACUUM FULL, if the database is on this machine. I need to do this from the command line 
		# because the user we connect as isn't allowed to do it. We'll also only vacuum our DB.
		my $db_name = "";
		foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "id",                        value1 => $id, 
				name2 => "scancore::db::${id}::host", value2 => $an->data->{scancore}{db}{$id}{host}, 
				name3 => "hostname",                  value3 => $an->hostname, 
				name4 => "short_hostname",            value4 => $an->short_hostname, 
			}, file => $THIS_FILE, line => __LINE__});
			if (($an->data->{scancore}{db}{$id}{host} eq $an->hostname) or ($an->data->{scancore}{db}{$id}{host} eq $an->short_hostname))
			{
				$db_name = $an->data->{scancore}{db}{$id}{name};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "db_name",                   value1 => $db_name, 
					name2 => "scancore::db::${id}::name", value2 => $an->data->{scancore}{db}{$id}{name}, 
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
		}
		if ($db_name)
		{
			my $start      = time;
			my $shell_call = $an->data->{path}{su}." - postgres -c \"".$an->data->{path}{psql}." $db_name -c 'VACUUM FULL;'\"";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "start",      value1 => $start, 
				name2 => "shell_call", value2 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			my $finished = time - $start;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "finished", value1 => $finished, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Release the lock
		$an->DB->locking({release => 1});
		
		# Compress the archives.
		foreach my $archive_file (sort {$a cmp $b} @{$compress})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "archive_file", value1 => $archive_file, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Compress the file.
			$an->System->compress_file({file => $archive_file});
		}
	}
	
	return(0);
}

# This archives the 'agents' table.
sub archive_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_agents" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{agents}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.agents 
WHERE 
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_agents_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY agents (agent_uuid, agent_host_uuid, agent_name, agent_exit_code, agent_runtime, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    agent_uuid, 
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
FROM 
    history.agents 
WHERE 
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $history_id      = defined $row->[0] ? $row->[0] : '\N';
			my $agent_uuid      = defined $row->[1] ? $row->[1] : '\N';
			my $agent_host_uuid = defined $row->[2] ? $row->[2] : '\N';
			my $agent_name      = defined $row->[3] ? $row->[3] : '\N';
			my $agent_exit_code = defined $row->[4] ? $row->[4] : '\N';
			my $agent_runtime   = defined $row->[5] ? $row->[5] : '\N';
			my $modified_date   = defined $row->[6] ? $row->[6] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "history_id",      value1 => $history_id, 
				name2 => "agent_uuid",      value2 => $agent_uuid, 
				name3 => "agent_host_uuid", value3 => $agent_host_uuid, 
				name4 => "agent_name",      value4 => $agent_name, 
				name5 => "agent_exit_code", value5 => $agent_exit_code, 
				name6 => "agent_runtime",   value6 => $agent_runtime, 
				name7 => "modified_date",   value7 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $agent_uuid."\t".$agent_host_uuid."\t".$agent_name."\t".$agent_exit_code."\t".$agent_runtime."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.agents 
WHERE 
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This archives the 'alerts' table.
sub archive_alerts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_alerts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{alerts}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_alerts_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY alerts (alert_uuid, alert_host_uuid, alert_agent_name, alert_level, alert_title_key, alert_title_variables, alert_message_key, alert_message_variables, alert_sort, alert_header, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    alert_uuid, 
    alert_host_uuid, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    alert_sort, 
    alert_header, 
    modified_date 
FROM 
    history.alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $history_id              = defined $row->[0]  ? $row->[0]  : '\N';
			my $alert_uuid              = defined $row->[1]  ? $row->[1]  : '\N';
			my $alert_host_uuid         = defined $row->[2]  ? $row->[2]  : '\N';
			my $alert_agent_name        = defined $row->[3]  ? $row->[3]  : '\N';
			my $alert_level             = defined $row->[4]  ? $row->[4]  : '\N';
			my $alert_title_key         = defined $row->[5]  ? $row->[5]  : '\N';
			my $alert_title_variables   = $an->DB->prep_for_archive({string => $row->[6]});
			my $alert_message_key       = defined $row->[7]  ? $row->[7]  : '\N';
			my $alert_message_variables = $an->DB->prep_for_archive({string => $row->[8]});
			my $alert_sort              = defined $row->[9]  ? $row->[9]  : '\N';
			my $alert_header            = defined $row->[10] ? $row->[10] : '\N';
			my $modified_date           = defined $row->[11] ? $row->[11] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0012", message_variables => {
				name1  => "history_id",              value1  => $history_id, 
				name2  => "alert_uuid",              value2  => $alert_uuid, 
				name3  => "alert_host_uuid",         value3  => $alert_host_uuid, 
				name4  => "alert_agent_name",        value4  => $alert_agent_name, 
				name5  => "alert_level",             value5  => $alert_level, 
				name6  => "alert_title_key",         value6  => $alert_title_key, 
				name7  => "alert_title_variables",   value7  => $alert_title_variables, 
				name8  => "alert_message_key",       value8  => $alert_message_key, 
				name9  => "alert_message_variables", value9  => $alert_message_variables, 
				name10 => "alert_sort",              value10 => $alert_sort, 
				name11 => "alert_header",            value11 => $alert_header, 
				name12 => "modified_date",           value12 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $alert_uuid."\t".$alert_host_uuid."\t".$alert_agent_name."\t".$alert_level."\t".$alert_title_key."\t".$alert_title_variables."\t".$alert_message_key."\t".$alert_message_variables."\t".$alert_sort."\t".$alert_header."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

### NOTE: Still need to test loading this...
# This archives the 'health' table.
sub archive_health
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_health" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{health}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.health 
WHERE 
    health_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_health_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY health (health_uuid, health_host_uuid, health_agent_name, health_source_name, health_source_weight, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    health_uuid, 
    health_host_uuid, 
    health_agent_name, 
    health_source_name,
    health_source_weight,
    modified_date 
FROM 
    history.health 
WHERE 
    health_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $history_id           = defined $row->[0] ? $row->[0] : '\N';
			my $health_uuid          = defined $row->[1] ? $row->[1] : '\N';
			my $health_host_uuid     = defined $row->[2] ? $row->[2] : '\N';
			my $health_agent_name    = defined $row->[3] ? $row->[3] : '\N';
			my $health_source_name   = defined $row->[4] ? $row->[4] : '\N';
			my $health_source_weight = defined $row->[5] ? $row->[5] : '\N';
			my $modified_date        = defined $row->[6] ? $row->[6] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "history_id",           value1 => $history_id, 
				name2 => "health_uuid",          value2 => $health_uuid, 
				name3 => "health_host_uuid",     value3 => $health_host_uuid, 
				name4 => "health_agent_name",    value4 => $health_agent_name, 
				name5 => "health_source_name",   value5 => $health_source_name, 
				name6 => "health_source_weight", value6 => $health_source_weight, 
				name7 => "modified_date",        value7 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $health_uuid."\t".$health_host_uuid."\t".$health_agent_name."\t".$health_source_name."\t".$health_source_weight."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.health 
WHERE 
    health_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This archives the 'power' table.
sub archive_power
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_power" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{power}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_power_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY power (power_uuid, power_host_uuid, power_agent_name, power_record_locator, power_ups_name, power_on_battery, power_seconds_left, power_charge_percentage, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    power_uuid, 
    power_host_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
FROM 
    history.power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $history_id              = defined $row->[0] ? $row->[0] : '\N';
			my $power_uuid              = defined $row->[1] ? $row->[1] : '\N';
			my $power_host_uuid         = defined $row->[2] ? $row->[2] : '\N';
			my $power_agent_name        = defined $row->[3] ? $row->[3] : '\N';
			my $power_record_locator    = defined $row->[4] ? $row->[4] : '\N';
			my $power_ups_name          = defined $row->[5] ? $row->[5] : '\N';
			my $power_on_battery        = defined $row->[6] ? $row->[6] : '\N';
			my $power_seconds_left      = defined $row->[7] ? $row->[7] : '\N';
			my $power_charge_percentage = defined $row->[8] ? $row->[8] : '\N';
			my $modified_date           = defined $row->[9] ? $row->[9] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "history_id",              value1  => $history_id, 
				name2  => "power_uuid",              value2  => $power_uuid, 
				name3  => "power_host_uuid",         value3  => $power_host_uuid, 
				name4  => "power_agent_name",        value4  => $power_agent_name, 
				name5  => "power_record_locator",    value5  => $power_record_locator, 
				name6  => "power_ups_name",          value6  => $power_ups_name, 
				name7  => "power_on_battery",        value7  => $power_on_battery, 
				name8  => "power_seconds_left",      value8  => $power_seconds_left, 
				name9  => "power_charge_percentage", value9  => $power_charge_percentage, 
				name10 => "modified_date",           value10 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $power_uuid."\t".$power_host_uuid."\t".$power_agent_name."\t".$power_record_locator."\t".$power_ups_name."\t".$power_on_battery."\t".$power_seconds_left."\t".$power_charge_percentage."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This archives the 'temperature' table.
sub archive_temperature
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_temperature" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{temperature}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_temperature_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY temperature (temperature_uuid, temperature_host_uuid, temperature_agent_name, temperature_sensor_host, temperature_sensor_name, temperature_celsius, temperature_state, temperature_is, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    temperature_uuid, 
    temperature_host_uuid, 
    temperature_agent_name, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
FROM 
    history.temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $history_id              = defined $row->[0] ? $row->[0] : '\N';
			my $temperature_uuid        = defined $row->[1] ? $row->[1] : '\N';
			my $temperature_host_uuid   = defined $row->[2] ? $row->[2] : '\N';
			my $temperature_agent_name  = defined $row->[3] ? $row->[3] : '\N'; 
			my $temperature_sensor_host = defined $row->[4] ? $row->[4] : '\N'; 
			my $temperature_sensor_name = defined $row->[5] ? $row->[5] : '\N';
			my $temperature_celsius     = defined $row->[6] ? $row->[6] : '\N';
			my $temperature_state       = defined $row->[7] ? $row->[7] : '\N';
			my $temperature_is          = defined $row->[8] ? $row->[8] : '\N';
			my $modified_date           = defined $row->[9] ? $row->[9] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "history_id",              value1  => $history_id, 
				name2  => "temperature_uuid",        value2  => $temperature_uuid, 
				name3  => "temperature_host_uuid",   value3  => $temperature_host_uuid, 
				name4  => "temperature_agent_name",  value4  => $temperature_agent_name, 
				name5  => "temperature_sensor_host", value5  => $temperature_sensor_host, 
				name6  => "temperature_sensor_name", value6  => $temperature_sensor_name, 
				name7  => "temperature_celsius",     value7  => $temperature_celsius, 
				name8  => "temperature_state",       value8  => $temperature_state, 
				name9  => "temperature_is",          value9  => $temperature_is, 
				name10 => "modified_date",           value10 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $temperature_uuid."\t".$temperature_host_uuid."\t".$temperature_agent_name."\t".$temperature_sensor_host."\t".$temperature_sensor_name."\t".$temperature_celsius."\t".$temperature_state."\t".$temperature_is."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This archives the 'ram_used' table.
sub archive_ram_used
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_ram_used" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{ram_used}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.ram_used 
WHERE 
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_ram_used_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY ram_used (ram_used_uuid, ram_used_host_uuid, ram_used_by, ram_used_bytes, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    ram_used_uuid, 
    ram_used_host_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
FROM 
    history.ram_used 
WHERE 
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $history_id         = defined $row->[0] ? $row->[0] : '\N';
			my $ram_used_uuid      = defined $row->[1] ? $row->[1] : '\N';
			my $ram_used_host_uuid = defined $row->[2] ? $row->[2] : '\N';
			my $ram_used_by        = defined $row->[3] ? $row->[3] : '\N';
			my $ram_used_bytes     = defined $row->[4] ? $row->[4] : '\N';
			my $modified_date      = defined $row->[5] ? $row->[5] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "history_id",         value1 => $history_id, 
				name2 => "ram_used_uuid",      value2 => $ram_used_uuid, 
				name3 => "ram_used_host_uuid", value3 => $ram_used_host_uuid, 
				name4 => "ram_used_by",        value4 => $ram_used_by, 
				name5 => "ram_used_bytes",     value5 => $ram_used_bytes, 
				name6 => "modified_date",      value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $ram_used_uuid."\t".$ram_used_host_uuid."\t".$ram_used_by."\t".$ram_used_bytes."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.ram_used 
WHERE 
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This archives the 'servers' table.
sub archive_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_servers" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{servers}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.servers 
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_servers_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY servers (server_uuid, server_anvil_uuid, server_name, server_stop_reason, server_start_after, server_start_delay, server_note, server_definition, server_host, server_state, server_migration_type, server_pre_migration_script, server_pre_migration_arguments, server_post_migration_script, server_post_migration_arguments, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    server_uuid, 
    server_anvil_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_note, 
    server_definition, 
    server_host, 
    server_state, 
    server_migration_type, 
    server_pre_migration_script, 
    server_pre_migration_arguments, 
    server_post_migration_script, 
    server_post_migration_arguments, 
    modified_date 
FROM 
    history.servers 
WHERE 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			# The 'prep_for_archive()' method is slow, so we only call it as needed.
			my $history_id                      = defined $row->[0]  ? $row->[0]  : '\N';
			my $server_uuid                     = defined $row->[1]  ? $row->[1]  : '\N';
			my $server_anvil_uuid               = defined $row->[2]  ? $row->[2]  : '\N';
			my $server_name                     = defined $row->[3]  ? $row->[3]  : '\N';
			my $server_stop_reason              = defined $row->[4]  ? $row->[4]  : '\N';
			my $server_start_after              = defined $row->[5]  ? $row->[5]  : '\N';
			my $server_start_delay              = defined $row->[6]  ? $row->[6]  : '\N';
			my $server_note                     = $an->DB->prep_for_archive({string => $row->[7]});
			my $server_definition               = $an->DB->prep_for_archive({string => $row->[8]});
			my $server_host                     = defined $row->[9]  ? $row->[9]  : '\N';
			my $server_state                    = defined $row->[10] ? $row->[10] : '\N';
			my $server_migration_type           = defined $row->[11] ? $row->[11] : '\N';
			my $server_pre_migration_script     = defined $row->[12] ? $row->[12] : '\N';
			my $server_pre_migration_arguments  = defined $row->[13] ? $row->[13] : '\N';
			my $server_post_migration_script    = defined $row->[14] ? $row->[14] : '\N';
			my $server_post_migration_arguments = defined $row->[15] ? $row->[15] : '\N';
			my $modified_date                   = defined $row->[16] ? $row->[16] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0017", message_variables => {
				name1  => "history_id",                      value1  => $history_id, 
				name2  => "server_uuid",                     value2  => $server_uuid, 
				name3  => "server_anvil_uuid",               value3  => $server_anvil_uuid, 
				name4  => "server_name",                     value4  => $server_name, 
				name5  => "server_stop_reason",              value5  => $server_stop_reason, 
				name6  => "server_start_after",              value6  => $server_start_after, 
				name7  => "server_start_delay",              value7  => $server_start_delay, 
				name8  => "server_note",                     value8  => $server_note, 
				name9  => "server_definition",               value9  => $server_definition, 
				name10 => "server_host",                     value10 => $server_host, 
				name11 => "server_state",                    value11 => $server_state, 
				name12 => "server_migration_type",           value12 => $server_migration_type, 
				name13 => "server_pre_migration_script",     value13 => $server_pre_migration_script, 
				name14 => "server_pre_migration_arguments",  value14 => $server_pre_migration_arguments, 
				name15 => "server_post_migration_script",    value15 => $server_post_migration_script, 
				name16 => "server_post_migration_arguments", value16 => $server_post_migration_arguments, 
				name17 => "modified_date",                   value17 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $server_uuid."\t".$server_anvil_uuid."\t".$server_name."\t".$server_stop_reason."\t".$server_start_after."\t".$server_start_delay."\t".$server_note."\t".$server_definition."\t".$server_host."\t".$server_state."\t".$server_migration_type."\t".$server_pre_migration_script."\t".$server_pre_migration_arguments."\t".$server_post_migration_script."\t".$server_post_migration_arguments."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.servers 
WHERE 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This archives the 'hosts' table.
sub archive_hosts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "archive_hosts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $offset = $an->data->{archive}{table}{hosts}{offset};
	my $query  = "
SELECT 
    modified_date 
FROM 
    history.hosts 
ORDER BY 
    modified_date ASC 
OFFSET ".$an->data->{sys}{use_db_fh}->quote($offset)." 
LIMIT 1
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	   $date = "" if not defined $date;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If I got a date, proceed.
	my $archive_file = "";
	if ($date)
	{
		# Start the output file.
		my $start_time    =  time;
		my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
		   $date_and_time =~ s/:/-/g;
		   $archive_file  =  $an->data->{path}{scancore_archive}."/scancore-archive_hosts_".$an->hostname."_".$date_and_time.".out";
		   $archive_file  =~ s/\/+/\//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "date_and_time", value1 => $date_and_time,
			name2 => "archive_file",  value2 => $archive_file,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Open the file
		my $header_date = $an->Get->date_and_time({split_date_time => 0});
		my $shell_call  = $archive_file;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "-- $header_date\n";
		print $file_handle $an->data->{scancore}{archive}{dump_file_header}."\n";
		print $file_handle "COPY hosts (host_uuid, host_name, host_type, host_emergency_stop, host_stop_reason, host_health, modified_date) FROM stdin;\n";
		
		my $query = "
SELECT 
    history_id, 
    host_uuid, 
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    host_health, 
    modified_date 
FROM 
    history.hosts 
WHERE 
    modified_date <= '$date'
ORDER BY 
    modified_date DESC 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "count",   value1 => $count, 
			name2 => "results", value2 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			# The 'prep_for_archive()' method is slow, so we only call it as needed.
			my $history_id          = defined $row->[0] ? $row->[0] : '\N';
			my $host_uuid           = defined $row->[1] ? $row->[1] : '\N';
			my $host_name           = defined $row->[2] ? $row->[2] : '\N';
			my $host_type           = defined $row->[3] ? $row->[3] : '\N';
			my $host_emergency_stop = defined $row->[4] ? $row->[4] : '\N';
			my $host_stop_reason    = defined $row->[5] ? $row->[5] : '\N';
			my $host_health         = defined $row->[6] ? $row->[6] : '\N';
			my $modified_date       = defined $row->[7] ? $row->[7] : '\N';
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "history_id",          value1 => $history_id, 
				name2 => "host_uuid",           value2 => $host_uuid, 
				name3 => "host_name",           value3 => $host_name, 
				name4 => "host_type",           value4 => $host_type, 
				name5 => "host_emergency_stop", value5 => $host_emergency_stop, 
				name6 => "host_stop_reason",    value6 => $host_stop_reason, 
				name7 => "host_health",         value7 => $host_health, 
				name8 => "modified_date",       value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# The 'history_id' is NOT consistent between databases! So we don't record it here.
			print $file_handle $host_uuid."\t".$host_name."\t".$host_type."\t".$host_emergency_stop."\t".$host_stop_reason."\t".$host_health."\t".$modified_date."\n";
		}
		
		# Close it up.
		print $file_handle "\\.\n\n";;
		close $file_handle;
		
		# Delete the records now.
		$query = "
DELETE FROM 
    history.hosts 
WHERE 
    modified_date <= '$date'
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $archive_time = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "archive_time", value1 => $archive_time, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "archive_file", value1 => $archive_file, 
	}, file => $THIS_FILE, line => __LINE__});
	return($archive_file);
}

# This connects to the available databases and clears the "resync" flag.
sub clear_resync_flag
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "clear_resync_flag" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
	if (not $connections)
	{
		# Failed to connect to any database.
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0094", file => $THIS_FILE, line => __LINE__});
		$an->nice_exit({exit_code => 1});
	}
	
	# Disconnect from databases.
	$an->DB->disconnect_from_databases();
	
	return(0);
}

# This locates and reads in the database data about this Anvil! 
sub update_anvil_data
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_anvil_data" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: Update this to work on dashboards as well
	# Load the information about the Anvil! this node is a part of (if it has been added to the database
	# yet).
	if ((not $an->data->{sys}{anvil_uuid}) && (-e $an->data->{path}{cman_config}))
	{
		my $cluster_name = $an->Cman->cluster_name();
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "cluster_name", value1 => $cluster_name,
		}, file => $THIS_FILE, line => __LINE__});
		my $anvil_data = $an->ScanCore->get_anvils();
		my $anvil_uuid = "";
		foreach my $hash_ref (@{$anvil_data})
		{
			my $anvil_name = $hash_ref->{anvil_name};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_name", value1 => $anvil_name,
			}, file => $THIS_FILE, line => __LINE__});

			if ($anvil_name eq $cluster_name)
			{
				# Found it.
				$anvil_uuid = $hash_ref->{anvil_uuid};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "anvil_uuid", value1 => $anvil_uuid,
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "anvil_uuid", value1 => $anvil_uuid,
		}, file => $THIS_FILE, line => __LINE__});
		if ($anvil_uuid)
		{
			$an->data->{sys}{anvil_uuid} = $anvil_uuid;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "sys::anvil_uuid", value1 => $an->data->{sys}{anvil_uuid},
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "sys::anvil_uuid", value1 => $an->data->{sys}{anvil_uuid},
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{anvil_uuid})
	{
		$an->Striker->load_anvil({anvil_uuid => $an->data->{sys}{anvil_uuid}});
	}
	
	return(0);
}

# This checks to see if an instance of the program is running. It also checks to see if the program is 
# configured to run on boot.
sub report_state
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "report_state" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Is it enabled in striker.conf?
	if ($an->data->{scancore}{enabled})
	{
		# Yup.
		print $an->String->get({key => "scancore_message_0007"})."\n";
	}
	else
	{
		# Nope.
		print $an->String->get({key => "scancore_message_0008"})."\n";
	}
	
	# Is it running now?
	my $pids  = $an->Get->pids({program_name => $0});
	my $count = @{$pids};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($count)
	{
		# Yup.
		print $an->String->get({key => "scancore_message_0009"})."\n";
		foreach my $pid (sort {$a cmp $b} @{$pids})
		{
			print $an->String->get({key => "scancore_message_0010", variables => { pid => $pid }})."\n";
		}
	}
	else
	{
		print $an->String->get({key => "scancore_message_0011"})."\n";
	}
	
	return(0);
}

# This exits if ScanCore was called with '--one-shot'
sub exit_if_one_shot
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "exit_if_one_shot" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if ($an->data->{switches}{'one-shot'})
	{
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0083", file => $THIS_FILE, line => __LINE__});
		my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
		if ($connections)
		{
			# Log that we're exiting on being disabled.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scancore_log_0083",
				alert_message_variables	=>	"",
			});
			process_alerts($an, 0);
			$an->DB->disconnect_from_databases();
		}
		$an->nice_exit({exit_code => 0});
	}
	
	return(0);
}

# This exits if the user has disabled ScanCore.
sub exit_if_disabled
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "exit_if_disabled" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	if (not $an->data->{scancore}{enabled})
	{
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0065", file => $THIS_FILE, line => __LINE__});
		my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
		if ($connections)
		{
			# Log that we're exiting on being disabled.
			$an->Alert->register_alert({
				alert_level		=>	"notice", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0003",
				alert_message_key	=>	"scancore_log_0065",
				alert_message_variables	=>	"",
			});
			process_alerts($an, 0);
			$an->DB->disconnect_from_databases();
		}
		$an->nice_exit({exit_code => 0});
	}
	
	return(0);
}

# This updates striker.conf to enable or disable ScanCore.
sub update_configuration
{
	my ($an, $do) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_configuration" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "do", value1 => $do,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $ok = 1;
	my $shell_call  = $an->data->{path}{sed}." -i 's/^scancore::enabled\\(\\s*\\)=\\(\\s*\\)1/scancore::enabled\\1=\\20/' ".$an->data->{path}{striker_config}."\n";
	if ($do eq "enable")
	{
		$shell_call = $an->data->{path}{sed}." -i 's/^scancore::enabled\\(\\s*\\)=\\(\\s*\\)0/scancore::enabled\\1=\\21/' ".$an->data->{path}{striker_config}."\n";
	}
	$shell_call .= "
if \$(".$an->data->{path}{'grep'}." -q '^scancore::enabled\\s*=\\s*1' ".$an->data->{path}{striker_config}.");
then 
    echo enabled; 
else 
    echo disabled;
fi";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($line =~ /enabled/)
		{
			# Did I want this?
			if ($do eq "enable")
			{
				# Good!
				$an->Log->entry({log_level => 1, message_key => "scancore_log_0071", file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Woops...
				$an->Alert->warning({message_key => "scancore_warning_0015", quiet => 1, file => $THIS_FILE, line => __LINE__});
				$ok = 0;
			}
			
			# Make sure the crontab entry exists.
			my $shell_call = "
if \$(".$an->data->{path}{'grep'}." -q '".$an->data->{path}{ScanCore}."' ".$an->data->{path}{striker_config}.");
then 
    ".$an->data->{path}{echo}." 'in crontab'; 
else 
    ".$an->data->{path}{echo}." 'adding the crontab';
    ".$an->data->{path}{echo}." '*/1 * * * * ".$an->data->{path}{ScanCore}."' >> ".$an->data->{path}{root_crontab}."
fi";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		elsif ($line =~ /disabled/)
		{
			# Did I want this?
			if ($do eq "disable")
			{
				# Good!
				$an->Log->entry({log_level => 1, message_key => "scancore_log_0072", file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Woops...
				$an->Alert->warning({message_key => "scancore_warning_0016", quiet => 1, file => $THIS_FILE, line => __LINE__});
				$ok = 0;
			}
		}
	}
	close $file_handle;
	
	return($ok);
}

# These are the scan run (different for nodes and dashboards) after a sweep is finished. This is where the 
# big decisions are made.
sub do_post_scan_checks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "do_post_scan_checks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# What we do here strongly depends on whether we're a node or a dashboard. 
	# 
	# If we're a node, we will withdraw and shut down if the UPS power is depleted past a certain point
	# or if temperatures go outside acceptible ranges. If any sensor deviates, we set our "sick" flag and
	# ensure it is clear if we're A-OK.
	# 
	# If this is a dashboard, we never shutdown. Instead, we will watch the nodes configured in our 
	# /etc/striker/striker.conf and if they're offline and the host shut itself down, we'll watch the
	# UPSes and temperature sensors. If/when things are good, we'll boot the nodes back up.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (not $an->data->{scancore}{i_am_a})
	{
		# What am I?
		$an->data->{scancore}{i_am_a} = $an->Get->what_am_i();
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::i_am_a", value1 => $an->data->{scancore}{i_am_a}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{i_am_a} eq "dashboard")
	{
		# Do the dashboard stuff.
		do_post_scan_dashboard_tasks($an);
	}
	else
	{
		# Do the node stuff.
		do_post_scan_node_tasks($an);
	}
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0061", file => $THIS_FILE, line => __LINE__});
	
	return(0);
}

### TODO: Make this AN::Tools::Get->node_cache().
# This reads in the various node cache files
sub read_cache
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "read_cache" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: Read in the nodes' etc_hosts cache and find their UPSes.
	
	# This will be stuck onto the start of fence agents that don't have a full path.
	my $fence_path = $an->data->{path}{fence_agents};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "fence_path", value1 => $fence_path
	}, file => $THIS_FILE, line => __LINE__});
	my $node_cache = $an->ScanCore->get_nodes_cache();
	my $node_data  = $an->ScanCore->get_nodes();
	foreach my $hash_ref (@{$node_data})
	{
		my $node_name                                  = $hash_ref->{host_name};
		my $node_uuid                                  = $hash_ref->{node_uuid};
		   $an->data->{node}{uuid_to_name}{$node_uuid} = $node_name;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "node::uuid_to_name::$node_uuid", value1 => $an->data->{node}{uuid_to_name}{$node_uuid}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	foreach my $hash_ref (@{$node_cache})
	{
		# Match the cache owner to a cache name.
		my $node_cache_node_uuid = $hash_ref->{node_cache_node_uuid};
		my $node_cache_name      = $hash_ref->{node_cache_name};
		my $node_cache_data      = $hash_ref->{node_cache_data};
		my $node_name            = $an->data->{node}{uuid_to_name}{$node_cache_node_uuid};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "node_cache_node_uuid", value1 => $node_cache_node_uuid, 
			name2 => "node_cache_name",      value2 => $node_cache_name, 
			name3 => "node_cache_data",      value3 => $node_cache_data, 
			name4 => "node_name",            value4 => $node_name, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Parse out the data
		if ($node_cache_name eq "etc_hosts")
		{
			foreach my $line (split/\n/, $node_cache_data)
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+(.*)/)
				{
					### TODO: Check if the host has spaces and split if so.
					my $this_ip   = $1;
					my $this_host = $2;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
						name1 => "this_ip",   value1 => $this_ip, 
						name2 => "this_host", value2 => $this_host, 
					}, file => $THIS_FILE, line => __LINE__});
					
					$an->data->{cache}{$node_name}{host}{$this_host}{ip} = $this_ip;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "cache::${node_name}::host::${this_host}::ip", value1 => $an->data->{cache}{$node_name}{host}{$this_host}{ip}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		else
		{
			if ($node_cache_name eq "power_check")
			{
				# Stick the full path onto the 'power_check_command'.
				$node_cache_data =~ s/^fence/$fence_path\/fence/;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "node_cache_data", value1 => $node_cache_data, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			$an->data->{cache}{$node_name}{info}{$node_cache_name} = $node_cache_data;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "cache::${node_name}::info::${node_cache_name}", value1 => $an->data->{cache}{$node_name}{info}{$node_cache_name}
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	return(0);
}

# This tries to log into each node 
sub check_for_dlm_hang
{
	my ($an, $node) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_for_dlm_hang" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "node", value1 => $node,
	}, file => $THIS_FILE, line => __LINE__});
	
	# We'll only act on nodes that we have the ability to fence.
	my $reboot = 0;
	### NOTE: This exposes the password.
	my $power_check_command = $an->data->{cache}{$node}{info}{power_check_command};
	$an->Log->entry({log_level => 4, message_key => "an_variables_0002", message_variables => {
		name1 => "power_check_command", value1 => $power_check_command, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($power_check_command)
	{
		# First, can we access it?
		my $return   = $an->Get->node_info({name => $node});
		my $target   = $return->{use_ip};
		my $port     = $return->{use_port};
		my $password = $return->{password};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "target", value1 => $target,
			name2 => "port",   value1 => $port,
		}, file => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "password", value1 => $password,
		}, file => $THIS_FILE, line => __LINE__});
		
		my $access = $an->Check->access({
			target		=>	$target,
			port		=>	$port,
			password	=>	$password,
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "access", value1 => $access,
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($access)
		{
			### TODO: Make this a lot more graceful...
			# If we're dashboard 2 (or higher), add time to the timeout to make sure we don't try
			# to kill the node at the exact same time as dashboard 1.
			if ($an->hostname() =~ /2$/)
			{
				$an->data->{scancore}{dashboard}{dlm_hung_timeout} += 10;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::dashboard::dlm_hung_timeout", value1 => $an->data->{scancore}{dashboard}{dlm_hung_timeout},
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($an->hostname() =~ /3$/)
			{
				$an->data->{scancore}{dashboard}{dlm_hung_timeout} += 20;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::dashboard::dlm_hung_timeout", value1 => $an->data->{scancore}{dashboard}{dlm_hung_timeout},
				}, file => $THIS_FILE, line => __LINE__});
			}
			if ($an->hostname() =~ /4$/)
			{
				$an->data->{scancore}{dashboard}{dlm_hung_timeout} += 30;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::dashboard::dlm_hung_timeout", value1 => $an->data->{scancore}{dashboard}{dlm_hung_timeout},
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# We can log in, so call 'timeout X ls /shared'
			my $shell_call = "
if [ -e '".$an->data->{path}{shared}." ];
then
    ".$an->data->{path}{timeout}." ".$an->data->{scancore}{dashboard}{dlm_hung_timeout}." ".$an->data->{path}{ls}." ".$an->data->{path}{shared}." || ".$an->data->{path}{echo}." timeout
else
    ".$an->data->{path}{echo}." 'does not exist'
fi
";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "shell_call", value1 => $shell_call,
				name2 => "target",     value2 => $node,
			}, file => $THIS_FILE, line => __LINE__});
			my ($error, $ssh_fh, $return) = $an->Remote->remote_call({
				target		=>	$target,
				port		=>	$port,
				password	=>	$password,
				'close'		=>	1,
				shell_call	=>	$shell_call,
			});
			foreach my $line (@{$return})
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($line eq "timeout")
				{
					# No good... fence it
					$reboot = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "reboot", value1 => $reboot, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "reboot", value1 => $reboot, 
	}, file => $THIS_FILE, line => __LINE__});
	return($reboot);
}

# This will read in all nodes in 'hosts' and for each node it sees, it will reference its cache to check 
# its power status. If the node if off, it will check hosts -> host_emergency_stop and if it is TRUE, check
# to see if it is safe to boot the nodes back up. If the node is on, it will clear the 'host_emergency_stop'
# and 'host_stop_reason', if set.
sub do_post_scan_dashboard_tasks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "do_post_scan_dashboard_tasks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Start by reading in all the cache files we have. We'll skip any nodes we see in the DB that don't
	# have a cache file.
	read_cache($an);
	
	# Make sure shorewall is not set to run on boot.
	check_shorewall($an);
	
	### TODO: Switch this to $an->ScanCore->get_hosts()'.
	# Now read in all the nodes we know about.
	my $query = "
SELECT 
    a.host_uuid, 
    a.host_name, 
    a.host_emergency_stop, 
    a.host_stop_reason, 
    a.host_health, 
    round(extract(epoch from a.modified_date)), 
    b.node_uuid 
FROM 
    hosts a, 
    nodes b 
WHERE 
    a.host_uuid = b.node_host_uuid 
AND 
    a.host_type = 'node' 
ORDER BY 
    a.host_name ASC
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $host_uuid           = $row->[0];
		my $host_name           = $row->[1];
		my $host_emergency_stop = $row->[2];
		my $host_stop_reason    = $row->[3] ? $row->[3] : "";
		my $host_health         = $row->[4] ? $row->[4] : "";
		my $unix_modified_date  = $row->[5];
		my $node_uuid           = $row->[6];
		$an->Log->entry({log_level => 1, message_key => "an_variables_0007", message_variables => {
			name1 => "host_uuid",           value1 => $host_uuid, 
			name2 => "host_name",           value2 => $host_name, 
			name3 => "host_emergency_stop", value3 => $host_emergency_stop, 
			name4 => "host_stop_reason",    value4 => $host_stop_reason, 
			name5 => "host_health",         value5 => $host_health, 
			name6 => "unix_modified_date",  value6 => $unix_modified_date, 
			name7 => "node_uuid",           value7 => $node_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# - Node states:
		# on      - The fence device is reachable and the port is in the on state.
		# unknown - The fence device could not be reached.
		# off     - The fence device is reachable and the port is in the off state.
		my $state = $an->ScanCore->target_power({
				target => $node_uuid, 
				task   => "status",
			});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "state", value1 => $state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		### TODO: Use the secondary fence method if the primary fence method fails.
		# Nothing to do if we can't reach the node
		if ($state eq "unknown")
		{
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0084", message_variables => { node => $host_name }, file => $THIS_FILE, line => __LINE__});
			next;
		}
		
		# If it is on, clear its 'host_emergency_stop' and 'host_stop_reason', if set. The exception
		# being when the 'host_stop_reason' is a time stamp or if it is 'clean' and less than two 
		# minutes old.
		if ($state eq "on")
		{
			# Before we do anything else, see if the node's DLM is hung, if enabled by the user.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "scancore::dashboard::dlm_hung_timeout", value1 => $an->data->{scancore}{dashboard}{dlm_hung_timeout}, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{scancore}{dashboard}{dlm_hung_timeout})
			{
				# Error if the value is not a digit.
				if ($an->data->{scancore}{dashboard}{dlm_hung_timeout} =~ /\D/)
				{
					$an->Log->entry({log_level => 1, title_key => "tools_title_0002", message_key => "scancore_warning_0025", message_variables => {
						value => $an->data->{scancore}{dashboard}{dlm_hung_timeout}, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				else
				{
					# Timeout value looks good.
					my $reboot = check_for_dlm_hang($an, $host_name);
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "reboot", value1 => $reboot, 
					}, file => $THIS_FILE, line => __LINE__});
					
					# Reboot, if needed
					if ($reboot)
					{
						$an->Log->entry({log_level => 0, title_key => "tools_title_0002", message_key => "scancore_log_0087", message_variables => {
							node => $host_name,
						}, file => $THIS_FILE, line => __LINE__});
						reboot_node($an, $host_name, $host_uuid, $node_uuid);
					}
				}
			}
			
			# No need to check if it should be booted.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0085", message_variables => { node => $host_name }, file => $THIS_FILE, line => __LINE__});
			
			# Check to see if there is a time-type stop reason and, if so, see if it is stale.
			my $clear   = 1;
			my $time    = time;
			my $set_age = $time - $unix_modified_date;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
				name1 => "host_stop_reason",   value1 => $host_stop_reason, 
				name2 => "time",               value2 => $time, 
				name3 => "unix_modified_date", value3 => $unix_modified_date, 
				name4 => "set_age",            value4 => $set_age, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($host_stop_reason =~ /^\d+$/)
			{
				# Timed reboot. See if the timer has expired.
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "time", value1 => time, 
				}, file => $THIS_FILE, line => __LINE__});
				if (time <= $host_stop_reason)
				{
					# It is active, don't clear it.
					$clear = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "clear", value1 => $clear, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			elsif ($host_stop_reason eq "clean")
			{
				# It is clean off, how long ago was it set? If it is less than two minutes 
				# old, don't clear it in case it is still shutting down.
				if ($set_age < 120)
				{
					# It is too recent, wait.
					$clear = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "clear", value1 => $clear, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			
			### NOTE: Disabled, because it was clearing before a 'clean' stop could finish. We'll
			###       trust the node to clear its own state on boot in anvil-safe-start.
# 			# OK, if 'clear' and if there is a stop reason and/or estop flag, clear it
# 			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
# 				name1 => "clear",               value1 => $clear, 
# 				name2 => "host_emergency_stop", value2 => $host_emergency_stop, 
# 				name3 => "host_stop_reason",    value3 => $host_stop_reason, 
# 			}, file => $THIS_FILE, line => __LINE__});
# 			if (($clear) && (($host_emergency_stop) or ($host_stop_reason)))
# 			{
# 				# Clear it
# 				$an->Log->entry({log_level => 1, message_key => "scancore_log_0086", message_variables => {
# 					node => $host_name, 
# 				}, file => $THIS_FILE, line => __LINE__});
# 				clear_node_stop($an, $host_uuid);
# 			}
			next;
		}
		
		### If we're still here, the node is off so see if we can boot it.
		# Read in the power table.
		read_power_table($an);
		
		# Make sure our own temperature is good.
		my $my_temperature_is_ok = check_node_temperature_health($an, $an->hostname);
		
		# See if the power and temperature at the node is safe enough to boot this node.
		my $power_is_safe       = check_node_power_health      ($an, $host_uuid);
		my $temperature_is_safe = check_node_temperature_health($an, $host_name);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "power_is_safe",                 value1 => $power_is_safe, 
			name2 => "temperature_is_safe",           value2 => $temperature_is_safe, 
			name3 => "my_temperature_is_ok",          value3 => $my_temperature_is_ok, 
			name4 => "scancore::disable::boot_nodes", value4 => $an->data->{scancore}{disable}{boot_nodes}
		}, file => $THIS_FILE, line => __LINE__});
		
		# If 'host_stop_reason' is 'clean', don't boot. Otherwise, if the power and temperature is 
		# good, try to boot the node!
		if ($host_stop_reason eq "clean")
		{
			# Leave it off.
			if (not $an->data->{sys}{reported}{$host_name}{node_clean_off})
			{
				$an->Log->entry({log_level => 1, message_key => "scancore_log_0063", message_variables => {
					node => $host_name, 
				}, file => $THIS_FILE, line => __LINE__});
				$an->data->{sys}{reported}{$host_name}{node_clean_off} = 1;
			}
		}
		elsif ($an->data->{scancore}{disable}{boot_nodes})
		{
			# Booting is disabled.
			if (not $an->data->{sys}{reported}{$host_name}{boot_disabled})
			{
				$an->Log->entry({log_level => 1, message_key => "scancore_log_0069", message_variables => {
					node => $host_name, 
				}, file => $THIS_FILE, line => __LINE__});
				$an->data->{sys}{reported}{$host_name}{boot_disabled} = 1;
			}
		}
		elsif ($host_stop_reason =~ /^\d+$/)
		{
			# Timed reboot. See if the timer has expired.
			my $time       = time;
			my $difference = time - $host_stop_reason;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
				name1 => "time",             value1 => $time, 
				name2 => "host_stop_reason", value2 => $host_stop_reason, 
				name3 => "difference",       value3 => $difference, 
			}, file => $THIS_FILE, line => __LINE__});
			if (time > $host_stop_reason)
			{
				# Time to boot.
				$an->Log->entry({log_level => 1, message_key => "scancore_log_0067", message_variables => {
					node => $host_name, 
				}, file => $THIS_FILE, line => __LINE__});
				my $state = $an->ScanCore->target_power({
						target => $node_uuid,
						task   => "on",
					});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "state", value1 => $state, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# Not yet time to boot.
				my $time_left = $host_stop_reason - time;
				if (not $an->data->{sys}{reported}{$host_name}{boot_delayed})
				{
					$an->Log->entry({log_level => 1, message_key => "scancore_log_0068", message_variables => {
						node		=>	$host_name, 
						time_left	=>	$time_left
					}, file => $THIS_FILE, line => __LINE__});
					$an->data->{sys}{reported}{$host_name}{boot_delayed} = 1;
				}
			}
		}
		elsif (($power_is_safe) && ($temperature_is_safe) && ($my_temperature_is_ok))
		{
			# Okie!
			my $state = $an->ScanCore->target_power({
					target => $node_uuid, 
					task   => "on",
				});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "state", value1 => $state, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Not ready to boot yet.
			if (not $an->data->{sys}{reported}{$host_name}{node_not_ready})
			{
				$an->Log->entry({log_level => 1, message_key => "scancore_log_0062", message_variables => {
					node => $host_name, 
				}, file => $THIS_FILE, line => __LINE__});
				$an->data->{sys}{reported}{$host_name}{node_not_ready} = 1;
			}
		}
		
	}
	
	return(0);
}

# This checks to ensure that shorewall is not set to start on boot, which can be set after an OS update.
sub check_shorewall
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_shorewall", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $state = $an->System->daemon_boot_config({daemon => "shorewall"});
	my $rc3   = $state->{3};
	my $rc5   = $state->{5};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "rc3", value1 => $rc3, 
		name2 => "rc5", value2 => $rc5, 
	}, file => $THIS_FILE, line => __LINE__});
	if (($rc3 eq "on") or ($rc5 eq "on"))
	{
		# Turn it off.
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0095", message_variables => {
			'3' => $rc3, 
			'5' => $rc5, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $state = $an->System->daemon_boot_config({
				daemon => "shorewall",
				set    => "off",
			});
		my $rc3   = $state->{3};
		my $rc5   = $state->{5};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "rc3", value1 => $rc3, 
			name2 => "rc5", value1 => $rc5, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This clears the node's 'host_emergency_stop' and 'host_stop_reason' columns.
sub clear_node_stop
{
	my ($an, $host_uuid) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "clear_node_stop" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "host_uuid", value1 => $host_uuid,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $query = "
UPDATE 
    hosts 
SET 
    host_emergency_stop = FALSE, 
    host_stop_reason    = NULL, 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    host_uuid           = ".$an->data->{sys}{use_db_fh}->quote($host_uuid)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
	return(0);
}

# This reboots a node (ie: that may be hung)
sub reboot_node
{
	my ($an, $host_name, $host_uuid, $node_uuid) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "reboot_node" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "host_name", value1 => $host_name, 
		name2 => "host_uuid", value2 => $host_uuid,
		name3 => "node_uuid", value3 => $node_uuid,
	}, file => $THIS_FILE, line => __LINE__});
	
	# This shouldn't be called unless we confirmed the node is off, so no need to check again, just boot.
	my $rebooted = 0;
	my $state    = $an->ScanCore->target_power({
			target => $node_uuid,
			task   => "off",
		});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "state", value1 => $state, 
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($state eq "off")
	{
		# Shutdown, at least, worked.
		$rebooted = 1;
		$an->Log->entry({log_level => 0, title_key => "tools_title_0002", message_key => "scancore_log_0088", message_variables => {
			node => $host_name,
		}, file => $THIS_FILE, line => __LINE__});
		
		$state = $an->ScanCore->target_power({
				target => $node_uuid,
				task   => "on",
			});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "state", value1 => $state, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "state", value1 => $state, 
	}, file => $THIS_FILE, line => __LINE__});
	return($state);
}

### TODO: Let the user set a minimum percentage based on 1 powered UPS and a separate one (that can be lower)
###       when both UPSes are powered.
# This pulls in the list of UPSes powering the given node and checks to see if they are healthy enough to 
# power the node.
sub check_node_power_health
{
	my ($an, $node_uuid) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_power_health" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "node_uuid", value1 => "$node_uuid" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $power_is_safe = 0;
	
	# This will hold the percentag charge of the strongest UPS powering the node that has input power.
	my $highest_charge = 0;
	
	### TODO: This should use power_ups_uuid, NOT power_ups_name!
	# Read in the names of the UPSes watched by this node.
	my $query = "
SELECT 
    power_ups_name 
FROM 
    power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($node_uuid)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count
	}, file => $THIS_FILE, line => __LINE__});
	if (not $count)
	{
		# We treat no UPSes as OK power.
		$power_is_safe = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "power_is_safe", value1 => $power_is_safe
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		foreach my $row (@{$results})
		{
			my $power_ups_name = $row->[0];
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "power_ups_name",                value1 => $power_ups_name, 
				name2 => "ref(power::${power_ups_name})", value2 => ref($an->data->{power}{$power_ups_name}),
			}, file => $THIS_FILE, line => __LINE__});
			
			# Do I know about this UPS?
			if (ref($an->data->{power}{$power_ups_name}))
			{
				# Yup!
				my $power_on_battery        = $an->data->{power}{$power_ups_name}{power_on_battery};
				my $power_charge_percentage = $an->data->{power}{$power_ups_name}{power_charge_percentage};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "power_on_battery",        value1 => $power_on_battery, 
					name2 => "power_charge_percentage", value2 => $power_charge_percentage,
				}, file => $THIS_FILE, line => __LINE__});
				
				$power_on_battery = 1 if $power_on_battery eq "TRUE";
				$power_on_battery = 0 if $power_on_battery eq "FALSE";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "power_on_battery", value1 => $power_on_battery, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
					name1 => "power_on_battery",        value1 => $power_on_battery, 
					name2 => "power_charge_percentage", value2 => $power_charge_percentage, 
					name3 => "highest_charge",          value3 => $highest_charge, 
				}, file => $THIS_FILE, line => __LINE__});
				if ((not $power_on_battery) && ($power_charge_percentage > $highest_charge))
				{
					$highest_charge = $power_charge_percentage;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "highest_charge", value1 => $highest_charge, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		
		# Now, do I have a UPS above the minimum charge percentage? Strip the '%' off if the user entered it.
		$an->data->{scancore}{minimum_safe_charge} =~ s/%//;
		$an->data->{scancore}{minimum_safe_charge} =~ s/\s//g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "scancore::minimum_safe_charge", value1 => $an->data->{scancore}{minimum_safe_charge}, 
			name2 => "highest_charge",                value2 => $highest_charge, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($highest_charge > $an->data->{scancore}{minimum_safe_charge})
		{
			# Yup, bueno!
			$power_is_safe = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "power_is_safe", value1 => $power_is_safe
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "power_is_safe", value1 => $power_is_safe
	}, file => $THIS_FILE, line => __LINE__});
	return($power_is_safe);
}

# This pulls in the list of temperatures for the given node and checks to see 
# if they are healthy enough to power the node back up.
sub check_node_temperature_health
{
	my ($an, $node) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_temperature_health" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "node", value1 => "$node" 
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: When this is called against a dashboard without IPMI, it will
	###       always return OK.
	# This will get set to '0' if the temperature is not OK.
	my $temperature_is_safe = 1;
	
	# Read in all of the temperature entries for this node 
	my $query = "
SELECT 
    temperature_agent_name, 
    temperature_sensor_name, 
    temperature_state 
FROM 
    temperature 
WHERE 
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($node)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		# If any are in 'warning' or 'critical', set the
		# 'temperature_is_safe' variable to '0'.
		my $temperature_agent_name  = $row->[0];
		my $temperature_sensor_name = $row->[1];
		my $temperature_state       = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "temperature_agent_name",  value1 => $temperature_agent_name, 
			name2 => "temperature_sensor_name", value2 => $temperature_sensor_name, 
			name3 => "temperature_state",       value3 => $temperature_state, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($temperature_state ne "ok")
		{
			$temperature_is_safe = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "temperature_is_safe",  value1 => $temperature_is_safe, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	### Make sure that, if the sensors are OK, that we've waited the required amount of time. If not, set
	### the 'temperature_is_safe' to '0' to prevent booting.
	
	# When a node has gone into emergency stop because of an over-temperature event, we want to give it 
	# time to cool down before we boot it back up.
	# 
	# Likewise, if we rebooted it and it went back down quickly, give it more time before starting it 
	# back up. We do this by reading in how many times the node went into thermal shutdown over the last
	# six hours. The number of returned shut-downs will determine how long I wait before booting the node
	# back up.
	# 
	# The default schedule is:
	# Reboots | Wait until boot
	# --------+-----------------
	#  1      | 10m
	#  2      | 30m
	#  3      | 60m
	#  4      | 120m
	#  >4     | 6h
	# --------+-----------------
	# 
	# NOTE: When a node is off, we can't read most of its sensors, but I usually can read 'Ambient' and
	#       'Systemboard'. So before starting the node, check with these values and make sure they're ok.
	#       If either are still in warning territory, stay off no matter what.
	#       
	# To determine the number or reboots, do the following query:
	# 
	# TODO: This will catch power-loss reboots. For now, we aren't going to worry about this because it
	#       is unlikely it would happen at the same time and even if it did, the consequences aren't that
	#       big. This could be a wrong assumption though, so revisit this later once testing is under 
	#       way.
	#     
	# NOTE: As time passes, we may slip into a period where the node starts rebooting more often until 
	#       the count goes back up. We may need to read the time stamps of the last day and analyze the 
	#       reboot times later.
	# 
	if ($temperature_is_safe)
	{
		# How often have I shut down?
		my $last_shutdown = 0;
		my $query         = "
SELECT 
    round(extract(epoch from modified_date))
FROM 
    history.hosts 
WHERE 
    host_name           = ".$an->data->{sys}{use_db_fh}->quote($node)." 
AND 
    host_emergency_stop = TRUE 
AND 
    host_stop_reason    = 'temperature' 
AND 
    modified_date > (now() - interval '6h')
ORDER BY 
    modified_date ASC
;";
		# There should always be at least one.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		my $results        = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $shutdown_count = @{$results};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shutdown_count", value1 => $shutdown_count
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			$last_shutdown = $row->[0];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "last_shutdown", value1 => $last_shutdown
			}, file => $THIS_FILE, line => __LINE__});
		}
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "last_shutdown", value1 => $last_shutdown
		}, file => $THIS_FILE, line => __LINE__});
		
		# Now I know when the node last shut down and how many times it
		# shut down in the last 6 hours. 
		# 
		# Now, how long should we wait and has it been that long since
		# the last shutdown?
		my $delay = 0;
		if ($shutdown_count > 4)
		{
			# 6 hours
			$delay = $an->data->{scancore}{thermal_reboot_delay}{more};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 4)
		{
			# 2 hours
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'4'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 3)
		{
			# 1 hour
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'3'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 2)
		{
			# 30 minutes
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'2'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($shutdown_count == 1)
		{
			# 10 minutes
			$delay = $an->data->{scancore}{thermal_reboot_delay}{'1'};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# No delay
			$delay = 0;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "delay", value1 => $delay
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Now, see if the last reboot time is more than delay time ago.
		if ($delay)
		{
			my $last_shutdown_was = (time - $last_shutdown);
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "last_shutdown_was", value1 => $last_shutdown_was, 
				name2 => "delay",             value2 => $delay, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($last_shutdown_was < $delay)
			{
				# Wait longer.
				$temperature_is_safe = 0;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "temperature_is_safe", value1 => $temperature_is_safe
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "temperature_is_safe", value1 => $temperature_is_safe
	}, file => $THIS_FILE, line => __LINE__});
	return($temperature_is_safe);
}

# This reads in all of the entries in the 'power' table that this host knows about. This will be used by 
# 'do_post_scan_dashboard_tasks()' to see if the node can be booted if it is in an emergency-stop condition 
# because of power loss.
sub read_power_table
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "read_power_table" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# First, read in the UPS information that I know. The records for the
	# nodes will be stale if they're off so they're not any use to us.
	my $query = "
SELECT 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage 
FROM 
    power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";
";
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $power_ups_name          = $row->[0];
		my $power_on_battery        = $row->[1] ? "TRUE" : "FALSE";
		my $power_seconds_left      = $row->[2];
		my $power_charge_percentage = $row->[3];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "power_ups_name",          value1 => $power_ups_name, 
			name2 => "power_on_battery",        value2 => $power_on_battery, 
			name3 => "power_seconds_left",      value3 => $power_seconds_left, 
			name4 => "power_charge_percentage", value4 => $power_charge_percentage, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Shovel it into the hash
		$an->data->{power}{$power_ups_name} = {
			power_on_battery	=>	$power_on_battery, 
			power_seconds_left	=>	$power_seconds_left, 
			power_charge_percentage	=>	$power_charge_percentage 
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "power::${power_ups_name}::power_on_battery",        value1 => $an->data->{power}{$power_ups_name}{power_on_battery}, 
			name2 => "power::${power_ups_name}::power_seconds_left",      value2 => $an->data->{power}{$power_ups_name}{power_seconds_left}, 
			name3 => "power::${power_ups_name}::power_charge_percentage", value3 => $an->data->{power}{$power_ups_name}{power_charge_percentage}, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This will check the 'power', 'temperature' and 'health' tables. If the UPSes found in the local 
# '/etc/hosts' file are both running on batteries, their remaining run time is checked. If the sum of the 
# health weights on one node exceeds the other node, hosted servers will be live-migrated to the healthier
# (lower sum weight) node.
sub do_post_scan_node_tasks
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "do_post_scan_node_tasks" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $hostname       = $an->hostname;
	my $short_hostname = $an->short_hostname;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "hostname",       value1 => $hostname, 
		name2 => "short_hostname", value2 => $short_hostname, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do a short scan of the system.
	$an->Striker->load_anvil();
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "sys::anvil::uuid",        value1 => $an->data->{sys}{anvil}{uuid}, 
		name2 => "sys::anvil::node1::uuid", value2 => $an->data->{sys}{anvil}{node1}{uuid}, 
		name3 => "sys::anvil::node2::uuid", value3 => $an->data->{sys}{anvil}{node2}{uuid}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{sys}{anvil}{node1}{uuid})
	{
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node1}{uuid}, short_scan => 1});
	}
	if ($an->data->{sys}{anvil}{node2}{uuid})
	{
		$an->Striker->scan_node({uuid => $an->data->{sys}{anvil}{node2}{uuid}, short_scan => 1});
	}
	
	# Values are:
	# 1 = At least one of the UPSes has power
	# 2 = Neither do but the hold-up time of at least one is above minimum
	# 3 = Both are on batteries and below the minimum hold-up time 
	# 4 = Both are on batteries and have been long enough to trigger load shedding (and load shedding 
	#     is not disabled)
	my ($node_power_ok) = check_node_power($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_power_ok", value1 => $node_power_ok,
	}, file => $THIS_FILE, line => __LINE__});
	
	my ($node_temperature_ok) = check_local_temperature_health($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_temperature_ok", value1 => $node_temperature_ok,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Check the node's health. If we're healthier than our peer, we'll live migrate nodes off. If we're 
	# sicker than our peer, we will do nothing (so that we don't get dueling migration commands).
	# Values are:
	# 1 = Both nodes have the same health.
	# 2 = We're healther than our peer (migrate)
	# 3 = We're sicker than our peer (do nothing)
	my ($node_health_ok) = check_node_health($an);
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_health_ok", value1 => $node_health_ok,
	}, file => $THIS_FILE, line => __LINE__});
	
	# OK, if both are '1', make sure our health is set to 'OK'. If either returned '2', make sure our 
	# health is set to 'Warning'. If either returned '3', set the health to 'Critical' and set the hosts
	# -> host_emergency_stop to TRUE and then call 'anvil-safe-stop --local'.
	if (($node_power_ok eq "3") or ($node_temperature_ok eq "3"))
	{
		# Set the health to 'Critical'.
		$an->ScanCore->host_state({set => "critical"});
		
		# Why exactly are we shutting down?
		my $host_stop_reason = $node_power_ok eq "3" ? "power" : "temperature";
		
		# Update hosts to set host_emergency_stop to TRUE
		my $query = "
UPDATE 
    hosts 
SET 
    host_emergency_stop = TRUE, 
    host_stop_reason    = ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    host_health         = 'critical', 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    host_uuid           = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
		$query =~ s/'NULL'/NULL/g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query,
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		my $do_shutdown = 1;
		my $message_key = "scancore_error_0015";
		if ((($host_stop_reason eq "power")       && ($an->data->{scancore}{disable}{power_shutdown})) or 
		    (($host_stop_reason eq "temperature") && ($an->data->{scancore}{disable}{thermal_shutdown})))
		{
			# Shutdown has been disabled.
			$do_shutdown = 0;
			$message_key = "scancore_error_0016";
			
			# Tell the user what's (not) happening
			if ($host_stop_reason eq "power")
			{
				# Power shutdown disabled.
				$an->Log->entry({log_level => 0, message_key => "scancore_warning_0017", file => $THIS_FILE, line => __LINE__});
			}
			elsif ($host_stop_reason eq "temperature")
			{
				# Thermal shutdown disabled.
				$an->Log->entry({log_level => 0, message_key => "scancore_warning_0018", file => $THIS_FILE, line => __LINE__});
			}
		}
		elsif ($host_stop_reason eq "power")
		{
			# Power shutdown enabled, we're going down.
			$an->Log->entry({log_level => 0, message_key => "scancore_warning_0019", file => $THIS_FILE, line => __LINE__});
		}
		elsif ($host_stop_reason eq "temperature")
		{
			# Thermal shutdown enabled, we're going down
			$an->Log->entry({log_level => 0, message_key => "scancore_warning_0020", file => $THIS_FILE, line => __LINE__});
		}
		# Send our final email.
		$an->Alert->register_alert({
			alert_level		=>	"critical", 
			alert_agent_name	=>	$THIS_FILE,
			alert_title_key		=>	"an_alert_title_0005",
			alert_message_key	=>	$message_key,
			alert_message_variables	=>	{
				node			=>	$an->hostname,
			},
		});
		
		# Send the email
		process_alerts($an, 0);
		if ($do_shutdown)
		{
			# Stop the anvil-kick-apc-ups if it is in use.
			my $stop_kicking = 0;
			my $shell_call   = $an->data->{path}{'anvil-kick-apc-ups'}." --status";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($line =~ /\[enabled\]/)
				{
					$stop_kicking = 1;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "stop_kicking", value1 => $stop_kicking, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			close $file_handle;
			if ($stop_kicking)
			{
				my $shell_call = $an->data->{path}{'anvil-kick-apc-ups'}." --cancel";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
			}
			
			# And now die via 'anvil-safe-stop'. We should be dead before this exits. So ya, so 
			# long and thanks for all the fish.
			$shell_call = $an->data->{path}{'anvil-safe-stop'}." --local";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open ($file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$line =~ s/\n//g;
				$line =~ s/\r//g;
				$an->Log->entry({log_level => 1, message_key => "scancore_warning_0021", message_variables => { line => $line }, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
			
			# Why are we still alive? die already.
			$an->nice_exit({exit_code => 999});
		}
		else
		{
			# We're not going to die, so record that we've warned the user.
			my $cleared = $an->Alert->check_alert_sent({
				type			=>	"warning",
				alert_sent_by		=>	$THIS_FILE,
				alert_record_locator	=>	$an->hostname,
				alert_name		=>	"shutdown_should_have_happened",
				modified_date		=>	$an->data->{sys}{db_timestamp},
			});
		}
	}
	elsif (($node_power_ok eq "4") or ($node_temperature_ok eq "4"))
	{
		# Which message?
		my $message_key = "scancore_warning_0026";
		if ($node_temperature_ok eq "4")
		{
			$message_key = "scancore_warning_0027";
		}
		
		# Power-triggered load shed! Tell the user.
		$an->Alert->register_alert({
			alert_level		=>	"warning", 
			alert_agent_name	=>	$THIS_FILE,
			alert_title_key		=>	"an_alert_title_0004",
			alert_message_key	=>	$message_key,
		});
		
		# Send the email, because we might be about to die.
		process_alerts($an, 0);
		
		# Now call the load shedding.
		my $shell_call = $an->data->{path}{'anvil-safe-stop'}." --shed-load --reason power_loss";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
	}
	elsif (($node_power_ok eq "2") or ($node_temperature_ok eq "2"))
	{
		### We're sick
		# Set the health to 'Warning'.
		$an->ScanCore->host_state({set => "warning"});
		
		# Tell the user that we're no longer a migration target.
		my $set = $an->Alert->check_alert_sent({
			type			=>	"warning",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	$an->hostname,
			alert_name		=>	"node_sick",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		if ($set)
		{
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0004",
				alert_message_key	=>	"scancore_warning_0012",
				alert_message_variables	=>	{
					node			=>	$an->hostname,
				},
			});
			
			# Send the email
			process_alerts($an, 0);
		}
	}
	else
	{
		### We're healthy
		# Set the health to 'OK'.
		$an->ScanCore->host_state({set => "ok"});
		
		# If we were previously sick, tell the user that we're OK now.
		my $cleared_node_sick = $an->Alert->check_alert_sent({
			type			=>	"clear",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	$an->hostname,
			alert_name		=>	"node_sick",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		my $cleared_poweroff = $an->Alert->check_alert_sent({
			type			=>	"clear",
			alert_sent_by		=>	$THIS_FILE,
			alert_record_locator	=>	$an->hostname,
			alert_name		=>	"shutdown_should_have_happened",
			modified_date		=>	$an->data->{sys}{db_timestamp},
		});
		if ($cleared_node_sick)
		{
			# Tell the user that we're OK.
			$an->Alert->register_alert({
				alert_level		=>	"warning", 
				alert_agent_name	=>	$THIS_FILE,
				alert_title_key		=>	"an_alert_title_0006",
				alert_message_key	=>	"scancore_warning_0013",
				alert_message_variables	=>	{
					node			=>	$an->hostname,
				},
			});
			
			# Send the email
			process_alerts($an, 0);
		}
	}
	
	### Log the state, if needed. Note that load shedding is handled in 'anvil-safe-stop', not here.
	# Power
	if ($node_power_ok eq "3")
	{
		if (not $an->data->{sys}{reported}{power_is_critical})
		{
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0079", file => $THIS_FILE, line => __LINE__});
			$an->data->{sys}{reported}{power_is_critical} = 1;
			$an->data->{sys}{reported}{power_is_warning}  = 0;
		}
	}
	elsif (($node_power_ok eq "2") or ($node_power_ok eq "4"))
	{
		if (not $an->data->{sys}{reported}{power_is_warning})
		{
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0077", file => $THIS_FILE, line => __LINE__});
			$an->data->{sys}{reported}{power_is_critical} = 0;
			$an->data->{sys}{reported}{power_is_warning}  = 1;
		}
	}
	else
	{
		if (($an->data->{sys}{reported}{power_is_critical}) or ($an->data->{sys}{reported}{power_is_warning}))
		{
			# Clear
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0081", file => $THIS_FILE, line => __LINE__});
			$an->data->{sys}{reported}{power_is_critical} = 0;
			$an->data->{sys}{reported}{power_is_warning}  = 0;
		}
	}
	
	# Temperature
	if ($node_temperature_ok eq "3")
	{
		if (not $an->data->{sys}{reported}{temperature_is_critical})
		{
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0080", file => $THIS_FILE, line => __LINE__});
			$an->data->{sys}{reported}{temperature_is_critical} = 1;
			$an->data->{sys}{reported}{temperature_is_warning}  = 0;
		}
	}
	elsif (($node_temperature_ok eq "2") or ($node_temperature_ok eq "4"))
	{
		if (not $an->data->{sys}{reported}{temperature_is_warning})
		{
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0078", file => $THIS_FILE, line => __LINE__});
			$an->data->{sys}{reported}{temperature_is_critical} = 0;
			$an->data->{sys}{reported}{temperature_is_warning}  = 1;
		}
	}
	else
	{
		if (($an->data->{sys}{reported}{temperature_is_critical}) or ($an->data->{sys}{reported}{temperature_is_warning}))
		{
			# Clear
			$an->Log->entry({log_level => 1, message_key => "scancore_log_0082", file => $THIS_FILE, line => __LINE__});
			$an->data->{sys}{reported}{temperature_is_critical} = 0;
			$an->data->{sys}{reported}{temperature_is_warning}  = 0;
		}
	}
	
	# Finally, migrate servers if necessary. 
	# 1 = Both nodes have the same health.
	# 2 = We're healther than our peer (migrate)
	# 3 = We're sicker than our peer (do nothing)
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "node_health_ok",                            value1 => $node_health_ok, 
		name2 => "scancore::disable::preventative_migration", value2 => $an->data->{scancore}{disable}{preventative_migration}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (($node_health_ok == 2) && (not $an->data->{scancore}{disable}{preventative_migration}))
	{
		# Migrate all servers to us.
		migrate_all_servers_to_here($an);
	}
	
	return(0);
}

### NOTE: Thos is only called by nodes.
# This finds all servers currently running on the peer and migrates them to this node.
sub migrate_all_servers_to_here
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "migrate_all_servers_to_here" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Who is my peer again?
	my $node_name = $an->hostname;
	my $peer_key  = $an->data->{sys}{node_name}{$node_name}{peer_node_key};
	my $peer_name = $an->data->{sys}{anvil}{$peer_key}{name};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
		name1 => "node_name", value1 => $node_name, 
		name2 => "peer_key",  value2 => $peer_key, 
		name3 => "peer_name", value3 => $peer_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: We DO NOT migrate directly! We will use 'anvil-migrate-server' because we WANT it to abort
	###       if the peer is not healthy.
	
	# Find the servers running on our peer. We'll call 'clustat' here to be sure we have the most current
	# view of system.
	my $to_migrate = [];
	my $shell_call = $an->data->{path}{clustat};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line =  $_;
		   $line =~ s/\s+/ /g;
		   $line =~ s/^\s+//;
		   $line =~ s/\s+$//;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^vm:(.*?) (.*?) (.*)/)
		{
			my $server = $1;
			my $host   = $2;
			my $state  = $3;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "server", value1 => $server, 
				name2 => "host",   value2 => $host, 
				name3 => "state",  value3 => $state, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if (($host eq $peer_name) && ($state eq "started"))
			{
				# Migrate it.
				push @{$to_migrate}, $server;
			}
		}
	}
	close $file_handle;
	
	# Well?
	if (@{$to_migrate} > 0)
	{
		### TODO: Send an alert if we migrate any servers!
		# Migrate!
		foreach my $server (sort {$a cmp $b} @{$to_migrate})
		{
			my $shell_call = $an->data->{path}{'anvil-migrate-server'}." --server $server";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line =  $_;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
	}
	
	### TODO: Update cluster.conf to set this node as the node with the 'delay' (or have scan-clustat 
	###       do it).
	
	return(0);
}

### NOTE: Thos is only called by nodes.
# This pulls the data on the various temperature sensors. If all are within acceptible ranges, '1' will be 
# returned. If any are in warning or critical state, '2' will be returned. If enough are critical to trigger 
# power-down, '3' will be returned. If enough are in warning and/or critical that, had they all been 
# critical, load shedding would have been triggered, 'sys::node::<node_name>::thermal_load_shed' is set to 
# '1'. If the peer is also set to '1' and both us and the peer have been set for more than 
# 'scancore::temperature::load_shed_delay' seconds, '4' will be returned, triggering a load-shed.
sub check_local_temperature_health
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_local_temperature_health" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# 1 == OK, 2 == Warning, 3 == Critical (should shut down), 4 == Warning:load_shed (if peer is also).
	my $node_temperature_ok           = 1;
	my $default_sensor_weight         = $an->data->{scancore}{temperature}{default_sensor_weight} ? $an->data->{scancore}{temperature}{default_sensor_weight} : 1;
	my $shutdown_threshold            = $an->data->{scancore}{temperature}{shutdown_limit}        ? $an->data->{scancore}{temperature}{shutdown_limit}        : 5;
	my $total_sensor_weight           = 0;
	my $critical_sensor_weight        = 0;
	my $my_thermal_load_shed_variable = "sys::node::".$an->hostname."::thermal_load_shed";
	
	# Read in the temperature values for this machine.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
		name1 => "node_temperature_ok",           value1 => $node_temperature_ok,
		name2 => "default_sensor_weight",         value2 => $default_sensor_weight,
		name3 => "shutdown_threshold",            value3 => $shutdown_threshold,
		name4 => "total_sensor_weight",           value4 => $total_sensor_weight,
		name5 => "my_thermal_load_shed_variable", value5 => $my_thermal_load_shed_variable,
	}, file => $THIS_FILE, line => __LINE__});
	
	# Pull in all the thermal sensors for this host.
	my $query = "
SELECT 
    temperature_agent_name, 
    temperature_sensor_name, 
    temperature_state 
FROM 
    temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($an->hostname)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	
	# If there are no results, then mark power as always OK because #yolo
	my $sensor_count = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "sensor_count", value1 => $sensor_count
	}, file => $THIS_FILE, line => __LINE__});
	if (not $sensor_count)
	{
		# No sensors are high, we're done.
		my $variable_uuid = $an->ScanCore->insert_or_update_variables({
			variable_name         => $my_thermal_load_shed_variable,
			variable_value        => "0",
			variable_source_uuid  => $an->data->{sys}{host_uuid}, 
			variable_source_table => "hosts", 
			update_value_only     => 1,
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "variable_uuid", value1 => $variable_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		return($node_temperature_ok);
	}
	
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $temperature_agent_name  = $row->[0];
		my $temperature_sensor_name = $row->[1];
		my $temperature_state       = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "temperature_agent_name",  value1 => $temperature_agent_name,
			name2 => "temperature_sensor_name", value2 => $temperature_sensor_name,
			name3 => "temperature_state",       value3 => $temperature_state,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If this is a sensor that is 'ok', skip it. Otherwise, we'll set the 'node_temperature_ok' 
		# to '2' (which may get set to '3' after these checks are done.
		next if $temperature_state eq "ok";
		$node_temperature_ok = 2;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_temperature_ok", value1 => $node_temperature_ok,
		}, file => $THIS_FILE, line => __LINE__});
		
		# If it is critical, find this sensor's weight and add it to the total.
		my $this_sensor_weight = $default_sensor_weight;
		
		# Get the weight of the sensor.
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "this_sensor_weight",                                                        value1 => $this_sensor_weight,
			name2 => "total_sensor_weight",                                                       value2 => $total_sensor_weight, 
			name3 => "critical_sensor_weight",                                                    value3 => $critical_sensor_weight, 
			name4 => "${temperature_agent_name}::thresholds::${temperature_sensor_name}::weight", value4 => $an->data->{$temperature_agent_name}{thresholds}{$temperature_sensor_name}{weight},
		}, file => $THIS_FILE, line => __LINE__});
		if ($an->data->{$temperature_agent_name}{thresholds}{$temperature_sensor_name}{weight})
		{
			$critical_sensor_weight = $an->data->{$temperature_agent_name}{thresholds}{$temperature_sensor_name}{weight};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "critical_sensor_weight", value1 => $critical_sensor_weight,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if ($temperature_state =~ /critical/)
		{
			$total_sensor_weight += $this_sensor_weight;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "total_sensor_weight", value1 => $total_sensor_weight,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# If we have enough sensors in a warning (or critcial) state to cross the heuristics for 
		# shutdown (had they all been critical), we will set our health to 'warning:load_shed' and
		# return '4'. If our peer is also 'warning:load_shed', then we'll shed load.
		$total_sensor_weight += $this_sensor_weight;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "total_sensor_weight", value1 => $total_sensor_weight,
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# If we've crossed the critical heauristic, we're dead. Otherwise, check to see if we're high enough
	# to set the 'warning:load_shed'.
	my $evaluate_load_shed = 0;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "total_sensor_weight",    value1 => $total_sensor_weight,
		name2 => "critical_sensor_weight", value2 => $critical_sensor_weight,
		name3 => "shutdown_threshold",     value3 => $shutdown_threshold,
	}, file => $THIS_FILE, line => __LINE__});
	if ($critical_sensor_weight > $shutdown_threshold)
	{
		$node_temperature_ok = 3;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_temperature_ok", value1 => $node_temperature_ok,
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($total_sensor_weight > $shutdown_threshold)
	{
		$evaluate_load_shed = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "evaluate_load_shed", value1 => $evaluate_load_shed,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Set the health to 'warning:load_shed'.
		$an->ScanCore->host_state({set => "warning:load_shed"});
	}
	
	# Set or clear the load_shed variable. If we need to set, also check the peer and see if we and they 
	# have been in this high-warning state for long enough to trigger a laod shed.
	if ($evaluate_load_shed)
	{
		# Set
		my $shed_load     = 1;
		my $variable_uuid = $an->ScanCore->insert_or_update_variables({
			variable_name         => $my_thermal_load_shed_variable,
			variable_value        => "1",
			variable_source_uuid  => $an->data->{sys}{host_uuid}, 
			variable_source_table => "hosts", 
			update_value_only     => 1,
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "variable_uuid", value1 => $variable_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Make sure both nodes are online. Otherwise, we'll not load shed anyway and might as well 
		# stop here.
		my $both_nodes_online = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "both_nodes_online", value1 => $both_nodes_online,
		}, file => $THIS_FILE, line => __LINE__});
		if ((not $an->data->{sys}{anvil}{node1}{online}) or (not $an->data->{sys}{anvil}{node2}{online}))
		{
			# Disable load shedding because our peer is dead.
			$both_nodes_online = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "both_nodes_online", value1 => $both_nodes_online,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# If both nodes are up and the user has not disabled load shedding, proceed.
		if ((not $an->data->{scancore}{disable}{load_shedding}) && ($both_nodes_online))
		{
			# WARNING: We can't use 'quote' to protect the 'scancore::temperature::load_shed_delay' 
			#          value so we must check that it is set and purely digits. '0' is OK, it 
			#          just means that we'll shed-load without delay.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "scancore::temperature::load_shed_delay", value1 => $an->data->{scancore}{temperature}{load_shed_delay},
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{scancore}{temperature}{load_shed_delay} eq "")
			{
				$an->data->{scancore}{temperature}{load_shed_delay} = 300;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::temperature::load_shed_delay", value1 => $an->data->{scancore}{temperature}{load_shed_delay},
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($an->data->{scancore}{temperature}{load_shed_delay} =~ /\D/)
			{
				$an->data->{scancore}{temperature}{load_shed_delay} = 300;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::temperature::load_shed_delay", value1 => $an->data->{scancore}{temperature}{load_shed_delay},
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Now check to see if we and the peer are both in high enough warning long enough to 
			# justify load shedding.
			my $my_host_uuid = $an->data->{sys}{host_uuid};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "my_host_uuid", value1 => $my_host_uuid,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $peer_host_uuid = "";
			my $peer_host_name = "";
			foreach my $node_key ("node1", "node2")
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "sys::anvil::${node_key}::uuid", value1 => $an->data->{sys}{anvil}{$node_key}{uuid},
					name2 => "sys::host_uuid",                value2 => $an->data->{sys}{host_uuid},
				}, file => $THIS_FILE, line => __LINE__});
				next if $an->data->{sys}{anvil}{$node_key}{uuid} eq $an->data->{sys}{host_uuid};
				
				$peer_host_uuid = $an->data->{sys}{anvil}{$node_key}{uuid};
				$peer_host_name = $an->data->{sys}{anvil}{$node_key}{name};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_host_uuid", value1 => $peer_host_uuid,
				}, file => $THIS_FILE, line => __LINE__});
				last;
			}
			
			# If I didn't find the peer's UUID, I Have a problem and I can not proceed.
			if (not $peer_host_uuid)
			{
				$an->Log->entry({log_level => 0, title_key => "tools_title_0002", message_key => "scancore_warning_0028", file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				### TODO: What happens if ScanCore runs on a node for the first time with 
				###       enough hot sensors to trigger a load shed? (before the history 
				###       table had any data)?
				# Read the variable values for 'sys::node::<node_name>::thermal_load_shed' 
				# within the load_shed_delay from the history table. If any are not '1', we
				# won't shed load yet.
				my $peer_thermal_load_shed_variable = "sys::node::".$peer_host_name."::thermal_load_shed";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "peer_thermal_load_shed_variable", value1 => $peer_thermal_load_shed_variable,
				}, file => $THIS_FILE, line => __LINE__});
				
				# Check myself.
				my $query = "
SELECT 
    variable_value, 
    modified_date 
FROM 
    history.variables 
WHERE 
    variable_name         = ".$an->data->{sys}{use_db_fh}->quote($my_thermal_load_shed_variable)."
AND 
    variable_source_uuid  = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    variable_source_table = ".$an->data->{sys}{use_db_fh}->quote("hosts")." 
AND 
    modified_date > (SELECT current_timestamp - interval '".$an->data->{scancore}{temperature}{load_shed_delay}." seconds') 
";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query
				}, file => $THIS_FILE, line => __LINE__});
				
				my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
				my $count   = @{$results};
				$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
					name1 => "results", value1 => $results, 
					name2 => "count",   value2 => $count,
				}, file => $THIS_FILE, line => __LINE__});
				if ($count < 1)
				{
					$shed_load = 0;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "shed_load", value1 => $shed_load, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				else
				{
					# We will disable shed load if any of these results are '0'.
					foreach my $row (@{$results})
					{
						# One or more records were found.
						my $therman_load_shed = $row->[0]; 
						my $modified_date     = $row->[1]; 
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "therman_load_shed", value1 => $therman_load_shed, 
							name2 => "modified_date",     value2 => $modified_date, 
						}, file => $THIS_FILE, line => __LINE__});
						
						if (not $therman_load_shed)
						{
							$shed_load = 0;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
								name1 => "shed_load", value1 => $shed_load, 
							}, file => $THIS_FILE, line => __LINE__});
						}
					}
				}
				
				# Check my peer now, if I haven't already aborted the load shedding.
				if ($shed_load)
				{
					my $query = "
SELECT 
    variable_value, 
    modified_date 
FROM 
    history.variables 
WHERE 
    variable_name         = ".$an->data->{sys}{use_db_fh}->quote($peer_thermal_load_shed_variable)."
AND 
    variable_source_uuid  = ".$an->data->{sys}{use_db_fh}->quote($peer_host_uuid)." 
AND 
    variable_source_table = ".$an->data->{sys}{use_db_fh}->quote("hosts")." 
AND 
    modified_date > (SELECT current_timestamp - interval '".$an->data->{scancore}{temperature}{load_shed_delay}." seconds') 
";
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "query", value1 => $query
					}, file => $THIS_FILE, line => __LINE__});
					
					my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
					my $count   = @{$results};
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "results", value1 => $results, 
						name2 => "count",   value2 => $count,
					}, file => $THIS_FILE, line => __LINE__});
					if ($count < 1)
					{
						$shed_load = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "shed_load", value1 => $shed_load, 
						}, file => $THIS_FILE, line => __LINE__});
					}
					else
					{
						# We will disable shed load if any of these results are '0'.
						foreach my $row (@{$results})
						{
							# One or more records were found.
							my $therman_load_shed = $row->[0]; 
							my $modified_date     = $row->[1]; 
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "therman_load_shed", value1 => $therman_load_shed, 
								name2 => "modified_date",     value2 => $modified_date, 
							}, file => $THIS_FILE, line => __LINE__});
							
							if (not $therman_load_shed)
							{
								$shed_load = 0;
								$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
									name1 => "shed_load", value1 => $shed_load, 
								}, file => $THIS_FILE, line => __LINE__});
							}
						}
					}
				}
			}
		}
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shed_load", value1 => $shed_load, 
		}, file => $THIS_FILE, line => __LINE__});
		if ($shed_load)
		{
			# OK, we're clear for load shed.
			$node_temperature_ok = 4;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "node_temperature_ok", value1 => $node_temperature_ok,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	else
	{
		# Clear (if needed)
		my $variable_uuid = $an->ScanCore->insert_or_update_variables({
			variable_name         => $my_thermal_load_shed_variable,
			variable_value        => "0",
			variable_source_uuid  => $an->data->{sys}{host_uuid}, 
			variable_source_table => "hosts", 
			update_value_only     => 1,
		});
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "variable_uuid", value1 => $variable_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_temperature_ok", value1 => $node_temperature_ok,
	}, file => $THIS_FILE, line => __LINE__});
	return($node_temperature_ok);
}

### TODO: If server waffling becomes a problem, we'll want to record when we do a precautionary migration and
###       then, here, check to see when the last precautionary migration happened and NOT migrate again 
###       within some set time.
# This pulls all of the health entries for this node and the peer node, sums them and determines if this node
# is equal in health, sicker or healthier.
sub check_node_health
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_power" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $node_health_ok     = 1;
	my $my_health_weight   = 0;
	my $peer_health_weight = 0;
	my $node_name          = $an->hostname;
	my $node_key           = $an->data->{sys}{node_name}{$node_name}{node_key};
	my $peer_key           = $an->data->{sys}{node_name}{$node_name}{peer_node_key};
	my $peer_name          = $an->data->{sys}{anvil}{$peer_key}{name};
	my $peer_uuid          = $an->data->{sys}{anvil}{$peer_key}{uuid};
	my $peer_online        = $an->data->{sys}{anvil}{$node_key}{online};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
		name1 => "node_name",   value1 => $node_name, 
		name2 => "node_key",    value2 => $node_key, 
		name3 => "peer_key",    value3 => $peer_key, 
		name4 => "peer_name",   value4 => $peer_name, 
		name5 => "peer_uuid",   value5 => $peer_uuid, 
		name6 => "peer_online", value6 => $peer_online, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# If the peer isn't online, there is no sense summing weights.
	if (not $peer_online)
	{
		$node_health_ok = 2;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_health_ok", value1 => $node_health_ok, 
		}, file => $THIS_FILE, line => __LINE__});
		return($node_health_ok);
	}
	
	# Read and sum my health weights. The agent and source name is for logging purposes only.
	my $query = "
SELECT 
    health_agent_name, 
    health_source_name, 
    health_source_weight 
FROM 
    health 
WHERE 
    health_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
		
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $health_agent_name    = $row->[0]; 
		my $health_source_name   = $row->[1]; 
		my $health_source_weight = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "health_agent_name",    value1 => $health_agent_name, 
			name2 => "health_source_name",   value2 => $health_source_name, 
			name3 => "health_source_weight", value3 => $health_source_weight, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$my_health_weight += $health_source_weight;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "my_health_weight", value1 => $my_health_weight, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Read in my peer's health.
	$query = "
SELECT 
    health_agent_name, 
    health_source_name, 
    health_source_weight 
FROM 
    health 
WHERE 
    health_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($peer_uuid)."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
		
	$results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $health_agent_name    = $row->[0]; 
		my $health_source_name   = $row->[1]; 
		my $health_source_weight = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "health_agent_name",    value1 => $health_agent_name, 
			name2 => "health_source_name",   value2 => $health_source_name, 
			name3 => "health_source_weight", value3 => $health_source_weight, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$peer_health_weight += $health_source_weight;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "peer_health_weight", value1 => $peer_health_weight, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# NOTE: We don't check the readiness of the peer to because 'anvil-migrate-server' has the health 
	#       check logic and will refuse to  migrate if the peer isn't healthy, regardless of what we do 
	#       here (and no, we will NOT use '--force'. We want this behaviour).
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "my_health_weight",   value1 => $my_health_weight, 
		name2 => "peer_health_weight", value2 => $peer_health_weight, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($my_health_weight < $peer_health_weight)
	{
		# We're healthier.
		$node_health_ok = 2;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_health_ok", value1 => $node_health_ok, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	elsif ($my_health_weight > $peer_health_weight)
	{
		# We're sicker.
		$node_health_ok = 3;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_health_ok", value1 => $node_health_ok, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Values are:
	# 1 = Both nodes have the same health.
	# 2 = We're healther than our peer (migrate)
	# 3 = We're sicker than our peer (do nothing)
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_health_ok", value1 => $node_health_ok, 
	}, file => $THIS_FILE, line => __LINE__});
	return($node_health_ok);
}

# This pulls the data on the UPSes associated with this node and returns '1' if at least one of the UPSes has
# power, '2' if neither do but the hold-up time of at least one is above minimum, '3' if both are on 
# batteries and below the minimum hold-up time and '4' if both are on batteries and have been long enough to
# trigger load shedding.
sub check_node_power
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_node_power" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $node_power_ok       = 1;
	my $a_ups_has_input     = 0;
	my $highest_holdup_time = 0;
	my $minimum_ups_runtime = $an->data->{scancore}{minimum_ups_runtime};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "node_power_ok",       value1 => $node_power_ok,
		name2 => "a_ups_has_input",     value2 => $a_ups_has_input,
		name3 => "highest_holdup_time", value3 => $highest_holdup_time,
		name4 => "minimum_ups_runtime", value4 => $minimum_ups_runtime,
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, see if my UPSes have input power. If not:
	# * See which has the longest hold-up time. If one of them is above the minimum hold-up time, set our
	#   health to '2/warning'.
	# * If the power is out to both and we're in warning, check to see if we've been in a warning state
	#   long enough to trigger load shedding. If so, we'll set our health to '4/load shed'.
	# * If the strongest is too low, set our health to '3/critical' and shut down.
	my $query = "
SELECT 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left 
FROM 
    power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";
";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	my $count   = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "results", value1 => $results, 
		name2 => "count",   value2 => $count
	}, file => $THIS_FILE, line => __LINE__});
	
	# If there are no results, then mark power as always OK because #yolo
	my $ups_count = @{$results};
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "ups_count", value1 => $ups_count
	}, file => $THIS_FILE, line => __LINE__});
	if (not $ups_count)
	{
		return(0);
	}
	
	# NOTE: I know I could sort by remaining hold-up time and/or filter by which UPS is on batteries, but
	#       slurping it all in makes it easier to debug with everything in memory.
	my $last_agent = "";
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $power_ups_name     = $row->[0];
		my $power_on_battery   = $row->[1];
		my $power_seconds_left = $row->[2];
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "power_ups_name",     value1 => $power_ups_name,
			name2 => "power_on_battery",   value2 => $power_on_battery,
			name3 => "power_seconds_left", value3 => $power_seconds_left,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record the highest hold-up time.
		if ($power_seconds_left > $highest_holdup_time)
		{
			$highest_holdup_time = $power_seconds_left;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "highest_holdup_time", value1 => $highest_holdup_time,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Are we on batteries?
		if ($power_on_battery)
		{
			# Well poop.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "power_seconds_left",  value1 => $power_seconds_left,
				name2 => "highest_holdup_time", value2 => $highest_holdup_time,
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# We've got input power, sweeeet.
			$a_ups_has_input = 1;
			$node_power_ok   = 1;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "node_power_ok", value1 => $node_power_ok,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	$results = "";
	
	# Now, if no UPS has input power, see if the highest holdup time exceeds the minimum required to 
	# avoid a shut down.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "a_ups_has_input", value1 => $a_ups_has_input,
	}, file => $THIS_FILE, line => __LINE__});
	if ($a_ups_has_input)
	{
		$node_power_ok = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "node_power_ok", value1 => $node_power_ok,
		}, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# No input power from mains...
		$node_power_ok = 2;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
			name1 => "node_power_ok",                    value1 => $node_power_ok,
			name2 => "minimum_ups_runtime",              value2 => $minimum_ups_runtime, 
			name3 => "highest_holdup_time",              value3 => $highest_holdup_time, 
			name4 => "scancore::disable::load_shedding", value4 => $an->data->{scancore}{disable}{load_shedding}, 
			name5 => "sys::anvil::node1::online",        value5 => $an->data->{sys}{anvil}{node1}{online}, 
			name6 => "sys::anvil::node2::online",        value6 => $an->data->{sys}{anvil}{node2}{online}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Log the time remaining. I know this might get noisey, but it could be very helpful to an
		# admin watching the logs.
		$an->Log->entry({log_level => 1, message_key => "scancore_warning_0022", message_variables => {
			highest_holdup_time => $highest_holdup_time,
			minimum_ups_runtime => $minimum_ups_runtime,
		}, file => $THIS_FILE, line => __LINE__});
		
		# Are both nodes up?
		my $both_nodes_online = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "both_nodes_online", value1 => $both_nodes_online,
		}, file => $THIS_FILE, line => __LINE__});
		if ((not $an->data->{sys}{anvil}{node1}{online}) or (not $an->data->{sys}{anvil}{node2}{online}))
		{
			# Disable load shedding because our peer is dead.
			$both_nodes_online = 0;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "both_nodes_online", value1 => $both_nodes_online,
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		if ($minimum_ups_runtime >= $highest_holdup_time)
		{
			# Time to go zzz
			$node_power_ok = 3;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "node_power_ok", value1 => $node_power_ok,
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ((not $an->data->{scancore}{disable}{load_shedding}) && ($both_nodes_online))
		{
			# WARNING: We can't use 'quote' to protect the 'scancore::power::load_shed_delay' 
			#          value so we must check that it is set and purely digits. '0' is OK, it 
			#          just means that we'll shed-load without delay.
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "scancore::power::load_shed_delay", value1 => $an->data->{scancore}{power}{load_shed_delay},
			}, file => $THIS_FILE, line => __LINE__});
			if ($an->data->{scancore}{power}{load_shed_delay} eq "")
			{
				$an->data->{scancore}{power}{load_shed_delay} = 300;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::power::load_shed_delay", value1 => $an->data->{scancore}{power}{load_shed_delay},
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($an->data->{scancore}{power}{load_shed_delay} =~ /\D/)
			{
				$an->data->{scancore}{power}{load_shed_delay} = 300;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "scancore::power::load_shed_delay", value1 => $an->data->{scancore}{power}{load_shed_delay},
				}, file => $THIS_FILE, line => __LINE__});
			}
			
			# Is it time to load-shed? No results == No.
			my $shed_load = 1;
			my $query     = "
SELECT 
    power_on_battery, 
    modified_date 
FROM 
    history.power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
AND 
    modified_date > (SELECT current_timestamp - interval '".$an->data->{scancore}{power}{load_shed_delay}." seconds') 
ORDER BY 
    modified_date DESC;
";
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
			
			my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
			my $count   = @{$results};
			$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
				name1 => "results", value1 => $results, 
				name2 => "count",   value2 => $count,
			}, file => $THIS_FILE, line => __LINE__});
			### TODO: There should be about 5+ entries (7~9 usually) if things have been running 
			###       normally. It might be worth NOT deciding to shed load unless we've got >5
			###       results... Something to think about and decide on later. For now, we'll not
			###       check the results count.
			if ($count < 1)
			{
				$shed_load = 0;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shed_load", value1 => $shed_load, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				# We will disable shed load if any of these results show 'power_on_battery' 
				# as 'TRUE'.
				foreach my $row (@{$results})
				{
					# One or more records were found.
					my $power_on_battery = $row->[0]; 
					my $modified_date    = $row->[1]; 
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "power_on_battery", value1 => $power_on_battery, 
						name2 => "modified_date",    value2 => $modified_date, 
					}, file => $THIS_FILE, line => __LINE__});
					
					if ($power_on_battery eq "0")
					{
						# Nope.
						$shed_load = 0;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
							name1 => "shed_load", value1 => $shed_load, 
						}, file => $THIS_FILE, line => __LINE__});
					}
				}
			}
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "shed_load", value1 => $shed_load, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($shed_load)
			{
				$node_power_ok = 4;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "node_power_ok", value1 => $node_power_ok, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	# Returns;
	# 1 = At least one of the UPSes has power
	# 2 = Neither do but the hold-up time of at least one is above minimum
	# 3 = Both are on batteries and below the minimum hold-up time 
	# 4 = Both are on batteries and have been long enough to trigger load shedding (and load shedding 
	#     is not disabled)
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "node_power_ok", value1 => $node_power_ok,
	}, file => $THIS_FILE, line => __LINE__});
	return ($node_power_ok);
}

# This looks at any agents and reads in their strings XML files.
sub load_agent_strings
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "load_agent_strings" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through the agents directory and call each agent. Record how long it takes and note the exit 
	# code, then record the run-data in the database.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::agents_directory", value1 => $an->data->{path}{agents_directory}
	}, file => $THIS_FILE, line => __LINE__});
	scan_directory($an, $an->data->{path}{agents_directory});
	
	# Now loop through the agents I found and try calling them.
	foreach my $agent (sort {$a cmp $b} @{$an->data->{sys}{agents}})
	{
		### TODO: Put a time limit on these...
		my $strings =  $agent.".xml";
		   $agent   =~ s/^.*\///;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "agent",   value1 => $agent, 
			name2 => "strings", value2 => $strings, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ((-e $strings) && (-r $strings))
		{
			# Read the strings file.
			$an->Storage->read_words({file => $strings});
		}
	}
	$an->data->{sys}{agents} = [];
	
	return(0);
}

# This reads in the 'alerts' table and generates the emails/log file entries as needed.
sub process_alerts
{
	my ($an, $first_run) = @_;
	$first_run = 0 if not defined $first_run;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_alerts", }, message_key => "tools_log_0003", message_variables => { 
		name1 => "first_run", value1 => $first_run
	}, file => $THIS_FILE, line => __LINE__});
	
	# Read in all pending alerts
	my $query = "
SELECT 
    alert_uuid, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    alert_header, 
    alert_sort, 
    modified_date
FROM 
    alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
ORDER BY 
    alert_agent_name ASC, 
    modified_date ASC, 
    alert_sort ASC 
;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results, 
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		# One or more records were found.
		my $alert_uuid              =         $row->[0]; 
		my $alert_agent_name        =         $row->[1]; 
		my $alert_level             =         $row->[2]; 
		my $alert_title_key         =         $row->[3]; 
		my $alert_title_variables   =         $row->[4]; 
		my $alert_message_key       =         $row->[5]; 
		my $alert_message_variables =         $row->[6]; 
		my $alert_header            =         $row->[7]; 
		my $alert_sort              = defined $row->[8] ? $row->[8] : 9999; 
		my $modified_date           =         $row->[9]; 
		$an->Log->entry({log_level => 2, message_key => "an_variables_0010", message_variables => {
			name1  => "alert_uuid",              value1  => $alert_uuid, 
			name2  => "alert_agent_name",        value2  => $alert_agent_name, 
			name3  => "alert_level",             value3  => $alert_level, 
			name4  => "alert_title_key",         value4  => $alert_title_key, 
			name5  => "alert_title_variables",   value5  => $alert_title_variables, 
			name6  => "alert_message_key",       value6  => $alert_message_key, 
			name7  => "alert_message_variables", value7  => $alert_message_variables, 
			name8  => "alert_header",            value8  => $alert_header, 
			name9  => "alert_sort",              value9  => $alert_sort, 
			name10 => "modified_date",           value10 => $modified_date, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Store the alert
		$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid} = {
			alert_level             => $alert_level, 
			alert_title_key         => $alert_title_key, 
			alert_title_variables   => $alert_title_variables, 
			alert_message_key       => $alert_message_key, 
			alert_message_variables => $alert_message_variables,
			alert_header 		=> $alert_header,
			modified_date           => $modified_date
		};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0007", message_variables => {
			name1 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::alert_level",             value1 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_level},
			name2 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::alert_title_key",         value2 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_title_key},
			name3 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::alert_title_variables",   value3 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_title_variables},
			name4 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::alert_message_key",       value4 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_message_key},
			name5 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::alert_message_variables", value5 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_message_variables},
			name6 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::alert_header",            value6 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_header},
			name7 => "db::alerts::agent_name::${alert_agent_name}::alert_sort::${alert_sort}::alert_uuid::${alert_uuid}::modified_date",           value7 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{modified_date},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Process alerts, if any.
	if (ref($an->data->{db}{alerts}{agent_name}))
	{
		### Load the latest alert recipient information
		# Email/file notification targets. We'll load them into an easy to access hash.
		my $notifications = $an->ScanCore->get_notifications();
		foreach my $hash_ref (@{$notifications})
		{
			my $notify_uuid     = $hash_ref->{notify_uuid};
			my $notify_name     = $hash_ref->{notify_name};
			my $notify_target   = $hash_ref->{notify_target};
			my $notify_language = $hash_ref->{notify_language};
			my $notify_level    = $hash_ref->{notify_level};
			my $notify_units    = $hash_ref->{notify_units};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "notify_uuid",     value1 => $notify_uuid,
				name2 => "notify_name",     value2 => $notify_name,
				name3 => "notify_target",   value3 => $notify_target,
				name4 => "notify_language", value4 => $notify_language,
				name5 => "notify_level",    value5 => $notify_level,
				name6 => "notify_units",    value6 => $notify_units,
			}, file => $THIS_FILE, line => __LINE__});
			
			$an->data->{notifications}{$notify_uuid}{notify_name}     = $notify_name;
			$an->data->{notifications}{$notify_uuid}{notify_target}   = $notify_target;
			$an->data->{notifications}{$notify_uuid}{notify_language} = $notify_language;
			$an->data->{notifications}{$notify_uuid}{notify_level}    = $notify_level;
			$an->data->{notifications}{$notify_uuid}{notify_units}    = $notify_units;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "notifications::${notify_uuid}::notify_name",     value1 => $an->data->{notifications}{$notify_uuid}{notify_name},
				name2 => "notifications::${notify_uuid}::notify_target",   value2 => $an->data->{notifications}{$notify_uuid}{notify_target},
				name3 => "notifications::${notify_uuid}::notify_language", value3 => $an->data->{notifications}{$notify_uuid}{notify_language},
				name4 => "notifications::${notify_uuid}::notify_level",    value4 => $an->data->{notifications}{$notify_uuid}{notify_level},
				name5 => "notifications::${notify_uuid}::notify_units",    value5 => $an->data->{notifications}{$notify_uuid}{notify_units},
			}, file => $THIS_FILE, line => __LINE__});
		}
		
		# Links notification targets with Anvils (and possible alert level overrides)
		my $recipients = $an->ScanCore->get_recipients();
		
		# Loop through recipients. Any that match this Anvil! will be compared against the recipients
		# requested alert level. If they want this level alert, we'll pull their data from 
		# notifications and email/log.
		foreach my $hash_ref (@{$recipients})
		{
			my $recipient_anvil_uuid   = $hash_ref->{recipient_anvil_uuid};
			my $recipient_notify_uuid  = $hash_ref->{recipient_notify_uuid};
			my $recipient_notify_level = $hash_ref->{recipient_notify_level};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "sys::anvil_uuid",        value1 => $an->data->{sys}{anvil_uuid},
				name2 => "recipient_anvil_uuid",   value2 => $recipient_anvil_uuid,
				name3 => "recipient_notify_uuid",  value3 => $recipient_notify_uuid,
				name4 => "recipient_notify_level", value4 => $recipient_notify_level,
			}, file => $THIS_FILE, line => __LINE__});
			next if $hash_ref->{recipient_anvil_uuid} ne $an->data->{sys}{anvil_uuid};
			
			# Get the information for this notification target
			if ($an->data->{notifications}{$recipient_notify_uuid}{notify_name})
			{
				# Match found, proceed.
				my $notify_name     = $an->data->{notifications}{$recipient_notify_uuid}{notify_name};
				my $notify_target   = $an->data->{notifications}{$recipient_notify_uuid}{notify_target};
				my $notify_language = $an->data->{notifications}{$recipient_notify_uuid}{notify_language};
				my $notify_level    = $an->data->{notifications}{$recipient_notify_uuid}{notify_level};
				my $notify_units    = $an->data->{notifications}{$recipient_notify_uuid}{notify_units};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
					name1 => "notify_name",            value1 => $notify_name,
					name2 => "notify_target",          value2 => $notify_target,
					name3 => "notify_language",        value3 => $notify_language,
					name4 => "notify_level",           value4 => $notify_level,
					name5 => "notify_units",           value5 => $notify_units,
					name6 => "recipient_notify_level", value6 => $recipient_notify_level,
				}, file => $THIS_FILE, line => __LINE__});
				
				# See if this notification target has a custom level for this Anvil!.
				if ($recipient_notify_level)
				{
					$notify_level = $recipient_notify_level;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "notify_level", value1 => $notify_level,
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				# Is this an email recipient?
				if ($an->Validate->is_email({email => $notify_target}))
				{
					# Send an email
					send_email($an, $notify_target, $notify_name, $notify_level, $notify_language, $notify_units);
				}
				else
				{
					# Record to a file.
					record_alert_to_file($an, $notify_target, $notify_name, $notify_level, $notify_language, $notify_units);
				}
			}
		}
		
		# All done, delete the public.alerts entries.
		$query = "DELETE FROM alerts WHERE alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		
		# Delete the alerts from memory.
		delete $an->data->{db}{alerts};
		
		# Mark that an alert was sent
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0053", file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# No alerts
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0052", file => $THIS_FILE, line => __LINE__}) if not $first_run;
	}
	
	return(0);
}

# This sends any pending alerts to a give recipient, if applicable.
sub send_email
{
	my ($an, $email, $name, $level, $language, $units) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "send_email" }, message_key => "an_variables_0005", message_variables => { 
		name1 => "email",    value1 => $email, 
		name2 => "name",     value2 => $name, 
		name3 => "level",    value3 => $level, 
		name4 => "language", value4 => $language, 
		name5 => "units",    value5 => $units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: At this time, dashboards can't send email.
	if (not -e $an->data->{path}{cman_config})
	{
		return(0);
	}
	
	# The 'subject' will hold the highest alert seen and be used to generate a proper email subject prior
	# to dispatching the email proper.
	# debug    = 5
	# info     = 4
	# notice   = 3
	# warning  = 2
	# critical = 1
	# ignore   = 0
	my $subject = 5;
	my $body    = "";
	
	# Convert the user's log level to a numeric number for easier comparison.
	$level = $an->Alert->convert_level_name_to_number({level => $level});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "level", value1 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Generate the title key.
	my $lowest_level = 5;
	foreach my $alert_agent_name (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "alert_agent_name", value1 => $alert_agent_name, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_sort (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_sort", value1 => $alert_sort, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $alert_uuid (keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}})
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "alert_uuid", value1 => $alert_uuid, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $alert_level             = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_level};
				my $alert_title_key         = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_title_key};
				my $alert_title_variables   = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_title_variables};
				my $alert_message_key       = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_message_key};
				my $alert_message_variables = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_message_variables};
				my $alert_header            = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_header};
				$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
					name1 => "alert_level",             value1 => $alert_level, 
					name2 => "alert_title_key",         value2 => $alert_title_key, 
					name3 => "alert_title_variables",   value3 => $alert_title_variables, 
					name4 => "alert_message_key",       value4 => $alert_message_key, 
					name5 => "alert_message_variables", value5 => $alert_message_variables, 
					name6 => "alert_header",            value6 => $alert_header, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$alert_level = $an->Alert->convert_level_name_to_number({level => $alert_level});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "alert_level",  value1 => $alert_level, 
					name2 => "lowest_level", value2 => $lowest_level, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($alert_level < $lowest_level)
				{
					$lowest_level = $alert_level;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "lowest_level", value1 => $lowest_level, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				
				# Record the alert level if it is higher than we saw before.
				$subject = $alert_level if $subject > $alert_level;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "subject", value1 => $subject, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# The conversion of C to F is handled in translate_sensor_{name,value}() functions.
				my $title   = get_string_from_double_bang($an, $language, $alert_title_key, $alert_title_variables, $units);
				my $message = get_string_from_double_bang($an, $language, $alert_message_key, $alert_message_variables, $units);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "level",       value1 => $level, 
					name2 => "alert_level", value2 => $alert_level, 
				}, file => $THIS_FILE, line => __LINE__});
				if ($level >= $alert_level)
				{
					if ($alert_header)
					{
						$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
							name1 => "title",   value1 => $title, 
							name2 => "message", value2 => $message, 
						}, file => $THIS_FILE, line => __LINE__});
						$body .= $an->String->get({language => $language, key => "scancore_email_0005", variables => {
								title   => $title,
								message => $message,
							}})."\n\n";
					}
					else
					{
						# No header
						$body .= $an->String->get({language => $language, key => "scancore_email_0006", variables => { message => $message }})."\n";
					}
				}
				else
				{
					# Ignored
					$an->Log->entry({log_level => 3, message_key => "scancore_log_0050", message_variables => {
						user       => "$name <$email>",
						alert_uuid => $alert_uuid, 
						title      => $title,
						message    => $message
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
	}
	
	# If there is no message body, we're done.
	if (not $body)
	{
		return(0);
	}
	
	# Generate the email body.
	my $subject_line = $an->String->get({language => $language, key => "scancore_email_0004", variables => { hostname => $an->hostname }});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "subject_line", value1 => $subject_line, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $say_subject = $an->String->get({language => $language, key => "scancore_email_0001", variables => {
			level   => "#!string!an_alert_subject_".sprintf("%04d", $lowest_level)."!#",
			subject => $subject_line,
		}});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "say_subject", value1 => $say_subject, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# The footer is a generic message tell the user not to yell at us for spamming them. (hey, you laugh,
	# but managers will get these emails...)
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::append_email_footer", value1 => $an->data->{scancore}{append_email_footer}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{append_email_footer})
	{
		$body .= $an->String->get({language => $language, key => "scancore_email_0003", variables => { hostname => $an->hostname }});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "body", value1 => $body, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Now assemble the message.
	my $say_to = "$name <$email>";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "sys::anvil::smtp::username", value1 => $an->data->{sys}{anvil}{smtp}{username},
		name2 => "say_to",                     value2 => $say_to, 
		name3 => "say_subject",                value3 => $say_subject,
		name4 => "body",                       value4 => $body,
	}, file => $THIS_FILE, line => __LINE__});
	my $email_body = $an->String->get({language => $language, key => "scancore_email_0002", variables => {
			from    => $an->data->{sys}{anvil}{smtp}{username},
			to      => $say_to,
			subject => $say_subject,
			body    => $body,
		}});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "email_body", value1 => $email_body,
	}, file => $THIS_FILE, line => __LINE__});
	
	# First, see if the relay file needs to be updated.
	check_email_configuration($an);
	
	# Select a known_free email file name.
	my $date_and_time =  $an->Get->date_and_time({split_date_time => 0, no_spaces => 1});
	   $date_and_time =~ s/:/-/g;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "date_and_time", value1 => $date_and_time,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $email_file = $an->data->{path}{alert_emails}."/$date_and_time.1";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "email_file", value1 => $email_file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $file_ok = 0;
	until ($file_ok)
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "email_file", value1 => $email_file, 
		}, file => $THIS_FILE, line => __LINE__});
		if (-e $email_file)
		{
			my ($file, $suffix) = ($email_file =~ /^(.*?)\.(\d+)$/);
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "file",   value1 => $file,
				name2 => "suffix", value2 => $suffix,
			}, file => $THIS_FILE, line => __LINE__});
			
			$suffix++;
			$email_file = "$file.$suffix";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "email_file", value1 => $email_file,
			}, file => $THIS_FILE, line => __LINE__});
			   
			# Make sure I'm not sending more than 10/sec...
			if ($suffix > 10)
			{
				# Given the precision of the date coming from pgsql, there must be something
				# wrong.
				$an->Alert->error({title_key => "an_0003", message_key => "scancore_error_0014", message_variables => { file => $email_file }, code => 2, file => $THIS_FILE, line => __LINE__});
			}
		}
		else
		{
			$file_ok = 1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "file_ok", value1 => $file_ok,
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Write out the email file.
	my $shell_call = $email_file;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	print $file_handle $email_body;
	close $file_handle;
	
	# Now send the email.
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0049", message_variables => { file => $email_file }, file => $THIS_FILE, line => __LINE__});
	
	$shell_call = $an->data->{path}{mailx}." -t < $email_file";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	return(0);
}

# This records entries from alerts to a file, if applicable.
sub record_alert_to_file
{
	my ($an, $file, $name, $level, $language, $units) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "record_alert_to_file" }, message_key => "an_variables_0005", message_variables => { 
		name1 => "file",     value1 => $file, 
		name2 => "name",     value2 => $name, 
		name3 => "level",    value3 => $level, 
		name4 => "language", value4 => $language, 
		name5 => "units",    value5 => $units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $messages = "";
	
	# Prepend the alert file path.
	$file = $an->data->{path}{alert_files}."/$file";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "file", value1 => $file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Convert the user's log level to a numeric number for easier comparison.
	$level = $an->Alert->convert_level_name_to_number({level => $level});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "level", value1 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Loop through all the alerts and prep the relevant ones to be written to the file.
	foreach my $alert_agent_name (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "alert_agent_name", value1 => $alert_agent_name, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_sort (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}})
		{
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_sort", value1 => $alert_sort, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $alert_uuid (keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}})
			{
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "alert_uuid", value1 => $alert_uuid, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $alert_level             = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_level};
				my $alert_title_key         = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_title_key};
				my $alert_title_variables   = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_title_variables};
				my $alert_message_key       = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_message_key};
				my $alert_message_variables = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{alert_message_variables};
				my $modified_date           = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_sort}{$alert_sort}{alert_uuid}{$alert_uuid}{modified_date};
				
				$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
					name1 => "alert_level",             value1 => $alert_level, 
					name2 => "alert_title_key",         value2 => $alert_title_key, 
					name3 => "alert_title_variables",   value3 => $alert_title_variables, 
					name4 => "alert_message_key",       value4 => $alert_message_key, 
					name5 => "alert_message_variables", value5 => $alert_message_variables, 
					name6 => "modified_date",           value6 => $modified_date, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$alert_level = $an->Alert->convert_level_name_to_number({level => $alert_level});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "alert_level", value1 => $alert_level, 
				}, file => $THIS_FILE, line => __LINE__});
				
				if ($level >= $alert_level)
				{
					my $title    =  get_string_from_double_bang($an, $language, $alert_title_key, $alert_title_variables, $units);
					my $message  =  get_string_from_double_bang($an, $language, $alert_message_key, $alert_message_variables, $units);
					my $say_date =  $modified_date;
					$say_date =~ s/(\d+-\d+-\d+ \d+:\d+:\d+)\.\d+(.*)$/$1 (GMT$2)/;
					
					my $string = $an->String->get({key => "scancore_log_0033", variables => {
							date			=>	$say_date,
							alert_agent_name	=>	$alert_agent_name,
							title			=>	$title, 
							message			=>	$message, 
						}});
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "string", value1 => $string, 
					}, file => $THIS_FILE, line => __LINE__});
					
					$messages .= "$string\n";
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "messages", value1 => $messages, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
		}
	}
	
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0032", message_variables => { file => $file }, file => $THIS_FILE, line => __LINE__});
	
	# Append to the log file.
	my $shell_call = ">>$file";
	open (my $filehandle, "$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	print $filehandle $messages;
	close $filehandle;
	
	return(0);
}

# This checks the local postfix and mail relay data and updates if needed.
sub check_email_configuration
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_email_configuration" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: At this time, dashboards can't send email.
	if (not -e $an->data->{path}{cman_config})
	{
		return(0);
	}
	
	# These will be set to '1' if either the relay file or main.cf need to be updated.
	my $reconfigure = 0;
	
	# Checking to see of the email relay file needs to be created or updated.
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0034", message_variables => {
		postfix_relay_file => $an->data->{path}{postfix_relay_file}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{postfix_relay_file})
	{
		# It exists, reading it.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0035", file => $THIS_FILE, line => __LINE__});
		my $alt_server_found = 0;
		my $shell_call       = $an->data->{path}{postfix_relay_file};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^\[(.*?)\]:(\d+)\s(.*?):(.*)$/)
			{
				my $server   = $1;
				my $port     = $2;
				my $username = $3;
				my $password = $4;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
					name1 => "server",                     value1 => $server, 
					name2 => "sys::anvil::smtp::server",   value2 => $an->data->{sys}{anvil}{smtp}{server},
					name3 => "port",                       value3 => $port, 
					name4 => "sys::anvil::smtp::port",     value4 => $an->data->{sys}{anvil}{smtp}{port},
					name5 => "username",                   value5 => $username, 
					name6 => "sys::anvil::smtp::username", value6 => $an->data->{sys}{anvil}{smtp}{username},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 4, message_key => "an_variables_0002", message_variables => {
					name1 => "password",                  value1 => $password, 
					name2 => "sys::anvil::smtp::password", value2 => $an->data->{sys}{anvil}{smtp}{password},
				}, file => $THIS_FILE, line => __LINE__});
				
				if (($server   ne $an->data->{sys}{anvil}{smtp}{server})   or
				    ($port     ne $an->data->{sys}{anvil}{smtp}{port})     or
				    ($username ne $an->data->{sys}{anvil}{smtp}{username}) or
				    ($password ne $an->data->{sys}{anvil}{smtp}{password}))
				{
					# Changes made
					$an->Log->entry({log_level => 2, message_key => "scancore_log_0036", file => $THIS_FILE, line => __LINE__});
					$reconfigure = 1;
				}
				else
				{
					# No change
					$an->Log->entry({log_level => 3, message_key => "scancore_log_0047", file => $THIS_FILE, line => __LINE__});
				}
			}
			
			# If there was a problem, this file might be blanked. If so, rewrite.
			if ($line eq "[]: :")
			{
				$reconfigure = 1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "reconfigure", value1 => $reconfigure, 
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
	}
	else
	{
		# Relay file doesn't exist at all, so this might be an upgrade. As such, check that the 
		# programs we need are installed.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0037", file => $THIS_FILE, line => __LINE__});
		$reconfigure = 1;
	}
	
	# Read in mail.cf now and see if anything there changed. If so. we'll update and write it out
	my $smtp_server         = "";
	my $smtp_port           = "";
	my $smtp_alt_server     = "";
	my $smtp_alt_port       = "";
	# These aren't checked yet
	#my $smtp_security       = "";
	#my $smtp_authentication = "";
	#my $smtp_helo_domain    = "";
	my $postfix_main_cf     = "";
	
	### TODO: Re: issue #80 - Add support for alternate/no security.
	# Read it in
	my $shell_call = $an->data->{path}{postfix_main};
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line                =  $_;
		   $postfix_main_cf .= "$line\n";
		
		# Find the old values
		if ($line =~ /^relayhost = \[(.*?)\]:(\d+)/)
		{
			$smtp_server = $1;
			$smtp_port   = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "smtp_server", value1 => $smtp_server, 
				name2 => "smtp_port",   value2 => $smtp_port, 
			}, file => $THIS_FILE, line => __LINE__});
			
		}
		if ($line =~ /^smtp_fallback_relay = \[(.*?)\]:(\d+)/)
		{
			$smtp_alt_server = $1;
			$smtp_alt_port   = $2;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
				name1 => "smtp_alt_server", value1 => $smtp_alt_server, 
				name2 => "smtp_alt_port",   value2 => $smtp_alt_port, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	close $file_handle;
	
	# Something changed?
	$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
		name1 => "smtp_server",                  value1 => $smtp_server, 
		name2 => "sys::anvil::smtp::server",     value2 => $an->data->{sys}{anvil}{smtp}{server},
		name3 => "smtp_port",                    value3 => $smtp_port, 
		name4 => "sys::anvil::smtp::port",       value4 => $an->data->{sys}{anvil}{smtp}{port},
		name5 => "smtp_alt_server",              value5 => $smtp_alt_server, 
		name6 => "sys::anvil::smtp::alt_server", value6 => $an->data->{sys}{anvil}{smtp}{alt_server},
		name7 => "smtp_alt_port",                value7 => $smtp_alt_port, 
		name8 => "sys::anvil::smtp::alt_port",   value8 => $an->data->{sys}{anvil}{smtp}{alt_port},
	}, file => $THIS_FILE, line => __LINE__});
	if (($smtp_server     ne $an->data->{sys}{anvil}{smtp}{server})     or
	    ($smtp_port       ne $an->data->{sys}{anvil}{smtp}{port})       or 
	    ($smtp_alt_server ne $an->data->{sys}{anvil}{smtp}{alt_server}) or
	    ($smtp_alt_port   ne $an->data->{sys}{anvil}{smtp}{alt_port}))
	{
		$reconfigure = 1;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "reconfigure", value1 => $reconfigure, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# (Re)write the relay file now, if needed.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "reconfigure", value1 => $reconfigure, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($reconfigure)
	{
		# Write the new relay file.
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0034", message_variables => { postfix_relay_file => $an->data->{path}{postfix_relay_file} }, file => $THIS_FILE, line => __LINE__});
		
		my $shell_call = $an->data->{path}{postfix_relay_file};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $postfix_line = "[".$an->data->{sys}{anvil}{smtp}{server}."]:".$an->data->{sys}{anvil}{smtp}{port}." ".$an->data->{sys}{anvil}{smtp}{username}.":".$an->data->{sys}{anvil}{smtp}{password};
		$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
			name1 => "postfix_line", value1 => $postfix_line,
		}, file => $THIS_FILE, line => __LINE__});
		
		open (my $file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle "$postfix_line\n";
		close $file_handle;
		
		# Generate the binary version.
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0039", file => $THIS_FILE, line => __LINE__});
		
		$shell_call = $an->data->{path}{postmap}." ".$an->data->{path}{postfix_relay_file};
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			### This can contain a password, so log level is 4.
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# If I am writing the file, there is a chance that postfix hasn't been configured yet. So 
		# check it and, if needed, fix it.
		my $backup_file = $an->data->{path}{postfix_main}.".anvil";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "backup_file", value1 => $backup_file, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if (not -e $backup_file)
		{
			# Backup the original.
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0034", message_variables => {
				source      => $an->data->{path}{postfix_main},
				destination =>  $backup_file,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $shell_call = $an->data->{path}{cp}." --archive --no-clobber --verbose ".$an->data->{path}{postfix_main}." $backup_file";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		else
		{
			# Already backed up
			$an->Log->entry({log_level => 2, message_key => "scancore_log_0040", file => $THIS_FILE, line => __LINE__});
		}
		
		# Now update the postfix main.cf file by reading it in and replacing the variables we want to
		# update, then writing it all back out.
		my $postfix_main = "";
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0041", message_variables => { postfix_main => $an->data->{path}{postfix_main} }, file => $THIS_FILE, line => __LINE__});
		
		$shell_call = $an->data->{path}{postfix_main};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, "<$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			
			# Avoid duplicates
			next if $line =~ /^relayhost = \[/;
			next if $line =~ /^smtp_use_tls =/;
			next if $line =~ /^smtp_sasl_auth_enable =/;
			next if $line =~ /^smtp_sasl_password_maps =/;
			next if $line =~ /^smtp_sasl_security_options =/;
			next if $line =~ /^smtp_tls_CAfile =/;
			next if $line =~ /^smtp_fallback_relay =/;
			next if $line =~ /^smtp_helo_name =/;
			
			if ($line =~ /#relayhost = \[an.ip.add.ress\]/)
			{
				# Insert the mail relay configuration here.
				$an->Log->entry({log_level => 3, message_key => "scancore_log_0042", file => $THIS_FILE, line => __LINE__});
				
				# TODO: Experiment if I really need to define the mail server and IP both 
				#       here and in the relay file.
				$postfix_main .= "$line\n";
				$postfix_main .= "relayhost = [".$an->data->{sys}{anvil}{smtp}{server}."]:".$an->data->{sys}{anvil}{smtp}{port}."\n";
				if ($an->data->{sys}{anvil}{smtp}{alt_server})
				{
					my $port         =  $an->data->{sys}{anvil}{smtp}{alt_port} ? $an->data->{sys}{anvil}{smtp}{alt_port} : $an->data->{sys}{anvil}{smtp}{port};
					   $postfix_main .= "smtp_fallback_relay = [".$an->data->{sys}{anvil}{smtp}{alt_server}."]:$port\n";
				}
				   $postfix_main .= "smtp_helo_name = ".$an->data->{sys}{anvil}{smtp}{helo_domain}."\n";
				$postfix_main .= "smtp_use_tls = yes\n";
				$postfix_main .= "smtp_sasl_auth_enable = yes\n";
				$postfix_main .= "smtp_sasl_password_maps = hash:".$an->data->{path}{postfix_relay_file}."\n";
				$postfix_main .= "smtp_sasl_security_options =\n";
				$postfix_main .= "smtp_tls_CAfile = /etc/pki/tls/certs/ca-bundle.crt\n";
			}
			else
			{
				$postfix_main .= "$line\n";
			}
		}
		close $file_handle;
		
		# Write out the new version.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0043", message_variables => { postfix_main => $an->data->{path}{postfix_main} }, file => $THIS_FILE, line => __LINE__});
		
		# Record the config in the main log
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "postfix_main", value1 => $postfix_main, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the actual write...
		$shell_call = $an->data->{path}{postfix_main};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, ">$shell_call") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		print $file_handle $postfix_main;
		close $file_handle;
		
		# Reload postfix
		$an->Log->entry({log_level => 1, message_key => "scancore_log_0044", file => $THIS_FILE, line => __LINE__});
		$shell_call = $an->data->{path}{initd}."/postfix restart";
		open ($file_handle, $shell_call." 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\n//g;
			$line =~ s/\r//g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		sleep 2;
	}
	
	# Make sure the mail alerts directory exists and create it if not.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::alert_emails", value1 => $an->data->{path}{alert_emails}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{alert_emails})
	{
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0055", message_variables => { email_directory => $an->data->{path}{alert_emails} }, file => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# Need to create it.
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0045", message_variables => { email_directory => $an->data->{path}{alert_emails} }, file => $THIS_FILE, line => __LINE__});
		
		mkdir $an->data->{path}{alert_emails} or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0019", message_variables => {
								directory => $an->data->{path}{alert_emails}, 
								error     => $! 
							}, code => 2, file => $THIS_FILE, line => __LINE__});
		
		# Set the mode
		my $directory_mode = 0775;
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0046", message_variables => { directory_mode => sprintf("%04o", $directory_mode) }, file => $THIS_FILE, line => __LINE__});
		chmod $directory_mode, $an->data->{path}{alert_emails};
	}
	
	return(0);
}

# This converts the string keys and variables stored in the alerts table (flanked with '!!') to strings. It
# also handles the special 'sensor' data and will convert metric to imperial values as needed.
sub get_string_from_double_bang
{
	my ($an, $language, $key, $variables, $units) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_string_from_double_bang" }, message_key => "an_variables_0004", message_variables => { 
		name1 => "language",  value1 => $language, 
		name2 => "key",       value2 => $key,  
		name3 => "variables", value3 => $variables, 
		name4 => "units",     value4 => $units
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($variables)
	{
		my $hash = {};
		my $i    = 0;
		while ($variables =~ /(!!.*?!!)/)
		{
			$i++;
			die "$THIS_FILE ".__LINE__."; Exiting on infinite loop parsing pairs out of: [$variables]\n" if $i > 1000;
			
			my $pair      =  ($variables =~ /(!!.*?!!)/s)[0];
			   $variables =~ s/\Q$pair\E//s;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "i",         value1 => $i, 
				name2 => "pair",      value2 => $pair, 
				name3 => "variables", value3 => $variables, 
			}, file => $THIS_FILE, line => __LINE__});
			next if not $pair;
			
			my $variable = "";
			my $value    = "";
			if ($pair =~ /^!!(.*?)!!!$/s)
			{
				# No value, this is OK.
				($variable) = ($pair =~ /^!!(.*?)!!!$/s);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "variable", value1 => $variable, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			elsif ($pair =~ /^!!(.*?)!(.*?)!!$/s)
			{
				($variable, $value) = ($pair =~ /^!!(.*?)!(.*?)!!$/s);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "variable", value1 => $variable, 
					name2 => "value",    value2 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# If the variable matches a key in the language file, translate it.
				if (exists $an->data->{strings}{lang}{$language}{key}{$value}{content})
				{
					# This language has a translation key!
					$value = $an->String->get({key => $value});
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			die "$THIS_FILE ".__LINE__."; No variable parsed from: [$pair]\n" if not defined $variable;
			
			# If the value is one of the special sensor name or value strings, translate it.
			if ($variable eq "sensor_name") 
			{
				my ($sensor_name, $sensor_units) = ($value =~ /name=(.*?):units=(.*)$/);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "sensor_name",  value1 => $sensor_name, 
					name2 => "sensor_units", value2 => $sensor_units, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$value = translate_sensor_name($an, $sensor_name, $sensor_units);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			# Catch 'sensor_value', 'new_sensor_value' and 'old_sensor_value'.
			elsif ($variable =~ /sensor_value/)
			{
				my ($sensor_value, $sensor_units) = ($value =~ /value=(.*?):units=(.*)$/);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "sensor_value", value1 => $sensor_value, 
					name2 => "sensor_units", value2 => $sensor_units, 
				}, file => $THIS_FILE, line => __LINE__});
				
				$value = translate_sensor_value($an, $sensor_value, $sensor_units, $units);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "value", value1 => $value, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			# This catches any value in the format 'X Y'.
			elsif ($value =~ /(.*?) (.*)$/)
			{
				# NOTE: This will split on *anything* with a space. So it is possible that 
				#       we're NOT looking at a 'value units' pair!
				my $left_hand_side  = $1;
				my $right_hand_side = $2;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "left_hand_side",  value1 => $left_hand_side, 
					name2 => "right_hand_side", value2 => $right_hand_side, 
				}, file => $THIS_FILE, line => __LINE__});
				
				my $returned = translate_units($an, $left_hand_side, $right_hand_side, $units);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "returned", value1 => $returned, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Only rewrite 'value' if 'returned' has something in it.
				if ($returned)
				{
					$value = $returned;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			# This catches certain values that we translate to the requested target's language.
			else
			{
				my $returned = translate_strings($an, $value);
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "returned", value1 => $returned, 
				}, file => $THIS_FILE, line => __LINE__});
				
				# Only rewrite 'value' if 'returned' has something in it.
				if ($returned)
				{
					$value = $returned;
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "value", value1 => $value, 
					}, file => $THIS_FILE, line => __LINE__});
				}
			}
			$hash->{$variable} = $value;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "hash->{$variable}", value1 => $hash->{$variable}, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		$variables = $hash;
	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "language",  value1 => $language, 
		name2 => "key",       value2 => $key, 
		name3 => "variables", value3 => $variables, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $string = $an->String->get({
		language  => $language,
		key       => $key,
		variables => $variables, 
	});
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "string", value1 => $string, 
	}, file => $THIS_FILE, line => __LINE__});
	return($string);
}

# This and translate_sensor_value() are special functions used to translate IPMI sensor data into a user's 
# chosen language and units (metric v. imperial).
sub translate_sensor_name
{
	my ($an, $ipmitool_sensor_name, $ipmitool_sensor_units) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "translate_sensor_name", }, message_key => "an_variables_0002", message_variables => { 
		name1 => "ipmitool_sensor_name",  value1 => $ipmitool_sensor_name, 
		name2 => "ipmitool_sensor_units", value2 => $ipmitool_sensor_units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $say_sensor_name = $ipmitool_sensor_name;
	
	# Now, if it is a sensor we know, we'll not use the base units but instead five it a proper name. 
	# We'll translate the value after.
	my $say_units = $ipmitool_sensor_units;
	if ($ipmitool_sensor_units eq "C")
	{
		if ($say_sensor_name eq "Ambient")
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0001"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /CPU(\d+)/)
		{
			my $cpu       = $1;
			   $say_units = $an->String->get({
				key	=>	"scan_ipmitool_sensor_name_0003",
				variables	=>	{
					cpu		=>	$cpu,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /DIMM-(.*)/)
		{
			my $module    = $1;
			   $say_units = $an->String->get({
				key	=>	"scan_ipmitool_sensor_name_0006",
				variables	=>	{
					module		=>	$module,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Systemboard/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0023"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "V")
	{
		if ($say_sensor_name =~ /BATT (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0002", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /CPU(\d+) (\d+\.?\d+?)V/)
		{
			my $cpu       = $1;
			my $voltage   = $2;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0004", 
				variables	=>	{
					cpu		=>	$cpu,
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /ICH (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0013", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /IOH (\d+\.?\d+?)V AUX/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0014", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /IOH (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0015", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /iRMC (\d+\.?\d+?)V STBY/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0016", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /LAN (\d+\.?\d+?)V STBY/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0017", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /MAIN (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0018", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /STBY (\d+\.?\d+?)V/)
		{
			my $voltage   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0022", 
				variables	=>	{
					voltage		=>	$voltage,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "W")
	{
		if ($say_sensor_name =~ /CPU(\d+) Power/)
		{
			my $cpu       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0005", 
				variables	=>	{
					cpu		=>	$cpu,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Fan Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0010"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /HDD Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0011"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Memory Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0019"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /PSU(\d+) Power/)
		{
			my $psu       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0020", 
				variables	=>	{
					psu		=>	$psu,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /Total Power/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0024"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "%")
	{
		if ($say_sensor_name =~ /I2C(\d+) error ratio/)
		{
			my $channel   = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0012", 
				variables	=>	{
					channel		=>	$channel,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /SEL Level/)
		{
			$say_units = $an->String->get({key => "scan_ipmitool_sensor_name_0021"});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	elsif ($ipmitool_sensor_units eq "RPM")
	{
		if ($say_sensor_name =~ /FAN(\d+) PSU(\d+)/)
		{
			my $fan       = $1;
			my $psu       = $2;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0007", 
				variables	=>	{
					psu		=>	$psu,
					fan		=>	$fan,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /FAN(\d+) PSU/)
		{
			my $fan       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0008", 
				variables	=>	{
					fan		=>	$fan,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		elsif ($say_sensor_name =~ /FAN(\d+) SYS/)
		{
			my $fan       = $1;
			   $say_units = $an->String->get({
				key		=>	"scan_ipmitool_sensor_name_0009", 
				variables	=>	{
					fan		=>	$fan,
				},
			});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "say_units", value1 => $say_units, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_sensor_name",  value1 => $say_sensor_name, 
	}, file => $THIS_FILE, line => __LINE__});
	return($say_sensor_name)
}

# This translates the string when appropriate.
sub translate_strings
{
	my ($an, $string) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "translate_strings" }, message_key => "an_variables_0002", message_variables => { 
		name1 => "string",     value1 => $string, 
		name2 => "lc(string)", value2 => lc($string), 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $return = "";
	if (lc($string) eq "yes")
	{
		$return = $an->String->get({key => "tools_suffix_0047"});
	}
	elsif (lc($string) eq "no")
	{
		$return = $an->String->get({key => "tools_suffix_0048"});
	}
	elsif (lc($string) eq "enabled")
	{
		$return = $an->String->get({key => "tools_suffix_0049"});
	}
	elsif (lc($string) eq "disabled")
	{
		$return = $an->String->get({key => "tools_suffix_0050"});
	}
	elsif (lc($string) eq "on")
	{
		$return = $an->String->get({key => "tools_suffix_0051"});
	}
	elsif (lc($string) eq "off")
	{
		$return = $an->String->get({key => "tools_suffix_0052"});
	}
	### TODO: Add these to the wiki
	elsif (lc($string) eq "optimal")
	{
		$return = $an->String->get({key => "tools_suffix_0053"});
	}
	elsif (lc($string) eq "partially degraded")
	{
		$return = $an->String->get({key => "tools_suffix_0054"});
	}
	elsif (lc($string) eq "degraded")
	{
		$return = $an->String->get({key => "tools_suffix_0055"});
	}
	elsif (lc($string) eq "no pending images")
	{
		$return = $an->String->get({key => "tools_suffix_0056"});
	}
	elsif ((lc($string) eq "auto") or (lc($string) eq "automatic"))
	{
		$return = $an->String->get({key => "tools_suffix_0057"});
	}
	elsif (lc($string) eq "allowed")
	{
		$return = $an->String->get({key => "tools_suffix_0059"});
	}
	elsif (lc($string) eq "not allowed")
	{
		$return = $an->String->get({key => "tools_suffix_0060"});
	}
	elsif (lc($string) eq "present")
	{
		$return = $an->String->get({key => "tools_suffix_0061"});
	}
	elsif (lc($string) eq "absent")
	{
		$return = $an->String->get({key => "tools_suffix_0062"});
	}
	elsif (lc($string) eq "missing")
	{
		$return = $an->String->get({key => "tools_suffix_0067"});
	}
	elsif (lc($string) eq "read ahead")
	{
		$return = $an->String->get({key => "tools_suffix_0063"});
	}
	elsif (lc($string) eq "no read ahead")
	{
		$return = $an->String->get({key => "tools_suffix_0064"});
	}
	elsif ((lc($string) eq "na") or (lc($string) eq "n/a"))
	{
		$return = $an->String->get({key => "tools_suffix_0065"});
	}
	elsif (lc($string) eq "none")
	{
		$return = $an->String->get({key => "tools_suffix_0066"});
	}
	elsif (lc($string) eq "battery is not being charged")
	{
		$return = $an->String->get({key => "tools_suffix_0068"});
	}
	elsif (lc($string) eq "lion")
	{
		$return = $an->String->get({key => "tools_suffix_0071"});
	}
	elsif (lc($string) eq "transparent")
	{
		$return = $an->String->get({key => "tools_suffix_0072"});
	}
	elsif (lc($string) eq "inconsistent")
	{
		$return = $an->String->get({key => "tools_suffix_0075"});
	}
	elsif (lc($string) eq "consistent")
	{
		$return = $an->String->get({key => "tools_suffix_0074"});
	}
	elsif (lc($string) eq "direct io")
	{
		$return = $an->String->get({key => "tools_suffix_0076"});
	}
	elsif (lc($string) eq "hdd")
	{
		$return = $an->String->get({key => "tools_suffix_0077"});
	}
	elsif (lc($string) eq "ssd")
	{
		$return = $an->String->get({key => "tools_suffix_0078"});
	}
	elsif (lc($string) eq "sas")
	{
		$return = $an->String->get({key => "tools_suffix_0079"});
	}
	elsif (lc($string) eq "sata")
	{
		$return = $an->String->get({key => "tools_suffix_0080"});
	}
	elsif (lc($string) eq "rbld")
	{
		$return = $an->String->get({key => "tools_suffix_0081"});
	}
# 	elsif (lc($string) eq "")
# 	{
# 		$return = $an->String->get({key => ""});
# 	}
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "return",  value1 => $return, 
	}, file => $THIS_FILE, line => __LINE__});
	return($return);
}

### NOTE: This is called loosely. It is entirely possible that 'units' is NOT valid. Simply return nothing in
###       such cases.
# This looks at the 'unit' and if it is one of the ones described in the ScanCore "Unit Parsing" page, 
# translate it. See: https://alteeve.ca/w/ScanCore#Unit_Parsing
sub translate_units
{
	my ($an, $value, $units, $user_units) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "translate_units" }, message_key => "an_variables_0003", message_variables => { 
		name1 => "value",      value1 => $value, 
		name2 => "units",      value2 => $units, 
		name3 => "user_units", value3 => $user_units, 
	}, file => $THIS_FILE, line => __LINE__});
	$user_units = "metric" if not $user_units;
	
	my $return = "";
	
	# This won't modify and values with a space in them.
	if (($value eq "") or ($value =~ /\s/))
	{
		return($return);
	}
	
	if ($units eq "%")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0016"});
	}
	elsif ($units eq "W")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0017"});
	}
	elsif ($units eq "vDC")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0018"});
	}
	elsif ($units eq "vAC")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0019"});
	}
	elsif ($units eq "A")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0020"});
	}
	elsif ($units eq "RPM")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0021"});
	}
	elsif ($units eq "Bps")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0021"});
	}
	elsif ($units eq "Kbps")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0022"});
	}
	elsif ($units eq "Mbps")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0023"});
	}
	elsif ($units eq "Gbps")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0024"});
	}
	elsif ($units eq "Tbps")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0025"});
	}
	elsif (($value =~ /^\d+$/) && ($units eq "Bytes"))
	{
		$return = $an->Readable->bytes_to_hr({'bytes' => $value});
	}
	elsif (($value =~ /^\d+$/) && ($units eq "sec"))
	{
		$return = $an->Readable->time({'time' => $value});
	}
	# Don't confuse this with 'Seconds', which is NOT converted.
	elsif (($value =~ /^\d+$/) && ($units eq "seconds"))
	{
		$return = $an->Readable->time({'time' => $value, suffix => "long"});
	}
	elsif ($units eq "Second")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0037"});
	}
	elsif ($units eq "Seconds")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0038"});
	}
	elsif ($units eq "Minute")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0039"});
	}
	elsif ($units eq "Minutes")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0040"});
	}
	elsif ($units eq "Hour")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0041"});
	}
	elsif ($units eq "Hours")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0042"});
	}
	elsif ($units eq "Day")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0043"});
	}
	elsif ($units eq "Days")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0044"});
	}
	elsif ($units eq "Week")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0045"});
	}
	elsif ($units eq "C")
	{
		# Temperature, convert to the user's desired units.
		if ($user_units eq "metric")
		{
			# Leave as C
			$return = $value." ".$an->String->get({key => "tools_suffix_0010"});
		}
		else
		{
			# Convert to F
			$return = $an->Convert->convert_to_fahrenheit({temperature => $value})." ".$an->String->get({key => "tools_suffix_0012"});
		}
	}
	### TODO: Add to wiki
	elsif ($units eq "Sectors")
	{
		$return = $value." ".$an->String->get({key => "tools_suffix_0058"});
	}
	elsif ($units eq "mAh")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0070"});
	}
	elsif ($units eq "mA")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0069"});
	}
	elsif ($units eq "J")
	{
		$return = $value.$an->String->get({key => "tools_suffix_0073"});
	}
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "return",  value1 => $return, 
	}, file => $THIS_FILE, line => __LINE__});
	return($return)
}

# This and translate_sensor_name() are special functions used to translate 
# PMI sensor data into a user's chosen language and units (metric v. imperial).
sub translate_sensor_value
{
	my ($an, $ipmitool_value_sensor_value, $ipmitool_sensor_units, $units) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "translate_sensor_value", }, message_key => "an_variables_0003", message_variables => { 
		name1 => "ipmitool_value_sensor_value", value1 => $ipmitool_value_sensor_value, 
		name2 => "ipmitool_sensor_units",       value2 => $ipmitool_sensor_units, 
		name3 => "units",                       value3 => $units, 
	}, file => $THIS_FILE, line => __LINE__});
	$units = "metric" if not $units;
	
	# Translate the sensor units.
	my $say_units = $ipmitool_sensor_units;
	if ($say_units eq "C")
	{
		if ($units eq "metric")
		{
			# Leave as C
			$say_units = $an->String->get({key => "tools_suffix_0010"});
		}
		else
		{
			# Convert to F
			$say_units                   = $an->String->get({key => "tools_suffix_0012"});
			$ipmitool_value_sensor_value = $an->Convert->convert_to_fahrenheit({temperature => $ipmitool_value_sensor_value});
		}
	} # Already C at this time
	elsif ($say_units eq "%")   { $say_units = $an->String->get({key => "tools_suffix_0016"}); }
	elsif ($say_units eq "W")   { $say_units = $an->String->get({key => "tools_suffix_0017"}); } # watts
	elsif ($say_units eq "V")   { $say_units = $an->String->get({key => "tools_suffix_0018"}); } # vDC is always assumed, may need to update this later.
	elsif ($say_units eq "RPM") { $say_units = $an->String->get({key => "tools_suffix_0021"}); } # rotations per minute.
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_units", value1 => $say_units, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Put them together
	my $say_sensor_value = "$ipmitool_value_sensor_value $say_units";
	
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "say_sensor_value", value1 => $say_sensor_value, 
	}, file => $THIS_FILE, line => __LINE__});
	return($say_sensor_value);
}

# This looks at each DB's 'updated' table to see if any are behind. If any are, it will update the tables 
# based on the time the last entry was made for a given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "scancore::db_resync_needed", value1 => $an->data->{scancore}{db_resync_needed}, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($an->data->{scancore}{db_resync_needed})
	{
		# Something somewhere is out of sync. So start with updating the core tables. The agents will
		# take care of their own.
		
		# Request a lock.
		$an->DB->locking({request => 1});
		
		# Update (and commit) the hosts table
		update_db_hosts($an);
		
		### NOTE: The order that these are updated is important because of constraints. Don't re-order them.
		# Now update the rest of the ScanCore tables
		update_db_owners($an);
		update_db_smtp($an);
		update_db_anvils($an);
		update_db_nodes($an);         
		update_db_notifications($an);
		update_db_recipients($an);
		update_db_states($an);
		update_db_nodes_cache($an);
		
		update_db_alerts($an);
		update_db_power($an);
		update_db_temperature($an);
		update_db_health($an);
		update_db_agents($an);
		update_db_ram_used($an);
		update_db_shared($an);
		update_db_servers($an);
		update_db_dr_targets($an);
		update_db_dr_jobs($an);
		update_db_manifests($an);
		update_db_variables($an);
		
		# Record the time
		$an->DB->update_time({file => $THIS_FILE});
		
		# Release the lock
		$an->DB->locking({release => 1});
	}
	
	return(0);
}

# Update the nodes_cache table, which is bound the the host_uuid.
sub update_db_nodes_cache
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_nodes_cache" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'nodes_cache' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    node_cache_uuid, 
    node_cache_node_uuid, 
    node_cache_name, 
    node_cache_data, 
    node_cache_note, 
    modified_date 
FROM 
    history.nodes_cache
WHERE
    node_cache_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $node_cache_uuid      = $row->[0];
			my $node_cache_node_uuid = $row->[1];
			my $node_cache_name      = $row->[2];
			my $node_cache_data      = $row->[3] ? $row->[3] : "NULL";
			my $node_cache_note      = $row->[4] ? $row->[4] : "NULL";
			my $modified_date        = $row->[5];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "node_cache_uuid",      value1 => $node_cache_uuid, 
				name2 => "node_cache_node_uuid", value2 => $node_cache_node_uuid, 
				name3 => "node_cache_name",      value3 => $node_cache_name, 
				name4 => "node_cache_data",      value4 => $node_cache_data, 
				name5 => "node_cache_note",      value5 => $node_cache_note, 
				name6 => "modified_date",        value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			### TODO: Sort out how to loop this given that we need to match the name and the node_uuid...
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid} = {
				node_cache_node_uuid	=>	$node_cache_node_uuid, 
				node_cache_name		=>	$node_cache_name, 
				node_cache_data		=>	$node_cache_data, 
				node_cache_note		=>	$node_cache_note, 
			};
			$an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid} = {
				node_cache_node_uuid	=>	$node_cache_node_uuid, 
				node_cache_name		=>	$node_cache_name, 
				node_cache_data		=>	$node_cache_data, 
				node_cache_note		=>	$node_cache_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{nodes_cache}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $node_cache_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}})
		{
			my $node_cache_node_uuid = $an->data->{db_data}{unified}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid}{node_cache_node_uuid};
			my $node_cache_name      = $an->data->{db_data}{unified}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid}{node_cache_name};
			my $node_cache_data      = $an->data->{db_data}{unified}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid}{node_cache_data};
			my $node_cache_note      = $an->data->{db_data}{unified}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid}{node_cache_note};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "node_cache_node_uuid", value1 => $node_cache_node_uuid, 
				name2 => "node_cache_name",      value2 => $node_cache_name, 
				name3 => "node_cache_data",      value3 => $node_cache_data, 
				name4 => "node_cache_note",      value4 => $node_cache_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'node_cache_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::nodes_cache::node_cache_uuid::${node_cache_uuid}::seen", value1 => $an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::nodes_cache::node_cache_uuid::${node_cache_uuid}::exists", value1 => $an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{nodes_cache}{node_cache_uuid}{$node_cache_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::nodes_cache::modified_date::${modified_date}::node_cache_uuid::${node_cache_uuid}", value1 => $an->data->{db_data}{$id}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.nodes_cache
SET
    node_cache_node_uuid = ".$an->data->{sys}{use_db_fh}->quote($node_cache_node_uuid).", 
    node_cache_name      = ".$an->data->{sys}{use_db_fh}->quote($node_cache_name).", 
    node_cache_data      = ".$an->data->{sys}{use_db_fh}->quote($node_cache_data).", 
    node_cache_note      = ".$an->data->{sys}{use_db_fh}->quote($node_cache_note).", 
    modified_date        = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    node_cache_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    node_cache_uuid      = ".$an->data->{sys}{use_db_fh}->quote($node_cache_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.nodes_cache
(
    node_cache_uuid, 
    node_cache_host_uuid, 
    node_cache_node_uuid, 
    node_cache_name, 
    node_cache_data, 
    node_cache_note, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_node_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_data).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'node_cache_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{nodes_cache}{modified_date}{$modified_date}{node_cache_uuid}{$node_cache_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.nodes_cache
(
    node_cache_uuid, 
    node_cache_host_uuid, 
    node_cache_node_uuid, 
    node_cache_name, 
    node_cache_data, 
    node_cache_note, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_node_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_data).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_cache_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen node_cache_uuid?
			} # foreach my $id 
		} # foreach my $node_cache_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the smtp table. Like 'servers', this table is not bound to a host.
sub update_db_smtp
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_smtp" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'smtp' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    smtp_uuid,
    smtp_server, 
    smtp_port, 
    smtp_username, 
    smtp_password, 
    smtp_security, 
    smtp_authentication, 
    smtp_helo_domain, 
    smtp_note, 
    smtp_alt_server, 
    smtp_alt_port, 
    modified_date 
FROM 
    history.smtp 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $smtp_uuid           = $row->[0];
			my $smtp_server         = $row->[1];
			my $smtp_port           = $row->[2];
			my $smtp_username       = $row->[3];
			my $smtp_password       = $row->[4];
			my $smtp_security       = $row->[5];
			my $smtp_authentication = $row->[6];
			my $smtp_helo_domain    = $row->[7];
			my $smtp_note           = $row->[8];
			my $smtp_alt_server     = $row->[9];
			my $smtp_alt_port       = $row->[10];
			my $modified_date       = $row->[11];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0011", message_variables => {
				name1  => "smtp_uuid",           value1  => $smtp_uuid, 
				name2  => "smtp_server",         value2  => $smtp_server,
				name3  => "smtp_port",           value3  => $smtp_port,
				name4  => "smtp_username",       value4  => $smtp_username,
				name5  => "smtp_security",       value5  => $smtp_security,
				name6  => "smtp_authentication", value6  => $smtp_authentication,
				name7  => "smtp_helo_domain",    value7  => $smtp_helo_domain,
				name8  => "smtp_note",           value8  => $smtp_note, 
				name9  => "smtp_alt_server",     value9  => $smtp_alt_server, 
				name10 => "smtp_alt_port",       value10 => $smtp_alt_port, 
				name11 => "modified_date",       value11 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "smtp_password", value1 => $smtp_password,
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid} = {
				smtp_server		=>	$smtp_server,
				smtp_port		=>	$smtp_port,
				smtp_username		=>	$smtp_username,
				smtp_password		=>	$smtp_password,
				smtp_security		=>	$smtp_security,
				smtp_authentication	=>	$smtp_authentication,
				smtp_helo_domain	=>	$smtp_helo_domain,
				smtp_note		=>	$smtp_note, 
				smtp_alt_server		=>	$smtp_alt_server, 
				smtp_alt_port		=>	$smtp_alt_port, 
			};
			
			$an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid} = {
				smtp_server		=>	$smtp_server,
				smtp_port		=>	$smtp_port,
				smtp_username		=>	$smtp_username,
				smtp_password		=>	$smtp_password,
				smtp_security		=>	$smtp_security,
				smtp_authentication	=>	$smtp_authentication,
				smtp_helo_domain	=>	$smtp_helo_domain,
				smtp_note		=>	$smtp_note, 
				smtp_alt_server		=>	$smtp_alt_server, 
				smtp_alt_port		=>	$smtp_alt_port, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{smtp}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $smtp_uuid (keys %{$an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}})
		{
			my $smtp_server         = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_server}; 
			my $smtp_port           = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_port}; 
			my $smtp_password       = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_password}; 
			my $smtp_username       = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_username}; 
			my $smtp_security       = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_security}; 
			my $smtp_authentication = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_authentication}; 
			my $smtp_helo_domain    = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_helo_domain}; 
			my $smtp_note           = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_note};
			my $smtp_alt_server     = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_alt_server};
			my $smtp_alt_port       = $an->data->{db_data}{unified}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}{smtp_alt_port};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "smtp_uuid",           value1  => $smtp_uuid, 
				name2  => "smtp_server",         value2  => $smtp_server,
				name3  => "smtp_port",           value3  => $smtp_port,
				name4  => "smtp_username",       value4  => $smtp_username,
				name5  => "smtp_security",       value5  => $smtp_security,
				name6  => "smtp_authentication", value6  => $smtp_authentication,
				name7  => "smtp_helo_domain",    value7  => $smtp_helo_domain,
				name8  => "smtp_note",           value8  => $smtp_note, 
				name9  => "smtp_alt_server",     value9  => $smtp_alt_server, 
				name10 => "smtp_alt_port",       value10 => $smtp_alt_port, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "smtp_password", value1 => $smtp_password,
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'smtp_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::smtp::smtp_uuid::${smtp_uuid}::seen", value1 => $an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::smtp::smtp_uuid::${smtp_uuid}::exists", value1 => $an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{smtp}{smtp_uuid}{$smtp_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::smtp::modified_date::${modified_date}::smtp_uuid::${smtp_uuid}", value1 => $an->data->{db_data}{$id}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.smtp 
SET
    smtp_server         = ".$an->data->{sys}{use_db_fh}->quote($smtp_server).",
    smtp_port           = ".$an->data->{sys}{use_db_fh}->quote($smtp_port).",
    smtp_username       = ".$an->data->{sys}{use_db_fh}->quote($smtp_username).",
    smtp_password       = ".$an->data->{sys}{use_db_fh}->quote($smtp_password).",
    smtp_security       = ".$an->data->{sys}{use_db_fh}->quote($smtp_security).",
    smtp_authentication = ".$an->data->{sys}{use_db_fh}->quote($smtp_authentication).",
    smtp_helo_domain    = ".$an->data->{sys}{use_db_fh}->quote($smtp_helo_domain).",
    smtp_note           = ".$an->data->{sys}{use_db_fh}->quote($smtp_note).", 
    smtp_alt_server     = ".$an->data->{sys}{use_db_fh}->quote($smtp_alt_server).", 
    smtp_alt_port       = ".$an->data->{sys}{use_db_fh}->quote($smtp_alt_port).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    smtp_uuid           = ".$an->data->{sys}{use_db_fh}->quote($smtp_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.smtp 
(
    smtp_uuid, 
    smtp_server, 
    smtp_port, 
    smtp_username, 
    smtp_password, 
    smtp_security, 
    smtp_authentication, 
    smtp_helo_domain, 
    smtp_note, 
    smtp_alt_server, 
    smtp_alt_port, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($smtp_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_server).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_username).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_security).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_authentication).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_helo_domain).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_alt_server).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_alt_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'smtp_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{smtp}{modified_date}{$modified_date}{smtp_uuid}{$smtp_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.smtp 
(
    smtp_uuid, 
    smtp_server, 
    smtp_port, 
    smtp_username, 
    smtp_password, 
    smtp_security, 
    smtp_authentication, 
    smtp_helo_domain, 
    smtp_note, 
    smtp_alt_server, 
    smtp_alt_port, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($smtp_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_server).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_username).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_security).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_authentication).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_helo_domain).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_alt_server).", 
    ".$an->data->{sys}{use_db_fh}->quote($smtp_alt_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen smtp_uuid?
			} # foreach my $id 
		} # foreach my $smtp_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This updates the variables table. Like 'servers', this table is not bound to a host.
sub update_db_variables
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_variables" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'variables' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    variable_uuid,
    variable_name, 
    variable_value, 
    variable_default, 
    variable_description, 
    variable_section, 
    variable_source_uuid, 
    variable_source_table, 
    modified_date 
FROM 
    history.variables 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $variable_uuid         = $row->[0];
			my $variable_name         = $row->[1]; 
			my $variable_value        = $row->[2] ? $row->[2] : "NULL"; 
			my $variable_default      = $row->[3] ? $row->[3] : "NULL"; 
			my $variable_description  = $row->[4] ? $row->[4] : "NULL"; 
			my $variable_section      = $row->[5] ? $row->[5] : "NULL"; 
			my $variable_source_uuid  = $row->[6] ? $row->[6] : "NULL"; 
			my $variable_source_table = $row->[7] ? $row->[7] : "NULL"; 
			my $modified_date         = $row->[8] ? $row->[8] : "NULL";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "variable_uuid",         value1 => $variable_uuid, 
				name2 => "variable_name",         value2 => $variable_name,
				name3 => "variable_value",        value3 => $variable_value,
				name4 => "variable_default",      value4 => $variable_default,
				name5 => "variable_description",  value5 => $variable_description,
				name6 => "variable_section",      value6 => $variable_section,
				name7 => "variable_source_uuid",  value7 => $variable_source_uuid,
				name8 => "variable_source_table", value8 => $variable_source_table,
				name9 => "modified_date",         value9 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid} = {
				variable_name		=>	$variable_name,
				variable_value		=>	$variable_value,
				variable_default	=>	$variable_default,
				variable_description	=>	$variable_description,
				variable_section	=>	$variable_section,
				variable_source_uuid	=>	$variable_source_uuid,
				variable_source_table	=>	$variable_source_table,
			};
			
			$an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid} = {
				variable_name		=>	$variable_name,
				variable_value		=>	$variable_value,
				variable_default	=>	$variable_default,
				variable_description	=>	$variable_description,
				variable_section	=>	$variable_section,
				variable_source_uuid	=>	$variable_source_uuid,
				variable_source_table	=>	$variable_source_table,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{variables}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $variable_uuid (keys %{$an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}})
		{
			my $variable_name         = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_name};
			my $variable_value        = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_value};
			my $variable_default      = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_default};
			my $variable_description  = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_description};
			my $variable_section      = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_section};
			my $variable_source_uuid  = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_source_uuid};
			my $variable_source_table = $an->data->{db_data}{unified}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}{variable_source_table};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "variable_uuid",         value1 => $variable_uuid, 
				name2 => "variable_name",         value2 => $variable_name,
				name3 => "variable_value",        value3 => $variable_value,
				name4 => "variable_default",      value4 => $variable_default,
				name5 => "variable_description",  value5 => $variable_description,
				name6 => "variable_section",      value6 => $variable_section,
				name7 => "variable_source_uuid",  value7 => $variable_source_uuid,
				name8 => "variable_source_table", value8 => $variable_source_table,
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'variable_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::variable::variable_uuid::${variable_uuid}::seen", value1 => $an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::variable::variable_uuid::${variable_uuid}::exists", value1 => $an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{variables}{variable_uuid}{$variable_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::variable::modified_date::${modified_date}::variable_uuid::${variable_uuid}", value1 => $an->data->{db_data}{$id}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.variables 
SET
    variable_name         = ".$an->data->{sys}{use_db_fh}->quote($variable_name).", 
    variable_value        = ".$an->data->{sys}{use_db_fh}->quote($variable_value).", 
    variable_default      = ".$an->data->{sys}{use_db_fh}->quote($variable_default).", 
    variable_description  = ".$an->data->{sys}{use_db_fh}->quote($variable_description).", 
    variable_section      = ".$an->data->{sys}{use_db_fh}->quote($variable_section).", 
    variable_source_uuid  = ".$an->data->{sys}{use_db_fh}->quote($variable_source_uuid).", 
    variable_source_table = ".$an->data->{sys}{use_db_fh}->quote($variable_source_table).", 
    modified_date         = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    variable_uuid = ".$an->data->{sys}{use_db_fh}->quote($variable_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.variables 
(
    variable_uuid, 
    variable_name, 
    variable_value, 
    variable_default, 
    variable_description, 
    variable_section, 
    variable_source_uuid, 
    variable_source_table, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($variable_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_default).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_description).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_section).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_source_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_source_table).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'variable_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{variables}{modified_date}{$modified_date}{variable_uuid}{$variable_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.variables 
(
    variable_uuid, 
    variable_name, 
    variable_value, 
    variable_default, 
    variable_description, 
    variable_section, 
    variable_source_uuid, 
    variable_source_table, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($variable_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_value).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_default).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_description).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_section).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_source_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($variable_source_table).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen variable_uuid?
			} # foreach my $id 
		} # foreach my $variable_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the manifests table. Like 'servers', this table is not bound to a host.
sub update_db_manifests
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_manifests" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'manifests' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    manifest_uuid,
    manifest_data, 
    manifest_note, 
    modified_date 
FROM 
    history.manifests 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $manifest_uuid = $row->[0];
			my $manifest_data = $row->[1];
			my $manifest_note = $row->[2];
			my $modified_date = $row->[3];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "manifest_uuid", value1 => $manifest_uuid, 
				name2 => "manifest_data", value2 => $manifest_data,
				name3 => "manifest_note", value3 => $manifest_note, 
				name4 => "modified_date", value4 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid} = {
				manifest_data	=>	$manifest_data,
				manifest_note	=>	$manifest_note, 
			};
			
			$an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid} = {
				manifest_data	=>	$manifest_data,
				manifest_note	=>	$manifest_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{manifests}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $manifest_uuid (keys %{$an->data->{db_data}{unified}{manifests}{modified_date}{$modified_date}{manifest_uuid}})
		{
			my $manifest_data = $an->data->{db_data}{unified}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid}{manifest_data}; 
			my $manifest_note = $an->data->{db_data}{unified}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid}{manifest_note};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "manifest_uuid", value1 => $manifest_uuid, 
				name2 => "manifest_data", value2 => $manifest_data,
				name3 => "manifest_note", value3 => $manifest_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'manifest_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::manifest::manifest_uuid::${manifest_uuid}::seen", value1 => $an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::manifest::manifest_uuid::${manifest_uuid}::exists", value1 => $an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{manifests}{manifest_uuid}{$manifest_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::manifest::modified_date::${modified_date}::manifest_uuid::${manifest_uuid}", value1 => $an->data->{db_data}{$id}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.manifests 
SET
    manifest_data = ".$an->data->{sys}{use_db_fh}->quote($manifest_data).", 
    manifest_note = ".$an->data->{sys}{use_db_fh}->quote($manifest_note).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    manifest_uuid = ".$an->data->{sys}{use_db_fh}->quote($manifest_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.manifests 
(
    manifest_uuid, 
    manifest_data, 
    manifest_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($manifest_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($manifest_data).", 
    ".$an->data->{sys}{use_db_fh}->quote($manifest_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'manifest_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{manifests}{modified_date}{$modified_date}{manifest_uuid}{$manifest_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.manifests 
(
    manifest_uuid, 
    manifest_data, 
    manifest_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($manifest_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($manifest_data).", 
    ".$an->data->{sys}{use_db_fh}->quote($manifest_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen manifest_uuid?
			} # foreach my $id 
		} # foreach my $manifest_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the recipients table. Like 'servers', this table is not bound to a host.
sub update_db_recipients
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_recipients" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'recipients' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    recipient_uuid,
    recipient_anvil_uuid, 
    recipient_notify_uuid, 
    recipient_notify_level, 
    recipient_note, 
    modified_date 
FROM 
    history.recipients 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $recipient_uuid         = $row->[0];
			my $recipient_anvil_uuid   = $row->[1];
			my $recipient_notify_uuid  = $row->[2];
			my $recipient_notify_level = $row->[3];
			my $recipient_note         = $row->[4];
			my $modified_date          = $row->[5];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "recipient_uuid",         value1 => $recipient_uuid, 
				name2 => "recipient_anvil_uuid",   value2 => $recipient_anvil_uuid,
				name3 => "recipient_notify_uuid",  value3 => $recipient_notify_uuid,
				name4 => "recipient_notify_level", value4 => $recipient_notify_uuid,
				name5 => "recipient_note",         value5 => $recipient_note, 
				name6 => "modified_date",          value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid} = {
				recipient_anvil_uuid	=>	$recipient_anvil_uuid,
				recipient_notify_uuid	=>	$recipient_notify_uuid,
				recipient_notify_level	=>	$recipient_notify_uuid,
				recipient_note		=>	$recipient_note, 
			};
			
			$an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid} = {
				recipient_anvil_uuid	=>	$recipient_anvil_uuid,
				recipient_notify_uuid	=>	$recipient_notify_uuid,
				recipient_notify_level	=>	$recipient_notify_uuid,
				recipient_note		=>	$recipient_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{recipients}{modified_date}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $recipient_uuid (keys %{$an->data->{db_data}{unified}{recipients}{modified_date}{$modified_date}{recipient_uuid}})
		{
			my $recipient_anvil_uuid   = $an->data->{db_data}{unified}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid}{recipient_anvil_uuid}; 
			my $recipient_notify_uuid  = $an->data->{db_data}{unified}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid}{recipient_notify_uuid}; 
			my $recipient_notify_level = $an->data->{db_data}{unified}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid}{recipient_notify_level}; 
			my $recipient_note         = $an->data->{db_data}{unified}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid}{recipient_note};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "recipient_uuid",         value1 => $recipient_uuid, 
				name2 => "recipient_anvil_uuid",   value2 => $recipient_anvil_uuid,
				name3 => "recipient_notify_uuid",  value3 => $recipient_notify_uuid,
				name4 => "recipient_notify_level", value4 => $recipient_notify_uuid,
				name5 => "recipient_note",         value5 => $recipient_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'recipient_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::recipient::recipient_uuid::${recipient_uuid}::seen", value1 => $an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::recipient::recipient_uuid::${recipient_uuid}::exists", value1 => $an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{recipients}{recipient_uuid}{$recipient_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::recipient::modified_date::${modified_date}::recipient_uuid::${recipient_uuid}", value1 => $an->data->{db_data}{$id}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.recipients 
SET
    recipient_anvil_uuid   = ".$an->data->{sys}{use_db_fh}->quote($recipient_anvil_uuid).", 
    recipient_notify_uuid  = ".$an->data->{sys}{use_db_fh}->quote($recipient_notify_uuid).", 
    recipient_notify_level = ".$an->data->{sys}{use_db_fh}->quote($recipient_notify_level).", 
    recipient_note         = ".$an->data->{sys}{use_db_fh}->quote($recipient_note).", 
    modified_date          = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    recipient_uuid         = ".$an->data->{sys}{use_db_fh}->quote($recipient_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.recipients 
(
    recipient_uuid, 
    recipient_anvil_uuid, 
    recipient_notify_uuid, 
    recipient_notify_level, 
    recipient_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($recipient_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_notify_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_notify_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'recipient_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{recipients}{modified_date}{$modified_date}{recipient_uuid}{$recipient_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.recipients 
(
    recipient_uuid, 
    recipient_anvil_uuid, 
    recipient_notify_uuid, 
    recipient_notify_level, 
    recipient_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($recipient_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_notify_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_notify_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($recipient_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen recipient_uuid?
			} # foreach my $id 
		} # foreach my $recipient_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the notifications table. Like 'servers', this table is not bound to a host.
sub update_db_notifications
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_notifications" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'notifications' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    notify_uuid,
    notify_name,
    notify_target,
    notify_language,
    notify_level,
    notify_units,
    notify_note, 
    modified_date 
FROM 
    history.notifications 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $notify_uuid     = $row->[0];
			my $notify_name     = $row->[1];
			my $notify_target   = $row->[2];
			my $notify_language = $row->[3];
			my $notify_level    = $row->[4];
			my $notify_units    = $row->[5];
			my $notify_note     = $row->[6] ? $row->[6] : "";
			my $modified_date   = $row->[7];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "notify_uuid",     value1 => $notify_uuid, 
				name2 => "notify_name",     value2 => $notify_name,
				name3 => "notify_target",   value3 => $notify_target,
				name4 => "notify_language", value4 => $notify_language,
				name5 => "notify_level",    value5 => $notify_level,
				name6 => "notify_units",    value6 => $notify_units,
				name7 => "notify_note",     value7 => $notify_note, 
				name8 => "modified_date",   value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid} = {
				notify_name	=>	$notify_name,
				notify_target	=>	$notify_target,
				notify_language	=>	$notify_language,
				notify_level	=>	$notify_level,
				notify_units	=>	$notify_units,
				notify_note	=>	$notify_note, 
			};
			
			$an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid} = {
				notify_name	=>	$notify_name,
				notify_target	=>	$notify_target,
				notify_language	=>	$notify_language,
				notify_level	=>	$notify_level,
				notify_units	=>	$notify_units,
				notify_note	=>	$notify_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{notifications}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $notify_uuid (keys %{$an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}})
		{
			my $notify_name     = $an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}{notify_name};
			my $notify_target   = $an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}{notify_target};
			my $notify_language = $an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}{notify_language};
			my $notify_level    = $an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}{notify_level};
			my $notify_units    = $an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}{notify_units};
			my $notify_note     = $an->data->{db_data}{unified}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}{notify_note};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "notify_uuid",     value1 => $notify_uuid, 
				name2 => "notify_name",     value2 => $notify_name,
				name3 => "notify_target",   value3 => $notify_target,
				name4 => "notify_language", value4 => $notify_language,
				name5 => "notify_level",    value5 => $notify_level,
				name6 => "notify_units",    value6 => $notify_units,
				name7 => "notify_note",     value7 => $notify_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'notify_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::notify::notify_uuid::${notify_uuid}::seen", value1 => $an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::notify::notify_uuid::${notify_uuid}::exists", value1 => $an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{notifications}{notify_uuid}{$notify_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::notify::modified_date::${modified_date}::notify_uuid::${notify_uuid}", value1 => $an->data->{db_data}{$id}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.notifications 
SET
    notify_name     = ".$an->data->{sys}{use_db_fh}->quote($notify_name).", 
    notify_target   = ".$an->data->{sys}{use_db_fh}->quote($notify_target).", 
    notify_language = ".$an->data->{sys}{use_db_fh}->quote($notify_language).", 
    notify_level    = ".$an->data->{sys}{use_db_fh}->quote($notify_level).", 
    notify_units    = ".$an->data->{sys}{use_db_fh}->quote($notify_units).", 
    notify_note     = ".$an->data->{sys}{use_db_fh}->quote($notify_note).", 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    notify_uuid     = ".$an->data->{sys}{use_db_fh}->quote($notify_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.notifications 
(
    notify_uuid, 
    notify_name,
    notify_target,
    notify_language,
    notify_level,
    notify_units,
    notify_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($notify_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_target).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_language).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_units).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'notify_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{notifications}{modified_date}{$modified_date}{notify_uuid}{$notify_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.notifications 
(
    notify_uuid, 
    notify_name,
    notify_target,
    notify_language,
    notify_level,
    notify_units,
    notify_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($notify_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_target).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_language).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_units).", 
    ".$an->data->{sys}{use_db_fh}->quote($notify_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen notify_uuid?
			} # foreach my $id 
		} # foreach my $notify_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the nodes table. Like 'servers', this table is not bound to a host.
sub update_db_nodes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_nodes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'nodes' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    node_uuid, 
    node_anvil_uuid, 
    node_host_uuid, 
    node_remote_ip, 
    node_remote_port, 
    node_note, 
    node_bcn, 
    node_sn, 
    node_ifn, 
    node_password, 
    modified_date 
FROM 
    history.nodes 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $node_uuid        = $row->[0];
			my $node_anvil_uuid  = $row->[1];
			my $node_host_uuid   = $row->[2];
			my $node_remote_ip   = $row->[3];
			my $node_remote_port = $row->[4];
			my $node_note        = $row->[5];
			my $node_bcn         = $row->[6];
			my $node_sn          = $row->[7];
			my $node_ifn         = $row->[8];
			my $node_password    = $row->[9];
			my $modified_date    = $row->[10];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0011", message_variables => {
				name1  => "node_uuid",        value1  => $node_uuid, 
				name2  => "node_anvil_uuid",  value2  => $node_anvil_uuid, 
				name3  => "node_host_uuid",   value3  => $node_host_uuid, 
				name4  => "node_remote_ip",   value4  => $node_remote_ip,
				name5  => "node_remote_port", value5  => $node_remote_port,
				name6  => "node_note",        value6  => $node_note, 
				name7  => "node_bcn",         value7  => $node_bcn,
				name8  => "node_sn",          value8  => $node_sn,
				name9  => "node_ifn",         value9  => $node_ifn,
				name10 => "node_password",    value10 => $node_password, 
				name11 => "modified_date",    value11 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid} = {
				node_anvil_uuid		=>	$node_anvil_uuid, 
				node_host_uuid		=>	$node_host_uuid, 
				node_remote_ip		=>	$node_remote_ip,
				node_remote_port	=>	$node_remote_port,
				node_note		=>	$node_note, 
				node_bcn		=>	$node_bcn,
				node_sn			=>	$node_sn,
				node_ifn		=>	$node_ifn,
				node_password		=>	$node_password, 
			};
			
			$an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid} = {
				node_anvil_uuid	=>	$node_anvil_uuid, 
				node_host_uuid		=>	$node_host_uuid, 
				node_remote_ip		=>	$node_remote_ip,
				node_remote_port	=>	$node_remote_port,
				node_note		=>	$node_note, 
				node_bcn		=>	$node_bcn,
				node_sn			=>	$node_sn,
				node_ifn		=>	$node_ifn,
				node_password		=>	$node_password, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{nodes}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $node_uuid (keys %{$an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}})
		{
			my $node_name        = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_name}; 
			my $node_anvil_uuid  = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_anvil_uuid}; 
			my $node_host_uuid   = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_host_uuid}; 
			my $node_remote_ip   = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_remote_ip};
			my $node_remote_port = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_remote_port};
			my $node_note        = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_note};
			my $node_bcn         = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_bcn};
			my $node_sn          = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_sn};
			my $node_ifn         = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_ifn};
			my $node_password    = $an->data->{db_data}{unified}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}{node_password};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "node_uuid",        value1 => $node_uuid, 
				name2 => "node_anvil_uuid",  value2 => $node_anvil_uuid, 
				name3 => "node_host_uuid",   value3 => $node_host_uuid, 
				name4 => "node_remote_ip",   value4 => $node_remote_ip,
				name5 => "node_remote_port", value5 => $node_remote_port,
				name6 => "node_note",        value6 => $node_note, 
				name7 => "node_bcn",         value7 => $node_bcn,
				name8 => "node_sn",          value8 => $node_sn,
				name9 => "node_ifn",         value9 => $node_ifn,
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "node_password", value1 => $node_password, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'node_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::node::node_uuid::${node_uuid}::seen", value1 => $an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::node::node_uuid::${node_uuid}::exists", value1 => $an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{nodes}{node_uuid}{$node_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::node::modified_date::${modified_date}::node_uuid::${node_uuid}", value1 => $an->data->{db_data}{$id}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.nodes 
SET
    node_anvil_uuid  = ".$an->data->{sys}{use_db_fh}->quote($node_anvil_uuid).", 
    node_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($node_host_uuid).", 
    node_remote_ip   = ".$an->data->{sys}{use_db_fh}->quote($node_remote_ip).", 
    node_remote_port = ".$an->data->{sys}{use_db_fh}->quote($node_remote_port).", 
    node_note        = ".$an->data->{sys}{use_db_fh}->quote($node_note).", 
    node_bcn         = ".$an->data->{sys}{use_db_fh}->quote($node_bcn).", 
    node_sn          = ".$an->data->{sys}{use_db_fh}->quote($node_sn).", 
    node_ifn         = ".$an->data->{sys}{use_db_fh}->quote($node_ifn).", 
    node_password    = ".$an->data->{sys}{use_db_fh}->quote($node_password).", 
    modified_date    = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    node_uuid        = ".$an->data->{sys}{use_db_fh}->quote($node_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.nodes 
(
    node_uuid, 
    node_anvil_uuid, 
    node_host_uuid, 
    node_remote_ip, 
    node_remote_port, 
    node_note, 
    node_bcn, 
    node_sn, 
    node_ifn, 
    node_password, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($node_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_remote_ip).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_remote_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_bcn).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_sn).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_ifn).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'node_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{nodes}{modified_date}{$modified_date}{node_uuid}{$node_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.nodes 
(
    node_uuid, 
    node_anvil_uuid, 
    node_host_uuid, 
    node_remote_ip, 
    node_remote_port, 
    node_note, 
    node_bcn, 
    node_sn, 
    node_ifn, 
    node_password, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($node_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_remote_ip).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_remote_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_bcn).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_sn).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_ifn).", 
    ".$an->data->{sys}{use_db_fh}->quote($node_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen node_uuid?
			} # foreach my $id 
		} # foreach my $node_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the anvils table. Like 'servers', this table is not bound to a host.
sub update_db_anvils
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_anvils" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'anvils' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    anvil_uuid,
    anvil_owner_uuid, 
    anvil_smtp_uuid, 
    anvil_name, 
    anvil_description, 
    anvil_note, 
    anvil_password, 
    modified_date 
FROM 
    history.anvils 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $anvil_uuid        = $row->[0];
			my $anvil_owner_uuid  = $row->[1];
			my $anvil_smtp_uuid   = $row->[2];
			my $anvil_name        = $row->[3];
			my $anvil_description = $row->[4]; 
			my $anvil_note        = $row->[5];
			my $anvil_password    = $row->[6];
			my $modified_date     = $row->[7];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "anvil_uuid",        value1 => $anvil_uuid, 
				name2 => "anvil_owner_uuid",  value2 => $anvil_owner_uuid, 
				name3 => "anvil_smtp_uuid",   value3 => $anvil_smtp_uuid, 
				name4 => "anvil_name",        value4 => $anvil_name, 
				name5 => "anvil_description", value5 => $anvil_description, 
				name6 => "anvil_note",        value6 => $anvil_note, 
				name7 => "modified_date",     value7 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_password", value1 => $anvil_password, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid} = {
				anvil_owner_uuid	=>	$anvil_owner_uuid, 
				anvil_smtp_uuid		=>	$anvil_smtp_uuid, 
				anvil_name		=>	$anvil_name, 
				anvil_description	=>	$anvil_description, 
				anvil_note		=>	$anvil_note, 
				anvil_password		=>	$anvil_password, 
			};
			
			$an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid} = {
				anvil_owner_uuid	=>	$anvil_owner_uuid, 
				anvil_smtp_uuid		=>	$anvil_smtp_uuid, 
				anvil_name		=>	$anvil_name, 
				anvil_description	=>	$anvil_description, 
				anvil_note		=>	$anvil_note, 
				anvil_password		=>	$anvil_password, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{anvils}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $anvil_uuid (keys %{$an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}})
		{
			my $anvil_owner_uuid  = $an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}{anvil_owner_uuid}, 
			my $anvil_smtp_uuid   = $an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}{anvil_smtp_uuid}, 
			my $anvil_name        = $an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}{anvil_name}; 
			my $anvil_description = $an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}{anvil_description}, 
			my $anvil_note        = $an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}{anvil_note};
			my $anvil_password    = $an->data->{db_data}{unified}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}{anvil_password}, 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "anvil_uuid",        value1 => $anvil_uuid, 
				name2 => "anvil_owner_uuid",  value2 => $anvil_owner_uuid, 
				name3 => "anvil_smtp_uuid",   value3 => $anvil_smtp_uuid, 
				name4 => "anvil_name",        value4 => $anvil_name, 
				name5 => "anvil_description", value5 => $anvil_description, 
				name6 => "anvil_note",        value6 => $anvil_note, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "anvil_password", value1 => $anvil_password, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'anvil_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::anvil::anvil_uuid::${anvil_uuid}::seen", value1 => $an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::anvil::anvil_uuid::${anvil_uuid}::exists", value1 => $an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{anvils}{anvil_uuid}{$anvil_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::anvil::modified_date::${modified_date}::anvil_uuid::${anvil_uuid}", value1 => $an->data->{db_data}{$id}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.anvils 
SET
    anvil_owner_uuid  = ".$an->data->{sys}{use_db_fh}->quote($anvil_owner_uuid).", 
    anvil_smtp_uuid   = ".$an->data->{sys}{use_db_fh}->quote($anvil_smtp_uuid).", 
    anvil_name        = ".$an->data->{sys}{use_db_fh}->quote($anvil_name).", 
    anvil_description = ".$an->data->{sys}{use_db_fh}->quote($anvil_description).", 
    anvil_note        = ".$an->data->{sys}{use_db_fh}->quote($anvil_note).", 
    anvil_password    = ".$an->data->{sys}{use_db_fh}->quote($anvil_password).", 
    modified_date     = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    anvil_uuid        = ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.anvils 
(
    anvil_uuid, 
    anvil_owner_uuid, 
    anvil_smtp_uuid, 
    anvil_name, 
    anvil_description, 
    anvil_note, 
    anvil_password, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_owner_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_smtp_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_description).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'anvil_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{anvils}{modified_date}{$modified_date}{anvil_uuid}{$anvil_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.anvils 
(
    anvil_uuid, 
    anvil_owner_uuid, 
    anvil_smtp_uuid, 
    anvil_name, 
    anvil_description, 
    anvil_note, 
    anvil_password, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_owner_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_smtp_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_description).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($anvil_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen anvil_uuid?
			} # foreach my $id 
		} # foreach my $anvil_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the owners table. Like 'servers', this table is not bound to a host.
sub update_db_owners
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_owners" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'owners' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    owner_uuid,
    owner_name, 
    owner_note, 
    modified_date 
FROM 
    history.owners 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $owner_uuid    = $row->[0];
			my $owner_name    = $row->[1];
			my $owner_note    = $row->[2];
			my $modified_date = $row->[3];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "owner_uuid",    value1 => $owner_uuid, 
				name2 => "owner_name",    value2 => $owner_name, 
				name3 => "owner_note",    value3 => $owner_note, 
				name4 => "modified_date", value4 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid} = {
				owner_name	=>	$owner_name, 
				owner_note	=>	$owner_note, 
			};
			
			$an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid} = {
				owner_name	=>	$owner_name, 
				owner_note	=>	$owner_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{owners}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $owner_uuid (keys %{$an->data->{db_data}{unified}{owners}{modified_date}{$modified_date}{owner_uuid}})
		{
			my $owner_name = $an->data->{db_data}{unified}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid}{owner_name}; 
			my $owner_note = $an->data->{db_data}{unified}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid}{owner_note};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "owner_uuid", value1 => $owner_uuid, 
				name2 => "owner_name", value2 => $owner_name, 
				name3 => "owner_note", value3 => $owner_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'owner_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::owner::owner_uuid::${owner_uuid}::seen", value1 => $an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::owner::owner_uuid::${owner_uuid}::exists", value1 => $an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{owners}{owner_uuid}{$owner_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::owner::modified_date::${modified_date}::owner_uuid::${owner_uuid}", value1 => $an->data->{db_data}{$id}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.owners 
SET
    owner_name    = ".$an->data->{sys}{use_db_fh}->quote($owner_name).", 
    owner_note    = ".$an->data->{sys}{use_db_fh}->quote($owner_note).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    owner_uuid    = ".$an->data->{sys}{use_db_fh}->quote($owner_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.owners 
(
    owner_uuid, 
    owner_name, 
    owner_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($owner_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($owner_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($owner_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'owner_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{owners}{modified_date}{$modified_date}{owner_uuid}{$owner_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.owners 
(
    owner_uuid, 
    owner_name, 
    owner_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($owner_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($owner_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($owner_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen owner_uuid?
			} # foreach my $id 
		} # foreach my $owner_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update/sync the states table. Like 'servers', this table is not bound to a host.
sub update_db_states
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_states" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'states' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    state_uuid,
    state_name, 
    state_host_uuid, 
    state_note, 
    modified_date 
FROM 
    history.states 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $state_uuid      = $row->[0];
			my $state_name      = $row->[1];
			my $state_host_uuid = $row->[2];
			my $state_note      = $row->[3];
			my $modified_date   = $row->[4];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "state_uuid",      value1 => $state_uuid, 
				name2 => "state_name",      value2 => $state_name, 
				name3 => "state_host_uuid", value3 => $state_host_uuid, 
				name4 => "state_note",      value4 => $state_note, 
				name5 => "modified_date",   value5 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid} = {
				state_name	=>	$state_name, 
				state_host_uuid	=>	$state_host_uuid, 
				state_note	=>	$state_note, 
			};
			
			$an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid} = {
				state_name	=>	$state_name, 
				state_host_uuid	=>	$state_host_uuid, 
				state_note	=>	$state_note, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{states}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $state_uuid (keys %{$an->data->{db_data}{unified}{states}{modified_date}{$modified_date}{state_uuid}})
		{
			my $state_name      = $an->data->{db_data}{unified}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid}{state_name}; 
			my $state_host_uuid = $an->data->{db_data}{unified}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid}{state_host_uuid}; 
			my $state_note      = $an->data->{db_data}{unified}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid}{state_note};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "state_uuid",      value1 => $state_uuid, 
				name2 => "state_name",      value2 => $state_name, 
				name3 => "state_host_uuid", value3 => $state_name, 
				name4 => "state_note",      value4 => $state_note, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'state_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::state::state_uuid::${state_uuid}::seen", value1 => $an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::state::state_uuid::${state_uuid}::exists", value1 => $an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{states}{state_uuid}{$state_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::state::modified_date::${modified_date}::state_uuid::${state_uuid}", value1 => $an->data->{db_data}{$id}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.states 
SET
    state_name      = ".$an->data->{sys}{use_db_fh}->quote($state_name).", 
    state_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($state_host_uuid).", 
    state_note      = ".$an->data->{sys}{use_db_fh}->quote($state_note).", 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    state_uuid      = ".$an->data->{sys}{use_db_fh}->quote($state_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.states 
(
    state_uuid, 
    state_name, 
    state_host_uuid, 
    state_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($state_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($state_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($state_host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($state_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'state_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{states}{modified_date}{$modified_date}{state_uuid}{$state_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.states 
(
    state_uuid, 
    state_name, 
    state_host_uuid, 
    state_note, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($state_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($state_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($state_host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($state_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen state_uuid?
			} # foreach my $id 
		} # foreach my $state_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'ram_used' table.
sub update_db_ram_used
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_ram_used" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'ram_used' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    ram_used_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
FROM 
    history.ram_used 
WHERE 
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $ram_used_uuid  = $row->[0];
			my $ram_used_by    = $row->[1];
			my $ram_used_bytes = $row->[2];
			my $modified_date  = $row->[3];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "ram_used_uuid",  value1 => $ram_used_uuid, 
				name2 => "ram_used_by",    value2 => $ram_used_by, 
				name3 => "ram_used_bytes", value3 => $ram_used_bytes, 
				name4 => "modified_date",  value4 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid} = {
				ram_used_by	=>	$ram_used_by, 
				ram_used_bytes	=>	$ram_used_bytes,
			};
			$an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid} = {
				ram_used_by	=>	$ram_used_by, 
				ram_used_bytes	=>	$ram_used_bytes,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{ram_used}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $ram_used_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}})
		{
			my $ram_used_by    = $an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid}{ram_used_by};
			my $ram_used_bytes = $an->data->{db_data}{unified}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid}{ram_used_bytes};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "ram_used_uuid",  value1 => $ram_used_uuid, 
				name2 => "ram_used_by",    value2 => $ram_used_by, 
				name3 => "ram_used_bytes", value3 => $ram_used_bytes, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'ram_used_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::ram_used::ram_used_uuid::${ram_used_uuid}::seen", value1 => $an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::ram_used::ram_used_uuid::${ram_used_uuid}::exists", value1 => $an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{ram_used}{ram_used_uuid}{$ram_used_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::ram_used::modified_date::${modified_date}::ram_used_uuid::${ram_used_uuid}", value1 => $an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.ram_used
SET
    ram_used_by         = ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).", 
    ram_used_bytes      = ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ram_used_uuid       = ".$an->data->{sys}{use_db_fh}->quote($ram_used_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.ram_used
(
    ram_used_host_uuid, 
    ram_used_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'ram_used_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{ram_used}{modified_date}{$modified_date}{ram_used_uuid}{$ram_used_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.ram_used
(
    ram_used_host_uuid, 
    ram_used_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).", 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen ram_used_uuid?
			} # foreach my $id 
		} # foreach my $ram_used_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (
			@{$an->data->{db_resync}{$id}{public}{sql}}, 
			@{$an->data->{db_resync}{$id}{history}{sql}}
		);
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the special 'temperature' table.
sub update_db_temperature
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_temperature" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'temperature' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    temperature_uuid, 
    temperature_agent_name, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
FROM 
    history.temperature 
WHERE 
    temperature_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $temperature_uuid        = $row->[0];
			my $temperature_agent_name  = $row->[1]; 
			my $temperature_sensor_host = $row->[2]; 
			my $temperature_sensor_name = $row->[3];
			my $temperature_celsius     = $row->[4];
			my $temperature_state       = $row->[5];
			my $temperature_is          = $row->[6];
			my $modified_date           = $row->[7];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "temperature_uuid",        value1 => $temperature_uuid, 
				name2 => "temperature_agent_name",  value2 => $temperature_agent_name, 
				name3 => "temperature_sensor_host", value3 => $temperature_sensor_host, 
				name4 => "temperature_sensor_name", value4 => $temperature_sensor_name, 
				name5 => "temperature_celsius",     value5 => $temperature_celsius, 
				name6 => "temperature_state",       value6 => $temperature_state, 
				name7 => "temperature_is",          value7 => $temperature_is, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name} = {
				temperature_uuid	=>	$temperature_uuid, 
				temperature_sensor_host	=>	$temperature_sensor_host,
				temperature_sensor_name	=>	$temperature_sensor_name,
				temperature_celsius	=>	$temperature_celsius,
				temperature_state	=>	$temperature_state,
				temperature_is		=>	$temperature_is,
			};
			$an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen}     = 0;
			$an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name} = {
				temperature_uuid	=>	$temperature_uuid, 
				temperature_sensor_host	=>	$temperature_sensor_host,
				temperature_sensor_name	=>	$temperature_sensor_name,
				temperature_celsius	=>	$temperature_celsius,
				temperature_state	=>	$temperature_state,
				temperature_is		=>	$temperature_is,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{temperature}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $temperature_agent_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}})
		{
			my $temperature_uuid        = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_uuid};
			my $temperature_sensor_host = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_sensor_host};
			my $temperature_sensor_name = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_sensor_name};
			my $temperature_celsius     = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_celsius};
			my $temperature_state       = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_state};
			my $temperature_is          = $an->data->{db_data}{unified}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}{temperature_is};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "temperature_uuid",        value1 => $temperature_uuid, 
				name2 => "temperature_agent_name",  value2 => $temperature_agent_name, 
				name3 => "temperature_sensor_host", value3 => $temperature_sensor_host, 
				name4 => "temperature_sensor_name", value4 => $temperature_sensor_name, 
				name5 => "temperature_celsius",     value5 => $temperature_celsius, 
				name6 => "temperature_state",       value6 => $temperature_state, 
				name7 => "temperature_is",          value7 => $temperature_is, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'temperature_agent_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::temperature::temperature_agent_name::${temperature_agent_name}::seen", value1 => $an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::temperature::temperature_agent_name::${temperature_agent_name}::exists", value1 => $an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{temperature}{temperature_agent_name}{$temperature_agent_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::temperature::modified_date::${modified_date}::temperature_agent_name::${temperature_agent_name}", value1 => $an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.temperature
SET
    temperature_agent_name  = ".$an->data->{sys}{use_db_fh}->quote($temperature_agent_name).", 
    temperature_sensor_host = ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_host).", 
    temperature_sensor_name = ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_name).", 
    temperature_celsius     = ".$an->data->{sys}{use_db_fh}->quote($temperature_celsius).", 
    temperature_state       = ".$an->data->{sys}{use_db_fh}->quote($temperature_state).", 
    temperature_is          = ".$an->data->{sys}{use_db_fh}->quote($temperature_is).", 
    modified_date           = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    temperature_host_uuid   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    temperature_uuid        = ".$an->data->{sys}{use_db_fh}->quote($temperature_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.temperature
(
    temperature_uuid, 
    temperature_agent_name, 
    temperature_host_uuid, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($temperature_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_celsius).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_is).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'temperature_agent_name' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{temperature}{modified_date}{$modified_date}{temperature_agent_name}{$temperature_agent_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.temperature
(
    temperature_uuid, 
    temperature_agent_name, 
    temperature_host_uuid, 
    temperature_sensor_host, 
    temperature_sensor_name, 
    temperature_celsius, 
    temperature_state, 
    temperature_is, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($temperature_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_sensor_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_celsius).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($temperature_is).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen temperature_agent_name?
			} # foreach my $id 
		} # foreach my $temperature_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the special 'health' table.
sub update_db_health
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_health" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'health' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    health_uuid, 
    health_agent_name, 
    health_source_name,
    health_source_weight,
    modified_date 
FROM 
    history.health 
WHERE 
    health_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $health_uuid          = $row->[0];
			my $health_agent_name    = $row->[1]; 
			my $health_source_name   = $row->[2]; 
			my $health_source_weight = $row->[3];
			my $modified_date        = $row->[4];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "health_uuid",          value1 => $health_uuid, 
				name2 => "health_agent_name",    value2 => $health_agent_name, 
				name3 => "health_source_name",   value3 => $health_source_name, 
				name4 => "health_source_weight", value4 => $health_source_weight, 
				name5 => "modified_date",        value5 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name} = {
				health_uuid		=>	$health_uuid, 
				health_source_name	=>	$health_source_name,
				health_source_weight	=>	$health_source_weight,
			};
			$an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{seen}     = 0;
			$an->data->{db_data}{$id}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name} = {
				health_uuid		=>	$health_uuid, 
				health_source_name	=>	$health_source_name,
				health_source_weight	=>	$health_source_weight,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{health}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $health_agent_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{health}{modified_date}{$modified_date}{health_agent_name}})
		{
			my $health_uuid          = $an->data->{db_data}{unified}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name}{health_uuid};
			my $health_source_name   = $an->data->{db_data}{unified}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name}{health_source_name};
			my $health_source_weight = $an->data->{db_data}{unified}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name}{health_source_weight};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "health_uuid",          value1 => $health_uuid, 
				name2 => "health_agent_name",    value2 => $health_agent_name, 
				name3 => "health_source_name",   value3 => $health_source_name, 
				name4 => "health_source_weight", value4 => $health_source_weight, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'health_agent_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::health::health_agent_name::${health_agent_name}::seen", value1 => $an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::health::health_agent_name::${health_agent_name}::exists", value1 => $an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{health}{health_agent_name}{$health_agent_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::health::modified_date::${modified_date}::health_agent_name::${health_agent_name}", value1 => $an->data->{db_data}{$id}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.health
SET
    health_agent_name    = ".$an->data->{sys}{use_db_fh}->quote($health_agent_name).", 
    health_source_name   = ".$an->data->{sys}{use_db_fh}->quote($health_source_name).", 
    health_source_weight = ".$an->data->{sys}{use_db_fh}->quote($health_source_weight).", 
    modified_date        = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    health_host_uuid     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    health_uuid          = ".$an->data->{sys}{use_db_fh}->quote($health_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.health
(
    health_uuid, 
    health_agent_name, 
    health_host_uuid, 
    health_source_name, 
    health_source_weight, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($health_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_source_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_source_weight).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'health_agent_name' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{health}{modified_date}{$modified_date}{health_agent_name}{$health_agent_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.health
(
    health_uuid, 
    health_agent_name, 
    health_host_uuid, 
    health_source_name, 
    health_source_weight, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($health_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_source_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($health_source_weight).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen health_agent_name?
			} # foreach my $id 
		} # foreach my $health_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'dr_targets' table.
sub update_db_dr_targets
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_dr_targets" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'dr_target' table records
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    dr_target_uuid, 
    dr_target_name, 
    dr_target_note, 
    dr_target_address, 
    dr_target_password, 
    dr_target_tcp_port, 
    dr_target_use_cache, 
    dr_target_store, 
    dr_target_copies, 
    dr_target_bandwidth_limit, 
    modified_date 
FROM 
    history.dr_targets 
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $dr_target_uuid            =         $row->[0]; 
			my $dr_target_name            =         $row->[1];
			my $dr_target_note            = defined $row->[2] ? $row->[2] : ""; 
			my $dr_target_address         =         $row->[3]; 
			my $dr_target_password        = defined $row->[4] ? $row->[4] : ""; 
			my $dr_target_tcp_port        = defined $row->[5] ? $row->[5] : ""; 
			my $dr_target_use_cache       =         $row->[6]; 
			my $dr_target_store           =         $row->[7]; 
			my $dr_target_copies          =         $row->[8]; 
			my $dr_target_bandwidth_limit = defined $row->[9] ? $row->[9] : ""; 
			my $modified_date             =         $row->[10];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "dr_target_uuid",            value1  => $dr_target_uuid, 
				name2  => "dr_target_name",            value2  => $dr_target_name, 
				name3  => "dr_target_note",            value3  => $dr_target_note, 
				name4  => "dr_target_address",         value4  => $dr_target_address, 
				name5  => "dr_target_tcp_port",        value5  => $dr_target_tcp_port, 
				name6  => "dr_target_use_cache",       value6  => $dr_target_use_cache, 
				name7  => "dr_target_store",           value7  => $dr_target_store, 
				name8  => "dr_target_copies",          value8  => $dr_target_copies, 
				name9  => "dr_target_bandwidth_limit", value9  => $dr_target_bandwidth_limit, 
				name10 => "modified_date",             value10 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			$an->Log->entry({log_level => 4, message_key => "an_variables_0001", message_variables => {
				name1 => "dr_target_password", value1 => $dr_target_password, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid} = {
				dr_target_name		=>	$dr_target_name, 
				dr_target_note		=>	$dr_target_note, 
				dr_target_address	=>	$dr_target_address, 
				dr_target_password	=>	$dr_target_password, 
				dr_target_tcp_port	=>	$dr_target_tcp_port, 
				dr_target_use_cache	=>	$dr_target_use_cache, 
				dr_target_store		=>	$dr_target_store, 
				dr_target_copies	=>	$dr_target_copies, 
				dr_target_bandwidth_limit =>	$dr_target_bandwidth_limit, 
			};
			
			$an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid} = {
				dr_target_name		=>	$dr_target_name, 
				dr_target_note		=>	$dr_target_note, 
				dr_target_address	=>	$dr_target_address, 
				dr_target_password	=>	$dr_target_password, 
				dr_target_tcp_port	=>	$dr_target_tcp_port, 
				dr_target_use_cache	=>	$dr_target_use_cache, 
				dr_target_store		=>	$dr_target_store, 
				dr_target_copies	=>	$dr_target_copies, 
				dr_target_bandwidth_limit =>	$dr_target_bandwidth_limit, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{dr_targets}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $dr_target_uuid (keys %{$an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}})
		{
			my $dr_target_name            = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_name}; 
			my $dr_target_note            = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_note}; 
			my $dr_target_address         = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_address}; 
			my $dr_target_password        = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_password}; 
			my $dr_target_tcp_port        = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_tcp_port}; 
			my $dr_target_use_cache       = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_use_cache}; 
			my $dr_target_store           = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_store}; 
			my $dr_target_copies          = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_copies}; 
			my $dr_target_bandwidth_limit = $an->data->{db_data}{unified}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}{dr_target_bandwidth_limit}; 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "dr_target_uuid",            value1 => $dr_target_uuid, 
				name2 => "dr_target_name",            value2 => $dr_target_name, 
				name3 => "dr_target_note",            value3 => $dr_target_note, 
				name4 => "dr_target_address",         value4 => $dr_target_address, 
				name5 => "dr_target_tcp_port",        value5 => $dr_target_tcp_port, 
				name6 => "dr_target_use_cache",       value6 => $dr_target_use_cache, 
				name7 => "dr_target_store",           value7 => $dr_target_store, 
				name8 => "dr_target_copies",          value8 => $dr_target_copies, 
				name9 => "dr_target_bandwidth_limit", value9 => $dr_target_bandwidth_limit, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'dr_target_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::dr_target::dr_target_uuid::${dr_target_uuid}::seen", value1 => $an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::dr_target::dr_target_uuid::${dr_target_uuid}::exists", value1 => $an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{dr_targets}{dr_target_uuid}{$dr_target_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::dr_target::modified_date::${modified_date}::dr_target_uuid::${dr_target_uuid}", value1 => $an->data->{db_data}{$id}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.dr_targets 
SET
    dr_target_name            = ".$an->data->{sys}{use_db_fh}->quote($dr_target_name).", 
    dr_target_note            = ".$an->data->{sys}{use_db_fh}->quote($dr_target_note).", 
    dr_target_address         = ".$an->data->{sys}{use_db_fh}->quote($dr_target_address).", 
    dr_target_password        = ".$an->data->{sys}{use_db_fh}->quote($dr_target_password).", 
    dr_target_tcp_port        = ".$an->data->{sys}{use_db_fh}->quote($dr_target_tcp_port).", 
    dr_target_use_cache       = ".$an->data->{sys}{use_db_fh}->quote($dr_target_use_cache).", 
    dr_target_store           = ".$an->data->{sys}{use_db_fh}->quote($dr_target_store).", 
    dr_target_copies          = ".$an->data->{sys}{use_db_fh}->quote($dr_target_copies).", 
    dr_target_bandwidth_limit = ".$an->data->{sys}{use_db_fh}->quote($dr_target_bandwidth_limit).", 
    modified_date             = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    dr_target_uuid            = ".$an->data->{sys}{use_db_fh}->quote($dr_target_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.dr_targets 
(
    dr_target_uuid,
    dr_target_name, 
    dr_target_note, 
    dr_target_address, 
    dr_target_password, 
    dr_target_tcp_port, 
    dr_target_use_cache, 
    dr_target_store, 
    dr_target_copies, 
    dr_target_bandwidth_limit, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_address).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_tcp_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_use_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_store).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_copies).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_bandwidth_limit).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'dr_target_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{dr_targets}{modified_date}{$modified_date}{dr_target_uuid}{$dr_target_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.dr_targets 
(
    dr_target_uuid,
    dr_target_name, 
    dr_target_note, 
    dr_target_address, 
    dr_target_password, 
    dr_target_tcp_port, 
    dr_target_use_cache, 
    dr_target_store, 
    dr_target_copies, 
    dr_target_bandwidth_limit, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_address).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_password).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_tcp_port).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_use_cache).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_store).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_copies).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_target_bandwidth_limit).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen dr_target_uuid?
			} # foreach my $id 
		} # foreach my $dr_target_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'dr_jobs' table.
sub update_db_dr_jobs
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_dr_jobs" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'dr_job' table records
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    dr_job_uuid, 
    dr_job_dr_target_uuid, 
    dr_job_anvil_uuid, 
    dr_job_name, 
    dr_job_note, 
    dr_job_servers, 
    dr_job_auto_prune, 
    dr_job_schedule, 
    modified_date 
FROM 
    history.dr_jobs 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $dr_job_uuid           =         $row->[0]; 
			my $dr_job_dr_target_uuid =         $row->[1];
			my $dr_job_anvil_uuid     =         $row->[2];
			my $dr_job_name           =         $row->[3];
			my $dr_job_note           = defined $row->[4] ? $row->[4] : "";
			my $dr_job_servers        =         $row->[5];
			my $dr_job_auto_prune     =         $row->[6];
			my $dr_job_schedule       =         $row->[7];
			my $modified_date         =         $row->[8];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "dr_job_uuid",           value1 => $dr_job_uuid, 
				name2 => "dr_job_dr_target_uuid", value2 => $dr_job_dr_target_uuid, 
				name3 => "dr_job_anvil_uuid",     value3 => $dr_job_anvil_uuid, 
				name4 => "dr_job_name",           value4 => $dr_job_name, 
				name5 => "dr_job_note",           value5 => $dr_job_note, 
				name6 => "dr_job_servers",        value6 => $dr_job_servers, 
				name7 => "dr_job_auto_prune",     value7 => $dr_job_auto_prune, 
				name8 => "dr_job_schedule",       value8 => $dr_job_schedule, 
				name9 => "modified_date",         value9 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid} = {
				dr_job_dr_target_uuid	=>	$dr_job_dr_target_uuid, 
				dr_job_anvil_uuid	=>	$dr_job_anvil_uuid, 
				dr_job_name		=>	$dr_job_name, 
				dr_job_note		=>	$dr_job_note, 
				dr_job_servers		=>	$dr_job_servers, 
				dr_job_auto_prune	=>	$dr_job_auto_prune, 
				dr_job_schedule		=>	$dr_job_schedule, 
			};
			
			$an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid} = {
				dr_job_dr_target_uuid	=>	$dr_job_dr_target_uuid, 
				dr_job_anvil_uuid	=>	$dr_job_anvil_uuid, 
				dr_job_name		=>	$dr_job_name, 
				dr_job_note		=>	$dr_job_note, 
				dr_job_servers		=>	$dr_job_servers, 
				dr_job_auto_prune	=>	$dr_job_auto_prune, 
				dr_job_schedule		=>	$dr_job_schedule, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{dr_jobs}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $dr_job_uuid (keys %{$an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}})
		{
			my $dr_job_dr_target_uuid = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_dr_target_uuid}; 
			my $dr_job_anvil_uuid     = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_anvil_uuid}; 
			my $dr_job_name           = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_name}; 
			my $dr_job_note           = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_note}; 
			my $dr_job_servers        = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_servers}; 
			my $dr_job_auto_prune     = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_auto_prune}; 
			my $dr_job_schedule       = $an->data->{db_data}{unified}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}{dr_job_schedule}; 
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "dr_job_uuid",           value1 => $dr_job_uuid, 
				name2 => "dr_job_dr_target_uuid", value2 => $dr_job_dr_target_uuid, 
				name3 => "dr_job_anvil_uuid",     value3 => $dr_job_anvil_uuid, 
				name4 => "dr_job_name",           value4 => $dr_job_name, 
				name5 => "dr_job_note",           value5 => $dr_job_note, 
				name6 => "dr_job_servers",        value6 => $dr_job_servers, 
				name7 => "dr_job_auto_prune",     value7 => $dr_job_auto_prune, 
				name8 => "dr_job_schedule",       value8 => $dr_job_schedule, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'dr_job_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::dr_job::dr_job_uuid::${dr_job_uuid}::seen", value1 => $an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::dr_job::dr_job_uuid::${dr_job_uuid}::exists", value1 => $an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{dr_jobs}{dr_job_uuid}{$dr_job_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::dr_job::modified_date::${modified_date}::dr_job_uuid::${dr_job_uuid}", value1 => $an->data->{db_data}{$id}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.dr_jobs 
SET
    dr_job_dr_target_uuid = ".$an->data->{sys}{use_db_fh}->quote($dr_job_dr_target_uuid).", 
    dr_job_anvil_uuid     = ".$an->data->{sys}{use_db_fh}->quote($dr_job_anvil_uuid).", 
    dr_job_name           = ".$an->data->{sys}{use_db_fh}->quote($dr_job_name).", 
    dr_job_note           = ".$an->data->{sys}{use_db_fh}->quote($dr_job_note).", 
    dr_job_servers        = ".$an->data->{sys}{use_db_fh}->quote($dr_job_servers).", 
    dr_job_auto_prune     = ".$an->data->{sys}{use_db_fh}->quote($dr_job_auto_prune).", 
    dr_job_schedule       = ".$an->data->{sys}{use_db_fh}->quote($dr_job_schedule).", 
    modified_date         = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    dr_job_uuid           = ".$an->data->{sys}{use_db_fh}->quote($dr_job_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.dr_jobs 
(
    dr_job_uuid,
    dr_job_dr_target_uuid, 
    dr_job_anvil_uuid, 
    dr_job_name, 
    dr_job_note, 
    dr_job_servers, 
    dr_job_auto_prune, 
    dr_job_schedule, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_dr_target_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_servers).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_auto_prune).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_schedule).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'dr_job_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{dr_jobs}{modified_date}{$modified_date}{dr_job_uuid}{$dr_job_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.dr_jobs 
(
    dr_job_uuid,
    dr_job_dr_target_uuid, 
    dr_job_anvil_uuid, 
    dr_job_name, 
    dr_job_note, 
    dr_job_servers, 
    dr_job_auto_prune, 
    dr_job_schedule, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_dr_target_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_servers).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_auto_prune).", 
    ".$an->data->{sys}{use_db_fh}->quote($dr_job_schedule).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen dr_job_uuid?
			} # foreach my $id 
		} # foreach my $dr_job_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the 'server' table.
sub update_db_servers
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_server" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'server' table records
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    server_uuid,
    server_anvil_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_note, 
    server_definition, 
    server_host, 
    server_state, 
    server_migration_type, 
    server_pre_migration_script, 
    server_pre_migration_arguments, 
    server_post_migration_script, 
    server_post_migration_arguments, 
    modified_date 
FROM 
    history.servers 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $server_uuid                     =         $row->[0];
			my $server_anvil_uuid               =         $row->[1];
			my $server_name                     =         $row->[2];
			my $server_stop_reason              = defined $row->[3]  ? $row->[3]  : "";
			my $server_start_after              = defined $row->[4]  ? $row->[4]  : "NULL";
			my $server_start_delay              = defined $row->[5]  ? $row->[5]  : "NULL";
			my $server_note                     = defined $row->[6]  ? $row->[6]  : "";
			my $server_definition               = defined $row->[7]  ? $row->[7]  : "";
			my $server_host                     = defined $row->[8]  ? $row->[8]  : "";
			my $server_state                    = defined $row->[9]  ? $row->[9]  : "";
			my $server_migration_type           = defined $row->[10] ? $row->[10] : "";
			my $server_pre_migration_script     = defined $row->[11] ? $row->[11] : "";
			my $server_pre_migration_arguments  = defined $row->[12] ? $row->[12] : "";
			my $server_post_migration_script    = defined $row->[13] ? $row->[13] : "";
			my $server_post_migration_arguments = defined $row->[14] ? $row->[14] : "";
			my $modified_date                   =         $row->[15];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0016", message_variables => {
				name1  => "server_uuid",                     value1  => $server_uuid, 
				name2  => "server_anvil_uuid",               value2  => $server_anvil_uuid, 
				name3  => "server_name",                     value3  => $server_name, 
				name4  => "server_stop_reason",              value4  => $server_stop_reason, 
				name5  => "server_start_after",              value5  => $server_start_after, 
				name6  => "server_start_delay",              value6  => $server_start_delay, 
				name7  => "server_note",                     value7  => $server_note, 
				name8  => "server_definition",               value8  => $server_definition, 
				name9  => "server_host",                     value9  => $server_host, 
				name10 => "server_state",                    value10 => $server_state, 
				name11 => "server_migration_type",           value11 => $server_migration_type,
				name12 => "server_pre_migration_script",     value12 => $server_pre_migration_script,
				name13 => "server_pre_migration_arguments",  value13 => $server_pre_migration_arguments,
				name14 => "server_post_migration_script",    value14 => $server_post_migration_script,
				name15 => "server_post_migration_arguments", value15 => $server_post_migration_arguments,
				name16 => "modified_date",                   value16 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid} = {
				server_anvil_uuid		=>	$server_anvil_uuid, 
				server_name			=>	$server_name, 
				server_stop_reason		=>	$server_stop_reason, 
				server_start_after		=>	$server_start_after, 
				server_start_delay		=>	$server_start_delay, 
				server_note			=>	$server_note, 
				server_definition		=>	$server_definition, 
				server_host			=>	$server_host, 
				server_state			=>	$server_state, 
				server_migration_type		=>	$server_migration_type,
				server_pre_migration_script	=>	$server_pre_migration_script,
				server_pre_migration_arguments	=>	$server_pre_migration_arguments,
				server_post_migration_script	=>	$server_post_migration_script,
				server_post_migration_arguments	=>	$server_post_migration_arguments,
			};
			
			$an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid} = {
				server_anvil_uuid		=>	$server_anvil_uuid, 
				server_name			=>	$server_name, 
				server_stop_reason		=>	$server_stop_reason, 
				server_start_after		=>	$server_start_after, 
				server_start_delay		=>	$server_start_delay, 
				server_note			=>	$server_note, 
				server_definition		=>	$server_definition, 
				server_host			=>	$server_host, 
				server_state			=>	$server_state, 
				server_migration_type		=>	$server_migration_type,
				server_pre_migration_script	=>	$server_pre_migration_script,
				server_pre_migration_arguments	=>	$server_pre_migration_arguments,
				server_post_migration_script	=>	$server_post_migration_script,
				server_post_migration_arguments	=>	$server_post_migration_arguments,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{servers}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $server_uuid (keys %{$an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}})
		{
			my $server_anvil_uuid               = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_anvil_uuid}; 
			my $server_name                     = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_name}; 
			my $server_stop_reason              = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_stop_reason};
			my $server_start_after              = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_start_after};
			my $server_start_delay              = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_start_delay};
			my $server_note	                    = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_note};
			my $server_definition               = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_definition};
			my $server_host                     = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_host};
			my $server_state                    = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_state};
			my $server_migration_type           = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_migration_type};
			my $server_pre_migration_script     = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_pre_migration_script};
			my $server_pre_migration_arguments  = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_pre_migration_arguments};
			my $server_post_migration_script    = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_post_migration_script};
			my $server_post_migration_arguments = $an->data->{db_data}{unified}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}{server_post_migration_arguments};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0015", message_variables => {
				name1  => "server_uuid",                     value1  => $server_uuid, 
				name2  => "server_anvil_uuid",               value2  => $server_anvil_uuid, 
				name3  => "server_name",                     value3  => $server_name, 
				name4  => "server_stop_reason",              value4  => $server_stop_reason, 
				name5  => "server_start_after",              value5  => $server_start_after, 
				name6  => "server_start_delay",              value6  => $server_start_delay, 
				name7  => "server_note",                     value7  => $server_note, 
				name8  => "server_definition",               value8  => $server_definition, 
				name9  => "server_host",                     value9  => $server_host, 
				name10 => "server_state",                    value10 => $server_state, 
				name11 => "server_migration_type",           value11 => $server_migration_type,
				name12 => "server_pre_migration_script",     value12 => $server_pre_migration_script,
				name13 => "server_pre_migration_arguments",  value13 => $server_pre_migration_arguments,
				name14 => "server_post_migration_script",    value14 => $server_post_migration_script,
				name15 => "server_post_migration_arguments", value15 => $server_post_migration_arguments,
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'server_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::server::server_uuid::${server_uuid}::seen", value1 => $an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::server::server_uuid::${server_uuid}::exists", value1 => $an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{servers}{server_uuid}{$server_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::server::modified_date::${modified_date}::server_uuid::${server_uuid}", value1 => $an->data->{db_data}{$id}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.servers 
SET
    server_anvil_uuid               = ".$an->data->{sys}{use_db_fh}->quote($server_anvil_uuid).", 
    server_name                     = ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    server_stop_reason              = ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    server_start_after              = ".$an->data->{sys}{use_db_fh}->quote($server_start_after).", 
    server_start_delay              = ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    server_note                     = ".$an->data->{sys}{use_db_fh}->quote($server_note).", 
    server_definition               = ".$an->data->{sys}{use_db_fh}->quote($server_definition).", 
    server_host                     = ".$an->data->{sys}{use_db_fh}->quote($server_host).", 
    server_state                    = ".$an->data->{sys}{use_db_fh}->quote($server_state).", 
    server_migration_type           = ".$an->data->{sys}{use_db_fh}->quote($server_migration_type).", 
    server_pre_migration_script     = ".$an->data->{sys}{use_db_fh}->quote($server_pre_migration_script).", 
    server_pre_migration_arguments  = ".$an->data->{sys}{use_db_fh}->quote($server_pre_migration_arguments).", 
    server_post_migration_script    = ".$an->data->{sys}{use_db_fh}->quote($server_post_migration_script).", 
    server_post_migration_arguments = ".$an->data->{sys}{use_db_fh}->quote($server_post_migration_arguments).", 
    modified_date                   = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    server_uuid                     = ".$an->data->{sys}{use_db_fh}->quote($server_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.servers 
(
    server_uuid, 
    server_anvil_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_note, 
    server_definition, 
    server_host, 
    server_state, 
    server_migration_type, 
    server_pre_migration_script, 
    server_pre_migration_arguments, 
    server_post_migration_script, 
    server_post_migration_arguments, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_after).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_definition).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_migration_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_pre_migration_script).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_pre_migration_arguments).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_post_migration_script).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_post_migration_arguments).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'server_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{servers}{modified_date}{$modified_date}{server_uuid}{$server_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.servers 
(
    server_uuid, 
    server_anvil_uuid, 
    server_name, 
    server_stop_reason, 
    server_start_after, 
    server_start_delay, 
    server_note, 
    server_definition, 
    server_host, 
    server_state, 
    server_migration_type, 
    server_pre_migration_script, 
    server_pre_migration_arguments, 
    server_post_migration_script, 
    server_post_migration_arguments, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($server_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_anvil_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_after).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_start_delay).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_note).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_definition).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_host).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_state).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_migration_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_pre_migration_script).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_pre_migration_arguments).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_post_migration_script).", 
    ".$an->data->{sys}{use_db_fh}->quote($server_post_migration_arguments).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen server_uuid?
			} # foreach my $id 
		} # foreach my $server_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the special 'shared' table.
sub update_db_shared
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_shared" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'power' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		### NOTE: This table is special in that it does NOT link back to a specific host.
		# Read in the history schema
		my $query = "
SELECT 
    shared_uuid,
    shared_source_name,
    shared_record_locator,
    shared_name,
    shared_data,
    modified_date 
FROM 
    history.shared 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $shared_uuid           = $row->[0]; 
			my $shared_source_name    = $row->[1]; 
			my $shared_record_locator = $row->[2]; 
			my $shared_name           = $row->[3]; 
			my $shared_data           = $row->[4]; 
			my $modified_date         = $row->[5];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "shared_uuid",           value1 => $shared_uuid, 
				name2 => "shared_source_name",    value2 => $shared_source_name, 
				name3 => "shared_record_locator", value3 => $shared_record_locator, 
				name4 => "shared_name",           value4 => $shared_name, 
				name5 => "shared_data",           value5 => $shared_data, 
				name6 => "modified_date",         value6 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid} = {
				shared_source_name	=>	$shared_source_name, 
				shared_record_locator	=>	$shared_record_locator,
				shared_name		=>	$shared_name,
				shared_data		=>	$shared_data,
			};
			
			$an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid} = {
				shared_source_name	=>	$shared_source_name, 
				shared_record_locator	=>	$shared_record_locator, 
				shared_name		=>	$shared_name, 
				shared_data		=>	$shared_data, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{shared}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $shared_uuid (keys %{$an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}})
		{
			my $shared_uuid           = $an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid}{shared_uuid};
			my $shared_record_locator = $an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid}{shared_record_locator};
			my $shared_source_name    = $an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid}{shared_source_name};
			my $shared_name           = $an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid}{shared_name};
			my $shared_data           = $an->data->{db_data}{unified}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid}{shared_data};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "shared_uuid",           value1 => $shared_uuid, 
				name2 => "shared_record_locator", value2 => $shared_record_locator, 
				name3 => "shared_source_name",    value3 => $shared_source_name, 
				name4 => "shared_name",           value4 => $shared_name, 
				name5 => "shared_data",           value5 => $shared_data, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'shared_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::shared::shared_uuid::${shared_uuid}::seen", value1 => $an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::shared::shared_uuid::${shared_uuid}::exists", value1 => $an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{shared}{shared_uuid}{$shared_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::shared::modified_date::${modified_date}::shared_uuid::${shared_uuid}", value1 => $an->data->{db_data}{$id}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.shared
SET
    shared_source_name    = ".$an->data->{sys}{use_db_fh}->quote($shared_source_name).", 
    shared_record_locator = ".$an->data->{sys}{use_db_fh}->quote($shared_record_locator).", 
    shared_name           = ".$an->data->{sys}{use_db_fh}->quote($shared_name).", 
    shared_data           = ".$an->data->{sys}{use_db_fh}->quote($shared_data).", 
    modified_date         = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    shared_uuid = ".$an->data->{sys}{use_db_fh}->quote($shared_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.shared
(
    shared_uuid, 
    shared_source_name, 
    shared_record_locator, 
    shared_name, 
    shared_data, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($shared_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_source_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_record_locator).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_data).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'shared_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{shared}{modified_date}{$modified_date}{shared_uuid}{$shared_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.shared
(
    shared_uuid, 
    shared_source_name, 
    shared_record_locator, 
    shared_name, 
    shared_data, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($shared_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_source_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_record_locator).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($shared_data).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen shared_uuid?
			} # foreach my $id 
		} # foreach my $shared_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the special 'power' table.
sub update_db_power
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_power" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'power' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    power_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
FROM 
    history.power 
WHERE 
    power_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $power_uuid              = $row->[0]; 
			my $power_agent_name        = $row->[1]; 
			my $power_record_locator    = $row->[2]; 
			my $power_ups_name          = $row->[3]; 
			my $power_on_battery        = $row->[4] ? "TRUE" : "FALSE"; 
			my $power_seconds_left      = $row->[5]; 
			my $power_charge_percentage = $row->[6]; 
			my $modified_date           = $row->[7];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "power_uuid",              value1 => $power_uuid, 
				name2 => "power_agent_name",        value2 => $power_agent_name, 
				name3 => "power_record_locator",    value3 => $power_record_locator, 
				name4 => "power_ups_name",          value4 => $power_ups_name, 
				name5 => "power_on_battery",        value5 => $power_on_battery, 
				name6 => "power_seconds_left",      value6 => $power_seconds_left, 
				name7 => "power_charge_percentage", value7 => $power_charge_percentage, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name} = {
				power_uuid		=>	$power_uuid, 
				power_record_locator	=>	$power_record_locator,
				power_ups_name		=>	$power_ups_name,
				power_on_battery	=>	$power_on_battery,
				power_seconds_left	=>	$power_seconds_left,
				power_charge_percentage	=>	$power_charge_percentage,
			};
			
			$an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{'exists'} = 1;
			$an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen}     = 0;
			$an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name} = {
				power_uuid		=>	$power_uuid, 
				power_record_locator	=>	$power_record_locator,
				power_ups_name		=>	$power_ups_name,
				power_on_battery	=>	$power_on_battery,
				power_seconds_left	=>	$power_seconds_left,
				power_charge_percentage	=>	$power_charge_percentage,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{power}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $power_agent_name (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}})
		{
			my $power_uuid              = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_uuid};
			my $power_record_locator    = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_record_locator};
			my $power_ups_name          = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_ups_name};
			my $power_on_battery        = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_on_battery};
			my $power_seconds_left      = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_seconds_left};
			my $power_charge_percentage = $an->data->{db_data}{unified}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}{power_charge_percentage};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0008", message_variables => {
				name1 => "power_uuid",              value1 => $power_uuid, 
				name2 => "power_agent_name",        value2 => $power_agent_name, 
				name3 => "power_record_locator",    value3 => $power_record_locator, 
				name4 => "power_ups_name",          value4 => $power_ups_name, 
				name5 => "power_on_battery",        value5 => $power_on_battery, 
				name6 => "power_seconds_left",      value6 => $power_seconds_left, 
				name7 => "power_charge_percentage", value7 => $power_charge_percentage, 
				name8 => "modified_date",           value8 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'power_agent_name' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::power::power_agent_name::${power_agent_name}::seen", value1 => $an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::power::power_agent_name::${power_agent_name}::exists", value1 => $an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{power}{power_agent_name}{$power_agent_name}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::power::modified_date::${modified_date}::power_agent_name::${power_agent_name}", value1 => $an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.power
SET
    power_ups_name          = ".$an->data->{sys}{use_db_fh}->quote($power_ups_name).", 
    power_on_battery        = ".$an->data->{sys}{use_db_fh}->quote($power_on_battery).", 
    power_seconds_left      = ".$an->data->{sys}{use_db_fh}->quote($power_seconds_left).", 
    power_charge_percentage = ".$an->data->{sys}{use_db_fh}->quote($power_charge_percentage).", 
    power_agent_name        = ".$an->data->{sys}{use_db_fh}->quote($power_agent_name).", 
    power_record_locator    = ".$an->data->{sys}{use_db_fh}->quote($power_record_locator).", 
    modified_date           = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    power_host_uuid         = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    power_uuid              = ".$an->data->{sys}{use_db_fh}->quote($power_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.power
(
    power_uuid, 
    power_host_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($power_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_record_locator).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_ups_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_on_battery).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_seconds_left).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_charge_percentage).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'power_agent_name' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{power}{modified_date}{$modified_date}{power_agent_name}{$power_agent_name})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.power
(
    power_uuid, 
    power_host_uuid, 
    power_agent_name, 
    power_record_locator, 
    power_ups_name, 
    power_on_battery, 
    power_seconds_left, 
    power_charge_percentage, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($power_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_record_locator).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_ups_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_on_battery).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_seconds_left).", 
    ".$an->data->{sys}{use_db_fh}->quote($power_charge_percentage).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen power_agent_name?
			} # foreach my $id 
		} # foreach my $power_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the alerts table.
sub update_db_alerts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_alerts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: Alerts get deleted once they're sent. So we don't care about the public schema here, only
	###       the history schema.
	
	# Now read in all the 'alerts' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# This will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    alert_uuid, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    alert_sort, 
    alert_header, 
    modified_date 
FROM 
    history.alerts 
WHERE 
    alert_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $alert_uuid              = $row->[0]; 
			my $alert_agent_name        = $row->[1]; 
			my $alert_level             = $row->[2]; 
			my $alert_title_key         = $row->[3]; 
			my $alert_title_variables   = $row->[4]; 
			my $alert_message_key       = $row->[5]; 
			my $alert_message_variables = $row->[6]; 
			my $alert_sort              = $row->[7]; 
			my $alert_header            = $row->[8];
			my $modified_date           = $row->[9];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0010", message_variables => {
				name1  => "alert_uuid",              value1  => $alert_uuid, 
				name2  => "alert_agent_name",        value2  => $alert_agent_name, 
				name3  => "alert_level",             value3  => $alert_level, 
				name4  => "alert_title_key",         value4  => $alert_title_key, 
				name5  => "alert_title_variables",   value5  => $alert_title_variables, 
				name6  => "alert_message_key",       value6  => $alert_message_key, 
				name7  => "alert_message_variables", value7  => $alert_message_variables, 
				name8  => "alert_sort",              value8  => $alert_sort, 
				name9  => "alert_header",            value9  => $alert_header, 
				name10 => "modified_date",           value10 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid} = {
				alert_agent_name	=>	$alert_agent_name, 
				alert_level		=>	$alert_level, 
				alert_title_key		=>	$alert_title_key, 
				alert_title_variables	=>	$alert_title_variables, 
				alert_message_key	=>	$alert_message_key, 
				alert_message_variables	=>	$alert_message_variables, 
				alert_sort		=>	$alert_sort, 
				alert_header		=>	$alert_header, 
			};
			$an->data->{db_data}{$id}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid} = {
				alert_agent_name	=>	$alert_agent_name, 
				alert_level		=>	$alert_level, 
				alert_title_key		=>	$alert_title_key, 
				alert_title_variables	=>	$alert_title_variables, 
				alert_message_key	=>	$alert_message_key, 
				alert_message_variables	=>	$alert_message_variables, 
				alert_sort		=>	$alert_sort, 
				alert_header		=>	$alert_header, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{alerts}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_uuid (keys %{$an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}})
		{
			my $alert_agent_name        = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_agent_name};
			my $alert_level             = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_level};
			my $alert_title_key         = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_title_key};
			my $alert_title_variables   = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_title_variables};
			my $alert_message_key       = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_message_key};
			my $alert_message_variables = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_message_variables};
			my $alert_sort              = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_sort};
			my $alert_header            = $an->data->{db_data}{unified}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}{alert_header};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0009", message_variables => {
				name1 => "alert_uuid",              value1 => $alert_uuid, 
				name2 => "alert_agent_name",        value2 => $alert_agent_name, 
				name3 => "alert_level",             value3 => $alert_level, 
				name4 => "alert_title_key",         value4 => $alert_title_key, 
				name5 => "alert_title_variables",   value5 => $alert_title_variables, 
				name6 => "alert_message_key",       value6 => $alert_message_key, 
				name7 => "alert_message_variables", value7 => $alert_message_variables, 
				name8 => "alert_sort",              value8 => $alert_sort, 
				name9 => "alert_header",            value9 => $alert_header, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# If this is the first record, then a little consideration is needed... One 
				# of three things can happen;
				# 1. The record doesn't exist at all, INSERT
				# 2. The record exists, but is old. UPDATE
				# 3. The record exists and is up to date, ignore it.
				# Case 1 & 2 go to the public schema.
				# 
				# All other records are written directly to the history schema as needed.
				my $this_schema = "history";
				$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
					name1 => "id",                                                                                 value1 => $id,
					name2 => "this_schema",                                                                        value2 => $this_schema, 
					name3 => "db_data::${id}::alerts::modified_date::${modified_date}::alert_uuid::${alert_uuid}", value3 => $an->data->{db_data}{$id}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid}
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{alerts}{modified_date}{$modified_date}{alert_uuid}{$alert_uuid})
				{
					my $query = "
INSERT INTO 
    history.alerts
(
    alert_uuid, 
    alert_agent_name, 
    alert_host_uuid, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    alert_sort, 
    alert_header, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($alert_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_title_key).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_title_variables).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_message_key).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_message_variables).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_sort).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_header).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
					# Now record the query in the array
					$query =~ s/'NULL'/NULL/g;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
						name1 => "id",    value1 => $id, 
						name2 => "query", value2 => $query
					}, file => $THIS_FILE, line => __LINE__});
					push @{$an->data->{db_resync}{$id}{sql}}, $query;
				}
			} # foreach my $id 
		} # foreach my $alert_agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update the agents table.
sub update_db_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_agents" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Now read in all the 'agents' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    agent_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
FROM 
    history.agents
WHERE
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "results", value1 => $results
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $agent_uuid      = $row->[0];
			my $agent_name      = $row->[1];
			my $agent_exit_code = $row->[2];
			my $agent_runtime   = $row->[3];
			my $modified_date   = $row->[4];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "agent_uuid",      value1 => $agent_uuid, 
				name2 => "agent_name",      value2 => $agent_name, 
				name3 => "agent_exit_code", value3 => $agent_exit_code, 
				name4 => "agent_runtime",   value4 => $agent_runtime, 
				name5 => "modified_date",   value5 => $modified_date
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid} = {
				agent_name	=>	$agent_name, 
				agent_exit_code	=>	$agent_exit_code,
				agent_runtime	=>	$agent_runtime,
			};
			$an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid} = {
				agent_name	=>	$agent_name, 
				agent_exit_code	=>	$agent_exit_code,
				agent_runtime	=>	$agent_runtime,
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{agents}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $agent_uuid (sort {$a cmp $b} keys %{$an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_uuid}})
		{
			my $agent_name      = $an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid}{agent_name};
			my $agent_exit_code = $an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid}{agent_exit_code};
			my $agent_runtime   = $an->data->{db_data}{unified}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid}{agent_runtime};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
				name1 => "agent_uuid",      value1 => $agent_uuid, 
				name2 => "agent_name",      value2 => $agent_name, 
				name3 => "agent_exit_code", value3 => $agent_exit_code, 
				name4 => "agent_runtime",   value4 => $agent_runtime, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'agent_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::agents::agent_name::${agent_name}::seen", value1 => $an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::agents::agent_name::${agent_name}::exists", value1 => $an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{agents}{agent_uuid}{$agent_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::agents::modified_date::${modified_date}::agent_name::${agent_name}", value1 => $an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.agents
SET
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    agent_name      = ".$an->data->{sys}{use_db_fh}->quote($agent_name).", 
    agent_exit_code = ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    agent_runtime   = ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    agent_uuid      = ".$an->data->{sys}{use_db_fh}->quote($agent_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.agents
(
    agent_uuid, 
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($agent_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'agent_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{agents}{modified_date}{$modified_date}{agent_uuid}{$agent_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.agents
(
    agent_uuid, 
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($agent_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen agent_name?
			} # foreach my $id 
		} # foreach my $agent_name ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# Update (and commit) the hosts table
sub update_db_hosts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "update_db_hosts" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### NOTE: Everything depends on 'hosts' -> 'host_uuid', so we need to update *AND* commit the changes
	###       before we leave this function.
	
	# Now read in all the 'hosts' table records that came from us.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# These will store the INSERTs for this DB, if needed.
		$an->data->{db_resync}{$id}{sql}          = [];
		$an->data->{db_resync}{$id}{public}{sql}  = [];
		$an->data->{db_resync}{$id}{history}{sql} = [];
		
		# Read in the history schema
		my $query = "
SELECT 
    host_uuid, 
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    host_health, 
    modified_date 
FROM 
    history.hosts
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "id",    value1 => $id, 
			name2 => "query", value2 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the query against the source DB and loop through the results.
		my $results = $an->DB->do_db_query({id => $id, query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "results", value1 => $results, 
			name2 => "count",   value2 => $count,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $host_uuid           = $row->[0];
			my $host_name           = $row->[1];
			my $host_type           = $row->[2];
			my $host_emergency_stop = $row->[3] ? "TRUE"    : "FALSE";
			my $host_stop_reason    = $row->[4] ? $row->[4] : "";
			my $host_health         = $row->[5] ? $row->[5] : "";
			my $modified_date       = $row->[6];
			$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
				name1 => "host_uuid",           value1 => $host_uuid, 
				name2 => "host_name",           value2 => $host_name, 
				name3 => "host_type",           value3 => $host_type, 
				name4 => "host_emergency_stop", value4 => $host_emergency_stop,
				name5 => "host_stop_reason",    value5 => $host_stop_reason, 
				name6 => "host_health",         value6 => $host_health, 
				name7 => "modified_date",       value7 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record this in the unified and local hashes.
			$an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid} = {
				host_name		=>	$host_name, 
				host_type		=>	$host_type, 
				host_emergency_stop	=>	$host_emergency_stop, 
				host_stop_reason	=>	$host_stop_reason, 
				host_health		=>	$host_health, 
			};
			
			$an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{'exists'} = 1;
			$an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen}     = 0;
			$an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid} = {
				host_name		=>	$host_name, 
				host_type		=>	$host_type,
				host_emergency_stop	=>	$host_emergency_stop,
				host_stop_reason	=>	$host_stop_reason,
				host_health		=>	$host_health, 
			};
		}
	}
	
	### NOTE: Sort '$b cmp $a' on the modified date.
	# Now, loop through each record from the unified table and see if it 
	# needs to be added to any DBs.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "db_data::unified::hosts::modified_date", value1 => $an->data->{db_data}{unified}{hosts}{modified_date},
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $modified_date (sort {$b cmp $a} keys %{$an->data->{db_data}{unified}{hosts}{modified_date}})
	{
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date,
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $host_uuid (keys %{$an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}})
		{
			my $host_name           = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_name};
			my $host_type           = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_type};
			my $host_emergency_stop = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_emergency_stop};
			my $host_stop_reason    = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_stop_reason};
			my $host_health         = $an->data->{db_data}{unified}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}{host_health};
			$an->Log->entry({log_level => 3, message_key => "an_variables_0006", message_variables => {
				name1 => "host_uuid",           value1 => $host_uuid, 
				name2 => "host_name",           value2 => $host_name, 
				name3 => "host_type",           value3 => $host_type, 
				name4 => "host_emergency_stop", value4 => $host_emergency_stop,
				name5 => "host_stop_reason",    value5 => $host_stop_reason, 
				name6 => "host_health",         value6 => $host_health, 
			}, file => $THIS_FILE, line => __LINE__});
			foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
			{
				# For each 'host_uuid' we see;
				# - Check if we've *seen* it before
				#   |- If not; See if it *exists* in the public schema yet.
				#   |  |- If so, check to see if the entry in the public schema is up to date.
				#   |  |  \- If not, _UPDATE_ public schema.
				#   |  \- If not, do an _INSERT_ into public schema.
				#   \- If we have, see if it exists at the current timestamp.
				#      \- If not, _INSERT_ it into history schema.
				#
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "db_data::${id}::hosts::host_uuid::${host_uuid}::seen", value1 => $an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen}, 
				}, file => $THIS_FILE, line => __LINE__});
				if (not $an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen})
				{
					# Mark this record as now having been seen.
					$an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{seen} = 1;
					
					# Never seen it. Check if it exists.
					$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
						name1 => "db_data::${id}::hosts::host_uuid::${host_uuid}::exists", value1 => $an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{'exists'}, 
					}, file => $THIS_FILE, line => __LINE__});
					if ($an->data->{db_data}{$id}{hosts}{host_uuid}{$host_uuid}{'exists'})
					{
						# It exists, but does it exist at this time stamp?
						$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
							name1  => "db_data::${id}::hosts::modified_date::${modified_date}::host_uuid::${host_uuid}", value1 => $an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid}, 
						}, file => $THIS_FILE, line => __LINE__});
						if (not $an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid})
						{
							# No, so UPDATE it.
							my $query = "
UPDATE 
    public.hosts 
SET
    host_name           = ".$an->data->{sys}{use_db_fh}->quote($host_name).", 
    host_type           = ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    host_emergency_stop = ".$an->data->{sys}{use_db_fh}->quote($host_emergency_stop).", 
    host_stop_reason    = ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    host_health         = ".$an->data->{sys}{use_db_fh}->quote($host_health).", 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    host_uuid           = ".$an->data->{sys}{use_db_fh}->quote($host_uuid)." 
;";
							# Now record the query in the array
							$query =~ s/'NULL'/NULL/g;
							$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
								name1 => "id",    value1 => $id, 
								name2 => "query", value2 => $query
							}, file => $THIS_FILE, line => __LINE__});
							push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
						}
					}
					else
					{
						# It doesn't exist, so INSERT it.
						my $query = "
INSERT INTO 
    public.hosts
(
    host_uuid,  
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    host_health, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_emergency_stop).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_health).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{public}{sql}}, $query;
					}
				}
				else
				{
					# We've seen this 'host_uuid' before, so it is just a question
					# of whether the entry for the current timestamp exists in the 
					# history schema.
					if (not $an->data->{db_data}{$id}{hosts}{modified_date}{$modified_date}{host_uuid}{$host_uuid})
					{
						# It doesn't, INSERT it.
						my $query = "
INSERT INTO 
    history.hosts
(
    host_uuid,  
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_stop_reason, 
    host_health, 
    modified_date 
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($host_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_name).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_emergency_stop).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_stop_reason).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_health).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);";
						# Now record the query in the array
						$query =~ s/'NULL'/NULL/g;
						$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
							name1 => "id",    value1 => $id, 
							name2 => "query", value2 => $query
						}, file => $THIS_FILE, line => __LINE__});
						push @{$an->data->{db_resync}{$id}{history}{sql}}, $query;
					} # Exist in history at timestamp?
				} # Seen host_uuid?
			} # foreach my $id 
		} # foreach my $host_uuid ...
	} # foreach $modified_date ...
	
	# Free up memory by deleting the DB data from the main hash.
	delete $an->data->{db_data};
	
	# Do the INSERTs now and then release the memory.
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{dbh}})
	{
		# Merge the queries with public schema queries being first.
		@{$an->data->{db_resync}{$id}{sql}} = (@{$an->data->{db_resync}{$id}{public}{sql}}, @{$an->data->{db_resync}{$id}{history}{sql}});
		if (@{$an->data->{db_resync}{$id}{sql}} > 0)
		{
			$an->DB->do_db_write({id => $id, query => $an->data->{db_resync}{$id}{sql}, source => $THIS_FILE, line => __LINE__});
			delete $an->data->{db_resync}{$id}{sql};
		}
	}
	
	return(0);
}

# This checks to see if the host name has changed.
sub check_hostname_for_changes
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_hostname_for_changes" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# What was the last recorded host name?
	my $query = "SELECT host_name FROM hosts WHERE host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $host_name = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "host_name", value1 => $host_name, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Has it changed?
	if ($host_name ne $an->hostname)
	{
		# Yup, updated.
		my $query = "
UPDATE 
    hosts
SET 
    host_name     = ".$an->data->{sys}{use_db_fh}->quote($an->hostname).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    host_uuid     = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query, 
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This checks to see if this node is in each database and, if not, adds it. It also will update the hostname
# if it has changed.
sub add_hostname_to_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "add_hostname_to_databases" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Check for a hostname using our UUID.
	my $query = "SELECT host_name FROM hosts WHERE host_uuid=".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).";";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	#              The actual query -----------------.                                                .------- Row 0
	#                                                |                                                |    .-- Columns 0
	my $host_name = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "host_name", value1 => $host_name
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do I need to add or update?
	if (not $host_name)
	{
		### TODO: For now, we determine if this host is a node or dashboard by analyzing it is 
		###       hostname. We will make this smarter later.
		my $host_name = $an->hostname;
		my $host_type = $an->Get->what_am_i();
		$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
			name1 => "sys::hostname", value1 => $an->hostname, 
			name2 => "host_name",     value2 => $host_name, 
			name3 => "host_type",     value3 => $host_type
		}, file => $THIS_FILE, line => __LINE__});
		$an->data->{scancore}{i_am_a} = $host_type;
		
		# Add this host to the DB
		my $query = "
INSERT INTO 
    hosts 
(
    host_uuid, 
    host_name, 
    host_type, 
    host_emergency_stop, 
    host_health, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_name).",
    ".$an->data->{sys}{use_db_fh}->quote($host_type).",
    FALSE, 
    NULL, 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
		$query =~ s/'NULL'/NULL/g;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# A record exists. Check to see if the 'host_emergency_stop' has been set and clear it, if so.
		my $query = "
SELECT 
    host_emergency_stop, 
    host_stop_reason, 
    round(extract(epoch from modified_date)) 
FROM 
    hosts 
WHERE 
    host_name = ".$an->data->{sys}{use_db_fh}->quote($an->hostname)."
;";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1  => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		my $results = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__});
		my $count   = @{$results};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "results", value1 => $results, 
			name2 => "count",   value2 => $count
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $row (@{$results})
		{
			my $host_emergency_stop =         $row->[0];
			my $host_stop_reason    = defined $row->[1] ? $row->[1] : "";
			my $unix_modified_date  =         $row->[2];
			my $current_time        = time;
			my $difference          = $current_time - $unix_modified_date;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0005", message_variables => {
				name1 => "host_emergency_stop", value1 => $host_emergency_stop, 
				name2 => "host_stop_reason",    value2 => $host_stop_reason, 
				name3 => "unix_modified_date",  value3 => $unix_modified_date, 
				name4 => "current_time",        value4 => $current_time, 
				name5 => "difference",          value5 => $difference, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# If the stop_reason is 'clean' but it is less than five minutes old, don't clear it
			# because the node is probably still shutting down.
			if (($host_stop_reason eq "clean") && ($difference) && ($difference < 300))
			{
				# Not old enough.
				$an->Log->entry({log_level => 2, message_key => "scancore_log_0091", message_variables => { seconds => $difference }, file => $THIS_FILE, line => __LINE__});
				last;
			}
			
			if (($host_emergency_stop) or ($host_stop_reason))
			{
				# Clear the stop data.
				my $query = "
UPDATE 
    hosts
SET 
    host_emergency_stop = FALSE, 
    host_stop_reason    = NULL, 
    modified_date       = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE
    host_uuid           = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "query", value1 => $query, 
				}, file => $THIS_FILE, line => __LINE__});
				$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
			}
		}
	}
	$an->data->{sys}{host_is_in_db} = 1;
	
	return(0);
}

# This loops through the agents directory 
sub call_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "call_agents" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through the agents directory and call each agent. Record how long it takes and note the exit 
	# code, then record the run-data in the database.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::agents_directory", value1 => $an->data->{path}{agents_directory}
	}, file => $THIS_FILE, line => __LINE__});
	scan_directory($an, $an->data->{path}{agents_directory});
	
	# Now loop through the agents I found and try calling them.
	foreach my $agent (sort {$a cmp $b} @{$an->data->{sys}{agents}})
	{
		### TODO: Put a time limit on these...
		my $start_time =  time;
		my $say_agent  = ($agent =~ /.*\/(.*)$/)[0];
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0015", message_variables => { agent => "$say_agent" }, file => $THIS_FILE, line => __LINE__});
		
		# I call these sequentially to minimize the load on the host.
		my $agent_rc   = "9999";
		my $shell_call = "$agent; ".$an->data->{path}{echo}." rc:\$?";
		if ($an->data->{scancore}{user_set_log_level})
		{
			$shell_call = "$agent ".$an->data->{scancore}{user_set_log_level}."; echo rc:\$?";
		}
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_message_0070", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => "$line"
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /rc:(\d+)/)
			{
				$agent_rc = $1;
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "agent_rc", value1 => "$agent_rc"
				}, file => $THIS_FILE, line => __LINE__});
			}
			else
			{
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => "$line"
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		
		# Note how long it took.
		my $runtime   = time - $start_time;
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0020", message_variables => { 
			agent   => $say_agent, 
			runtime => $runtime 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record this run in the DB.
		my $query = "
SELECT 
    agent_uuid 
FROM 
    agents 
WHERE 
    agent_name      = ".$an->data->{sys}{use_db_fh}->quote($say_agent)." 
AND
    agent_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1  => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		my $agent_uuid = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];	# (->[row]->[column])
		   $agent_uuid = "" if not defined $agent_uuid;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "agent_uuid", value1 => $agent_uuid, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not $agent_uuid)
		{
			# Add this agent to the DB
			my $agent_uuid = $an->Get->uuid();
			my $query      = "
INSERT INTO 
    agents 
(
    agent_uuid, 
    agent_host_uuid, 
    agent_name, 
    agent_exit_code, 
    agent_runtime,
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($agent_uuid).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($say_agent).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_rc).", 
    ".$an->data->{sys}{use_db_fh}->quote($runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1  => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
			$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# It exists, update it.
			my $query = "
UPDATE 
    agents 
SET
    agent_exit_code = ".$an->data->{sys}{use_db_fh}->quote($agent_rc).", 
    agent_runtime   = ".$an->data->{sys}{use_db_fh}->quote($runtime).", 
    modified_date   = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    agent_uuid      = ".$an->data->{sys}{use_db_fh}->quote($agent_uuid)."
;";
			$query =~ s/'NULL'/NULL/g;
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1  => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
			$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
		}
	}
	
	# Clear the agent list.
	$an->data->{sys}{agents} = [];
	
	return(0);
}

# This checks the amount RAM used by ScanCore and exits if it exceeds a scancore::maximum_ram bytes. It looks
# for any process with our name and sums the RAM used.
sub check_ram_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "check_ram_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in how much RAM we're using.
	my $used_ram = $an->Get->ram_used_by_program({program_name => $an->data->{sys}{program_name}});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
		name1 => "used_ram",              value1 => "$used_ram", 
		name2 => "scancore::maximum_ram", value2 => $an->data->{scancore}{maximum_ram}
	}, file => $THIS_FILE, line => __LINE__});
	
	# Exit if I failed to read the amount of RAM in use.
	if (not $used_ram)
	{
		$an->Alert->warning({message_key => "scancore_warning_0023", message_variables => { program_name => $an->data->{sys}{program_name} }, quiet => 1, file => $THIS_FILE, line => __LINE__});
		$an->data->{sys}{'exit'} = 1;
	}
	
	# Records the RAM used.
	my $query = "
SELECT 
    ram_used_bytes 
FROM 
    ram_used 
WHERE 
    ram_used_by        = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name})." 
AND
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $ram_used_bytes = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];	# (->[row]->[column])
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "ram_used_bytes", value1 => $ram_used_bytes
	}, file => $THIS_FILE, line => __LINE__});
	if (not $ram_used_bytes)
	{
		# Add this agent to the DB
		my $query = "
INSERT INTO 
    ram_used 
(
    ram_used_host_uuid, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid}).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name}).", 
    ".$an->data->{sys}{use_db_fh}->quote($used_ram).", 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
);
";
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
	}
	elsif ($ram_used_bytes ne $used_ram)
	{
		# It exists and the value has changed.
		my $query = "
UPDATE 
    ram_used 
SET
    ram_used_bytes     = ".$an->data->{sys}{use_db_fh}->quote($used_ram).", 
    modified_date      = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{db_timestamp})."
WHERE 
    ram_used_by        = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name})." 
AND
    ram_used_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})."
;";
		$an->DB->do_db_write({query => $query, source => $THIS_FILE, line => __LINE__});
	}
	else
	{
		# The amount of RAM used is unchanged.
		#print __LINE__."; The amount of RAM used by ".$an->data->{sys}{program_name}." is unchanged.\n";
	}
	
	if ($used_ram > $an->data->{scancore}{maximum_ram})
	{
		# Much, too much, much music!
		# err, too much RAM...
		$an->Alert->error({title_key => "an_0003", message_key => "scancore_error_0013", message_variables => { 
			used_ram    => $an->Readable->bytes_to_hr({'bytes' => $used_ram}), 
			maximum_ram => $an->Readable->bytes_to_hr({'bytes' => $an->data->{scancore}{maximum_ram}})
		}, code => 5, file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This will read the 'results table' and looks for bad conditions, eventually.
sub analyze_results
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "analyze_results" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in the 'alerts' table, using $an->data->{sys}{scan_time} as the time to select after. 
	
	return(0);
}

# This digs through a directory looking for scan agents to call. It will dive
# into subdiretories as well. Anything it finds, it will record the path to
# sys::agents.
sub scan_directory
{
	my ($an, $directory) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory" }, message_key => "an_variables_0001", message_variables => { 
		name1 => "directory", value1 => "$directory" 
	}, file => $THIS_FILE, line => __LINE__});
	
	local(*DIRECTORY);
	opendir(DIRECTORY, $an->data->{path}{agents_directory});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		my $full_path = "$directory/$file";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "full_path", value1 => $full_path, 
		}, file => $THIS_FILE, line => __LINE__});
		if (-d $full_path)
		{
			# This is a directory, dive into it.
			scan_directory($an, $full_path);
		}
		elsif (-x $full_path)
		{
			# Now I only want to know if the file starts with 'scan-'
			next if $file !~ /^scan-/;
			
			# If I am still alive, I am looking at a scan agent!
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0014", message_variables => { agent => "$full_path" }, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{agents}}, $full_path;
		}
	}
	
	return(0);
}

# This causes the script to exit if another instance is already running.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $my_pid = $$;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "my_pid", value1 => $my_pid,
	}, file => $THIS_FILE, line => __LINE__});
	
	# See if there is a pending lock. If there is, we won't do anything because the other instance might
	# be waiting on the lock. We don't worry about lock age because any other node or dashboard will reap
	# the lock if it gets too old.
	my $lock = $an->DB->locking({check => 1});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "lock", value1 => $lock,
	}, file => $THIS_FILE, line => __LINE__});
	
	my $already_running = 0;
	my $other_pids      = [];
	my $shell_call      = $an->data->{path}{ps}." aux | ".$an->data->{path}{'grep'}." -v grep | ".$an->data->{path}{'grep'}." -v tail | ".$an->data->{path}{'grep'}." -v '\/bin\/sh' | ".$an->data->{path}{'grep'}." $THIS_FILE";
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_message_0070", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
	while (<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line,
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($line =~ /^.*?\s+(\d+)\s/)
		{
			my $pid = $1;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "pid", value1 => $pid,
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($pid ne $my_pid)
			{
				# Another copy is running.
				$already_running = 1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "already_running", value1 => $already_running,
				}, file => $THIS_FILE, line => __LINE__});
				
				push @{$other_pids}, $pid;
			}
		}
	}
	close $file_handle;
	
	# If another copy is running, and there is no lock, see when it last finished a scan. If it was more
	# than five minutes ago, kill it because it might be hung.
	if (($already_running) && (not $lock))
	{
		my $query = "
SELECT 
    round(extract(epoch from modified_date)) 
FROM 
    updated 
WHERE 
    updated_host_uuid = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{host_uuid})." 
AND 
    updated_by        = ".$an->data->{sys}{use_db_fh}->quote($THIS_FILE).";
";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1  => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		
		my $last_updated = $an->DB->do_db_query({query => $query, source => $THIS_FILE, line => __LINE__})->[0]->[0];
		   $last_updated = 0 if not defined $last_updated;
		my $current_time = time;
		my $difference   = $current_time - $last_updated;
		### NOTE: Customer requested, move to 2 before v2.0 release
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "last_updated",               value1 => $last_updated, 
			name2 => "current_time",               value2 => $current_time, 
			name3 => "difference",                 value3 => $difference, 
			name4 => "scancore::update_age_limit", value4 => $an->data->{scancore}{update_age_limit}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if ($difference > $an->data->{scancore}{update_age_limit})
		{
			# Kill it and then exit. We could keep running, but it is safer to wait for cron to 
			# re-fire ScanCore.
			$an->Log->entry({log_level => 0, message_key => "scancore_log_0089", message_variables => { difference => $difference }, file => $THIS_FILE, line => __LINE__});
			foreach my $pid (sort {$a cmp $b} @{$other_pids})
			{
				# Tell the user which PID we're killing
				$an->Log->entry({log_level => 0, message_key => "scancore_log_0090", message_variables => { pid => $pid }, file => $THIS_FILE, line => __LINE__});
				
				# Kill it
				my $shell_call = $an->data->{path}{'kill'}." $pid";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "shell_call", value1 => $shell_call, 
				}, file => $THIS_FILE, line => __LINE__});
				open (my $file_handle, "$shell_call 2>&1 |") or $an->Alert->error({title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => $THIS_FILE, line => __LINE__});
				while(<$file_handle>)
				{
					chomp;
					my $line = $_;
					$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
						name1 => "line", value1 => $line, 
					}, file => $THIS_FILE, line => __LINE__});
				}
				close $file_handle;
			}
		}
		
		$an->nice_exit({exit_code => 6});
	}
	
	return (0);
}

# Print the usage information.
sub print_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "print_usage" }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $help = $an->String->get({key => "scancore_message_0012"})."\n";
	open (my $file_handle, ">", "/tmp/${THIS_FILE}.help") or die "Couldn't write help to /tmp/, error was: $!\n";
	print $file_handle $help;
	close $file_handle;
	
	system($an->data->{path}{'less'}." /tmp/${THIS_FILE}.help");

	return(0);
}
