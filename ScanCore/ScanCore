#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - Failed to connect to any database.
# 2  - Error preparing a database query.
# 3  - Failed to read a file.
# 4  - Failed to get an ID when initializing a database.
# 
# TODO:
# - 
#         
# BUG:
# - 
# 
# =============================================================================
=pod
Steps to setup ScanCore DB:

# Database setup
/etc/init.d/postgresql-9.4 initdb
/etc/init.d/postgresql-9.4 start
chkconfig postgresql-9.4 on
su - postgres -c "psql template1 -c \"ALTER ROLE postgres WITH PASSWORD 'secret';\""
echo *:*:*:postgres:secret > /var/lib/pgsql/.pgpass
chown postgres:postgres /var/lib/pgsql/.pgpass
chmod 600 /var/lib/pgsql/.pgpass
sed -i.bak '/# TYPE  DATABASE/a host\tall\tall\t10.20.0.0\/16\tmd5\nhost\tall\tall\t10.250.0.0\/16\tmd5' /var/lib/pgsql/9.4/data/pg_hba.conf 
sed -i 's/local   all         all                               ident/local   all         all                               md5/' /var/lib/pgsql/9.4/data/pg_hba.conf 
sed -i.bak "s/#listen_addresses = 'localhost'/listen_addresses = '*'/" /var/lib/pgsql/9.4/data/postgresql.conf
chown postgres:postgres /var/lib/pgsql/9.4/data/*
/etc/init.d/postgresql-9.4 restart
su - postgres -c "createuser --no-superuser --createdb --no-createrole striker"
su - postgres -c "psql template1 -c \"ALTER ROLE striker WITH PASSWORD 'secret';\""
su - postgres -c "createdb --owner striker scancore"

----

# Reset DB
su - postgres -c "dropdb scancore"
su - postgres -c "createdb --owner striker scancore"
su postgres -c "psql scancore"


=cut
# =============================================================================

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			agents_directory	=>	"$running_directory/agents",
			log_file		=>	"/var/log/striker.log",
			scancore_strings	=>	"$running_directory/ScanCore.xml",
			scancore_sql		=>	"$running_directory/ScanCore.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"$running_directory/Data/strings.xml",
		},
		sys		=>	{
			agents			=>	[],
			hostname		=>	$ENV{HOSTNAME},
			log_level		=>	2,
			log_language		=>	"en_CA",
			max_scancore_ram	=>	(64 * 1048576),		# 64 MiB
			sleep_time		=>	30,
		},
	}
});

# Read my stuff
$an->Log->level($an->data->{sys}{log_level});
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
$an->String->read_words({file => $an->data->{path}{scancore_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

print $an->String->get({key => "scancore_message_0001"}), "\n";

# Connect to the database(s). This is different from the in-loop connection in
# that failing to connect to any databases right off the bad will cause the
# program to bail out.
my $connections = $an->DB->connect_to_databases();
if (not $connections)
{
	# Failed to connect to any database.
	print $an->String->get({
		key		=>	"scancore_message_0002",
		variables	=>	{
			title		=>	$an->String->get({key => "scancore_title_0003"}),
			message		=>	$an->String->get({key => "scancore_message_0004"}),
		},
	}), "\n";
	
	# TODO: Send an email.
	
	# die...
	exit(1);
}

# Disconnect from databases... We'll reconnect once the loop starts.
$an->DB->disconnect_from_databases();

# Run the agents we find.
$an->Log->entry({
	log_level	=>	2,
	title_key	=>	"scancore_title_0005",
	message_key	=>	"scancore_log_0011",	# Entering the scan loop
	file		=>	$THIS_FILE,
	line		=>	__LINE__,
	language	=>	$an->data->{sys}{log_language},
	log_to		=>	$an->data->{path}{log_file},
});
while (1)
{
	# Re-read the configuration
	$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
	$an->String->read_words({file => $an->data->{path}{scancore_strings}});
	$an->String->read_words({file => $an->data->{path}{striker_strings}});
	
	# Connect to the databases.
	my $connections = $an->DB->connect_to_databases();
	if ($connections)
	{
		### At least one database connection is up.
		# Check to see if any of the databases need to be brought up to
		# date.
		sync_dbs($an);
		
		# Call all agents
		call_agents($an);
		
		# Analyze results and take any necessary actions.
		analyze_results($an);
		
		# Sleep
		$an->Log->entry({
			log_level	=>	3,
			title_key	=>	"scancore_title_0001",
			message_key	=>	"scancore_log_0012",	# Sleeping for X seconds.
			message_vars	=>	{
				sleep_time	=>	$an->data->{sys}{sleep_time},
			},
			file		=>	$THIS_FILE,
			line		=>	__LINE__,
			language	=>	$an->data->{sys}{log_language},
			log_to		=>	$an->data->{path}{log_file},
		});
	}
	else
	{
		# Failed to connect to any database. This isn't fatal though...
		# Send an alert email if we haven't already, sleep.
		print $an->String->get({
			key		=>	"scancore_message_0002",
			variables	=>	{
				title		=>	$an->String->get({key => "scancore_title_0003"}),
				message		=>	$an->String->get({key => "scancore_message_0004"}),
			},
		}), "\n";
	}
	
	# Disconnect from databases.
	$an->DB->disconnect_from_databases();
	
	# Check RAM usage and bail if it looks like we're leaking.
	check_ram_usage($an);
	
	# Sleep.
	sleep $an->data->{sys}{sleep_time};
}

# This should never be hit...
nice_exit($an);

###############################################################################
# Functions                                                                   #
###############################################################################

# This 'checks last_updated -> last_updated_date' for this node on all DBs and
# if any are behind, it will read in the changes from the most up to date DB
sub sync_dbs
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "sync_dbs", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Get this node's ID for each DB with:
	# 
	
	# Read the time as a unix timestamp for easier comparison with:
	# SELECT round(extract(epoch from now()));
	
	return(0);
}

# This loops through the agents directory 
sub call_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "call_agents", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Loop through the agents directory and call each agent. Record how
	# long it takes and note the exit code, then record the run-data in the
	# database.
	scan_directory($an, $an->data->{path}{agents_directory});
	
	# Now loop through the agents I found and try calling them.
	foreach my $agent (sort {$a cmp $b} @{$an->data->{sys}{agents}})
	{
		### TODO: Put a timer on these.
		my $start_time = time;
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0015", message_vars => { agent => "$agent" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
		
		# I call these sequentially to minimize the load on the host.
		my $shell_call = "$agent; echo rc:\$? 2>&1 |";
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0007", message_vars => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
		open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "scancore_title_0003", message_key => "scancore_error_0006", message_vars => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__ });
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => { name1 => "line", value1 => "$line" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			if ($line =~ /rc:(\d+)/)
			{
				my $agent_rc = $1;
				$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => { name1 => "agent_rc", value1 => "$agent_rc" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			}
		}
		close $file_handle;
		my $runtime = time - $start_time;
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0020", message_vars => { agent => "$agent", runtime => $runtime }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	}
	
	return(0);
}

# This checks the amount RAM used by ScanCore and exits if it exceeds a
# sys::max_scancore_ram bytes.
sub check_ram_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "check_ram_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Use 'ps auxf' to find ScanCore and it's children, then for each PID, call:
	#
	### NOTE: Using 'rgmanager' as an example
	#[root@an-a05n01 ~]# ps auxf | grep -v grep | grep rgmanager
	#root      3164  0.0  0.0  36948  6252 ?        S<Ls 11:27   0:00 rgmanager
	#root      3166  0.0  0.0 494828  3044 ?        S<l  11:27   0:06  \_ rgmanager
	# 
	#[root@an-a05n01 ~]# pmap 3164 | grep total | awk '{print $2}' | sed 's/K/000 bytes/'
	#36948000 bytes
	#[root@an-a05n01 ~]# pmap 3166 | grep total | awk '{print $2}' | sed 's/K/000 bytes/'
	#494828000 bytes
	#
	### NOTE: There shouldn't be any child processes when this is called...
	
	
	
	return(0);
}

# This reads the 'results table' and looks for bad conditions
sub analyze_results
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "analyze_results", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Read in the 'alerts' table, using $an->data->{sys}{scan_time} as the
	# time to select after. 
	
	return(0);
}

# This digs through a directory looking for scan agents to call. It will dive
# into subdiretories as well. Anything it finds, it will record the path to
# sys::agents.
sub scan_directory
{
	my ($an, $directory) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_vars => { function => "scan_directory", }, message_key => "tools_log_0003", message_vars => { name1 => "directory", value1 => "$directory" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	local(*DIRECTORY);
	opendir(DIRECTORY, $an->data->{path}{agents_directory});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		my $full_path = "$directory/$file";
		$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0003", message_vars => { name1 => "full_path", value1 => "$full_path" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
		if (-d $full_path)
		{
			# This is a directory, dive into it.
			scan_directory($an, $full_path);
		}
		elsif (-x $full_path)
		{
			# Now I only want to know if the file starts with 'scan-'
			next if $file !~ /^scan-/;
			
			# If I am still alive, I am looking at a scan agent!
			$an->Log->entry({log_level => 2, title_key => "scancore_title_0001", message_key => "scancore_log_0014", message_vars => { agent => "$full_path" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
			push @{$an->data->{sys}{agents}}, $full_path;
		}
	}
	
	return(0);
}

# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_vars => { function => "nice_exit", }, message_key => "tools_log_0003", message_vars => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__, language => $an->data->{sys}{log_language}, log_to => $an->data->{path}{log_file}});
	
	# Close database connections
	$an->DB->disconnect_from_databases();
	
	exit(0);
}
