#!/usr/bin/perl
# 
# This software was created by Alteeve's Niche! Inc. and has been released
# under the terms of the GNU GPL version 2.
#
# https://alteeve.ca
# 
# Exit Codes:
# 0  - Success
# 1  - Failed to connect to any database.
# 2  - Error preparing a database query.
# 3  - Failed to read a file.
# 4  - Failed to get an ID when initializing a database.
# 5  - Used too much RAM, exited to avoid a problem.
# 6  - Another copy of ScanCore is running.
# 
# TODO:
# - Record the hostname to a file and check the current host name with the one
#   on file. If it differs, update the appropriate 'hosts' table in the DBs
#         
# BUG:
# - 
# 
# NOTE: Because each DB may use different serial IDs for various DBs, they 
#       can't be used to directly UPDATE or reference when INSERTing values. So
#       instead, we use the hostname as the "global" common variable amoungst 
#       DBs and then divine each DB's individual table/column IDs from it. This
#       means we can do UPDATE and INSERTs into all DBs with one query, but it
#       makes those queries... awkward. It also means that the user changing
#       the hostname *MUST* be caught by ScanCore via a cache file in order to
#       alter the hosts -> host_name column without losing the host_id.
#       
#       I'm open to better ideas...
#       
# =============================================================================
=pod
Steps to setup ScanCore DB:

# Database setup
/etc/init.d/postgresql-9.4 initdb
/etc/init.d/postgresql-9.4 start
chkconfig postgresql-9.4 on
su - postgres -c "psql template1 -c \"ALTER ROLE postgres WITH PASSWORD 'secret';\""
echo *:*:*:postgres:secret > /var/lib/pgsql/.pgpass
chown postgres:postgres /var/lib/pgsql/.pgpass
chmod 600 /var/lib/pgsql/.pgpass
sed -i.bak '/# TYPE  DATABASE/a host\tall\tall\t10.20.0.0\/16\tmd5\nhost\tall\tall\t10.250.0.0\/16\tmd5' /var/lib/pgsql/9.4/data/pg_hba.conf 
sed -i 's/local   all         all                               ident/local   all         all                               md5/' /var/lib/pgsql/9.4/data/pg_hba.conf 
sed -i.bak "s/#listen_addresses = 'localhost'/listen_addresses = '*'/" /var/lib/pgsql/9.4/data/postgresql.conf
chown postgres:postgres /var/lib/pgsql/9.4/data/*
/etc/init.d/postgresql-9.4 restart
su - postgres -c "createuser --no-superuser --createdb --no-createrole striker"
su - postgres -c "psql template1 -c \"ALTER ROLE striker WITH PASSWORD 'secret';\""
su - postgres -c "createdb --owner striker scancore"
su postgres -c "psql scancore"

----

# Reset DB
su - postgres -c "dropdb scancore"
su - postgres -c "createdb --owner striker scancore"
su postgres -c "psql scancore"


=cut
# =============================================================================

# Determine this file name.
my $THIS_FILE =  $0;
   $THIS_FILE =~ s/^.*\///;

# Use my modules.
use strict;
use warnings;
use AN::Tools;
use Data::Dumper;

# Disable buffering.
$| = 1;

# This allows our XML and SQL files to be found, even if the path the program
# is in changes.
my $running_directory = ($0 =~ /^(.*?)\/$THIS_FILE$/)[0];

# Get the handle to the AN::Tools and preset some variables I will use.
my $an = AN::Tools->new({data => 
	{
		path		=>	{
			agents_directory	=>	"$running_directory/agents",
			cp			=>	"/bin/cp",
			email_directory		=>	"/var/log/alert_emails",
			log_file		=>	"/var/log/striker.log",
			mailx			=>	"/bin/mailx",
			postfix_init		=>	"/etc/init.d/postfix",
			postfix_main		=>	"/etc/postfix/main.cf",
			postfix_relay_file	=>	"/etc/postfix/relay_password",
			postmap			=>	"/usr/sbin/postmap",
			scancore_strings	=>	"$running_directory/ScanCore.xml",
			scancore_sql		=>	"$running_directory/ScanCore.sql",
			striker_config		=>	"/etc/striker/striker.conf",
			striker_strings		=>	"$running_directory/Data/strings.xml",
		},
		strings_read			=>	{},
		sys		=>	{
			agents			=>	[],
			append_email_footer	=>	0,			# Set to '1' to add the footer warning that the email did not come from alteeve.ca
			db_timestamp		=>	"",			# This will hold the timestamp used to set 'modified_date' on all DB records.
			# This will get set by AN::Tools::DB->connect_to_databases()
			host_id_query		=>	"",
			language		=>	"en_CA",
			log_level		=>	2,
			log_language		=>	"en_CA",
			# This looks like a lot, but 'pmap' kinda sucks and 
			# reports shared memory, so to even start a program 
			# lists 120 MiB+ used. I will make it smarter later.
			maximum_ram		=>	(256 * 1048576),
			program_name		=>	$THIS_FILE,
			read_db_id		=>	"",
			sleep_time		=>	30,
			use_db_fh		=>	"",
		},
	}
});

# Set some defaults
$an->default_language    ($an->data->{sys}{language});
$an->default_log_language($an->data->{sys}{log_language});
$an->default_log_file    ($an->data->{path}{log_file});

# Set the log level.
$an->Log->level($an->data->{sys}{log_level});

# Read my stuff
$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
$an->String->read_words({file => $an->data->{path}{scancore_strings}});
$an->String->read_words({file => $an->data->{path}{striker_strings}});

# Should I live?
avoid_duplicate_run($an);

# Number 5 is Alive!
print $an->String->get({key => "scancore_message_0001"}), "\n";

# Connect to the database(s). This is different from the in-loop connection in
# that failing to connect to any databases right off the bad will cause the
# program to bail out.
my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
if (not $connections)
{
	# Failed to connect to any database.
	print $an->String->get({
		key		=>	"scancore_message_0002",
		variables	=>	{
			title		=>	$an->String->get({key => "scancore_title_0003"}),
			message		=>	$an->String->get({key => "scancore_message_0004"}),
		},
	}), "\n";
	
	# TODO: Send an email.
	
	exit(1);
}
# Look to see if any databases need to be updated.
update_db($an);

# Make sure this node is in the database.
add_host_to_databases($an);

# Disconnect from databases... We'll reconnect once the loop starts.
$an->DB->disconnect_from_databases();

# Run the agents we find.
$an->Log->entry({
	log_level	=>	2,
	title_key	=>	"scancore_title_0005",
	message_key	=>	"scancore_log_0011",	# Entering the scan loop
	file		=>	$THIS_FILE,
	line		=>	__LINE__,
	log_to		=>	$an->data->{path}{log_file},
});
while (1)
{
	# Re-read the configuration
	$an->Storage->read_conf({file => $an->data->{path}{striker_config}});
	$an->String->read_words({file => $an->data->{path}{scancore_strings}});
	$an->String->read_words({file => $an->data->{path}{striker_strings}});
	
	# Connect to the databases.
	my $connections = $an->DB->connect_to_databases({file => $THIS_FILE});
	if ($connections)
	{
		# Look to see if any databases need to be updated.
		update_db($an);
		
		# Call all agents
		call_agents($an);
		
		# Analyze results and take any necessary actions.
		analyze_results($an);
		
		# Sleep
		$an->Log->entry({
			log_level	=>	3,
			title_key	=>	"scancore_title_0001",
			message_key	=>	"scancore_log_0012",	# Sleeping for X seconds.
			message_variables	=>	{
				sleep_time	=>	$an->data->{sys}{sleep_time},
			},
			file		=>	$THIS_FILE,
			line		=>	__LINE__,
			log_to		=>	$an->data->{path}{log_file},
		});
	}
	else
	{
		# Failed to connect to any database. This isn't fatal though...
		# Send an alert email if we haven't already, sleep.
		print $an->String->get({
			key		=>	"scancore_message_0002",
			variables	=>	{
				title		=>	$an->String->get({key => "scancore_title_0003"}),
				message		=>	$an->String->get({key => "scancore_message_0004"}),
			},
		}), "\n";
	}
	
	# Check RAM usage and bail if it looks like we're leaking.
	check_ram_usage($an);
	
	# Check for and process alerts
	process_alerts($an);
	
	# Record the time
	$an->DB->update_time({file => $THIS_FILE});
	
	# Disconnect from databases.
	$an->DB->disconnect_from_databases();
	
	# Sleep.
	sleep $an->data->{sys}{sleep_time};
}

# This should never be hit...
nice_exit($an);

###############################################################################
# Functions                                                                   #
###############################################################################

# This reads in the 'alerts' table and generates the emails/log file entries as
# needed.
sub process_alerts
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "process_alerts", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in all pending alerts
	my $query = "
SELECT 
    alert_id, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    modified_date
FROM 
    alerts 
WHERE 
    alert_host_id = (".$an->data->{sys}{host_id_query}.");";
	my $results = $an->DB->do_db_query({query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	
	my $last_agent = "";
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $alert_id                = $row->[0]; 
		my $alert_agent_name        = $row->[1]; 
		my $alert_level             = $row->[2]; 
		my $alert_title_key         = $row->[3]; 
		my $alert_title_variables   = $row->[4]; 
		my $alert_message_key       = $row->[5]; 
		my $alert_message_variables = $row->[6]; 
		my $modified_date           = $row->[7]; 
		
		# Sometimes alerts are sent by modules. In those cases, ignore
		# them.
		if ($last_agent ne $alert_agent_name)
		{
			   $last_agent    = $alert_agent_name;
			my $agent_strings = $alert_agent_name eq "ScanCore" ? $an->data->{path}{scancore_strings} : $an->data->{path}{agents_directory}."/$alert_agent_name/$alert_agent_name.xml";
			   $an->String->read_words({file => $agent_strings});
		}
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0008", message_variables => {
			name1 => "alert_id",                value1 => $alert_id, 
			name2 => "alert_agent_name",        value2 => $alert_agent_name, 
			name3 => "alert_level",             value3 => $alert_level, 
			name4 => "alert_title_key",         value4 => $alert_title_key, 
			name5 => "alert_title_variables",   value5 => $alert_title_variables, 
			name6 => "alert_message_key",       value6 => $alert_message_key, 
			name7 => "alert_message_variables", value7 => $alert_message_variables, 
			name8 => "modified_date",           value8 => $alert_message_variables, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id} = {
			alert_level             => $alert_level, 
			alert_title_key         => $alert_title_key, 
			alert_title_variables   => $alert_title_variables, 
			alert_message_key       => $alert_message_key, 
			alert_message_variables => $alert_message_variables,
			modified_date           => $modified_date
		};
		
		$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
			name1 => "db::alerts::agent_name::${alert_agent_name}::alert_id::${alert_id}::alert_level",             value1 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_level},
			name2 => "db::alerts::agent_name::${alert_agent_name}::alert_id::${alert_id}::alert_title_key",         value2 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_title_key},
			name3 => "db::alerts::agent_name::${alert_agent_name}::alert_id::${alert_id}::alert_title_variables",   value3 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_title_variables},
			name4 => "db::alerts::agent_name::${alert_agent_name}::alert_id::${alert_id}::alert_message_key",       value4 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_message_key},
			name5 => "db::alerts::agent_name::${alert_agent_name}::alert_id::${alert_id}::alert_message_variables", value5 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_message_variables},
			name6 => "db::alerts::agent_name::${alert_agent_name}::alert_id::${alert_id}::modified_date",           value6 => $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{modified_date},
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Process alerts, if any.
	if (ref($an->data->{db}{alerts}{agent_name}))
	{
		# Sort out who is getting which alerts.
		foreach my $integer (sort {$a cmp $b} keys %{$an->data->{alerts}{recipient}})
		{
			if ($an->data->{alerts}{recipient}{$integer}{email})
			{
				# Email recipient
				send_email($an, $an->data->{alerts}{recipient}{$integer}{email});
			}
			elsif ($an->data->{alerts}{recipient}{$integer}{file})
			{
				# Write to a file
				record_alert_to_file($an, $an->data->{alerts}{recipient}{$integer}{file});
			}
			else
			{
				# Bad entry
				$an->Log->entry({log_level => 2, message_key => "scancore_log_0051", file => $THIS_FILE, line => __LINE__});
			}
		}
		
		# All done, delete the public.alerts entries.
		$query = "DELETE FROM alerts WHERE alert_host_id = (".$an->data->{sys}{host_id_query}.");";
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		$an->DB->do_db_write({query => $query});
		
		# Delete the alerts from memory.
		delete $an->data->{db}{alerts};
	}
	else
	{
		# No alerts
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0052", file => $THIS_FILE, line => __LINE__});
	}
	
	return(0);
}

# This sends any pending alerts to a give recipient, if applicable.
sub send_email
{
	my ($an, $variables) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "send_email", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "variables", value1 => "$variables" 
	}, file => $THIS_FILE, line => __LINE__});
	
	# The 'subject' will hold the highest alert seen and be used to 
	# generate a proper email subject prior to dispatching the email 
	# proper.
	my $subject  = 5;
	my $body     = "";
	
	my $name     = "";
	my $email    = "";
	my $language = $an->data->{sys}{language};
	my $level    = "warning";
	foreach my $pair (split/,/, $variables)
	{
		next if not $pair;
		my ($variable, $value) = ($pair =~ /^(.*?)="(.*)"/);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "variable", value1 => $variable, 
			name2 => "value",    value2 => $value, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if    ($variable eq "name")     { $name     = $value; }
		elsif ($variable eq "email")    { $email    = $value; }
		elsif ($variable eq "language") { $language = $value; }
		elsif ($variable eq "level")    { $level    = $value; }
		else
		{
			# Invalid entry.
			$an->Log->entry({log_level => 1, message_key => "scancore_warning_0009", message_variables => {
				variable => $variable, 
				value    => $value, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
		name1 => "name",     value1 => $name, 
		name2 => "email",    value2 => $email, 
		name3 => "language", value3 => $language, 
		name4 => "level",    value4 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Convert the user's log level to a numeric number for easier
	# comparison.
	$level = $an->Alert->convert_level_name_to_number({level => $level});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "level", value1 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Generate the title key.
	foreach my $alert_agent_name (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "alert_agent_name", value1 => $alert_agent_name, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_id (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_id", value1 => $alert_id, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $alert_level             = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_level};
			my $alert_title_key         = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_title_key};
			my $alert_title_variables   = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_title_variables};
			my $alert_message_key       = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_message_key};
			my $alert_message_variables = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_message_variables};
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0005", message_variables => {
				name1 => "alert_level",             value1 => $alert_level, 
				name2 => "alert_title_key",         value2 => $alert_title_key, 
				name3 => "alert_title_variables",   value3 => $alert_title_variables, 
				name4 => "alert_message_key",       value4 => $alert_message_key, 
				name5 => "alert_message_variables", value5 => $alert_message_variables, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$alert_level = $an->Alert->convert_level_name_to_number({level => $alert_level});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_level", value1 => $alert_level, 
			}, file => $THIS_FILE, line => __LINE__});
			
			# Record the alert level if it's higher than we saw
			# before.
			$subject = $alert_level if $subject > $alert_level;
			#print "$THIS_FILE ".__LINE__."; subject: [$subject], alert_level: [$alert_level]\n";
			
			my $title   = get_string_from_double_bang($an, $language, $alert_title_key, $alert_title_variables);
			my $message = get_string_from_double_bang($an, $language, $alert_message_key, $alert_message_variables);
			if ($level >= $alert_level)
			{
				#print "$THIS_FILE ".__LINE__."; Sending alert: [$alert_id] to: [$name <$email>] in the language: [$language]...\n";
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "title",   value1 => $title, 
					name2 => "message", value2 => $message, 
				}, file => $THIS_FILE, line => __LINE__});
				$body .= $an->String->get({
					language	=>	$language,
					key		=>	"scancore_email_0005",
					variables	=>	{
						title		=>	$title,
						message		=>	$message
					},
				})."\n\n";
			}
			else
			{
				# Ignored
				$an->Log->entry({log_level => 2, message_key => "scancore_log_0050", message_variables => {
					user     => "$name <$email>",
					alert_id => $alert_id, 
					title    => $title,
					message  => $message
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
	}
	
	# Generate the email body.
	my $subject_line = $an->String->get({
		language	=>	$language,
		key		=>	"scancore_email_0004",
		variables	=>	{
			hostname	=>	$an->hostname,
		},
	});
	#print "$THIS_FILE ".__LINE__."; subject: [$subject]\n";
	my $say_subject = $an->String->get({
		language	=>	$language,
		key		=>	"scancore_email_0001",
		variables	=>	{
			level		=>	$an->Alert->convert_level_number_to_name({level => $subject}),
			subject		=>	$subject_line,
		},
	});
	
	# The footer is a generic message tell the user not to yell at us for
	# spamming them. (hey, you laugh, but managers will get these 
	# emails...)
	if ($an->data->{sys}{append_email_footer})
	{
		$body .= $an->String->get({
			language	=>	$language,
			key		=>	"scancore_email_0003",
			variables	=>	{
				hostname	=>	$an->hostname,
			},
		});
		#print "$THIS_FILE ".__LINE__."; say_footer: [$say_footer]\n";
	}
	
	# Now assemble the message.
	my $say_to = "$name <$email>";
	#print "$THIS_FILE ".__LINE__."; from:    [".$an->data->{smtp}{username}."]\n";
	#print "$THIS_FILE ".__LINE__."; to:      [$say_to]\n";
	#print "$THIS_FILE ".__LINE__."; subject: [$say_subject]\n";
	#print "$THIS_FILE ".__LINE__."; body:    [$body]\n";
	#print "$THIS_FILE ".__LINE__."; footer:  [$body]\n";
	my $email_body = $an->String->get({
		language	=>	$language,
		key		=>	"scancore_email_0002",
		variables	=>	{
			from		=>	$an->data->{smtp}{username},
			to		=>	$say_to,
			subject		=>	$say_subject,
			body		=>	$body,
		},
	});
	
	# First, see if the relay file needs to be updated.
	check_email_configuration($an);
	
	### TODO: Send the email!
	#print "====================================\n";
	#print "$email_body\n";
	#print "====================================\n";
	
	# Select a known_free email file name.
	my $email_file = $an->data->{path}{email_directory}."/".get_date($an).".1";
	my $file_ok = 0;
	until ($file_ok)
	{
		if (-e $email_file)
		{
			my ($file, $suffix) = ($email_file =~ /^(.*?)\.(\d+)$/);
			$suffix++;
			$email_file = "$file.$suffix\n";
			# Make sure I'm not sending more than 10/sec...
			if ($suffix > 10)
			{
				# Given the precision of the date coming from
				# pgsql, there must be something wrong.
				$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0014", message_variables => { 
					file => $email_file, 
				}, code => 2, file => "$THIS_FILE", line => __LINE__});
			}
		}
		else
		{
			$file_ok = 1;
		}
	}
	
	# Write out the email file.
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0048", message_variables => {
		file => $email_file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $shell_call = $email_file;
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call",   value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	print $file_handle $email_body;
	close $file_handle;
	
	# Now send the email.
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0049", message_variables => {
		file => $email_file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	$shell_call = $an->data->{path}{mailx}." -t < $email_file 2>&1 |";
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "shell_call", value1 => $shell_call, 
	}, file => $THIS_FILE, line => __LINE__});
	
	open ($file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => $line, 
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	return(0);
}

# This gets the current date and time from one of the databases.
sub get_date
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_date", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $query = "SELECT now();";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $date =  $an->DB->do_db_query({query => $query})->[0]->[0];
	   $date =~ s/ /_/g;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "date", value1 => $date
	}, file => $THIS_FILE, line => __LINE__});
	
	return($date);
}

# This records entries from alerts to a file, if applicable.
sub record_alert_to_file
{
	my ($an, $variables) = @_;
	$an->Log->entry({log_level => 2, title_key => "tools_log_0001", title_variables => { function => "record_alert_to_file", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "variables", value1 => "$variables" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $messages = "";
	my $file     = "";
	my $language = $an->data->{sys}{language};
	my $level    = "warning";
	foreach my $pair (split/,/, $variables)
	{
		next if not $pair;
		my ($variable, $value) = ($pair =~ /^(.*?)="(.*)"/);
		$an->Log->entry({log_level => 2, message_key => "an_variables_0002", message_variables => {
			name1 => "variable", value1 => $variable, 
			name2 => "value",    value2 => $value, 
		}, file => $THIS_FILE, line => __LINE__});
		
		if    ($variable eq "file")     { $file     = $value; }
		elsif ($variable eq "language") { $language = $value; }
		elsif ($variable eq "level")    { $level    = $value; }
		else
		{
			# Invalid entry.
			$an->Log->entry({log_level => 1, message_key => "scancore_warning_0010", message_variables => {
				variable => $variable, 
				value    => $value, 
			}, file => $THIS_FILE, line => __LINE__});
		}
	}
	$an->Log->entry({log_level => 2, message_key => "an_variables_0003", message_variables => {
		name1 => "file",     value1 => $file, 
		name2 => "language", value2 => $language, 
		name3 => "level",    value3 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Convert the user's log level to a numeric number for easier
	# comparison.
	$level = $an->Alert->convert_level_name_to_number({level => $level});
	$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
		name1 => "level", value1 => $level, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Loop through all the alerts and prep the relevant ones to be written
	# to the file.
	foreach my $alert_agent_name (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}})
	{
		$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
			name1 => "alert_agent_name", value1 => $alert_agent_name, 
		}, file => $THIS_FILE, line => __LINE__});
		foreach my $alert_id (sort {$a cmp $b} keys %{$an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}})
		{
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_id", value1 => $alert_id, 
			}, file => $THIS_FILE, line => __LINE__});
			
			my $alert_level             = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_level};
			my $alert_title_key         = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_title_key};
			my $alert_title_variables   = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_title_variables};
			my $alert_message_key       = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_message_key};
			my $alert_message_variables = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{alert_message_variables};
			my $modified_date           = $an->data->{db}{alerts}{agent_name}{$alert_agent_name}{alert_id}{$alert_id}{modified_date};
			
			$an->Log->entry({log_level => 2, message_key => "an_variables_0006", message_variables => {
				name1 => "alert_level",             value1 => $alert_level, 
				name2 => "alert_title_key",         value2 => $alert_title_key, 
				name3 => "alert_title_variables",   value3 => $alert_title_variables, 
				name4 => "alert_message_key",       value4 => $alert_message_key, 
				name5 => "alert_message_variables", value5 => $alert_message_variables, 
				name6 => "modified_date",           value6 => $modified_date, 
			}, file => $THIS_FILE, line => __LINE__});
			
			$alert_level = $an->Alert->convert_level_name_to_number({level => $alert_level});
			$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
				name1 => "alert_level", value1 => $alert_level, 
			}, file => $THIS_FILE, line => __LINE__});
			
			if ($level >= $alert_level)
			{
				my $title    =  get_string_from_double_bang($an, $language, $alert_title_key, $alert_title_variables);
				my $message  =  get_string_from_double_bang($an, $language, $alert_message_key, $alert_message_variables);
				my $say_date =  $modified_date;
				   $say_date =~ s/(\d+-\d+-\d+ \d+:\d+:\d+)\.\d+(.*)$/$1 (GMT$2)/;
				
				my $string = $an->String->get({
					key			=>	"scancore_log_0033",
					variables		=>	{
						date			=>	$say_date,
						alert_agent_name	=>	$alert_agent_name,
						title			=>	$title, 
						message			=>	$message, 
					},
				});
				$an->Log->entry({log_level => 2, message_key => "an_variables_0001", message_variables => {
					name1 => "string", value1 => $string, 
				}, file => $THIS_FILE, line => __LINE__});
				$messages .= "$string\n";
			}
		}
	}
	
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0032", message_variables => {
		file => $file, 
	}, file => $THIS_FILE, line => __LINE__});
	
	# Append to the log file.
	my $shell_call = ">>$file";
	open (my $filehandle, "$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	print $filehandle $messages;
	close $filehandle;
	
	return(0);
}

# This checks the local postfix and mail relay data and updates if needed.
sub check_email_configuration
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_email_configuration", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	
	my $write_relay_file = 0;
	
	# Checking to see of the email relay file needs to be created or updated.
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0034", message_variables => {
		postfix_relay_file => $an->data->{path}{postfix_relay_file}, 
	}, file => $THIS_FILE, line => __LINE__});
	if (-e $an->data->{path}{postfix_relay_file})
	{
		# It exists, reading it.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0035", file => $THIS_FILE, line => __LINE__});
		my $shell_call = $an->data->{path}{postfix_relay_file};
		open (my $file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /^\[(.*?)\]:(\d+)\s(.*?):(.*)$/)
			{
				my $server   = $1;
				my $port     = $2;
				my $username = $3;
				my $password = $4;
				
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "server",       value1 => $server, 
					name2 => "smtp::server", value2 => $an->data->{smtp}{server},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "port",       value1 => $port, 
					name2 => "smtp::port", value2 => $an->data->{smtp}{port},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "username",       value1 => $username, 
					name2 => "smtp::username", value2 => $an->data->{smtp}{username},
				}, file => $THIS_FILE, line => __LINE__});
				$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
					name1 => "password",       value1 => $password, 
					name2 => "smtp::password", value2 => $an->data->{smtp}{password},
				}, file => $THIS_FILE, line => __LINE__});
				if (($server   ne $an->data->{smtp}{server}) ||
				    ($port     ne $an->data->{smtp}{port}) ||
				    ($username ne $an->data->{smtp}{username}) ||
				    ($password ne $an->data->{smtp}{password}))
				{
					# Changes made
					$an->Log->entry({log_level => 3, message_key => "scancore_log_0036", file => $THIS_FILE, line => __LINE__});
					$write_relay_file = 1;
				}
				else
				{
					# No change
					$an->Log->entry({log_level => 3, message_key => "scancore_log_0047", file => $THIS_FILE, line => __LINE__});
				}
			}
		}
		close $file_handle;
	}
	else
	{
		# Relay file doesn't exist at all, so this might be an upgrade.
		# As such, check that the programs we need are installed.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0037", file => $THIS_FILE, line => __LINE__});
		$write_relay_file = 1;
	}
	
	# (Re)write the relay file now, if needed.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "write_relay_file", value1 => $write_relay_file, 
	}, file => $THIS_FILE, line => __LINE__});
	if ($write_relay_file)
	{
		# Write the new relay file.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0034", message_variables => {
			postfix_relay_file => $an->data->{path}{postfix_relay_file}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		my $shell_call   = $an->data->{path}{postfix_relay_file};
		my $postfix_line = "[".$an->data->{smtp}{server}."]:".$an->data->{smtp}{port}." ".$an->data->{smtp}{username}.":".$an->data->{smtp}{password};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "shell_call",   value1 => $shell_call, 
			name2 => "postfix_line", value2 => $postfix_line,
		}, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		print $file_handle "$postfix_line\n";
		close $file_handle;
		
		# Generate the binary version.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0039", file => $THIS_FILE, line => __LINE__});
		$shell_call = $an->data->{path}{postmap}." ".$an->data->{path}{postfix_relay_file}." 2>&1 |";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call", value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		
		# If I am writing the file, there is a chance that postfix
		# hasn't been configured yet. So check it and, if needed,
		# fix it.
		my $backup_file = $an->data->{path}{postfix_main}.".anvil";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "backup_file", value1 => $backup_file, 
		}, file => $THIS_FILE, line => __LINE__});
		if (not -e $backup_file)
		{
			# Backup the original.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0034", message_variables => {
				source      => $an->data->{path}{postfix_main},
				destination =>  $backup_file,
			}, file => $THIS_FILE, line => __LINE__});
			
			my $shell_call = $an->data->{path}{cp}." --archive --no-clobber --verbose ".$an->data->{path}{postfix_main}." $backup_file 2>&1 |";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "shell_call", value1 => $shell_call, 
			}, file => $THIS_FILE, line => __LINE__});
			open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
			while(<$file_handle>)
			{
				chomp;
				my $line = $_;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "line", value1 => $line, 
				}, file => $THIS_FILE, line => __LINE__});
			}
			close $file_handle;
		}
		else
		{
			# Already backed up
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0040", file => $THIS_FILE, line => __LINE__});
		}
		
		# Now update the postfix main.cf file by reading it in and
		# replacing the variables we want to update, then writing it
		# all back out.
		my $postfix_main = "";
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0041", message_variables => {
			postfix_main => $an->data->{path}{postfix_main}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		$shell_call = $an->data->{path}{postfix_main};
		open ($file_handle, "<$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0016", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			
			# Avoid duplicates
			next if $line =~ /^relayhost = \[/;
			next if $line =~ /^smtp_use_tls =/;
			next if $line =~ /^smtp_sasl_auth_enable =/;
			next if $line =~ /^smtp_sasl_password_maps =/;
			next if $line =~ /^smtp_sasl_security_options =/;
			next if $line =~ /^smtp_tls_CAfile =/;
			
			if ($line =~ /#relayhost = \[an.ip.add.ress\]/)
			{
				# Insert the mail relay configuration here.
				$an->Log->entry({log_level => 3, message_key => "scancore_log_0042", file => $THIS_FILE, line => __LINE__});
				# TODO: Find out how to support non-secure mail
				#       servers.
				# TODO: Experiment if I really need to define
				#       the mail server and IP both here and in
				#       the relay file.
				$postfix_main .= "$line\n";
				$postfix_main .= "relayhost = [".$an->data->{smtp}{server}."]:".$an->data->{smtp}{port}."\n";
				$postfix_main .= "smtp_use_tls = yes\n";
				$postfix_main .= "smtp_sasl_auth_enable = yes\n";
				$postfix_main .= "smtp_sasl_password_maps = hash:".$an->data->{path}{postfix_relay_file}."\n";
				$postfix_main .= "smtp_sasl_security_options =\n";
				$postfix_main .= "smtp_tls_CAfile = /etc/pki/tls/certs/ca-bundle.crt\n";
			}
			else
			{
				$postfix_main .= "$line\n";
			}
		}
		close $file_handle;
		
		# Write out the new version.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0043", message_variables => {
			postfix_main => $an->data->{path}{postfix_main}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record the config in the main log
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "postfix_main", value1 => $postfix_main, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Do the actual write...
		$shell_call = $an->data->{path}{postfix_main};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "shell_call",   value1 => $shell_call, 
		}, file => $THIS_FILE, line => __LINE__});
		open ($file_handle, ">$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0015", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		print $file_handle $postfix_main;
		close $file_handle;
		
		# Reload postfix
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0044", file => $THIS_FILE, line => __LINE__});
		$shell_call = $an->data->{path}{postfix_init}." restart 2>&1 |";
		open ($file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line = $_;
			$line =~ s/\n//g;
			$line =~ s/\r//g;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => $line, 
			}, file => $THIS_FILE, line => __LINE__});
		}
		close $file_handle;
		sleep 2;
	}
	
	# Make sure the mail alerts directory exists and create it if not.
	if (not -e $an->data->{path}{email_directory})
	{
		# Need to create it.
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0045", message_variables => {
			email_directory => $an->data->{path}{email_directory}, 
		}, file => $THIS_FILE, line => __LINE__});
		
		mkdir $an->data->{path}{email_directory} or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "error_title_0014", message_variables => {
								directory => $an->data->{path}{email_directory}, 
								error     => $! 
							}, code => 2, file => "$THIS_FILE", line => __LINE__});
		
		# Set the mode
		my $directory_mode = 0775;
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0046", message_variables => {
			directory_mode => sprintf("%04o", $directory_mode), 
		}, file => $THIS_FILE, line => __LINE__});
		chmod $directory_mode, $an->data->{path}{email_directory};
	}
	
	return(0);
}

# This converts the string keys and variables stored in the alerts table (flanked with '!!') to strings.
sub get_string_from_double_bang
{
	my ($an, $language, $key, $variables) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "get_string_from_double_bang", }, message_key => "an_variables_0003", message_variables => { 
		name1 => "language",  value1 => "$language", 
		name2 => "key",       value2 => "$key", 
		name3 => "variables", value3 => "$variables" 
	}, file => $THIS_FILE, line => __LINE__});
	
	if ($variables)
	{
		my $hash = {};
		foreach my $pair (split/,/, $variables)
		{
			next if not $pair;
			my ($variable, $value) = ($pair =~ /^!!(.*?)!(.*)!!$/);
			$hash->{$variable} = $value;
			
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "$variable", value1 => $value, 
			}, file => $THIS_FILE, line => __LINE__});
			
		}
		$variables = $hash;
	}
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "language",  value1 => $language, 
		name2 => "key",       value2 => $key, 
		name3 => "variables", value3 => $variables, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $string = $an->String->get({
		language  => $language,
		key       => $key,
		variables => $variables
	});
	
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "string", value1 => $string, 
	}, file => $THIS_FILE, line => __LINE__});
	
	return($string);
}

# This looks at each DB's 'updated' table to see if any are behind. If any are,
# it will update the tables based on the time the last entry was made for a
# given host.
sub update_db
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	$an->data->{sys}{sql} = [];
	foreach my $id (sort {$a cmp $b} keys %{$an->data->{scancore}{db_to_update}})
	{
		my $db_is_behind = $an->data->{scancore}{db_to_update}{$id}{behind};
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "db_is_behind", value1 => $db_is_behind, 
		}, file => $THIS_FILE, line => __LINE__});
		next if not $db_is_behind;
		
		my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
		my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
		my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
		$an->Log->entry({log_level => 3, message_key => "scancore_log_0028", message_variables => {
			id                  => $id, 
			source_db_id        => $source_db_id, 
			source_updated_time => $source_updated_time,
			target_last_updated => $target_last_updated
		}, file => $THIS_FILE, line => __LINE__});
		if (not $target_last_updated)
		{
			# Full recovery needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0029", file => $THIS_FILE, line => __LINE__});
		}
		elsif ($source_updated_time ne $target_last_updated)
		{
			# Partial recovery needed.
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0030", message_variables => {
				seconds_behind => ($source_updated_time - $target_last_updated), 
			}, file => $THIS_FILE, line => __LINE__});
		}
	
		# Update (and commit) the hosts table
		update_db_hosts($an, $id);
		
		# Now update the rest of the ScanCore tables.
		update_db_agents($an, $id);
		update_db_ram_used($an, $id);
		update_db_alerts($an, $id);
		#update_db_temperature($an, $id);
		#update_db_power($an, $id);
		
		# All done, update the time
		$an->DB->update_time({file => $THIS_FILE});
	}
	
	return(0);
}

# Update the 'ram_used' table.
sub update_db_ram_used
{
	my ($an, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_ram_used", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "id", value1 => "$id" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
	my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
	my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
	my $target_db_id        = $id;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_last_updated", value1 => $target_last_updated, 
		name2 => "source_updated_time", value2 => $source_updated_time, 
		name3 => "source_db_id",        value3 => $source_db_id, 
		name4 => "target_db_id",        value4 => $target_db_id
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the unix time that this table was last updated for this host.
	my $query = "SELECT modified_date FROM ram_used WHERE ram_used_host_id = (".$an->data->{sys}{host_id_query}.") ORDER BY modified_date DESC LIMIT 1;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target_db_id", value1 => "$target_db_id", 
		name2 => "query",        value2 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_ram_used_last_updated = $an->DB->do_db_query({id => $target_db_id, query => $query})->[0]->[0];
	   $target_ram_used_last_updated = 0 if not $target_ram_used_last_updated;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "target_ram_used_last_updated", value1 => $target_ram_used_last_updated
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: For each ram_used_by, check to see if the same name exists
	###       in the target and decide if it needs an INSERT or UPDATE. So
	###       first, pull all the existing entries out of the target.
	   $query   = "SELECT ram_used_by, round(extract(epoch from modified_date)) FROM ram_used WHERE ram_used_host_id = (".$an->data->{sys}{host_id_query}.");";
	my $results = $an->DB->do_db_query({id => $target_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $ram_used_by = $row->[0];
		my $modified_date = $row->[1];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "ram_used_by", value1 => $ram_used_by, 
			name2 => "modified_date", value2 => $modified_date
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{db}{target}{ram_used}{$ram_used_by}{modified_date} = $modified_date;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "db::target::ram_used::${ram_used_by}::modified_date", value1 => $an->data->{db}{target}{ram_used}{$ram_used_by}{modified_date}
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Now read in all the newer records from the source DB.
	my $old_date = $target_ram_used_last_updated;
	if ($target_ram_used_last_updated =~ /^\d+$/)
	{
		# It's unix time.
		$old_date = "(SELECT to_timestamp(".$an->data->{sys}{use_db_fh}->quote($target_ram_used_last_updated)."))";
	}
	else
	{
		# Already a SQL time stamp
		$old_date = $an->data->{sys}{use_db_fh}->quote($target_ram_used_last_updated);
	}
	$query = "
SELECT 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
FROM 
    history.ram_used 
WHERE 
    ram_used_host_id = (".$an->data->{sys}{host_id_query}.") 
AND 
    $old_date < modified_date 
ORDER BY
    modified_date ASC;
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	$results = "";
	$results = $an->DB->do_db_query({id => $source_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $ram_used_by    = $row->[0];
		my $ram_used_bytes = $row->[1];
		my $modified_date  = $row->[2];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "ram_used_by",    value1 => $ram_used_by, 
			name2 => "ram_used_bytes", value2 => $ram_used_bytes, 
			name3 => "modified_date",  value3 => $modified_date
		}, file => $THIS_FILE, line => __LINE__});
		
		# If there isn't an existing extry in the target, do an insert
		if (not $an->data->{db}{target}{ram_used}{$ram_used_by})
		{
			# Insert!
			$an->data->{db}{target}{ram_used}{$ram_used_by} = {};
			push @{$an->data->{sys}{sql}}, "
INSERT INTO 
    ram_used
(
    ram_used_host_id, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date 
) VALUES (
    (".$an->data->{sys}{host_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).",  
    ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)." 
);";
		}
		else
		{
			# Update
			push @{$an->data->{sys}{sql}}, "
UPDATE 
    ram_used
SET
    ram_used_host_id = (".$an->data->{sys}{host_id_query}."), 
    ram_used_bytes = ".$an->data->{sys}{use_db_fh}->quote($ram_used_bytes).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($ram_used_by).";
";
		}
	}
	
	# Commit the changes (if any).
	if (@{$an->data->{sys}{sql}})
	{
		$an->DB->do_db_write({id => $target_db_id, query => $an->data->{sys}{sql}});
		$an->data->{sys}{sql} = [];
	}
	
	return(0);
}

# Update the alerts table.
sub update_db_alerts
{
	my ($an, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_alerts", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "id", value1 => "$id" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
	my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
	my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
	my $target_db_id        = $id;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_last_updated", value1 => $target_last_updated, 
		name2 => "source_updated_time", value2 => $source_updated_time, 
		name3 => "source_db_id",        value3 => $source_db_id, 
		name4 => "target_db_id",        value4 => $target_db_id
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the time that this table was last updated for this host.
	my $query = "SELECT modified_date FROM alerts WHERE alert_host_id = (".$an->data->{sys}{host_id_query}.") ORDER BY modified_date DESC LIMIT 1;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target_db_id", value1 => "$target_db_id", 
		name2 => "query",        value2 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_alerts_last_updated = $an->DB->do_db_query({id => $target_db_id, query => $query})->[0]->[0];
	   $target_alerts_last_updated = 0 if not $target_alerts_last_updated;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "target_alerts_last_updated", value1 => $target_alerts_last_updated
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: Alerts are a strange beast... There should never be an entry
	###       in the public table, except when alerts are pending being
	###       sent. So we'll read in all the missing records from the
	###       history schema, INSERT them into target, then delete from the
	###       public schema all the entries NOT in the source's public
	###       schema so that a pile of old alarms don't go out.
	
	# Read in all the newer records from the source DB.
	my $old_date = $target_alerts_last_updated;
	if ($target_alerts_last_updated =~ /^\d+$/)
	{
		# It's unix time.
		$old_date = "(SELECT to_timestamp(".$an->data->{sys}{use_db_fh}->quote($target_alerts_last_updated)."))";
	}
	else
	{
		# Already a SQL time stamp
		$old_date = $an->data->{sys}{use_db_fh}->quote($target_alerts_last_updated);
	}
	$query = "
SELECT 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    modified_date 
FROM 
    history.alerts 
WHERE 
    alert_host_id = (".$an->data->{sys}{host_id_query}.") 
AND 
    $old_date < modified_date;
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $results = $an->DB->do_db_query({id => $source_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $alert_agent_name        = $row->[0];
		my $alert_level             = $row->[1];
		my $alert_title_key         = $row->[2];
		my $alert_title_variables   = $row->[3];
		my $alert_message_key       = $row->[4];
		my $alert_message_variables = $row->[5];
		my $modified_date           = $row->[6];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0007", message_variables => {
			name1 => "alert_agent_name",        value1 => $alert_agent_name, 
			name2 => "alert_level",             value2 => $alert_level, 
			name3 => "alert_title_key",         value3 => $alert_title_key, 
			name4 => "alert_title_variables",   value4 => $alert_title_variables, 
			name5 => "alert_message_key",       value5 => $alert_message_key, 
			name6 => "alert_message_variables", value6 => $alert_message_variables, 
			name7 => "modified_date",           value7 => $modified_date, 
		}, file => $THIS_FILE, line => __LINE__});
		
		# If there isn't an existing extry in the target, do an insert
		my $query = "
INSERT INTO 
    alerts 
(
    alert_host_id, 
    alert_agent_name, 
    alert_level, 
    alert_title_key, 
    alert_title_variables, 
    alert_message_key, 
    alert_message_variables, 
    modified_date 
) VALUES (
    (".$an->data->{sys}{host_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($alert_agent_name).",  
    ".$an->data->{sys}{use_db_fh}->quote($alert_level).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_title_key).",  
    ".$an->data->{sys}{use_db_fh}->quote($alert_title_variables).", 
    ".$an->data->{sys}{use_db_fh}->quote($alert_message_key).",  
    ".$an->data->{sys}{use_db_fh}->quote($alert_message_variables).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)." 
);";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		push @{$an->data->{sys}{sql}}, $query;
	}
	
	# Now read is the remaining alerts from the source and delete
	# all others from the target.
	my @save_the_dates;
	$query = "SELECT modified_date FROM alerts WHERE alert_host_id = (".$an->data->{sys}{host_id_query}.");";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	$results = "";
	$results = $an->DB->do_db_query({id => $source_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $modified_date = $row->[0];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "modified_date", value1 => $modified_date
		}, file => $THIS_FILE, line => __LINE__});
		push @save_the_dates, $modified_date;
	}
	
	# Now create the DELETE FROM ... query.
	$query = "
DELETE FROM 
    alerts 
WHERE 
    alert_host_id = (".$an->data->{sys}{host_id_query}.")";
	
	foreach my $modified_date (@save_the_dates)
	{
		$query .= "
AND 
    modified_date != ".$an->data->{sys}{use_db_fh}->quote($modified_date)." ";
	}
	$query .= ";";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	push @{$an->data->{sys}{sql}}, $query;
	
	# Commit the changes (if any).
	if (@{$an->data->{sys}{sql}})
	{
		$an->DB->do_db_write({id => $target_db_id, query => $an->data->{sys}{sql}});
		$an->data->{sys}{sql} = [];
	}
	
	return(0);
}

# Update the temperature table.
sub update_db_temperature
{
	my ($an, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_temperature", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "id", value1 => "$id" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
	my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
	my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
	my $target_db_id        = $id;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_last_updated", value1 => $target_last_updated, 
		name2 => "source_updated_time", value2 => $source_updated_time, 
		name3 => "source_db_id",        value3 => $source_db_id, 
		name4 => "target_db_id",        value4 => $target_db_id
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the unix time that this table was last updated for this host.
	my $query = "SELECT modified_date FROM alerts WHERE alert_host_id = (".$an->data->{sys}{host_id_query}.");";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target_db_id", value1 => "$target_db_id", 
		name2 => "query",        value2 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_alerts_last_updated = $an->DB->do_db_query({id => $target_db_id, query => $query})->[0]->[0];
	   $target_alerts_last_updated = 0 if not $target_alerts_last_updated;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "target_alerts_last_updated", value1 => $target_alerts_last_updated
	}, file => $THIS_FILE, line => __LINE__});
	
	### TODO
	
	return(0);
}

# Update the power table.
sub update_db_power
{
	my ($an, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_power", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "id", value1 => "$id" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
	my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
	my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
	my $target_db_id        = $id;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_last_updated", value1 => $target_last_updated, 
		name2 => "source_updated_time", value2 => $source_updated_time, 
		name3 => "source_db_id",        value3 => $source_db_id, 
		name4 => "target_db_id",        value4 => $target_db_id
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the unix time that this table was last updated for this host.
	my $query = "SELECT modified_date FROM alerts WHERE alert_host_id = (".$an->data->{sys}{host_id_query}.");";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target_db_id", value1 => "$target_db_id", 
		name2 => "query",        value2 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_alerts_last_updated = $an->DB->do_db_query({id => $target_db_id, query => $query})->[0]->[0];
	   $target_alerts_last_updated = 0 if not $target_alerts_last_updated;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "target_alerts_last_updated", value1 => $target_alerts_last_updated
	}, file => $THIS_FILE, line => __LINE__});
	
	### TODO
	
	return(0);
}

# Update the agents table.
sub update_db_agents
{
	my ($an, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_agents", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "id", value1 => "$id" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
	my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
	my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
	my $target_db_id        = $id;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_last_updated", value1 => $target_last_updated, 
		name2 => "source_updated_time", value2 => $source_updated_time, 
		name3 => "source_db_id",        value3 => $source_db_id, 
		name4 => "target_db_id",        value4 => $target_db_id
	}, file => $THIS_FILE, line => __LINE__});
	
	# Get the unix time that this table was last updated for this host.
	my $query = "SELECT modified_date FROM agents WHERE agent_host_id = (".$an->data->{sys}{host_id_query}.") ORDER BY modified_date DESC LIMIT 1;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
		name1 => "target_db_id", value1 => "$target_db_id", 
		name2 => "query",        value2 => $query, 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_agents_last_updated = $an->DB->do_db_query({id => $target_db_id, query => $query})->[0]->[0];
	   $target_agents_last_updated = 0 if not $target_agents_last_updated;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "target_agents_last_updated", value1 => $target_agents_last_updated
	}, file => $THIS_FILE, line => __LINE__});
	
	### NOTE: For each agent_name, check to see if the same name exists in
	###       the target and decide if it needs an INSERT or UPDATE. So
	###       first, pull all the existing entries out of the target.
	   $query   = "SELECT agent_name, round(extract(epoch from modified_date)) FROM agents WHERE agent_host_id = (".$an->data->{sys}{host_id_query}.");";
	my $results = $an->DB->do_db_query({id => $target_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $agent_name    = $row->[0];
		my $modified_date = $row->[1];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0002", message_variables => {
			name1 => "agent_name",    value1 => $agent_name, 
			name2 => "modified_date", value2 => $modified_date
		}, file => $THIS_FILE, line => __LINE__});
		
		$an->data->{db}{target}{agents}{$agent_name}{modified_date} = $modified_date;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "db::target::agents::${agent_name}::modified_date", value1 => $an->data->{db}{target}{agents}{$agent_name}{modified_date}
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	# Now read in all the newer records from the source DB.
	my $old_date = $target_agents_last_updated;
	if ($target_agents_last_updated =~ /^\d+$/)
	{
		# It's unix time.
		$old_date = "(SELECT to_timestamp(".$an->data->{sys}{use_db_fh}->quote($target_agents_last_updated)."))";
	}
	else
	{
		# Already a SQL time stamp
		$old_date = $an->data->{sys}{use_db_fh}->quote($target_agents_last_updated);
	}
	$query = "
SELECT 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
FROM 
    history.agents 
WHERE 
    agent_host_id = (".$an->data->{sys}{host_id_query}.") 
AND 
    $old_date < modified_date 
ORDER BY
    modified_date ASC;
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	$results = "";
	$results = $an->DB->do_db_query({id => $source_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	# One or more records were found.
	foreach my $row (@{$results})
	{
		my $agent_name      = $row->[0];
		my $agent_exit_code = $row->[1];
		my $agent_runtime   = $row->[2]; 
		my $modified_date   = $row->[3];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "agent_name",      value1 => $agent_name, 
			name2 => "agent_exit_code", value2 => $agent_exit_code, 
			name3 => "agent_runtime",   value3 => $agent_runtime, 
			name4 => "modified_date",   value4 => $modified_date
		}, file => $THIS_FILE, line => __LINE__});
		
		# If there isn't an existing extry in the target, do an insert
		if (not $an->data->{db}{target}{agents}{$agent_name})
		{
			# Insert!
			$an->data->{db}{target}{agents}{$agent_name} = {};
			push @{$an->data->{sys}{sql}}, "
INSERT INTO 
    agents
(
    agent_host_id, 
    agent_name, 
    agent_exit_code, 
    agent_runtime, 
    modified_date 
) VALUES (
    (".$an->data->{sys}{host_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($agent_name).",  
    ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)." 
);";
		}
		else
		{
			# Update
			push @{$an->data->{sys}{sql}}, "
UPDATE 
    agents
SET
    agent_host_id = (".$an->data->{sys}{host_id_query}."), 
    agent_exit_code = ".$an->data->{sys}{use_db_fh}->quote($agent_exit_code).", 
    agent_runtime = ".$an->data->{sys}{use_db_fh}->quote($agent_runtime).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE 
    agent_name = ".$an->data->{sys}{use_db_fh}->quote($agent_name).";
";
		}
	}
	
	# Commit the changes (if any).
	if (@{$an->data->{sys}{sql}})
	{
		$an->DB->do_db_write({id => $id, query => $an->data->{sys}{sql}});
		$an->data->{sys}{sql} = [];
	}
	
	return(0);
}

# Update (and commit) the hosts table
sub update_db_hosts
{
	my ($an, $id) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "update_db_hosts", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "id", value1 => "$id" 
	}, file => $THIS_FILE, line => __LINE__});
	
	my $target_last_updated = $an->data->{scancore}{db}{$id}{last_updated};
	my $source_updated_time = $an->data->{scancore}{sql}{source_updated_time};
	my $source_db_id        = $an->data->{scancore}{sql}{source_db_id};
	my $target_db_id        = $id;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_last_updated", value1 => $target_last_updated, 
		name2 => "source_updated_time", value2 => $source_updated_time, 
		name3 => "source_db_id",        value3 => $source_db_id, 
		name4 => "target_db_id",        value4 => $target_db_id
	}, file => $THIS_FILE, line => __LINE__});
	
	#######################################################################
	# NOTE: Changing the host name while a DB is offline will cause the   #
	#       target to think it found a new host!                          #
	#######################################################################
	
	# This defaults to the last time the target was updated, but will be
	# changed if newer entries were found in the target's DB.
	my $target_hosts_last_updated = $target_last_updated;
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "target_hosts_last_updated", value1 => $target_hosts_last_updated
	}, file => $THIS_FILE, line => __LINE__});
	
	# So first, what is the host_id for the hostname on the source DB?
	my ($source_host_id) = $an->DB->get_host_id({id => $source_db_id, hostname => $an->hostname});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
		name1 => "source_db_id",   value1 => $source_db_id, 
		name2 => "an->hostname",   value2 => $an->hostname, 
		name3 => "source_host_id", value3 => "$source_host_id"
	}, file => $THIS_FILE, line => __LINE__});
	
	# Now, do I have any more recent entries in the target?
	my ($target_host_id, $modified_time) = $an->DB->get_host_id({id => $target_db_id, hostname => $an->hostname});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
		name1 => "target_db_id",   value1 => $target_db_id, 
		name2 => "an->hostname",   value2 => $an->hostname, 
		name3 => "target_host_id", value3 => $target_host_id, 
		name4 => "modified_time",  value4 => $modified_time
	}, file => $THIS_FILE, line => __LINE__});
	
	# If there is no target host_id, I'll need to read in all the data. If
	# there is, update the target_hosts_last_updated.
	if ($target_host_id)
	{
		$target_hosts_last_updated = $modified_time;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "target_hosts_last_updated", value1 => $target_hosts_last_updated
		}, file => $THIS_FILE, line => __LINE__});
	}
	
	### NOTE: I convert the DB's timestamp to unixtime because the 
	###       super-high precision time stored in pgsql can by 
	###       microseconds newer than the converted timestamp, causing
	###       and extra record to be returned.
	# Now read in the source DB's history.hosts starting from when the
	# target's DB was last updated.
	my $query = "
SELECT 
    host_name, 
    host_type, 
    host_status, 
    modified_date 
FROM 
    history.hosts 
WHERE 
    host_id = ".$an->data->{sys}{use_db_fh}->quote($source_host_id)." 
AND
    ".$an->data->{sys}{use_db_fh}->quote($target_hosts_last_updated)." < round(extract(epoch from modified_date))
ORDER BY 
    modified_date ASC;";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	# Do the query against the source DB and loop through the results.
	my $results = $an->DB->do_db_query({id => $source_db_id, query => $query});
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "results", value1 => $results
	}, file => $THIS_FILE, line => __LINE__});
	foreach my $row (@{$results})
	{
		my $host_name     = $row->[0];
		my $host_type     = $row->[1]; 
		my $host_status   = $row->[2];
		my $modified_date = $row->[3];
		$an->Log->entry({log_level => 3, message_key => "an_variables_0004", message_variables => {
			name1 => "host_name",     value1 => $host_name, 
			name2 => "host_type",     value2 => $host_type, 
			name3 => "host_status",   value3 => $host_status, 
			name4 => "modified_date", value4 => $modified_date
		}, file => $THIS_FILE, line => __LINE__});
		
		# If I don't have a host_id, the first record will need to be
		# an INSERT.
		if (not $target_host_id)
		{
			# Insert
			my $query = "
INSERT INTO 
    hosts
(
    host_name, 
    host_type, 
    host_status, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($an->hostname).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    ".$an->data->{sys}{use_db_fh}->quote($host_status).", 
    ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
);
";
			$an->DB->do_db_write({id => $target_db_id, query => $query});
			
			# Now read back the host_id that was set.
			($target_host_id) = $an->DB->get_host_id({id => $target_db_id, hostname => $an->hostname});
			$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
				name1 => "target_db_id",   value1 => $target_db_id, 
				name2 => "an->hostname",   value2 => $an->hostname, 
				name3 => "target_host_id", value3 => $target_host_id
			}, file => $THIS_FILE, line => __LINE__});
		}
		else
		{
			# Update
			my $query = "
UPDATE 
    hosts
SET
    host_name = ".$an->data->{sys}{use_db_fh}->quote($an->hostname).", 
    host_type = ".$an->data->{sys}{use_db_fh}->quote($host_type).", 
    host_status = ".$an->data->{sys}{use_db_fh}->quote($host_status).", 
    modified_date = ".$an->data->{sys}{use_db_fh}->quote($modified_date)."
WHERE
    host_id = ".$an->data->{sys}{use_db_fh}->quote($target_host_id).";
";
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1  => "query", value1 => $query
			}, file => $THIS_FILE, line => __LINE__});
			$an->DB->do_db_write({id => $target_db_id, query => $query});
		}
	}
	
	return(0);
}

# This checks to see if this node is in each database and, if not, adds it.
sub add_host_to_databases
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "add_host_to_databases", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Check each DB
	my $query = "SELECT COUNT(*) FROM hosts WHERE host_name=".$an->data->{sys}{use_db_fh}->quote($an->hostname).";";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	
	#          The actual query -----------------.        .------- Row 0
	#                                            |        |    .-- Columns 0
	my $count = $an->DB->do_db_query({query => $query})->[0]->[0];
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "count", value1 => $count
	}, file => $THIS_FILE, line => __LINE__});
	if ($count < 1)
	{
		### TODO: For now, we determine if this host is a node
		###       or dashboard by analyzing it's hostname. We
		###       will make this smarter later.
		my $host_name = $an->hostname;
		my $host_type = "node";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0003", message_variables => {
			name1 => "sys::hostname", value1 => $an->hostname, 
			name2 => "host_name",     value2 => $host_name, 
			name3 => "host_type",     value3 => $host_type
		}, file => $THIS_FILE, line => __LINE__});
		
		if (($host_name =~ /striker/) || ($host_name =~ /dashboard/))
		{
			$host_type = "dashboard";
		}
		
		# Add this host to the DB
		my $query = "
INSERT INTO 
    hosts 
(
    host_name, 
    host_type, 
    modified_date
) VALUES (
    ".$an->data->{sys}{use_db_fh}->quote($host_name).",
    '$host_type',
    ".$an->data->{sys}{db_timestamp}."
);
";
		$an->DB->do_db_write({query => $query});
	}
	
	return(0);
}

# This loops through the agents directory 
sub call_agents
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "call_agents", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Loop through the agents directory and call each agent. Record how
	# long it takes and note the exit code, then record the run-data in the
	# database.
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "path::agents_directory", value1 => $an->data->{path}{agents_directory}
	}, file => $THIS_FILE, line => __LINE__});
	scan_directory($an, $an->data->{path}{agents_directory});
	
	# Now loop through the agents I found and try calling them.
	foreach my $agent (sort {$a cmp $b} @{$an->data->{sys}{agents}})
	{
		### TODO: Put a time limit on these...
		my $start_time =  time;
		my $say_agent  =  $agent;
		   $say_agent  =~ s/^.*\///;
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0015", message_variables => { agent => "$say_agent" }, file => $THIS_FILE, line => __LINE__});
		
		# I call these sequentially to minimize the load on the host.
		my $agent_rc   = "9999";
		my $shell_call = "$agent; echo rc:\$? 2>&1 |";
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
		open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0006", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
		while(<$file_handle>)
		{
			chomp;
			my $line =  $_;
			$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
				name1 => "line", value1 => "$line"
			}, file => $THIS_FILE, line => __LINE__});
			if ($line =~ /rc:(\d+)/)
			{
				$agent_rc = $1;
				$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
					name1 => "agent_rc", value1 => "$agent_rc"
				}, file => $THIS_FILE, line => __LINE__});
			}
		}
		close $file_handle;
		my $runtime = time - $start_time;
		$an->Log->entry({log_level => 2, message_key => "scancore_log_0020", message_variables => { 
			agent   => "$agent", 
			runtime => $runtime 
		}, file => $THIS_FILE, line => __LINE__});
		
		# Record this run in the DB.
		my $query = "
SELECT 
    COUNT(*) 
FROM 
    agents 
WHERE 
    agent_name = ".$an->data->{sys}{use_db_fh}->quote($say_agent)." 
AND
    agent_host_id = (".$an->data->{sys}{host_id_query}.")
;
";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1  => "query", value1 => $query
		}, file => $THIS_FILE, line => __LINE__});
		my $count = $an->DB->do_db_query({query => $query})->[0]->[0];	# (->[row]->[column])
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "count", value1 => $count
		}, file => $THIS_FILE, line => __LINE__});
		if ($count < 1)
		{
			# Add this agent to the DB
			my $query = "
INSERT INTO 
    agents 
(
    agent_host_id, 
    agent_name, 
    agent_exit_code, 
    agent_runtime,
    modified_date
) VALUES (
    (".$an->data->{sys}{host_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($say_agent).", 
    ".$an->data->{sys}{use_db_fh}->quote($agent_rc).", 
    ".$an->data->{sys}{use_db_fh}->quote($runtime).", 
    ".$an->data->{sys}{db_timestamp}."
);
";
			$an->DB->do_db_write({query => $query});
		}
		else
		{
			# It exists, update it.
			my $query = "
UPDATE 
    agents 
SET
    agent_exit_code = ".$an->data->{sys}{use_db_fh}->quote($agent_rc).", 
    agent_runtime = ".$an->data->{sys}{use_db_fh}->quote($runtime).", 
    modified_date = ".$an->data->{sys}{db_timestamp}."
WHERE 
    agent_host_id = (".$an->data->{sys}{host_id_query}.")
AND
    agent_name = ".$an->data->{sys}{use_db_fh}->quote($say_agent).";
";
			$an->DB->do_db_write({query => $query});
		}
	}
	
	# Clear the agent list.
	$an->data->{sys}{agents} = [];
	
	return(0);
}

# This checks the amount RAM used by ScanCore and exits if it exceeds a
# sys::maximum_ram bytes. It looks for any process with our name and sums the
# RAM used.
sub check_ram_usage
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "check_ram_usage", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	### TODO: Make this ___way___ smarter.
	# Call PS to get our (and any other duplicate copies of ScanCore) RAM 
	# usage.
	my $used_ram   = 0;
	my $shell_call = $an->data->{path}{ps}." aux 2>&1 |";
	$an->Log->entry({log_level => 2, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
	open (my $file_handle, $shell_call) or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0006", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while(<$file_handle>)
	{
		chomp;
		my $line = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => ">> line", value1 => "$line"
		}, file => $THIS_FILE, line => __LINE__});
		
		next if $line !~ /$THIS_FILE/;
		next if $line =~ /grep $THIS_FILE/;
		$line =~ s/^\s+//;
		$line =~ s/\s+$//;
		$line =~ s/\s+/ /g;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "line", value1 => "$line"
		}, file => $THIS_FILE, line => __LINE__});
		
		# Dig out the PID
		my $pid        =  ($line =~ /^.*?\s(\d+)\s/)[0];
		my ($pids_ram) =  $an->Get->get_ram_used_by_pid({pid => $pid});
		   $used_ram   += $pids_ram;
		$an->Log->entry({log_level => 2, message_key => "an_variables_0004", message_variables => {
			name1 => "pid",              value1 => "$pid", 
			name2 => "pids_ram",         value2 => "$pids_ram", 
			name3 => "used_ram",         value3 => "$used_ram", 
			name4 => "sys::maximum_ram", value4 => $an->data->{sys}{maximum_ram}
		}, file => $THIS_FILE, line => __LINE__});
	}
	close $file_handle;
	
	# Records the RAM used.
	my $query = "
SELECT 
    ram_used_bytes 
FROM 
    ram_used 
WHERE 
    ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name})." 
AND
    ram_used_host_id = (".$an->data->{sys}{host_id_query}.");
";
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1  => "query", value1 => $query
	}, file => $THIS_FILE, line => __LINE__});
	my $ram_used_bytes = $an->DB->do_db_query({query => $query})->[0]->[0];	# (->[row]->[column])
	$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
		name1 => "ram_used_bytes", value1 => $ram_used_bytes
	}, file => $THIS_FILE, line => __LINE__});
	if (not $ram_used_bytes)
	{
		# Add this agent to the DB
		my $query = "
INSERT INTO 
    ram_used 
(
    ram_used_host_id, 
    ram_used_by, 
    ram_used_bytes, 
    modified_date
) VALUES (
    (".$an->data->{sys}{host_id_query}."), 
    ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name}).", 
    ".$an->data->{sys}{use_db_fh}->quote($used_ram).", 
    ".$an->data->{sys}{db_timestamp}."
);
";
		$an->DB->do_db_write({query => $query});
	}
	elsif ($ram_used_bytes ne $used_ram)
	{
		# It exists and the value has changed.
		my $query = "
UPDATE 
    ram_used 
SET
    ram_used_bytes = ".$an->data->{sys}{use_db_fh}->quote($used_ram).", 
    modified_date = ".$an->data->{sys}{db_timestamp}."
WHERE 
    ram_used_by = ".$an->data->{sys}{use_db_fh}->quote($an->data->{sys}{program_name})." 
AND
    ram_used_host_id = (".$an->data->{sys}{host_id_query}.");
";
		$an->DB->do_db_write({query => $query});
	}
	else
	{
		# The amount of RAM used is unchanged.
		#print __LINE__."; The amount of RAM used by ".$an->data->{sys}{program_name}." is unchanged.\n";
	}
	
	if ($used_ram > $an->data->{sys}{maximum_ram})
	{
		# Much, too much, much music!
		# err, too much RAM...
		$an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0013", message_variables => { 
			used_ram    => $an->Readable->bytes_to_hr({'bytes' => $used_ram}), 
			maximum_ram => $an->Readable->bytes_to_hr({'bytes' => $an->data->{sys}{maximum_ram}})
		}, code => 5, file => "$THIS_FILE", line => __LINE__});
	}
	
	return(0);
}

# This reads the 'results table' and looks for bad conditions
sub analyze_results
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "analyze_results", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	# Read in the 'alerts' table, using $an->data->{sys}{scan_time} as the
	# time to select after. 
	
	return(0);
}

# This digs through a directory looking for scan agents to call. It will dive
# into subdiretories as well. Anything it finds, it will record the path to
# sys::agents.
sub scan_directory
{
	my ($an, $directory) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "scan_directory", }, message_key => "an_variables_0001", message_variables => { 
		name1 => "directory", value1 => "$directory" 
	}, file => $THIS_FILE, line => __LINE__});
	
	local(*DIRECTORY);
	opendir(DIRECTORY, $an->data->{path}{agents_directory});
	while(my $file = readdir(DIRECTORY))
	{
		next if $file eq ".";
		next if $file eq "..";
		my $full_path = "$directory/$file";
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "full_path", value1 => "$full_path"
		}, file => $THIS_FILE, line => __LINE__});
		if (-d $full_path)
		{
			# This is a directory, dive into it.
			scan_directory($an, $full_path);
		}
		elsif (-x $full_path)
		{
			# Now I only want to know if the file starts with 'scan-'
			next if $file !~ /^scan-/;
			
			# If I am still alive, I am looking at a scan agent!
			$an->Log->entry({log_level => 3, message_key => "scancore_log_0014", message_variables => { agent => "$full_path" }, file => $THIS_FILE, line => __LINE__});
			push @{$an->data->{sys}{agents}}, $full_path;
		}
	}
	
	return(0);
}

# Nicely exits the program.
sub nice_exit
{
	my ($an, $exit_code) = @_;
	$exit_code = 99 if not defined $exit_code;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "nice_exit", }, message_key => "an_variables_0001", message_variables => { name1 => "exit_code", value1 => "$exit_code" }, file => $THIS_FILE, line => __LINE__});
	
	# Close database connections
	$an->DB->disconnect_from_databases();
	
	exit(0);
}

# This causes the script to exit if another instance is already running.
sub avoid_duplicate_run
{
	my ($an) = @_;
	$an->Log->entry({log_level => 3, title_key => "tools_log_0001", title_variables => { function => "avoid_duplicate_run", }, message_key => "tools_log_0002", file => $THIS_FILE, line => __LINE__});
	
	my $file_handle = IO::Handle->new();
	my $shell_call  = $an->data->{path}{pgrep}." $THIS_FILE 2>&1 |";
	$an->Log->entry({log_level => 3, message_key => "scancore_log_0007", message_variables => { shell_call => $shell_call }, file => $THIS_FILE, line => __LINE__});
	open ($file_handle, "$shell_call") or $an->Alert->error({fatal => 1, title_key => "an_0003", message_key => "scancore_error_0006", message_variables => { shell_call => $shell_call, error => $! }, code => 2, file => "$THIS_FILE", line => __LINE__});
	while (<$file_handle>)
	{
		chomp;
		my $pid = $_;
		$an->Log->entry({log_level => 3, message_key => "an_variables_0001", message_variables => {
			name1 => "pid", value1 => "$pid"
		}, file => $THIS_FILE, line => __LINE__});
		if ($pid ne $$)
		{
			# Another copy is running, exit.
			close $file_handle;
			$an->Log->entry({log_level => 3, message_key => "scancore_message_0003", file => $THIS_FILE, line => __LINE__});
			exit(6);
		}
	}
	close $file_handle;
	
	return (0);
}
